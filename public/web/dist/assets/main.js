(function(factory) {
  typeof define === "function" && define.amd ? define(factory) : factory();
})(function() {
  "use strict";
  var __vite_style__ = document.createElement("style");
  __vite_style__.textContent = `
/* https://altcha.org/docs/widget-customization/ */

.v-enter-active[data-v-b85fc969],
.v-leave-active[data-v-b85fc969] {
  transition: opacity 0.3s ease, max-height 0.3s ease;
}
.v-enter-from[data-v-b85fc969],
.v-leave-to[data-v-b85fc969] {
  opacity: 0;
}

/* Ensure the dropdown container has a higher z-index than the input field */
.absolute[data-v-93c94bbe] {
  z-index: 40;
}

@keyframes throb-b0241b04 {
0%,
  100% {
    transform: scale(1);
}
50% {
    transform: scale(1.05);
}
}
.animate-throb[data-v-b0241b04] {
  animation: throb-b0241b04 2s ease-in-out infinite;
}
/*
! tailwindcss v3.4.6 | MIT License | https://tailwindcss.com
*//*
1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)
2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)
*/

*,
::before,
::after {
  box-sizing: border-box; /* 1 */
  border-width: 0; /* 2 */
  border-style: solid; /* 2 */
  border-color: #e5e7eb; /* 2 */
}

::before,
::after {
  --tw-content: '';
}

/*
1. Use a consistent sensible line-height in all browsers.
2. Prevent adjustments of font size after orientation changes in iOS.
3. Use a more readable tab size.
4. Use the user's configured \`sans\` font-family by default.
5. Use the user's configured \`sans\` font-feature-settings by default.
6. Use the user's configured \`sans\` font-variation-settings by default.
7. Disable tap highlights on iOS
*/

html,
:host {
  line-height: 1.5; /* 1 */
  -webkit-text-size-adjust: 100%; /* 2 */
  -moz-tab-size: 4; /* 3 */
  -o-tab-size: 4;
     tab-size: 4; /* 3 */
  font-family: ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; /* 4 */
  font-feature-settings: normal; /* 5 */
  font-variation-settings: normal; /* 6 */
  -webkit-tap-highlight-color: transparent; /* 7 */
}

/*
1. Remove the margin in all browsers.
2. Inherit line-height from \`html\` so users can set them as a class directly on the \`html\` element.
*/

body {
  margin: 0; /* 1 */
  line-height: inherit; /* 2 */
}

/*
1. Add the correct height in Firefox.
2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)
3. Ensure horizontal rules are visible by default.
*/

hr {
  height: 0; /* 1 */
  color: inherit; /* 2 */
  border-top-width: 1px; /* 3 */
}

/*
Add the correct text decoration in Chrome, Edge, and Safari.
*/

abbr:where([title]) {
  -webkit-text-decoration: underline dotted;
          text-decoration: underline dotted;
}

/*
Remove the default font size and weight for headings.
*/

h1,
h2,
h3,
h4,
h5,
h6 {
  font-size: inherit;
  font-weight: inherit;
}

/*
Reset links to optimize for opt-in styling instead of opt-out.
*/

a {
  color: inherit;
  text-decoration: inherit;
}

/*
Add the correct font weight in Edge and Safari.
*/

b,
strong {
  font-weight: bolder;
}

/*
1. Use the user's configured \`mono\` font-family by default.
2. Use the user's configured \`mono\` font-feature-settings by default.
3. Use the user's configured \`mono\` font-variation-settings by default.
4. Correct the odd \`em\` font sizing in all browsers.
*/

code,
kbd,
samp,
pre {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; /* 1 */
  font-feature-settings: normal; /* 2 */
  font-variation-settings: normal; /* 3 */
  font-size: 1em; /* 4 */
}

/*
Add the correct font size in all browsers.
*/

small {
  font-size: 80%;
}

/*
Prevent \`sub\` and \`sup\` elements from affecting the line height in all browsers.
*/

sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sub {
  bottom: -0.25em;
}

sup {
  top: -0.5em;
}

/*
1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)
2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)
3. Remove gaps between table borders by default.
*/

table {
  text-indent: 0; /* 1 */
  border-color: inherit; /* 2 */
  border-collapse: collapse; /* 3 */
}

/*
1. Change the font styles in all browsers.
2. Remove the margin in Firefox and Safari.
3. Remove default padding in all browsers.
*/

button,
input,
optgroup,
select,
textarea {
  font-family: inherit; /* 1 */
  font-feature-settings: inherit; /* 1 */
  font-variation-settings: inherit; /* 1 */
  font-size: 100%; /* 1 */
  font-weight: inherit; /* 1 */
  line-height: inherit; /* 1 */
  letter-spacing: inherit; /* 1 */
  color: inherit; /* 1 */
  margin: 0; /* 2 */
  padding: 0; /* 3 */
}

/*
Remove the inheritance of text transform in Edge and Firefox.
*/

button,
select {
  text-transform: none;
}

/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Remove default button styles.
*/

button,
input:where([type='button']),
input:where([type='reset']),
input:where([type='submit']) {
  -webkit-appearance: button; /* 1 */
  background-color: transparent; /* 2 */
  background-image: none; /* 2 */
}

/*
Use the modern Firefox focus style for all focusable elements.
*/

:-moz-focusring {
  outline: auto;
}

/*
Remove the additional \`:invalid\` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)
*/

:-moz-ui-invalid {
  box-shadow: none;
}

/*
Add the correct vertical alignment in Chrome and Firefox.
*/

progress {
  vertical-align: baseline;
}

/*
Correct the cursor style of increment and decrement buttons in Safari.
*/

::-webkit-inner-spin-button,
::-webkit-outer-spin-button {
  height: auto;
}

/*
1. Correct the odd appearance in Chrome and Safari.
2. Correct the outline style in Safari.
*/

[type='search'] {
  -webkit-appearance: textfield; /* 1 */
  outline-offset: -2px; /* 2 */
}

/*
Remove the inner padding in Chrome and Safari on macOS.
*/

::-webkit-search-decoration {
  -webkit-appearance: none;
}

/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Change font properties to \`inherit\` in Safari.
*/

::-webkit-file-upload-button {
  -webkit-appearance: button; /* 1 */
  font: inherit; /* 2 */
}

/*
Add the correct display in Chrome and Safari.
*/

summary {
  display: list-item;
}

/*
Removes the default spacing and border for appropriate elements.
*/

blockquote,
dl,
dd,
h1,
h2,
h3,
h4,
h5,
h6,
hr,
figure,
p,
pre {
  margin: 0;
}

fieldset {
  margin: 0;
  padding: 0;
}

legend {
  padding: 0;
}

ol,
ul,
menu {
  list-style: none;
  margin: 0;
  padding: 0;
}

/*
Reset default styling for dialogs.
*/
dialog {
  padding: 0;
}

/*
Prevent resizing textareas horizontally by default.
*/

textarea {
  resize: vertical;
}

/*
1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)
2. Set the default placeholder color to the user's configured gray 400 color.
*/

input::-moz-placeholder, textarea::-moz-placeholder {
  opacity: 1; /* 1 */
  color: #9ca3af; /* 2 */
}

input::placeholder,
textarea::placeholder {
  opacity: 1; /* 1 */
  color: #9ca3af; /* 2 */
}

/*
Set the default cursor for buttons.
*/

button,
[role="button"] {
  cursor: pointer;
}

/*
Make sure disabled buttons don't get the pointer cursor.
*/
:disabled {
  cursor: default;
}

/*
1. Make replaced elements \`display: block\` by default. (https://github.com/mozdevs/cssremedy/issues/14)
2. Add \`vertical-align: middle\` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)
   This can trigger a poorly considered lint error in some tools but is included by design.
*/

img,
svg,
video,
canvas,
audio,
iframe,
embed,
object {
  display: block; /* 1 */
  vertical-align: middle; /* 2 */
}

/*
Constrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)
*/

img,
video {
  max-width: 100%;
  height: auto;
}

/* Make elements with the HTML hidden attribute stay hidden by default */
[hidden] {
  display: none;
}

[type='text'],input:where(:not([type])),[type='email'],[type='url'],[type='password'],[type='number'],[type='date'],[type='datetime-local'],[type='month'],[type='search'],[type='tel'],[type='time'],[type='week'],[multiple],textarea,select {
  -webkit-appearance: none;
     -moz-appearance: none;
          appearance: none;
  background-color: #fff;
  border-color: #6b7280;
  border-width: 1px;
  border-radius: 0px;
  padding-top: 0.5rem;
  padding-right: 0.75rem;
  padding-bottom: 0.5rem;
  padding-left: 0.75rem;
  font-size: 1rem;
  line-height: 1.5rem;
  --tw-shadow: 0 0 #0000;
}

[type='text']:focus, input:where(:not([type])):focus, [type='email']:focus, [type='url']:focus, [type='password']:focus, [type='number']:focus, [type='date']:focus, [type='datetime-local']:focus, [type='month']:focus, [type='search']:focus, [type='tel']:focus, [type='time']:focus, [type='week']:focus, [multiple]:focus, textarea:focus, select:focus {
  outline: 2px solid transparent;
  outline-offset: 2px;
  --tw-ring-inset: var(--tw-empty,/*!*/ /*!*/);
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: #2563eb;
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  border-color: #2563eb;
}

input::-moz-placeholder, textarea::-moz-placeholder {
  color: #6b7280;
  opacity: 1;
}

input::placeholder,textarea::placeholder {
  color: #6b7280;
  opacity: 1;
}

::-webkit-datetime-edit-fields-wrapper {
  padding: 0;
}

::-webkit-date-and-time-value {
  min-height: 1.5em;
  text-align: inherit;
}

::-webkit-datetime-edit {
  display: inline-flex;
}

::-webkit-datetime-edit,::-webkit-datetime-edit-year-field,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute-field,::-webkit-datetime-edit-second-field,::-webkit-datetime-edit-millisecond-field,::-webkit-datetime-edit-meridiem-field {
  padding-top: 0;
  padding-bottom: 0;
}

select {
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
  background-position: right 0.5rem center;
  background-repeat: no-repeat;
  background-size: 1.5em 1.5em;
  padding-right: 2.5rem;
  -webkit-print-color-adjust: exact;
          print-color-adjust: exact;
}

[multiple],[size]:where(select:not([size="1"])) {
  background-image: initial;
  background-position: initial;
  background-repeat: unset;
  background-size: initial;
  padding-right: 0.75rem;
  -webkit-print-color-adjust: unset;
          print-color-adjust: unset;
}

[type='checkbox'],[type='radio'] {
  -webkit-appearance: none;
     -moz-appearance: none;
          appearance: none;
  padding: 0;
  -webkit-print-color-adjust: exact;
          print-color-adjust: exact;
  display: inline-block;
  vertical-align: middle;
  background-origin: border-box;
  -webkit-user-select: none;
     -moz-user-select: none;
          user-select: none;
  flex-shrink: 0;
  height: 1rem;
  width: 1rem;
  color: #2563eb;
  background-color: #fff;
  border-color: #6b7280;
  border-width: 1px;
  --tw-shadow: 0 0 #0000;
}

[type='checkbox'] {
  border-radius: 0px;
}

[type='radio'] {
  border-radius: 100%;
}

[type='checkbox']:focus,[type='radio']:focus {
  outline: 2px solid transparent;
  outline-offset: 2px;
  --tw-ring-inset: var(--tw-empty,/*!*/ /*!*/);
  --tw-ring-offset-width: 2px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: #2563eb;
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
}

[type='checkbox']:checked,[type='radio']:checked {
  border-color: transparent;
  background-color: currentColor;
  background-size: 100% 100%;
  background-position: center;
  background-repeat: no-repeat;
}

[type='checkbox']:checked {
  background-image: url("data:image/svg+xml,%3csvg viewBox='0 0 16 16' fill='white' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M12.207 4.793a1 1 0 010 1.414l-5 5a1 1 0 01-1.414 0l-2-2a1 1 0 011.414-1.414L6.5 9.086l4.293-4.293a1 1 0 011.414 0z'/%3e%3c/svg%3e");
}

@media (forced-colors: active)  {

  [type='checkbox']:checked {
    -webkit-appearance: auto;
       -moz-appearance: auto;
            appearance: auto;
  }
}

[type='radio']:checked {
  background-image: url("data:image/svg+xml,%3csvg viewBox='0 0 16 16' fill='white' xmlns='http://www.w3.org/2000/svg'%3e%3ccircle cx='8' cy='8' r='3'/%3e%3c/svg%3e");
}

@media (forced-colors: active)  {

  [type='radio']:checked {
    -webkit-appearance: auto;
       -moz-appearance: auto;
            appearance: auto;
  }
}

[type='checkbox']:checked:hover,[type='checkbox']:checked:focus,[type='radio']:checked:hover,[type='radio']:checked:focus {
  border-color: transparent;
  background-color: currentColor;
}

[type='checkbox']:indeterminate {
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 16 16'%3e%3cpath stroke='white' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M4 8h8'/%3e%3c/svg%3e");
  border-color: transparent;
  background-color: currentColor;
  background-size: 100% 100%;
  background-position: center;
  background-repeat: no-repeat;
}

@media (forced-colors: active)  {

  [type='checkbox']:indeterminate {
    -webkit-appearance: auto;
       -moz-appearance: auto;
            appearance: auto;
  }
}

[type='checkbox']:indeterminate:hover,[type='checkbox']:indeterminate:focus {
  border-color: transparent;
  background-color: currentColor;
}

[type='file'] {
  background: unset;
  border-color: inherit;
  border-width: 0;
  border-radius: 0;
  padding: 0;
  font-size: unset;
  line-height: inherit;
}

[type='file']:focus {
  outline: 1px solid ButtonText;
  outline: 1px auto -webkit-focus-ring-color;
}

@font-face {
  font-family: Zilla Slab;
  src: url('/dist/assets/ZillaSlab-Regular.woff2') format('woff2'), url('/dist/assets/ZillaSlab-Regular.woff') format('woff');
  font-weight: 400;
  font-style: normal;
  font-display: fallback;
}

@font-face {
  font-family: Zilla Slab;
  src: url('/dist/assets/ZillaSlab-Bold.woff2') format('woff2'), url('/dist/assets/ZillaSlab-Bold.woff') format('woff');
  font-weight: 700;
  font-style: normal;
  font-display: fallback;
}

@font-face {
  font-family: Zilla Slab;
  src: url('/dist/assets/ZillaSlab-Italic.woff2') format('woff2'), url('/dist/assets/ZillaSlab-Italic.woff') format('woff');
  font-weight: 400;
  font-style: italic;
  font-display: fallback;
}

@font-face {
  font-family: Zilla Slab;
  src: url('/dist/assets/ZillaSlab-BoldItalic.woff2') format('woff2'), url('/dist/assets/ZillaSlab-BoldItalic.woff') format('woff');
  font-weight: 700;
  font-style: italic;
  font-display: fallback;
}
  html {
    font-family: ui-serif, Georgia, Cambria, "Times New Roman", Times, serif;
  }
  h1,h2,h3,h4,h5 {
    font-family: Zilla Slab, ui-serif, Georgia, Cambria, "Times New Roman", Times, serif;
    /*margin: theme('spacing.5') 0;*/
  }

  button, a.block {
    font-family: Zilla Slab, ui-serif, Georgia, Cambria, "Times New Roman", Times, serif;
  }
  h1 {
  margin-bottom: 0.75rem;
  font-size: 2.25rem;
  line-height: 2.5rem;
  font-weight: 700;
  --tw-text-opacity: 1;
  color: rgb(17 24 39 / var(--tw-text-opacity));
}
  h2 {
  margin-bottom: 0.75rem;
  font-size: 1.875rem;
  line-height: 2.25rem;
  font-weight: 700;
  --tw-text-opacity: 1;
  color: rgb(31 41 55 / var(--tw-text-opacity));
}

  h3 {
  margin-bottom: 0.5rem;
  font-size: 1.5rem;
  line-height: 2rem;
  font-weight: 600;
  --tw-text-opacity: 1;
  color: rgb(55 65 81 / var(--tw-text-opacity));
}

  h4 {
  margin-bottom: 0.25rem;
  font-size: 1.25rem;
  line-height: 1.75rem;
  font-weight: 500;
  --tw-text-opacity: 1;
  color: rgb(75 85 99 / var(--tw-text-opacity));
}

  h5 {
  margin-bottom: 0.5rem;
  font-size: 1.125rem;
  line-height: 1.75rem;
  font-weight: 600;
  --tw-text-opacity: 1;
  color: rgb(55 65 81 / var(--tw-text-opacity));
}

*, ::before, ::after {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position:  ;
  --tw-gradient-via-position:  ;
  --tw-gradient-to-position:  ;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
  --tw-contain-size:  ;
  --tw-contain-layout:  ;
  --tw-contain-paint:  ;
  --tw-contain-style:  ;
}

::backdrop {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position:  ;
  --tw-gradient-via-position:  ;
  --tw-gradient-to-position:  ;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
  --tw-contain-size:  ;
  --tw-contain-layout:  ;
  --tw-contain-paint:  ;
  --tw-contain-style:  ;
}
.container {
  width: 100%;
}
@media (min-width: 640px) {

  .container {
    max-width: 640px;
  }
}
@media (min-width: 768px) {

  .container {
    max-width: 768px;
  }
}
@media (min-width: 1024px) {

  .container {
    max-width: 1024px;
  }
}
@media (min-width: 1280px) {

  .container {
    max-width: 1280px;
  }
}
@media (min-width: 1536px) {

  .container {
    max-width: 1536px;
  }
}
.prose {
  color: var(--tw-prose-body);
  max-width: 65ch;
}
.prose :where(p):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  margin-top: 1.25em;
  margin-bottom: 1.25em;
}
.prose :where([class~="lead"]):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  color: var(--tw-prose-lead);
  font-size: 1.25em;
  line-height: 1.6;
  margin-top: 1.2em;
  margin-bottom: 1.2em;
}
.prose :where(a):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  color: var(--tw-prose-links);
  text-decoration: underline;
  font-weight: 500;
}
.prose :where(strong):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  color: var(--tw-prose-bold);
  font-weight: 600;
}
.prose :where(a strong):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  color: inherit;
}
.prose :where(blockquote strong):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  color: inherit;
}
.prose :where(thead th strong):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  color: inherit;
}
.prose :where(ol):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  list-style-type: decimal;
  margin-top: 1.25em;
  margin-bottom: 1.25em;
  padding-inline-start: 1.625em;
}
.prose :where(ol[type="A"]):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  list-style-type: upper-alpha;
}
.prose :where(ol[type="a"]):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  list-style-type: lower-alpha;
}
.prose :where(ol[type="A" s]):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  list-style-type: upper-alpha;
}
.prose :where(ol[type="a" s]):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  list-style-type: lower-alpha;
}
.prose :where(ol[type="I"]):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  list-style-type: upper-roman;
}
.prose :where(ol[type="i"]):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  list-style-type: lower-roman;
}
.prose :where(ol[type="I" s]):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  list-style-type: upper-roman;
}
.prose :where(ol[type="i" s]):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  list-style-type: lower-roman;
}
.prose :where(ol[type="1"]):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  list-style-type: decimal;
}
.prose :where(ul):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  list-style-type: disc;
  margin-top: 1.25em;
  margin-bottom: 1.25em;
  padding-inline-start: 1.625em;
}
.prose :where(ol > li):not(:where([class~="not-prose"],[class~="not-prose"] *))::marker {
  font-weight: 400;
  color: var(--tw-prose-counters);
}
.prose :where(ul > li):not(:where([class~="not-prose"],[class~="not-prose"] *))::marker {
  color: var(--tw-prose-bullets);
}
.prose :where(dt):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  color: var(--tw-prose-headings);
  font-weight: 600;
  margin-top: 1.25em;
}
.prose :where(hr):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  border-color: var(--tw-prose-hr);
  border-top-width: 1px;
  margin-top: 3em;
  margin-bottom: 3em;
}
.prose :where(blockquote):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  font-weight: 500;
  font-style: italic;
  color: var(--tw-prose-quotes);
  border-inline-start-width: 0.25rem;
  border-inline-start-color: var(--tw-prose-quote-borders);
  quotes: "\\201C""\\201D""\\2018""\\2019";
  margin-top: 1.6em;
  margin-bottom: 1.6em;
  padding-inline-start: 1em;
}
.prose :where(blockquote p:first-of-type):not(:where([class~="not-prose"],[class~="not-prose"] *))::before {
  content: open-quote;
}
.prose :where(blockquote p:last-of-type):not(:where([class~="not-prose"],[class~="not-prose"] *))::after {
  content: close-quote;
}
.prose :where(h1):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  color: var(--tw-prose-headings);
  font-weight: 800;
  font-size: 2.25em;
  margin-top: 0;
  margin-bottom: 0.8888889em;
  line-height: 1.1111111;
}
.prose :where(h1 strong):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  font-weight: 900;
  color: inherit;
}
.prose :where(h2):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  color: var(--tw-prose-headings);
  font-weight: 700;
  font-size: 1.5em;
  margin-top: 2em;
  margin-bottom: 1em;
  line-height: 1.3333333;
}
.prose :where(h2 strong):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  font-weight: 800;
  color: inherit;
}
.prose :where(h3):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  color: var(--tw-prose-headings);
  font-weight: 600;
  font-size: 1.25em;
  margin-top: 1.6em;
  margin-bottom: 0.6em;
  line-height: 1.6;
}
.prose :where(h3 strong):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  font-weight: 700;
  color: inherit;
}
.prose :where(h4):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  color: var(--tw-prose-headings);
  font-weight: 600;
  margin-top: 1.5em;
  margin-bottom: 0.5em;
  line-height: 1.5;
}
.prose :where(h4 strong):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  font-weight: 700;
  color: inherit;
}
.prose :where(img):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  margin-top: 2em;
  margin-bottom: 2em;
}
.prose :where(picture):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  display: block;
  margin-top: 2em;
  margin-bottom: 2em;
}
.prose :where(video):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  margin-top: 2em;
  margin-bottom: 2em;
}
.prose :where(kbd):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  font-weight: 500;
  font-family: inherit;
  color: var(--tw-prose-kbd);
  box-shadow: 0 0 0 1px rgb(var(--tw-prose-kbd-shadows) / 10%), 0 3px 0 rgb(var(--tw-prose-kbd-shadows) / 10%);
  font-size: 0.875em;
  border-radius: 0.3125rem;
  padding-top: 0.1875em;
  padding-inline-end: 0.375em;
  padding-bottom: 0.1875em;
  padding-inline-start: 0.375em;
}
.prose :where(code):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  color: var(--tw-prose-code);
  font-weight: 600;
  font-size: 0.875em;
}
.prose :where(code):not(:where([class~="not-prose"],[class~="not-prose"] *))::before {
  content: "\`";
}
.prose :where(code):not(:where([class~="not-prose"],[class~="not-prose"] *))::after {
  content: "\`";
}
.prose :where(a code):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  color: inherit;
}
.prose :where(h1 code):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  color: inherit;
}
.prose :where(h2 code):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  color: inherit;
  font-size: 0.875em;
}
.prose :where(h3 code):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  color: inherit;
  font-size: 0.9em;
}
.prose :where(h4 code):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  color: inherit;
}
.prose :where(blockquote code):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  color: inherit;
}
.prose :where(thead th code):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  color: inherit;
}
.prose :where(pre):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  color: var(--tw-prose-pre-code);
  background-color: var(--tw-prose-pre-bg);
  overflow-x: auto;
  font-weight: 400;
  font-size: 0.875em;
  line-height: 1.7142857;
  margin-top: 1.7142857em;
  margin-bottom: 1.7142857em;
  border-radius: 0.375rem;
  padding-top: 0.8571429em;
  padding-inline-end: 1.1428571em;
  padding-bottom: 0.8571429em;
  padding-inline-start: 1.1428571em;
}
.prose :where(pre code):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  background-color: transparent;
  border-width: 0;
  border-radius: 0;
  padding: 0;
  font-weight: inherit;
  color: inherit;
  font-size: inherit;
  font-family: inherit;
  line-height: inherit;
}
.prose :where(pre code):not(:where([class~="not-prose"],[class~="not-prose"] *))::before {
  content: none;
}
.prose :where(pre code):not(:where([class~="not-prose"],[class~="not-prose"] *))::after {
  content: none;
}
.prose :where(table):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  width: 100%;
  table-layout: auto;
  text-align: start;
  margin-top: 2em;
  margin-bottom: 2em;
  font-size: 0.875em;
  line-height: 1.7142857;
}
.prose :where(thead):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  border-bottom-width: 1px;
  border-bottom-color: var(--tw-prose-th-borders);
}
.prose :where(thead th):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  color: var(--tw-prose-headings);
  font-weight: 600;
  vertical-align: bottom;
  padding-inline-end: 0.5714286em;
  padding-bottom: 0.5714286em;
  padding-inline-start: 0.5714286em;
}
.prose :where(tbody tr):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  border-bottom-width: 1px;
  border-bottom-color: var(--tw-prose-td-borders);
}
.prose :where(tbody tr:last-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  border-bottom-width: 0;
}
.prose :where(tbody td):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  vertical-align: baseline;
}
.prose :where(tfoot):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  border-top-width: 1px;
  border-top-color: var(--tw-prose-th-borders);
}
.prose :where(tfoot td):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  vertical-align: top;
}
.prose :where(figure > *):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  margin-top: 0;
  margin-bottom: 0;
}
.prose :where(figcaption):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  color: var(--tw-prose-captions);
  font-size: 0.875em;
  line-height: 1.4285714;
  margin-top: 0.8571429em;
}
.prose {
  --tw-prose-body: #374151;
  --tw-prose-headings: #111827;
  --tw-prose-lead: #4b5563;
  --tw-prose-links: #111827;
  --tw-prose-bold: #111827;
  --tw-prose-counters: #6b7280;
  --tw-prose-bullets: #d1d5db;
  --tw-prose-hr: #e5e7eb;
  --tw-prose-quotes: #111827;
  --tw-prose-quote-borders: #e5e7eb;
  --tw-prose-captions: #6b7280;
  --tw-prose-kbd: #111827;
  --tw-prose-kbd-shadows: 17 24 39;
  --tw-prose-code: #111827;
  --tw-prose-pre-code: #e5e7eb;
  --tw-prose-pre-bg: #1f2937;
  --tw-prose-th-borders: #d1d5db;
  --tw-prose-td-borders: #e5e7eb;
  --tw-prose-invert-body: #d1d5db;
  --tw-prose-invert-headings: #fff;
  --tw-prose-invert-lead: #9ca3af;
  --tw-prose-invert-links: #fff;
  --tw-prose-invert-bold: #fff;
  --tw-prose-invert-counters: #9ca3af;
  --tw-prose-invert-bullets: #4b5563;
  --tw-prose-invert-hr: #374151;
  --tw-prose-invert-quotes: #f3f4f6;
  --tw-prose-invert-quote-borders: #374151;
  --tw-prose-invert-captions: #9ca3af;
  --tw-prose-invert-kbd: #fff;
  --tw-prose-invert-kbd-shadows: 255 255 255;
  --tw-prose-invert-code: #fff;
  --tw-prose-invert-pre-code: #d1d5db;
  --tw-prose-invert-pre-bg: rgb(0 0 0 / 50%);
  --tw-prose-invert-th-borders: #4b5563;
  --tw-prose-invert-td-borders: #374151;
  font-size: 1rem;
  line-height: 1.75;
}
.prose :where(picture > img):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  margin-top: 0;
  margin-bottom: 0;
}
.prose :where(li):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}
.prose :where(ol > li):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  padding-inline-start: 0.375em;
}
.prose :where(ul > li):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  padding-inline-start: 0.375em;
}
.prose :where(.prose > ul > li p):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  margin-top: 0.75em;
  margin-bottom: 0.75em;
}
.prose :where(.prose > ul > li > p:first-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  margin-top: 1.25em;
}
.prose :where(.prose > ul > li > p:last-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  margin-bottom: 1.25em;
}
.prose :where(.prose > ol > li > p:first-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  margin-top: 1.25em;
}
.prose :where(.prose > ol > li > p:last-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  margin-bottom: 1.25em;
}
.prose :where(ul ul, ul ol, ol ul, ol ol):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  margin-top: 0.75em;
  margin-bottom: 0.75em;
}
.prose :where(dl):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  margin-top: 1.25em;
  margin-bottom: 1.25em;
}
.prose :where(dd):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  margin-top: 0.5em;
  padding-inline-start: 1.625em;
}
.prose :where(hr + *):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  margin-top: 0;
}
.prose :where(h2 + *):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  margin-top: 0;
}
.prose :where(h3 + *):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  margin-top: 0;
}
.prose :where(h4 + *):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  margin-top: 0;
}
.prose :where(thead th:first-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  padding-inline-start: 0;
}
.prose :where(thead th:last-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  padding-inline-end: 0;
}
.prose :where(tbody td, tfoot td):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  padding-top: 0.5714286em;
  padding-inline-end: 0.5714286em;
  padding-bottom: 0.5714286em;
  padding-inline-start: 0.5714286em;
}
.prose :where(tbody td:first-child, tfoot td:first-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  padding-inline-start: 0;
}
.prose :where(tbody td:last-child, tfoot td:last-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  padding-inline-end: 0;
}
.prose :where(figure):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  margin-top: 2em;
  margin-bottom: 2em;
}
.prose :where(.prose > :first-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  margin-top: 0;
}
.prose :where(.prose > :last-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
  margin-bottom: 0;
}
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}
.pointer-events-none {
  pointer-events: none;
}
.visible {
  visibility: visible;
}
.collapse {
  visibility: collapse;
}
.fixed {
  position: fixed;
}
.absolute {
  position: absolute;
}
.relative {
  position: relative;
}
.sticky {
  position: sticky;
}
.inset-0 {
  inset: 0px;
}
.inset-x-0 {
  left: 0px;
  right: 0px;
}
.inset-y-0 {
  top: 0px;
  bottom: 0px;
}
.-bottom-6 {
  bottom: -1.5rem;
}
.-top-10 {
  top: -2.5rem;
}
.-top-3 {
  top: -0.75rem;
}
.bottom-0 {
  bottom: 0px;
}
.bottom-10 {
  bottom: 2.5rem;
}
.bottom-2 {
  bottom: 0.5rem;
}
.bottom-4 {
  bottom: 1rem;
}
.bottom-full {
  bottom: 100%;
}
.left-0 {
  left: 0px;
}
.left-1\\/2 {
  left: 50%;
}
.left-3 {
  left: 0.75rem;
}
.left-4 {
  left: 1rem;
}
.left-\\[max\\(-7rem\\2c calc\\(50\\%-52rem\\)\\)\\] {
  left: max(-7rem,calc(50% - 52rem));
}
.left-\\[max\\(45rem\\2c calc\\(50\\%\\+8rem\\)\\)\\] {
  left: max(45rem,calc(50% + 8rem));
}
.right-0 {
  right: 0px;
}
.right-2 {
  right: 0.5rem;
}
.right-3 {
  right: 0.75rem;
}
.right-4 {
  right: 1rem;
}
.top-0 {
  top: 0px;
}
.top-1\\/2 {
  top: 50%;
}
.top-2 {
  top: 0.5rem;
}
.isolate {
  isolation: isolate;
}
.-z-10 {
  z-index: -10;
}
.z-0 {
  z-index: 0;
}
.z-10 {
  z-index: 10;
}
.z-50 {
  z-index: 50;
}
.col-span-full {
  grid-column: 1 / -1;
}
.float-right {
  float: right;
}
.float-left {
  float: left;
}
.-m-2\\.5 {
  margin: -0.625rem;
}
.-m-3 {
  margin: -0.75rem;
}
.-mx-4 {
  margin-left: -1rem;
  margin-right: -1rem;
}
.mx-0 {
  margin-left: 0px;
  margin-right: 0px;
}
.mx-1 {
  margin-left: 0.25rem;
  margin-right: 0.25rem;
}
.mx-12 {
  margin-left: 3rem;
  margin-right: 3rem;
}
.mx-2 {
  margin-left: 0.5rem;
  margin-right: 0.5rem;
}
.mx-auto {
  margin-left: auto;
  margin-right: auto;
}
.my-16 {
  margin-top: 4rem;
  margin-bottom: 4rem;
}
.my-20 {
  margin-top: 5rem;
  margin-bottom: 5rem;
}
.my-4 {
  margin-top: 1rem;
  margin-bottom: 1rem;
}
.my-6 {
  margin-top: 1.5rem;
  margin-bottom: 1.5rem;
}
.my-8 {
  margin-top: 2rem;
  margin-bottom: 2rem;
}
.-ml-1 {
  margin-left: -0.25rem;
}
.-ml-6 {
  margin-left: -1.5rem;
}
.-ml-px {
  margin-left: -1px;
}
.-mr-1 {
  margin-right: -0.25rem;
}
.-mt-80 {
  margin-top: -20rem;
}
.mb-0 {
  margin-bottom: 0px;
}
.mb-1 {
  margin-bottom: 0.25rem;
}
.mb-2 {
  margin-bottom: 0.5rem;
}
.mb-3 {
  margin-bottom: 0.75rem;
}
.mb-4 {
  margin-bottom: 1rem;
}
.mb-6 {
  margin-bottom: 1.5rem;
}
.mb-8 {
  margin-bottom: 2rem;
}
.ml-2 {
  margin-left: 0.5rem;
}
.ml-3 {
  margin-left: 0.75rem;
}
.ml-auto {
  margin-left: auto;
}
.mr-0 {
  margin-right: 0px;
}
.mr-1 {
  margin-right: 0.25rem;
}
.mr-2 {
  margin-right: 0.5rem;
}
.mr-3 {
  margin-right: 0.75rem;
}
.mr-4 {
  margin-right: 1rem;
}
.mt-0\\.5 {
  margin-top: 0.125rem;
}
.mt-1 {
  margin-top: 0.25rem;
}
.mt-10 {
  margin-top: 2.5rem;
}
.mt-16 {
  margin-top: 4rem;
}
.mt-2 {
  margin-top: 0.5rem;
}
.mt-24 {
  margin-top: 6rem;
}
.mt-3 {
  margin-top: 0.75rem;
}
.mt-4 {
  margin-top: 1rem;
}
.mt-5 {
  margin-top: 1.25rem;
}
.mt-6 {
  margin-top: 1.5rem;
}
.mt-8 {
  margin-top: 2rem;
}
.block {
  display: block;
}
.inline-block {
  display: inline-block;
}
.inline {
  display: inline;
}
.flex {
  display: flex;
}
.inline-flex {
  display: inline-flex;
}
.table {
  display: table;
}
.flow-root {
  display: flow-root;
}
.grid {
  display: grid;
}
.contents {
  display: contents;
}
.hidden {
  display: none;
}
.aspect-\\[1155\\/678\\] {
  aspect-ratio: 1155/678;
}
.aspect-\\[577\\/310\\] {
  aspect-ratio: 577/310;
}
.h-1 {
  height: 0.25rem;
}
.h-1\\.5 {
  height: 0.375rem;
}
.h-10 {
  height: 2.5rem;
}
.h-12 {
  height: 3rem;
}
.h-20 {
  height: 5rem;
}
.h-24 {
  height: 6rem;
}
.h-32 {
  height: 8rem;
}
.h-4 {
  height: 1rem;
}
.h-48 {
  height: 12rem;
}
.h-5 {
  height: 1.25rem;
}
.h-6 {
  height: 1.5rem;
}
.h-8 {
  height: 2rem;
}
.h-\\[64rem\\] {
  height: 64rem;
}
.max-h-0 {
  max-height: 0px;
}
.max-h-60 {
  max-height: 15rem;
}
.max-h-\\[400px\\] {
  max-height: 400px;
}
.max-h-\\[500px\\] {
  max-height: 500px;
}
.min-h-\\[6rem\\] {
  min-height: 6rem;
}
.min-h-full {
  min-height: 100%;
}
.w-1\\.5 {
  width: 0.375rem;
}
.w-1\\/4 {
  width: 25%;
}
.w-10 {
  width: 2.5rem;
}
.w-12 {
  width: 3rem;
}
.w-16 {
  width: 4rem;
}
.w-2\\/3 {
  width: 66.666667%;
}
.w-20 {
  width: 5rem;
}
.w-24 {
  width: 6rem;
}
.w-32 {
  width: 8rem;
}
.w-4 {
  width: 1rem;
}
.w-5 {
  width: 1.25rem;
}
.w-56 {
  width: 14rem;
}
.w-6 {
  width: 1.5rem;
}
.w-60 {
  width: 15rem;
}
.w-8 {
  width: 2rem;
}
.w-\\[36\\.0625rem\\] {
  width: 36.0625rem;
}
.w-\\[72\\.1875rem\\] {
  width: 72.1875rem;
}
.w-full {
  width: 100%;
}
.w-px {
  width: 1px;
}
.w-screen {
  width: 100vw;
}
.min-w-0 {
  min-width: 0px;
}
.min-w-\\[320px\\] {
  min-width: 320px;
}
.min-w-full {
  min-width: 100%;
}
.max-w-2xl {
  max-width: 42rem;
}
.max-w-4xl {
  max-width: 56rem;
}
.max-w-7xl {
  max-width: 80rem;
}
.max-w-\\[150px\\] {
  max-width: 150px;
}
.max-w-lg {
  max-width: 32rem;
}
.max-w-md {
  max-width: 28rem;
}
.max-w-xl {
  max-width: 36rem;
}
.flex-1 {
  flex: 1 1 0%;
}
.flex-auto {
  flex: 1 1 auto;
}
.flex-none {
  flex: none;
}
.flex-shrink-0 {
  flex-shrink: 0;
}
.flex-grow {
  flex-grow: 1;
}
.origin-bottom-right {
  transform-origin: bottom right;
}
.origin-top-right {
  transform-origin: top right;
}
.-translate-x-1\\/2 {
  --tw-translate-x: -50%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.-translate-y-1\\/2 {
  --tw-translate-y: -50%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.-translate-y-2 {
  --tw-translate-y: -0.5rem;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.translate-y-0 {
  --tw-translate-y: 0px;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.translate-y-4 {
  --tw-translate-y: 1rem;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.scale-100 {
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.scale-95 {
  --tw-scale-x: .95;
  --tw-scale-y: .95;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.transform {
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.transform-gpu {
  transform: translate3d(var(--tw-translate-x), var(--tw-translate-y), 0) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
@keyframes spin {

  to {
    transform: rotate(360deg);
  }
}
.animate-spin {
  animation: spin 1s linear infinite;
}
.cursor-default {
  cursor: default;
}
.cursor-pointer {
  cursor: pointer;
}
.select-none {
  -webkit-user-select: none;
     -moz-user-select: none;
          user-select: none;
}
.resize-none {
  resize: none;
}
.list-inside {
  list-style-position: inside;
}
.list-decimal {
  list-style-type: decimal;
}
.list-disc {
  list-style-type: disc;
}
.appearance-none {
  -webkit-appearance: none;
     -moz-appearance: none;
          appearance: none;
}
.grid-cols-1 {
  grid-template-columns: repeat(1, minmax(0, 1fr));
}
.grid-cols-2 {
  grid-template-columns: repeat(2, minmax(0, 1fr));
}
.flex-col {
  flex-direction: column;
}
.flex-wrap {
  flex-wrap: wrap;
}
.items-start {
  align-items: flex-start;
}
.items-end {
  align-items: flex-end;
}
.items-center {
  align-items: center;
}
.items-baseline {
  align-items: baseline;
}
.justify-end {
  justify-content: flex-end;
}
.justify-center {
  justify-content: center;
}
.justify-between {
  justify-content: space-between;
}
.gap-2 {
  gap: 0.5rem;
}
.gap-4 {
  gap: 1rem;
}
.gap-6 {
  gap: 1.5rem;
}
.gap-8 {
  gap: 2rem;
}
.gap-x-1 {
  -moz-column-gap: 0.25rem;
       column-gap: 0.25rem;
}
.gap-x-2 {
  -moz-column-gap: 0.5rem;
       column-gap: 0.5rem;
}
.gap-x-3 {
  -moz-column-gap: 0.75rem;
       column-gap: 0.75rem;
}
.gap-x-4 {
  -moz-column-gap: 1rem;
       column-gap: 1rem;
}
.gap-x-6 {
  -moz-column-gap: 1.5rem;
       column-gap: 1.5rem;
}
.gap-x-8 {
  -moz-column-gap: 2rem;
       column-gap: 2rem;
}
.gap-y-6 {
  row-gap: 1.5rem;
}
.space-x-1 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-x-reverse: 0;
  margin-right: calc(0.25rem * var(--tw-space-x-reverse));
  margin-left: calc(0.25rem * calc(1 - var(--tw-space-x-reverse)));
}
.space-x-2 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-x-reverse: 0;
  margin-right: calc(0.5rem * var(--tw-space-x-reverse));
  margin-left: calc(0.5rem * calc(1 - var(--tw-space-x-reverse)));
}
.space-x-3 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-x-reverse: 0;
  margin-right: calc(0.75rem * var(--tw-space-x-reverse));
  margin-left: calc(0.75rem * calc(1 - var(--tw-space-x-reverse)));
}
.space-x-4 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-x-reverse: 0;
  margin-right: calc(1rem * var(--tw-space-x-reverse));
  margin-left: calc(1rem * calc(1 - var(--tw-space-x-reverse)));
}
.space-x-5 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-x-reverse: 0;
  margin-right: calc(1.25rem * var(--tw-space-x-reverse));
  margin-left: calc(1.25rem * calc(1 - var(--tw-space-x-reverse)));
}
.space-y-1 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-y-reverse: 0;
  margin-top: calc(0.25rem * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(0.25rem * var(--tw-space-y-reverse));
}
.space-y-2 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-y-reverse: 0;
  margin-top: calc(0.5rem * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(0.5rem * var(--tw-space-y-reverse));
}
.space-y-20 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-y-reverse: 0;
  margin-top: calc(5rem * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(5rem * var(--tw-space-y-reverse));
}
.space-y-3 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-y-reverse: 0;
  margin-top: calc(0.75rem * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(0.75rem * var(--tw-space-y-reverse));
}
.space-y-4 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-y-reverse: 0;
  margin-top: calc(1rem * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(1rem * var(--tw-space-y-reverse));
}
.space-y-6 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-y-reverse: 0;
  margin-top: calc(1.5rem * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(1.5rem * var(--tw-space-y-reverse));
}
.space-y-8 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-y-reverse: 0;
  margin-top: calc(2rem * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(2rem * var(--tw-space-y-reverse));
}
.space-y-9 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-y-reverse: 0;
  margin-top: calc(2.25rem * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(2.25rem * var(--tw-space-y-reverse));
}
.divide-y > :not([hidden]) ~ :not([hidden]) {
  --tw-divide-y-reverse: 0;
  border-top-width: calc(1px * calc(1 - var(--tw-divide-y-reverse)));
  border-bottom-width: calc(1px * var(--tw-divide-y-reverse));
}
.divide-gray-200 > :not([hidden]) ~ :not([hidden]) {
  --tw-divide-opacity: 1;
  border-color: rgb(229 231 235 / var(--tw-divide-opacity));
}
.divide-gray-300 > :not([hidden]) ~ :not([hidden]) {
  --tw-divide-opacity: 1;
  border-color: rgb(209 213 219 / var(--tw-divide-opacity));
}
.overflow-hidden {
  overflow: hidden;
}
.overflow-x-auto {
  overflow-x: auto;
}
.overflow-y-auto {
  overflow-y: auto;
}
.truncate {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.whitespace-normal {
  white-space: normal;
}
.whitespace-nowrap {
  white-space: nowrap;
}
.break-words {
  overflow-wrap: break-word;
}
.break-all {
  word-break: break-all;
}
.rounded {
  border-radius: 0.25rem;
}
.rounded-3xl {
  border-radius: 1.5rem;
}
.rounded-full {
  border-radius: 9999px;
}
.rounded-lg {
  border-radius: 0.5rem;
}
.rounded-md {
  border-radius: 0.375rem;
}
.rounded-xl {
  border-radius: 0.75rem;
}
.rounded-l-md {
  border-top-left-radius: 0.375rem;
  border-bottom-left-radius: 0.375rem;
}
.rounded-r-md {
  border-top-right-radius: 0.375rem;
  border-bottom-right-radius: 0.375rem;
}
.rounded-t-3xl {
  border-top-left-radius: 1.5rem;
  border-top-right-radius: 1.5rem;
}
.border {
  border-width: 1px;
}
.border-0 {
  border-width: 0px;
}
.border-2 {
  border-width: 2px;
}
.border-b {
  border-bottom-width: 1px;
}
.border-l-4 {
  border-left-width: 4px;
}
.border-r {
  border-right-width: 1px;
}
.border-t {
  border-top-width: 1px;
}
.border-dashed {
  border-style: dashed;
}
.border-amber-400 {
  --tw-border-opacity: 1;
  border-color: rgb(251 191 36 / var(--tw-border-opacity));
}
.border-brand-400 {
  --tw-border-opacity: 1;
  border-color: rgb(230 139 94 / var(--tw-border-opacity));
}
.border-brand-500 {
  --tw-border-opacity: 1;
  border-color: rgb(220 74 34 / var(--tw-border-opacity));
}
.border-brandcomp-500 {
  --tw-border-opacity: 1;
  border-color: rgb(35 181 221 / var(--tw-border-opacity));
}
.border-gray-200 {
  --tw-border-opacity: 1;
  border-color: rgb(229 231 235 / var(--tw-border-opacity));
}
.border-gray-300 {
  --tw-border-opacity: 1;
  border-color: rgb(209 213 219 / var(--tw-border-opacity));
}
.border-gray-400 {
  --tw-border-opacity: 1;
  border-color: rgb(156 163 175 / var(--tw-border-opacity));
}
.border-red-400 {
  --tw-border-opacity: 1;
  border-color: rgb(248 113 113 / var(--tw-border-opacity));
}
.border-red-500 {
  --tw-border-opacity: 1;
  border-color: rgb(239 68 68 / var(--tw-border-opacity));
}
.border-transparent {
  border-color: transparent;
}
.bg-amber-50 {
  --tw-bg-opacity: 1;
  background-color: rgb(255 251 235 / var(--tw-bg-opacity));
}
.bg-black {
  --tw-bg-opacity: 1;
  background-color: rgb(0 0 0 / var(--tw-bg-opacity));
}
.bg-blue-50 {
  --tw-bg-opacity: 1;
  background-color: rgb(239 246 255 / var(--tw-bg-opacity));
}
.bg-blue-500 {
  --tw-bg-opacity: 1;
  background-color: rgb(59 130 246 / var(--tw-bg-opacity));
}
.bg-brand-100 {
  --tw-bg-opacity: 1;
  background-color: rgb(252 244 232 / var(--tw-bg-opacity));
}
.bg-brand-50 {
  --tw-bg-opacity: 1;
  background-color: rgb(252 248 242 / var(--tw-bg-opacity));
}
.bg-brand-500 {
  --tw-bg-opacity: 1;
  background-color: rgb(220 74 34 / var(--tw-bg-opacity));
}
.bg-brand-600 {
  --tw-bg-opacity: 1;
  background-color: rgb(196 61 27 / var(--tw-bg-opacity));
}
.bg-brandcomp-100 {
  --tw-bg-opacity: 1;
  background-color: rgb(232 250 252 / var(--tw-bg-opacity));
}
.bg-brandcomp-50 {
  --tw-bg-opacity: 1;
  background-color: rgb(242 251 252 / var(--tw-bg-opacity));
}
.bg-brandcomp-500 {
  --tw-bg-opacity: 1;
  background-color: rgb(35 181 221 / var(--tw-bg-opacity));
}
.bg-gray-100 {
  --tw-bg-opacity: 1;
  background-color: rgb(243 244 246 / var(--tw-bg-opacity));
}
.bg-gray-200 {
  --tw-bg-opacity: 1;
  background-color: rgb(229 231 235 / var(--tw-bg-opacity));
}
.bg-gray-400 {
  --tw-bg-opacity: 1;
  background-color: rgb(156 163 175 / var(--tw-bg-opacity));
}
.bg-gray-50 {
  --tw-bg-opacity: 1;
  background-color: rgb(249 250 251 / var(--tw-bg-opacity));
}
.bg-gray-500 {
  --tw-bg-opacity: 1;
  background-color: rgb(107 114 128 / var(--tw-bg-opacity));
}
.bg-gray-600 {
  --tw-bg-opacity: 1;
  background-color: rgb(75 85 99 / var(--tw-bg-opacity));
}
.bg-gray-800 {
  --tw-bg-opacity: 1;
  background-color: rgb(31 41 55 / var(--tw-bg-opacity));
}
.bg-gray-900 {
  --tw-bg-opacity: 1;
  background-color: rgb(17 24 39 / var(--tw-bg-opacity));
}
.bg-green-100 {
  --tw-bg-opacity: 1;
  background-color: rgb(220 252 231 / var(--tw-bg-opacity));
}
.bg-green-400 {
  --tw-bg-opacity: 1;
  background-color: rgb(74 222 128 / var(--tw-bg-opacity));
}
.bg-green-50 {
  --tw-bg-opacity: 1;
  background-color: rgb(240 253 244 / var(--tw-bg-opacity));
}
.bg-indigo-600 {
  --tw-bg-opacity: 1;
  background-color: rgb(79 70 229 / var(--tw-bg-opacity));
}
.bg-inherit {
  background-color: inherit;
}
.bg-orange-600 {
  --tw-bg-opacity: 1;
  background-color: rgb(234 88 12 / var(--tw-bg-opacity));
}
.bg-pink-400 {
  --tw-bg-opacity: 1;
  background-color: rgb(244 114 182 / var(--tw-bg-opacity));
}
.bg-red-100 {
  --tw-bg-opacity: 1;
  background-color: rgb(254 226 226 / var(--tw-bg-opacity));
}
.bg-red-50 {
  --tw-bg-opacity: 1;
  background-color: rgb(254 242 242 / var(--tw-bg-opacity));
}
.bg-red-500 {
  --tw-bg-opacity: 1;
  background-color: rgb(239 68 68 / var(--tw-bg-opacity));
}
.bg-red-600 {
  --tw-bg-opacity: 1;
  background-color: rgb(220 38 38 / var(--tw-bg-opacity));
}
.bg-slate-800 {
  --tw-bg-opacity: 1;
  background-color: rgb(30 41 59 / var(--tw-bg-opacity));
}
.bg-transparent {
  background-color: transparent;
}
.bg-white {
  --tw-bg-opacity: 1;
  background-color: rgb(255 255 255 / var(--tw-bg-opacity));
}
.bg-white\\/5 {
  background-color: rgb(255 255 255 / 0.05);
}
.bg-white\\/60 {
  background-color: rgb(255 255 255 / 0.6);
}
.bg-yellow-100 {
  --tw-bg-opacity: 1;
  background-color: rgb(254 249 195 / var(--tw-bg-opacity));
}
.bg-yellow-400 {
  --tw-bg-opacity: 1;
  background-color: rgb(250 204 21 / var(--tw-bg-opacity));
}
.bg-opacity-20 {
  --tw-bg-opacity: 0.2;
}
.bg-opacity-30 {
  --tw-bg-opacity: 0.3;
}
.bg-opacity-50 {
  --tw-bg-opacity: 0.5;
}
.bg-opacity-70 {
  --tw-bg-opacity: 0.7;
}
.bg-opacity-75 {
  --tw-bg-opacity: 0.75;
}
.bg-opacity-80 {
  --tw-bg-opacity: 0.8;
}
.bg-gradient-to-r {
  background-image: linear-gradient(to right, var(--tw-gradient-stops));
}
.from-\\[\\#dc4a22\\] {
  --tw-gradient-from: #dc4a22 var(--tw-gradient-from-position);
  --tw-gradient-to: rgb(220 74 34 / 0) var(--tw-gradient-to-position);
  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);
}
.from-brand-600 {
  --tw-gradient-from: #c43d1b var(--tw-gradient-from-position);
  --tw-gradient-to: rgb(196 61 27 / 0) var(--tw-gradient-to-position);
  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);
}
.from-pink-500 {
  --tw-gradient-from: #ec4899 var(--tw-gradient-from-position);
  --tw-gradient-to: rgb(236 72 153 / 0) var(--tw-gradient-to-position);
  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);
}
.via-red-500 {
  --tw-gradient-to: rgb(239 68 68 / 0)  var(--tw-gradient-to-position);
  --tw-gradient-stops: var(--tw-gradient-from), #ef4444 var(--tw-gradient-via-position), var(--tw-gradient-to);
}
.to-\\[\\#fcf4e8\\] {
  --tw-gradient-to: #fcf4e8 var(--tw-gradient-to-position);
}
.to-brand-800 {
  --tw-gradient-to: #85200c var(--tw-gradient-to-position);
}
.to-yellow-400 {
  --tw-gradient-to: #facc15 var(--tw-gradient-to-position);
}
.p-1 {
  padding: 0.25rem;
}
.p-1\\.5 {
  padding: 0.375rem;
}
.p-2 {
  padding: 0.5rem;
}
.p-3 {
  padding: 0.75rem;
}
.p-4 {
  padding: 1rem;
}
.p-5 {
  padding: 1.25rem;
}
.p-6 {
  padding: 1.5rem;
}
.p-8 {
  padding: 2rem;
}
.px-0 {
  padding-left: 0px;
  padding-right: 0px;
}
.px-2 {
  padding-left: 0.5rem;
  padding-right: 0.5rem;
}
.px-2\\.5 {
  padding-left: 0.625rem;
  padding-right: 0.625rem;
}
.px-3 {
  padding-left: 0.75rem;
  padding-right: 0.75rem;
}
.px-3\\.5 {
  padding-left: 0.875rem;
  padding-right: 0.875rem;
}
.px-36 {
  padding-left: 9rem;
  padding-right: 9rem;
}
.px-4 {
  padding-left: 1rem;
  padding-right: 1rem;
}
.px-5 {
  padding-left: 1.25rem;
  padding-right: 1.25rem;
}
.px-6 {
  padding-left: 1.5rem;
  padding-right: 1.5rem;
}
.px-8 {
  padding-left: 2rem;
  padding-right: 2rem;
}
.py-0\\.5 {
  padding-top: 0.125rem;
  padding-bottom: 0.125rem;
}
.py-1 {
  padding-top: 0.25rem;
  padding-bottom: 0.25rem;
}
.py-1\\.5 {
  padding-top: 0.375rem;
  padding-bottom: 0.375rem;
}
.py-12 {
  padding-top: 3rem;
  padding-bottom: 3rem;
}
.py-2 {
  padding-top: 0.5rem;
  padding-bottom: 0.5rem;
}
.py-2\\.5 {
  padding-top: 0.625rem;
  padding-bottom: 0.625rem;
}
.py-3 {
  padding-top: 0.75rem;
  padding-bottom: 0.75rem;
}
.py-3\\.5 {
  padding-top: 0.875rem;
  padding-bottom: 0.875rem;
}
.py-4 {
  padding-top: 1rem;
  padding-bottom: 1rem;
}
.py-5 {
  padding-top: 1.25rem;
  padding-bottom: 1.25rem;
}
.py-6 {
  padding-top: 1.5rem;
  padding-bottom: 1.5rem;
}
.py-8 {
  padding-top: 2rem;
  padding-bottom: 2rem;
}
.pb-10 {
  padding-bottom: 2.5rem;
}
.pb-12 {
  padding-bottom: 3rem;
}
.pb-24 {
  padding-bottom: 6rem;
}
.pb-4 {
  padding-bottom: 1rem;
}
.pb-6 {
  padding-bottom: 1.5rem;
}
.pb-8 {
  padding-bottom: 2rem;
}
.pb-96 {
  padding-bottom: 24rem;
}
.pl-10 {
  padding-left: 2.5rem;
}
.pl-3 {
  padding-left: 0.75rem;
}
.pl-4 {
  padding-left: 1rem;
}
.pl-5 {
  padding-left: 1.25rem;
}
.pl-6 {
  padding-left: 1.5rem;
}
.pr-10 {
  padding-right: 2.5rem;
}
.pr-2 {
  padding-right: 0.5rem;
}
.pr-3 {
  padding-right: 0.75rem;
}
.pr-4 {
  padding-right: 1rem;
}
.pr-6 {
  padding-right: 1.5rem;
}
.pt-20 {
  padding-top: 5rem;
}
.pt-24 {
  padding-top: 6rem;
}
.pt-4 {
  padding-top: 1rem;
}
.pt-5 {
  padding-top: 1.25rem;
}
.pt-6 {
  padding-top: 1.5rem;
}
.text-left {
  text-align: left;
}
.text-center {
  text-align: center;
}
.text-right {
  text-align: right;
}
.align-baseline {
  vertical-align: baseline;
}
.font-brand {
  font-family: Zilla Slab, ui-serif, Georgia, Cambria, "Times New Roman", Times, serif;
}
.font-mono {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}
.font-serif {
  font-family: ui-serif, Georgia, Cambria, "Times New Roman", Times, serif;
}
.text-2xl {
  font-size: 1.5rem;
  line-height: 2rem;
}
.text-3xl {
  font-size: 1.875rem;
  line-height: 2.25rem;
}
.text-4xl {
  font-size: 2.25rem;
  line-height: 2.5rem;
}
.text-5xl {
  font-size: 3rem;
  line-height: 1;
}
.text-base {
  font-size: 1rem;
  line-height: 1.5rem;
}
.text-lg {
  font-size: 1.125rem;
  line-height: 1.75rem;
}
.text-sm {
  font-size: 0.875rem;
  line-height: 1.25rem;
}
.text-xl {
  font-size: 1.25rem;
  line-height: 1.75rem;
}
.text-xs {
  font-size: 0.75rem;
  line-height: 1rem;
}
.font-bold {
  font-weight: 700;
}
.font-extrabold {
  font-weight: 800;
}
.font-medium {
  font-weight: 500;
}
.font-semibold {
  font-weight: 600;
}
.uppercase {
  text-transform: uppercase;
}
.italic {
  font-style: italic;
}
.leading-5 {
  line-height: 1.25rem;
}
.leading-6 {
  line-height: 1.5rem;
}
.leading-7 {
  line-height: 1.75rem;
}
.leading-8 {
  line-height: 2rem;
}
.leading-\\[1\\.2\\] {
  line-height: 1.2;
}
.leading-relaxed {
  line-height: 1.625;
}
.leading-tight {
  line-height: 1.25;
}
.tracking-tight {
  letter-spacing: -0.025em;
}
.tracking-wide {
  letter-spacing: 0.025em;
}
.tracking-wider {
  letter-spacing: 0.05em;
}
.text-amber-700 {
  --tw-text-opacity: 1;
  color: rgb(180 83 9 / var(--tw-text-opacity));
}
.text-blue-500 {
  --tw-text-opacity: 1;
  color: rgb(59 130 246 / var(--tw-text-opacity));
}
.text-blue-700 {
  --tw-text-opacity: 1;
  color: rgb(29 78 216 / var(--tw-text-opacity));
}
.text-brand-400 {
  --tw-text-opacity: 1;
  color: rgb(230 139 94 / var(--tw-text-opacity));
}
.text-brand-500 {
  --tw-text-opacity: 1;
  color: rgb(220 74 34 / var(--tw-text-opacity));
}
.text-brand-600 {
  --tw-text-opacity: 1;
  color: rgb(196 61 27 / var(--tw-text-opacity));
}
.text-brand-700 {
  --tw-text-opacity: 1;
  color: rgb(163 45 18 / var(--tw-text-opacity));
}
.text-brandcomp-500 {
  --tw-text-opacity: 1;
  color: rgb(35 181 221 / var(--tw-text-opacity));
}
.text-brandcomp-600 {
  --tw-text-opacity: 1;
  color: rgb(28 156 199 / var(--tw-text-opacity));
}
.text-brandcomp-700 {
  --tw-text-opacity: 1;
  color: rgb(20 120 166 / var(--tw-text-opacity));
}
.text-brandcomp-800 {
  --tw-text-opacity: 1;
  color: rgb(13 89 133 / var(--tw-text-opacity));
}
.text-gray-300 {
  --tw-text-opacity: 1;
  color: rgb(209 213 219 / var(--tw-text-opacity));
}
.text-gray-400 {
  --tw-text-opacity: 1;
  color: rgb(156 163 175 / var(--tw-text-opacity));
}
.text-gray-500 {
  --tw-text-opacity: 1;
  color: rgb(107 114 128 / var(--tw-text-opacity));
}
.text-gray-600 {
  --tw-text-opacity: 1;
  color: rgb(75 85 99 / var(--tw-text-opacity));
}
.text-gray-700 {
  --tw-text-opacity: 1;
  color: rgb(55 65 81 / var(--tw-text-opacity));
}
.text-gray-800 {
  --tw-text-opacity: 1;
  color: rgb(31 41 55 / var(--tw-text-opacity));
}
.text-gray-900 {
  --tw-text-opacity: 1;
  color: rgb(17 24 39 / var(--tw-text-opacity));
}
.text-green-400 {
  --tw-text-opacity: 1;
  color: rgb(74 222 128 / var(--tw-text-opacity));
}
.text-green-500 {
  --tw-text-opacity: 1;
  color: rgb(34 197 94 / var(--tw-text-opacity));
}
.text-green-600 {
  --tw-text-opacity: 1;
  color: rgb(22 163 74 / var(--tw-text-opacity));
}
.text-green-700 {
  --tw-text-opacity: 1;
  color: rgb(21 128 61 / var(--tw-text-opacity));
}
.text-green-800 {
  --tw-text-opacity: 1;
  color: rgb(22 101 52 / var(--tw-text-opacity));
}
.text-indigo-400 {
  --tw-text-opacity: 1;
  color: rgb(129 140 248 / var(--tw-text-opacity));
}
.text-indigo-600 {
  --tw-text-opacity: 1;
  color: rgb(79 70 229 / var(--tw-text-opacity));
}
.text-red-400 {
  --tw-text-opacity: 1;
  color: rgb(248 113 113 / var(--tw-text-opacity));
}
.text-red-500 {
  --tw-text-opacity: 1;
  color: rgb(239 68 68 / var(--tw-text-opacity));
}
.text-red-600 {
  --tw-text-opacity: 1;
  color: rgb(220 38 38 / var(--tw-text-opacity));
}
.text-red-700 {
  --tw-text-opacity: 1;
  color: rgb(185 28 28 / var(--tw-text-opacity));
}
.text-red-800 {
  --tw-text-opacity: 1;
  color: rgb(153 27 27 / var(--tw-text-opacity));
}
.text-slate-300 {
  --tw-text-opacity: 1;
  color: rgb(203 213 225 / var(--tw-text-opacity));
}
.text-slate-500 {
  --tw-text-opacity: 1;
  color: rgb(100 116 139 / var(--tw-text-opacity));
}
.text-slate-600 {
  --tw-text-opacity: 1;
  color: rgb(71 85 105 / var(--tw-text-opacity));
}
.text-white {
  --tw-text-opacity: 1;
  color: rgb(255 255 255 / var(--tw-text-opacity));
}
.text-white\\/60 {
  color: rgb(255 255 255 / 0.6);
}
.text-white\\/90 {
  color: rgb(255 255 255 / 0.9);
}
.text-yellow-400 {
  --tw-text-opacity: 1;
  color: rgb(250 204 21 / var(--tw-text-opacity));
}
.text-yellow-600 {
  --tw-text-opacity: 1;
  color: rgb(202 138 4 / var(--tw-text-opacity));
}
.text-yellow-800 {
  --tw-text-opacity: 1;
  color: rgb(133 77 14 / var(--tw-text-opacity));
}
.underline {
  text-decoration-line: underline;
}
.line-through {
  text-decoration-line: line-through;
}
.no-underline {
  text-decoration-line: none;
}
.placeholder-gray-400::-moz-placeholder {
  --tw-placeholder-opacity: 1;
  color: rgb(156 163 175 / var(--tw-placeholder-opacity));
}
.placeholder-gray-400::placeholder {
  --tw-placeholder-opacity: 1;
  color: rgb(156 163 175 / var(--tw-placeholder-opacity));
}
.opacity-0 {
  opacity: 0;
}
.opacity-100 {
  opacity: 1;
}
.opacity-25 {
  opacity: 0.25;
}
.opacity-30 {
  opacity: 0.3;
}
.opacity-40 {
  opacity: 0.4;
}
.opacity-50 {
  opacity: 0.5;
}
.opacity-55 {
  opacity: 0.55;
}
.opacity-60 {
  opacity: 0.6;
}
.opacity-75 {
  opacity: 0.75;
}
.opacity-80 {
  opacity: 0.8;
}
.shadow {
  --tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.shadow-2xl {
  --tw-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.25);
  --tw-shadow-colored: 0 25px 50px -12px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.shadow-lg {
  --tw-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.shadow-md {
  --tw-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.shadow-sm {
  --tw-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  --tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.shadow-xl {
  --tw-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 20px 25px -5px var(--tw-shadow-color), 0 8px 10px -6px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.ring-1 {
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
}
.ring-2 {
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
}
.ring-inset {
  --tw-ring-inset: inset;
}
.ring-black {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(0 0 0 / var(--tw-ring-opacity));
}
.ring-gray-200 {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(229 231 235 / var(--tw-ring-opacity));
}
.ring-gray-300 {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(209 213 219 / var(--tw-ring-opacity));
}
.ring-gray-900\\/10 {
  --tw-ring-color: rgb(17 24 39 / 0.1);
}
.ring-indigo-200 {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(199 210 254 / var(--tw-ring-opacity));
}
.ring-opacity-5 {
  --tw-ring-opacity: 0.05;
}
.blur-2xl {
  --tw-blur: blur(40px);
  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
}
.blur-3xl {
  --tw-blur: blur(64px);
  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
}
.blur-lg {
  --tw-blur: blur(16px);
  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
}
.blur-sm {
  --tw-blur: blur(4px);
  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
}
.filter {
  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
}
.transition {
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-backdrop-filter;
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-backdrop-filter;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.transition-all {
  transition-property: all;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.transition-colors {
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.transition-opacity {
  transition-property: opacity;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.duration-100 {
  transition-duration: 100ms;
}
.duration-150 {
  transition-duration: 150ms;
}
.duration-200 {
  transition-duration: 200ms;
}
.duration-300 {
  transition-duration: 300ms;
}
.duration-75 {
  transition-duration: 75ms;
}
.ease-in {
  transition-timing-function: cubic-bezier(0.4, 0, 1, 1);
}
.ease-in-out {
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
}
.ease-out {
  transition-timing-function: cubic-bezier(0, 0, 0.2, 1);
}
.\\[mask-image\\:radial-gradient\\(closest-side\\2c white\\2c transparent\\)\\] {
  -webkit-mask-image: radial-gradient(closest-side,white,transparent);
          mask-image: radial-gradient(closest-side,white,transparent);
}
@media (min-width: 640px) {

   a.sm\\:block {
    font-family: Zilla Slab, ui-serif, Georgia, Cambria, "Times New Roman", Times, serif;
  }
}
.dark\\:prose-invert:is(.dark *) {
  --tw-prose-body: var(--tw-prose-invert-body);
  --tw-prose-headings: var(--tw-prose-invert-headings);
  --tw-prose-lead: var(--tw-prose-invert-lead);
  --tw-prose-links: var(--tw-prose-invert-links);
  --tw-prose-bold: var(--tw-prose-invert-bold);
  --tw-prose-counters: var(--tw-prose-invert-counters);
  --tw-prose-bullets: var(--tw-prose-invert-bullets);
  --tw-prose-hr: var(--tw-prose-invert-hr);
  --tw-prose-quotes: var(--tw-prose-invert-quotes);
  --tw-prose-quote-borders: var(--tw-prose-invert-quote-borders);
  --tw-prose-captions: var(--tw-prose-invert-captions);
  --tw-prose-kbd: var(--tw-prose-invert-kbd);
  --tw-prose-kbd-shadows: var(--tw-prose-invert-kbd-shadows);
  --tw-prose-code: var(--tw-prose-invert-code);
  --tw-prose-pre-code: var(--tw-prose-invert-pre-code);
  --tw-prose-pre-bg: var(--tw-prose-invert-pre-bg);
  --tw-prose-th-borders: var(--tw-prose-invert-th-borders);
  --tw-prose-td-borders: var(--tw-prose-invert-td-borders);
}
@media (min-width: 768px) {

  .md\\:prose-lg {
    font-size: 1.125rem;
    line-height: 1.7777778;
  }

  .md\\:prose-lg :where(p):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.3333333em;
    margin-bottom: 1.3333333em;
  }

  .md\\:prose-lg :where([class~="lead"]):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 1.2222222em;
    line-height: 1.4545455;
    margin-top: 1.0909091em;
    margin-bottom: 1.0909091em;
  }

  .md\\:prose-lg :where(blockquote):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.6666667em;
    margin-bottom: 1.6666667em;
    padding-inline-start: 1em;
  }

  .md\\:prose-lg :where(h1):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 2.6666667em;
    margin-top: 0;
    margin-bottom: 0.8333333em;
    line-height: 1;
  }

  .md\\:prose-lg :where(h2):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 1.6666667em;
    margin-top: 1.8666667em;
    margin-bottom: 1.0666667em;
    line-height: 1.3333333;
  }

  .md\\:prose-lg :where(h3):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 1.3333333em;
    margin-top: 1.6666667em;
    margin-bottom: 0.6666667em;
    line-height: 1.5;
  }

  .md\\:prose-lg :where(h4):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.7777778em;
    margin-bottom: 0.4444444em;
    line-height: 1.5555556;
  }

  .md\\:prose-lg :where(img):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.7777778em;
    margin-bottom: 1.7777778em;
  }

  .md\\:prose-lg :where(picture):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.7777778em;
    margin-bottom: 1.7777778em;
  }

  .md\\:prose-lg :where(picture > img):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0;
    margin-bottom: 0;
  }

  .md\\:prose-lg :where(video):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.7777778em;
    margin-bottom: 1.7777778em;
  }

  .md\\:prose-lg :where(kbd):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 0.8888889em;
    border-radius: 0.3125rem;
    padding-top: 0.2222222em;
    padding-inline-end: 0.4444444em;
    padding-bottom: 0.2222222em;
    padding-inline-start: 0.4444444em;
  }

  .md\\:prose-lg :where(code):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 0.8888889em;
  }

  .md\\:prose-lg :where(h2 code):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 0.8666667em;
  }

  .md\\:prose-lg :where(h3 code):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 0.875em;
  }

  .md\\:prose-lg :where(pre):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 0.8888889em;
    line-height: 1.75;
    margin-top: 2em;
    margin-bottom: 2em;
    border-radius: 0.375rem;
    padding-top: 1em;
    padding-inline-end: 1.5em;
    padding-bottom: 1em;
    padding-inline-start: 1.5em;
  }

  .md\\:prose-lg :where(ol):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.3333333em;
    margin-bottom: 1.3333333em;
    padding-inline-start: 1.5555556em;
  }

  .md\\:prose-lg :where(ul):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.3333333em;
    margin-bottom: 1.3333333em;
    padding-inline-start: 1.5555556em;
  }

  .md\\:prose-lg :where(li):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0.6666667em;
    margin-bottom: 0.6666667em;
  }

  .md\\:prose-lg :where(ol > li):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    padding-inline-start: 0.4444444em;
  }

  .md\\:prose-lg :where(ul > li):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    padding-inline-start: 0.4444444em;
  }

  .md\\:prose-lg :where(.md\\:prose-lg > ul > li p):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0.8888889em;
    margin-bottom: 0.8888889em;
  }

  .md\\:prose-lg :where(.md\\:prose-lg > ul > li > p:first-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.3333333em;
  }

  .md\\:prose-lg :where(.md\\:prose-lg > ul > li > p:last-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-bottom: 1.3333333em;
  }

  .md\\:prose-lg :where(.md\\:prose-lg > ol > li > p:first-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.3333333em;
  }

  .md\\:prose-lg :where(.md\\:prose-lg > ol > li > p:last-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-bottom: 1.3333333em;
  }

  .md\\:prose-lg :where(ul ul, ul ol, ol ul, ol ol):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0.8888889em;
    margin-bottom: 0.8888889em;
  }

  .md\\:prose-lg :where(dl):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.3333333em;
    margin-bottom: 1.3333333em;
  }

  .md\\:prose-lg :where(dt):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.3333333em;
  }

  .md\\:prose-lg :where(dd):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0.6666667em;
    padding-inline-start: 1.5555556em;
  }

  .md\\:prose-lg :where(hr):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 3.1111111em;
    margin-bottom: 3.1111111em;
  }

  .md\\:prose-lg :where(hr + *):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0;
  }

  .md\\:prose-lg :where(h2 + *):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0;
  }

  .md\\:prose-lg :where(h3 + *):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0;
  }

  .md\\:prose-lg :where(h4 + *):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0;
  }

  .md\\:prose-lg :where(table):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 0.8888889em;
    line-height: 1.5;
  }

  .md\\:prose-lg :where(thead th):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    padding-inline-end: 0.75em;
    padding-bottom: 0.75em;
    padding-inline-start: 0.75em;
  }

  .md\\:prose-lg :where(thead th:first-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    padding-inline-start: 0;
  }

  .md\\:prose-lg :where(thead th:last-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    padding-inline-end: 0;
  }

  .md\\:prose-lg :where(tbody td, tfoot td):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    padding-top: 0.75em;
    padding-inline-end: 0.75em;
    padding-bottom: 0.75em;
    padding-inline-start: 0.75em;
  }

  .md\\:prose-lg :where(tbody td:first-child, tfoot td:first-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    padding-inline-start: 0;
  }

  .md\\:prose-lg :where(tbody td:last-child, tfoot td:last-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    padding-inline-end: 0;
  }

  .md\\:prose-lg :where(figure):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.7777778em;
    margin-bottom: 1.7777778em;
  }

  .md\\:prose-lg :where(figure > *):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0;
    margin-bottom: 0;
  }

  .md\\:prose-lg :where(figcaption):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 0.8888889em;
    line-height: 1.5;
    margin-top: 1em;
  }

  .md\\:prose-lg :where(.md\\:prose-lg > :first-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0;
  }

  .md\\:prose-lg :where(.md\\:prose-lg > :last-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-bottom: 0;
  }
}
@media (min-width: 1024px) {

  .lg\\:prose-lg {
    font-size: 1.125rem;
    line-height: 1.7777778;
  }

  .lg\\:prose-lg :where(p):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.3333333em;
    margin-bottom: 1.3333333em;
  }

  .lg\\:prose-lg :where([class~="lead"]):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 1.2222222em;
    line-height: 1.4545455;
    margin-top: 1.0909091em;
    margin-bottom: 1.0909091em;
  }

  .lg\\:prose-lg :where(blockquote):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.6666667em;
    margin-bottom: 1.6666667em;
    padding-inline-start: 1em;
  }

  .lg\\:prose-lg :where(h1):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 2.6666667em;
    margin-top: 0;
    margin-bottom: 0.8333333em;
    line-height: 1;
  }

  .lg\\:prose-lg :where(h2):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 1.6666667em;
    margin-top: 1.8666667em;
    margin-bottom: 1.0666667em;
    line-height: 1.3333333;
  }

  .lg\\:prose-lg :where(h3):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 1.3333333em;
    margin-top: 1.6666667em;
    margin-bottom: 0.6666667em;
    line-height: 1.5;
  }

  .lg\\:prose-lg :where(h4):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.7777778em;
    margin-bottom: 0.4444444em;
    line-height: 1.5555556;
  }

  .lg\\:prose-lg :where(img):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.7777778em;
    margin-bottom: 1.7777778em;
  }

  .lg\\:prose-lg :where(picture):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.7777778em;
    margin-bottom: 1.7777778em;
  }

  .lg\\:prose-lg :where(picture > img):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0;
    margin-bottom: 0;
  }

  .lg\\:prose-lg :where(video):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.7777778em;
    margin-bottom: 1.7777778em;
  }

  .lg\\:prose-lg :where(kbd):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 0.8888889em;
    border-radius: 0.3125rem;
    padding-top: 0.2222222em;
    padding-inline-end: 0.4444444em;
    padding-bottom: 0.2222222em;
    padding-inline-start: 0.4444444em;
  }

  .lg\\:prose-lg :where(code):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 0.8888889em;
  }

  .lg\\:prose-lg :where(h2 code):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 0.8666667em;
  }

  .lg\\:prose-lg :where(h3 code):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 0.875em;
  }

  .lg\\:prose-lg :where(pre):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 0.8888889em;
    line-height: 1.75;
    margin-top: 2em;
    margin-bottom: 2em;
    border-radius: 0.375rem;
    padding-top: 1em;
    padding-inline-end: 1.5em;
    padding-bottom: 1em;
    padding-inline-start: 1.5em;
  }

  .lg\\:prose-lg :where(ol):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.3333333em;
    margin-bottom: 1.3333333em;
    padding-inline-start: 1.5555556em;
  }

  .lg\\:prose-lg :where(ul):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.3333333em;
    margin-bottom: 1.3333333em;
    padding-inline-start: 1.5555556em;
  }

  .lg\\:prose-lg :where(li):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0.6666667em;
    margin-bottom: 0.6666667em;
  }

  .lg\\:prose-lg :where(ol > li):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    padding-inline-start: 0.4444444em;
  }

  .lg\\:prose-lg :where(ul > li):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    padding-inline-start: 0.4444444em;
  }

  .lg\\:prose-lg :where(.lg\\:prose-lg > ul > li p):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0.8888889em;
    margin-bottom: 0.8888889em;
  }

  .lg\\:prose-lg :where(.lg\\:prose-lg > ul > li > p:first-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.3333333em;
  }

  .lg\\:prose-lg :where(.lg\\:prose-lg > ul > li > p:last-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-bottom: 1.3333333em;
  }

  .lg\\:prose-lg :where(.lg\\:prose-lg > ol > li > p:first-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.3333333em;
  }

  .lg\\:prose-lg :where(.lg\\:prose-lg > ol > li > p:last-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-bottom: 1.3333333em;
  }

  .lg\\:prose-lg :where(ul ul, ul ol, ol ul, ol ol):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0.8888889em;
    margin-bottom: 0.8888889em;
  }

  .lg\\:prose-lg :where(dl):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.3333333em;
    margin-bottom: 1.3333333em;
  }

  .lg\\:prose-lg :where(dt):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.3333333em;
  }

  .lg\\:prose-lg :where(dd):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0.6666667em;
    padding-inline-start: 1.5555556em;
  }

  .lg\\:prose-lg :where(hr):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 3.1111111em;
    margin-bottom: 3.1111111em;
  }

  .lg\\:prose-lg :where(hr + *):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0;
  }

  .lg\\:prose-lg :where(h2 + *):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0;
  }

  .lg\\:prose-lg :where(h3 + *):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0;
  }

  .lg\\:prose-lg :where(h4 + *):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0;
  }

  .lg\\:prose-lg :where(table):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 0.8888889em;
    line-height: 1.5;
  }

  .lg\\:prose-lg :where(thead th):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    padding-inline-end: 0.75em;
    padding-bottom: 0.75em;
    padding-inline-start: 0.75em;
  }

  .lg\\:prose-lg :where(thead th:first-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    padding-inline-start: 0;
  }

  .lg\\:prose-lg :where(thead th:last-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    padding-inline-end: 0;
  }

  .lg\\:prose-lg :where(tbody td, tfoot td):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    padding-top: 0.75em;
    padding-inline-end: 0.75em;
    padding-bottom: 0.75em;
    padding-inline-start: 0.75em;
  }

  .lg\\:prose-lg :where(tbody td:first-child, tfoot td:first-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    padding-inline-start: 0;
  }

  .lg\\:prose-lg :where(tbody td:last-child, tfoot td:last-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    padding-inline-end: 0;
  }

  .lg\\:prose-lg :where(figure):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.7777778em;
    margin-bottom: 1.7777778em;
  }

  .lg\\:prose-lg :where(figure > *):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0;
    margin-bottom: 0;
  }

  .lg\\:prose-lg :where(figcaption):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 0.8888889em;
    line-height: 1.5;
    margin-top: 1em;
  }

  .lg\\:prose-lg :where(.lg\\:prose-lg > :first-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0;
  }

  .lg\\:prose-lg :where(.lg\\:prose-lg > :last-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-bottom: 0;
  }

  .lg\\:prose-xl {
    font-size: 1.25rem;
    line-height: 1.8;
  }

  .lg\\:prose-xl :where(p):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.2em;
    margin-bottom: 1.2em;
  }

  .lg\\:prose-xl :where([class~="lead"]):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 1.2em;
    line-height: 1.5;
    margin-top: 1em;
    margin-bottom: 1em;
  }

  .lg\\:prose-xl :where(blockquote):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.6em;
    margin-bottom: 1.6em;
    padding-inline-start: 1.0666667em;
  }

  .lg\\:prose-xl :where(h1):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 2.8em;
    margin-top: 0;
    margin-bottom: 0.8571429em;
    line-height: 1;
  }

  .lg\\:prose-xl :where(h2):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 1.8em;
    margin-top: 1.5555556em;
    margin-bottom: 0.8888889em;
    line-height: 1.1111111;
  }

  .lg\\:prose-xl :where(h3):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 1.5em;
    margin-top: 1.6em;
    margin-bottom: 0.6666667em;
    line-height: 1.3333333;
  }

  .lg\\:prose-xl :where(h4):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.8em;
    margin-bottom: 0.6em;
    line-height: 1.6;
  }

  .lg\\:prose-xl :where(img):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 2em;
    margin-bottom: 2em;
  }

  .lg\\:prose-xl :where(picture):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 2em;
    margin-bottom: 2em;
  }

  .lg\\:prose-xl :where(picture > img):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0;
    margin-bottom: 0;
  }

  .lg\\:prose-xl :where(video):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 2em;
    margin-bottom: 2em;
  }

  .lg\\:prose-xl :where(kbd):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 0.9em;
    border-radius: 0.3125rem;
    padding-top: 0.25em;
    padding-inline-end: 0.4em;
    padding-bottom: 0.25em;
    padding-inline-start: 0.4em;
  }

  .lg\\:prose-xl :where(code):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 0.9em;
  }

  .lg\\:prose-xl :where(h2 code):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 0.8611111em;
  }

  .lg\\:prose-xl :where(h3 code):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 0.9em;
  }

  .lg\\:prose-xl :where(pre):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 0.9em;
    line-height: 1.7777778;
    margin-top: 2em;
    margin-bottom: 2em;
    border-radius: 0.5rem;
    padding-top: 1.1111111em;
    padding-inline-end: 1.3333333em;
    padding-bottom: 1.1111111em;
    padding-inline-start: 1.3333333em;
  }

  .lg\\:prose-xl :where(ol):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.2em;
    margin-bottom: 1.2em;
    padding-inline-start: 1.6em;
  }

  .lg\\:prose-xl :where(ul):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.2em;
    margin-bottom: 1.2em;
    padding-inline-start: 1.6em;
  }

  .lg\\:prose-xl :where(li):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0.6em;
    margin-bottom: 0.6em;
  }

  .lg\\:prose-xl :where(ol > li):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    padding-inline-start: 0.4em;
  }

  .lg\\:prose-xl :where(ul > li):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    padding-inline-start: 0.4em;
  }

  .lg\\:prose-xl :where(.lg\\:prose-xl > ul > li p):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0.8em;
    margin-bottom: 0.8em;
  }

  .lg\\:prose-xl :where(.lg\\:prose-xl > ul > li > p:first-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.2em;
  }

  .lg\\:prose-xl :where(.lg\\:prose-xl > ul > li > p:last-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-bottom: 1.2em;
  }

  .lg\\:prose-xl :where(.lg\\:prose-xl > ol > li > p:first-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.2em;
  }

  .lg\\:prose-xl :where(.lg\\:prose-xl > ol > li > p:last-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-bottom: 1.2em;
  }

  .lg\\:prose-xl :where(ul ul, ul ol, ol ul, ol ol):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0.8em;
    margin-bottom: 0.8em;
  }

  .lg\\:prose-xl :where(dl):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.2em;
    margin-bottom: 1.2em;
  }

  .lg\\:prose-xl :where(dt):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.2em;
  }

  .lg\\:prose-xl :where(dd):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0.6em;
    padding-inline-start: 1.6em;
  }

  .lg\\:prose-xl :where(hr):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 2.8em;
    margin-bottom: 2.8em;
  }

  .lg\\:prose-xl :where(hr + *):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0;
  }

  .lg\\:prose-xl :where(h2 + *):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0;
  }

  .lg\\:prose-xl :where(h3 + *):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0;
  }

  .lg\\:prose-xl :where(h4 + *):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0;
  }

  .lg\\:prose-xl :where(table):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 0.9em;
    line-height: 1.5555556;
  }

  .lg\\:prose-xl :where(thead th):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    padding-inline-end: 0.6666667em;
    padding-bottom: 0.8888889em;
    padding-inline-start: 0.6666667em;
  }

  .lg\\:prose-xl :where(thead th:first-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    padding-inline-start: 0;
  }

  .lg\\:prose-xl :where(thead th:last-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    padding-inline-end: 0;
  }

  .lg\\:prose-xl :where(tbody td, tfoot td):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    padding-top: 0.8888889em;
    padding-inline-end: 0.6666667em;
    padding-bottom: 0.8888889em;
    padding-inline-start: 0.6666667em;
  }

  .lg\\:prose-xl :where(tbody td:first-child, tfoot td:first-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    padding-inline-start: 0;
  }

  .lg\\:prose-xl :where(tbody td:last-child, tfoot td:last-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    padding-inline-end: 0;
  }

  .lg\\:prose-xl :where(figure):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 2em;
    margin-bottom: 2em;
  }

  .lg\\:prose-xl :where(figure > *):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0;
    margin-bottom: 0;
  }

  .lg\\:prose-xl :where(figcaption):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 0.9em;
    line-height: 1.5555556;
    margin-top: 1em;
  }

  .lg\\:prose-xl :where(.lg\\:prose-xl > :first-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0;
  }

  .lg\\:prose-xl :where(.lg\\:prose-xl > :last-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-bottom: 0;
  }
}
@media (min-width: 1280px) {

  .xl\\:prose-xl {
    font-size: 1.25rem;
    line-height: 1.8;
  }

  .xl\\:prose-xl :where(p):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.2em;
    margin-bottom: 1.2em;
  }

  .xl\\:prose-xl :where([class~="lead"]):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 1.2em;
    line-height: 1.5;
    margin-top: 1em;
    margin-bottom: 1em;
  }

  .xl\\:prose-xl :where(blockquote):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.6em;
    margin-bottom: 1.6em;
    padding-inline-start: 1.0666667em;
  }

  .xl\\:prose-xl :where(h1):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 2.8em;
    margin-top: 0;
    margin-bottom: 0.8571429em;
    line-height: 1;
  }

  .xl\\:prose-xl :where(h2):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 1.8em;
    margin-top: 1.5555556em;
    margin-bottom: 0.8888889em;
    line-height: 1.1111111;
  }

  .xl\\:prose-xl :where(h3):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 1.5em;
    margin-top: 1.6em;
    margin-bottom: 0.6666667em;
    line-height: 1.3333333;
  }

  .xl\\:prose-xl :where(h4):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.8em;
    margin-bottom: 0.6em;
    line-height: 1.6;
  }

  .xl\\:prose-xl :where(img):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 2em;
    margin-bottom: 2em;
  }

  .xl\\:prose-xl :where(picture):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 2em;
    margin-bottom: 2em;
  }

  .xl\\:prose-xl :where(picture > img):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0;
    margin-bottom: 0;
  }

  .xl\\:prose-xl :where(video):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 2em;
    margin-bottom: 2em;
  }

  .xl\\:prose-xl :where(kbd):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 0.9em;
    border-radius: 0.3125rem;
    padding-top: 0.25em;
    padding-inline-end: 0.4em;
    padding-bottom: 0.25em;
    padding-inline-start: 0.4em;
  }

  .xl\\:prose-xl :where(code):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 0.9em;
  }

  .xl\\:prose-xl :where(h2 code):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 0.8611111em;
  }

  .xl\\:prose-xl :where(h3 code):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 0.9em;
  }

  .xl\\:prose-xl :where(pre):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 0.9em;
    line-height: 1.7777778;
    margin-top: 2em;
    margin-bottom: 2em;
    border-radius: 0.5rem;
    padding-top: 1.1111111em;
    padding-inline-end: 1.3333333em;
    padding-bottom: 1.1111111em;
    padding-inline-start: 1.3333333em;
  }

  .xl\\:prose-xl :where(ol):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.2em;
    margin-bottom: 1.2em;
    padding-inline-start: 1.6em;
  }

  .xl\\:prose-xl :where(ul):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.2em;
    margin-bottom: 1.2em;
    padding-inline-start: 1.6em;
  }

  .xl\\:prose-xl :where(li):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0.6em;
    margin-bottom: 0.6em;
  }

  .xl\\:prose-xl :where(ol > li):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    padding-inline-start: 0.4em;
  }

  .xl\\:prose-xl :where(ul > li):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    padding-inline-start: 0.4em;
  }

  .xl\\:prose-xl :where(.xl\\:prose-xl > ul > li p):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0.8em;
    margin-bottom: 0.8em;
  }

  .xl\\:prose-xl :where(.xl\\:prose-xl > ul > li > p:first-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.2em;
  }

  .xl\\:prose-xl :where(.xl\\:prose-xl > ul > li > p:last-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-bottom: 1.2em;
  }

  .xl\\:prose-xl :where(.xl\\:prose-xl > ol > li > p:first-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.2em;
  }

  .xl\\:prose-xl :where(.xl\\:prose-xl > ol > li > p:last-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-bottom: 1.2em;
  }

  .xl\\:prose-xl :where(ul ul, ul ol, ol ul, ol ol):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0.8em;
    margin-bottom: 0.8em;
  }

  .xl\\:prose-xl :where(dl):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.2em;
    margin-bottom: 1.2em;
  }

  .xl\\:prose-xl :where(dt):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 1.2em;
  }

  .xl\\:prose-xl :where(dd):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0.6em;
    padding-inline-start: 1.6em;
  }

  .xl\\:prose-xl :where(hr):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 2.8em;
    margin-bottom: 2.8em;
  }

  .xl\\:prose-xl :where(hr + *):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0;
  }

  .xl\\:prose-xl :where(h2 + *):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0;
  }

  .xl\\:prose-xl :where(h3 + *):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0;
  }

  .xl\\:prose-xl :where(h4 + *):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0;
  }

  .xl\\:prose-xl :where(table):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 0.9em;
    line-height: 1.5555556;
  }

  .xl\\:prose-xl :where(thead th):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    padding-inline-end: 0.6666667em;
    padding-bottom: 0.8888889em;
    padding-inline-start: 0.6666667em;
  }

  .xl\\:prose-xl :where(thead th:first-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    padding-inline-start: 0;
  }

  .xl\\:prose-xl :where(thead th:last-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    padding-inline-end: 0;
  }

  .xl\\:prose-xl :where(tbody td, tfoot td):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    padding-top: 0.8888889em;
    padding-inline-end: 0.6666667em;
    padding-bottom: 0.8888889em;
    padding-inline-start: 0.6666667em;
  }

  .xl\\:prose-xl :where(tbody td:first-child, tfoot td:first-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    padding-inline-start: 0;
  }

  .xl\\:prose-xl :where(tbody td:last-child, tfoot td:last-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    padding-inline-end: 0;
  }

  .xl\\:prose-xl :where(figure):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 2em;
    margin-bottom: 2em;
  }

  .xl\\:prose-xl :where(figure > *):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0;
    margin-bottom: 0;
  }

  .xl\\:prose-xl :where(figcaption):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    font-size: 0.9em;
    line-height: 1.5555556;
    margin-top: 1em;
  }

  .xl\\:prose-xl :where(.xl\\:prose-xl > :first-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-top: 0;
  }

  .xl\\:prose-xl :where(.xl\\:prose-xl > :last-child):not(:where([class~="not-prose"],[class~="not-prose"] *)) {
    margin-bottom: 0;
  }
}
.placeholder\\:text-gray-400::-moz-placeholder {
  --tw-text-opacity: 1;
  color: rgb(156 163 175 / var(--tw-text-opacity));
}
.placeholder\\:text-gray-400::placeholder {
  --tw-text-opacity: 1;
  color: rgb(156 163 175 / var(--tw-text-opacity));
}
.invalid\\:border-red-500:invalid {
  --tw-border-opacity: 1;
  border-color: rgb(239 68 68 / var(--tw-border-opacity));
}
.focus-within\\:ring-2:focus-within {
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
}
.focus-within\\:ring-indigo-600:focus-within {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(79 70 229 / var(--tw-ring-opacity));
}
.hover\\:w-56:hover {
  width: 14rem;
}
.hover\\:scale-105:hover {
  --tw-scale-x: 1.05;
  --tw-scale-y: 1.05;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.hover\\:border-brand-600:hover {
  --tw-border-opacity: 1;
  border-color: rgb(196 61 27 / var(--tw-border-opacity));
}
.hover\\:bg-brand-50:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(252 248 242 / var(--tw-bg-opacity));
}
.hover\\:bg-brand-500:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(220 74 34 / var(--tw-bg-opacity));
}
.hover\\:bg-brand-600:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(196 61 27 / var(--tw-bg-opacity));
}
.hover\\:bg-brand-700:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(163 45 18 / var(--tw-bg-opacity));
}
.hover\\:bg-brandcomp-600:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(28 156 199 / var(--tw-bg-opacity));
}
.hover\\:bg-gray-100:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(243 244 246 / var(--tw-bg-opacity));
}
.hover\\:bg-gray-200:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(229 231 235 / var(--tw-bg-opacity));
}
.hover\\:bg-gray-300:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(209 213 219 / var(--tw-bg-opacity));
}
.hover\\:bg-gray-50:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(249 250 251 / var(--tw-bg-opacity));
}
.hover\\:bg-gray-500:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(107 114 128 / var(--tw-bg-opacity));
}
.hover\\:bg-gray-600:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(75 85 99 / var(--tw-bg-opacity));
}
.hover\\:bg-indigo-500:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(99 102 241 / var(--tw-bg-opacity));
}
.hover\\:bg-orange-700:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(194 65 12 / var(--tw-bg-opacity));
}
.hover\\:bg-red-500:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(239 68 68 / var(--tw-bg-opacity));
}
.hover\\:bg-red-700:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(185 28 28 / var(--tw-bg-opacity));
}
.hover\\:bg-yellow-300:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(253 224 71 / var(--tw-bg-opacity));
}
.hover\\:text-amber-900:hover {
  --tw-text-opacity: 1;
  color: rgb(120 53 15 / var(--tw-text-opacity));
}
.hover\\:text-brand-500:hover {
  --tw-text-opacity: 1;
  color: rgb(220 74 34 / var(--tw-text-opacity));
}
.hover\\:text-brand-900:hover {
  --tw-text-opacity: 1;
  color: rgb(99 21 7 / var(--tw-text-opacity));
}
.hover\\:text-brandcomp-500:hover {
  --tw-text-opacity: 1;
  color: rgb(35 181 221 / var(--tw-text-opacity));
}
.hover\\:text-brandcomp-600:hover {
  --tw-text-opacity: 1;
  color: rgb(28 156 199 / var(--tw-text-opacity));
}
.hover\\:text-gray-200:hover {
  --tw-text-opacity: 1;
  color: rgb(229 231 235 / var(--tw-text-opacity));
}
.hover\\:text-gray-300:hover {
  --tw-text-opacity: 1;
  color: rgb(209 213 219 / var(--tw-text-opacity));
}
.hover\\:text-gray-500:hover {
  --tw-text-opacity: 1;
  color: rgb(107 114 128 / var(--tw-text-opacity));
}
.hover\\:text-gray-600:hover {
  --tw-text-opacity: 1;
  color: rgb(75 85 99 / var(--tw-text-opacity));
}
.hover\\:text-gray-700:hover {
  --tw-text-opacity: 1;
  color: rgb(55 65 81 / var(--tw-text-opacity));
}
.hover\\:text-gray-900:hover {
  --tw-text-opacity: 1;
  color: rgb(17 24 39 / var(--tw-text-opacity));
}
.hover\\:text-red-600:hover {
  --tw-text-opacity: 1;
  color: rgb(220 38 38 / var(--tw-text-opacity));
}
.hover\\:text-red-900:hover {
  --tw-text-opacity: 1;
  color: rgb(127 29 29 / var(--tw-text-opacity));
}
.hover\\:text-slate-700:hover {
  --tw-text-opacity: 1;
  color: rgb(51 65 85 / var(--tw-text-opacity));
}
.hover\\:underline:hover {
  text-decoration-line: underline;
}
.hover\\:opacity-100:hover {
  opacity: 1;
}
.hover\\:shadow-lg:hover {
  --tw-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.hover\\:ring-gray-300:hover {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(209 213 219 / var(--tw-ring-opacity));
}
.hover\\:ring-indigo-300:hover {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(165 180 252 / var(--tw-ring-opacity));
}
.focus\\:z-10:focus {
  z-index: 10;
}
.focus\\:border-brand-500:focus {
  --tw-border-opacity: 1;
  border-color: rgb(220 74 34 / var(--tw-border-opacity));
}
.focus\\:border-brandcomp-500:focus {
  --tw-border-opacity: 1;
  border-color: rgb(35 181 221 / var(--tw-border-opacity));
}
.focus\\:border-brandcompdim-500:focus {
  --tw-border-opacity: 1;
  border-color: rgb(28 156 199 / var(--tw-border-opacity));
}
.focus\\:outline-none:focus {
  outline: 2px solid transparent;
  outline-offset: 2px;
}
.focus\\:ring:focus {
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(3px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
}
.focus\\:ring-0:focus {
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
}
.focus\\:ring-2:focus {
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
}
.focus\\:ring-inset:focus {
  --tw-ring-inset: inset;
}
.focus\\:ring-brand-500:focus {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(220 74 34 / var(--tw-ring-opacity));
}
.focus\\:ring-brandcomp-500:focus {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(35 181 221 / var(--tw-ring-opacity));
}
.focus\\:ring-brandcomp-600:focus {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(28 156 199 / var(--tw-ring-opacity));
}
.focus\\:ring-brandcompdim-500:focus {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(28 156 199 / var(--tw-ring-opacity));
}
.focus\\:ring-gray-400:focus {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(156 163 175 / var(--tw-ring-opacity));
}
.focus\\:ring-indigo-500:focus {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(99 102 241 / var(--tw-ring-opacity));
}
.focus\\:ring-red-500:focus {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(239 68 68 / var(--tw-ring-opacity));
}
.focus\\:ring-yellow-400:focus {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(250 204 21 / var(--tw-ring-opacity));
}
.focus\\:ring-opacity-50:focus {
  --tw-ring-opacity: 0.5;
}
.focus\\:ring-offset-2:focus {
  --tw-ring-offset-width: 2px;
}
.focus\\:ring-offset-gray-100:focus {
  --tw-ring-offset-color: #f3f4f6;
}
.focus-visible\\:outline:focus-visible {
  outline-style: solid;
}
.focus-visible\\:outline-2:focus-visible {
  outline-width: 2px;
}
.focus-visible\\:outline-offset-2:focus-visible {
  outline-offset: 2px;
}
.focus-visible\\:outline-offset-\\[-4px\\]:focus-visible {
  outline-offset: -4px;
}
.focus-visible\\:outline-brand-500:focus-visible {
  outline-color: #dc4a22;
}
.focus-visible\\:outline-brand-600:focus-visible {
  outline-color: #c43d1b;
}
.focus-visible\\:outline-gray-600:focus-visible {
  outline-color: #4b5563;
}
.focus-visible\\:outline-indigo-600:focus-visible {
  outline-color: #4f46e5;
}
.disabled\\:cursor-not-allowed:disabled {
  cursor: not-allowed;
}
.disabled\\:bg-gray-400:disabled {
  --tw-bg-opacity: 1;
  background-color: rgb(156 163 175 / var(--tw-bg-opacity));
}
.disabled\\:opacity-50:disabled {
  opacity: 0.5;
}
.disabled\\:hover\\:w-12:hover:disabled {
  width: 3rem;
}
.disabled\\:hover\\:scale-100:hover:disabled {
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.disabled\\:hover\\:bg-gray-400:hover:disabled {
  --tw-bg-opacity: 1;
  background-color: rgb(156 163 175 / var(--tw-bg-opacity));
}
.group:hover .group-hover\\:mr-2 {
  margin-right: 0.5rem;
}
.group:hover .group-hover\\:opacity-100 {
  opacity: 1;
}
.dark\\:divide-gray-700:is(.dark *) > :not([hidden]) ~ :not([hidden]) {
  --tw-divide-opacity: 1;
  border-color: rgb(55 65 81 / var(--tw-divide-opacity));
}
.dark\\:border-amber-500:is(.dark *) {
  --tw-border-opacity: 1;
  border-color: rgb(245 158 11 / var(--tw-border-opacity));
}
.dark\\:border-brand-400:is(.dark *) {
  --tw-border-opacity: 1;
  border-color: rgb(230 139 94 / var(--tw-border-opacity));
}
.dark\\:border-brand-500:is(.dark *) {
  --tw-border-opacity: 1;
  border-color: rgb(220 74 34 / var(--tw-border-opacity));
}
.dark\\:border-gray-500:is(.dark *) {
  --tw-border-opacity: 1;
  border-color: rgb(107 114 128 / var(--tw-border-opacity));
}
.dark\\:border-gray-600:is(.dark *) {
  --tw-border-opacity: 1;
  border-color: rgb(75 85 99 / var(--tw-border-opacity));
}
.dark\\:border-gray-700:is(.dark *) {
  --tw-border-opacity: 1;
  border-color: rgb(55 65 81 / var(--tw-border-opacity));
}
.dark\\:border-gray-800:is(.dark *) {
  --tw-border-opacity: 1;
  border-color: rgb(31 41 55 / var(--tw-border-opacity));
}
.dark\\:border-red-600:is(.dark *) {
  --tw-border-opacity: 1;
  border-color: rgb(220 38 38 / var(--tw-border-opacity));
}
.dark\\:bg-amber-900:is(.dark *) {
  --tw-bg-opacity: 1;
  background-color: rgb(120 53 15 / var(--tw-bg-opacity));
}
.dark\\:bg-blue-800:is(.dark *) {
  --tw-bg-opacity: 1;
  background-color: rgb(30 64 175 / var(--tw-bg-opacity));
}
.dark\\:bg-blue-900:is(.dark *) {
  --tw-bg-opacity: 1;
  background-color: rgb(30 58 138 / var(--tw-bg-opacity));
}
.dark\\:bg-brand-500:is(.dark *) {
  --tw-bg-opacity: 1;
  background-color: rgb(220 74 34 / var(--tw-bg-opacity));
}
.dark\\:bg-brand-600:is(.dark *) {
  --tw-bg-opacity: 1;
  background-color: rgb(196 61 27 / var(--tw-bg-opacity));
}
.dark\\:bg-brand-900:is(.dark *) {
  --tw-bg-opacity: 1;
  background-color: rgb(99 21 7 / var(--tw-bg-opacity));
}
.dark\\:bg-brandcomp-900:is(.dark *) {
  --tw-bg-opacity: 1;
  background-color: rgb(7 59 99 / var(--tw-bg-opacity));
}
.dark\\:bg-gray-500:is(.dark *) {
  --tw-bg-opacity: 1;
  background-color: rgb(107 114 128 / var(--tw-bg-opacity));
}
.dark\\:bg-gray-600:is(.dark *) {
  --tw-bg-opacity: 1;
  background-color: rgb(75 85 99 / var(--tw-bg-opacity));
}
.dark\\:bg-gray-700:is(.dark *) {
  --tw-bg-opacity: 1;
  background-color: rgb(55 65 81 / var(--tw-bg-opacity));
}
.dark\\:bg-gray-800:is(.dark *) {
  --tw-bg-opacity: 1;
  background-color: rgb(31 41 55 / var(--tw-bg-opacity));
}
.dark\\:bg-gray-800\\/60:is(.dark *) {
  background-color: rgb(31 41 55 / 0.6);
}
.dark\\:bg-gray-900:is(.dark *) {
  --tw-bg-opacity: 1;
  background-color: rgb(17 24 39 / var(--tw-bg-opacity));
}
.dark\\:bg-gray-950:is(.dark *) {
  --tw-bg-opacity: 1;
  background-color: rgb(3 7 18 / var(--tw-bg-opacity));
}
.dark\\:bg-green-800:is(.dark *) {
  --tw-bg-opacity: 1;
  background-color: rgb(22 101 52 / var(--tw-bg-opacity));
}
.dark\\:bg-green-900:is(.dark *) {
  --tw-bg-opacity: 1;
  background-color: rgb(20 83 45 / var(--tw-bg-opacity));
}
.dark\\:bg-indigo-500:is(.dark *) {
  --tw-bg-opacity: 1;
  background-color: rgb(99 102 241 / var(--tw-bg-opacity));
}
.dark\\:bg-red-700:is(.dark *) {
  --tw-bg-opacity: 1;
  background-color: rgb(185 28 28 / var(--tw-bg-opacity));
}
.dark\\:bg-red-800:is(.dark *) {
  --tw-bg-opacity: 1;
  background-color: rgb(153 27 27 / var(--tw-bg-opacity));
}
.dark\\:bg-red-900:is(.dark *) {
  --tw-bg-opacity: 1;
  background-color: rgb(127 29 29 / var(--tw-bg-opacity));
}
.dark\\:bg-slate-700:is(.dark *) {
  --tw-bg-opacity: 1;
  background-color: rgb(51 65 85 / var(--tw-bg-opacity));
}
.dark\\:bg-yellow-800:is(.dark *) {
  --tw-bg-opacity: 1;
  background-color: rgb(133 77 14 / var(--tw-bg-opacity));
}
.dark\\:bg-opacity-80:is(.dark *) {
  --tw-bg-opacity: 0.8;
}
.dark\\:from-brand-800:is(.dark *) {
  --tw-gradient-from: #85200c var(--tw-gradient-from-position);
  --tw-gradient-to: rgb(133 32 12 / 0) var(--tw-gradient-to-position);
  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);
}
.dark\\:to-brand-900:is(.dark *) {
  --tw-gradient-to: #631507 var(--tw-gradient-to-position);
}
.dark\\:text-amber-100:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(254 243 199 / var(--tw-text-opacity));
}
.dark\\:text-blue-200:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(191 219 254 / var(--tw-text-opacity));
}
.dark\\:text-brand-100:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(252 244 232 / var(--tw-text-opacity));
}
.dark\\:text-brand-400:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(230 139 94 / var(--tw-text-opacity));
}
.dark\\:text-brandcomp-200:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(195 240 247 / var(--tw-text-opacity));
}
.dark\\:text-brandcomp-300:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(160 230 242 / var(--tw-text-opacity));
}
.dark\\:text-brandcomp-400:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(95 207 232 / var(--tw-text-opacity));
}
.dark\\:text-brandcomp-600:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(28 156 199 / var(--tw-text-opacity));
}
.dark\\:text-gray-100:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(243 244 246 / var(--tw-text-opacity));
}
.dark\\:text-gray-200:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(229 231 235 / var(--tw-text-opacity));
}
.dark\\:text-gray-300:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(209 213 219 / var(--tw-text-opacity));
}
.dark\\:text-gray-400:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(156 163 175 / var(--tw-text-opacity));
}
.dark\\:text-gray-500:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(107 114 128 / var(--tw-text-opacity));
}
.dark\\:text-gray-600:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(75 85 99 / var(--tw-text-opacity));
}
.dark\\:text-green-100:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(220 252 231 / var(--tw-text-opacity));
}
.dark\\:text-green-200:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(187 247 208 / var(--tw-text-opacity));
}
.dark\\:text-green-300:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(134 239 172 / var(--tw-text-opacity));
}
.dark\\:text-green-400:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(74 222 128 / var(--tw-text-opacity));
}
.dark\\:text-indigo-300:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(165 180 252 / var(--tw-text-opacity));
}
.dark\\:text-indigo-400:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(129 140 248 / var(--tw-text-opacity));
}
.dark\\:text-red-100:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(254 226 226 / var(--tw-text-opacity));
}
.dark\\:text-red-200:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(254 202 202 / var(--tw-text-opacity));
}
.dark\\:text-red-300:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(252 165 165 / var(--tw-text-opacity));
}
.dark\\:text-red-400:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(248 113 113 / var(--tw-text-opacity));
}
.dark\\:text-slate-400:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(148 163 184 / var(--tw-text-opacity));
}
.dark\\:text-white:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(255 255 255 / var(--tw-text-opacity));
}
.dark\\:text-white\\/70:is(.dark *) {
  color: rgb(255 255 255 / 0.7);
}
.dark\\:text-white\\/80:is(.dark *) {
  color: rgb(255 255 255 / 0.8);
}
.dark\\:text-yellow-100:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(254 249 195 / var(--tw-text-opacity));
}
.dark\\:placeholder-gray-500:is(.dark *)::-moz-placeholder {
  --tw-placeholder-opacity: 1;
  color: rgb(107 114 128 / var(--tw-placeholder-opacity));
}
.dark\\:placeholder-gray-500:is(.dark *)::placeholder {
  --tw-placeholder-opacity: 1;
  color: rgb(107 114 128 / var(--tw-placeholder-opacity));
}
.dark\\:ring-gray-100\\/10:is(.dark *) {
  --tw-ring-color: rgb(243 244 246 / 0.1);
}
.dark\\:ring-gray-600:is(.dark *) {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(75 85 99 / var(--tw-ring-opacity));
}
.dark\\:ring-gray-700:is(.dark *) {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(55 65 81 / var(--tw-ring-opacity));
}
.dark\\:ring-indigo-700:is(.dark *) {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(67 56 202 / var(--tw-ring-opacity));
}
.dark\\:ring-slate-800:is(.dark *) {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(30 41 59 / var(--tw-ring-opacity));
}
.dark\\:ring-offset-gray-800:is(.dark *) {
  --tw-ring-offset-color: #1f2937;
}
.dark\\:placeholder\\:text-gray-400:is(.dark *)::-moz-placeholder {
  --tw-text-opacity: 1;
  color: rgb(156 163 175 / var(--tw-text-opacity));
}
.dark\\:placeholder\\:text-gray-400:is(.dark *)::placeholder {
  --tw-text-opacity: 1;
  color: rgb(156 163 175 / var(--tw-text-opacity));
}
.dark\\:hover\\:border-gray-600:hover:is(.dark *) {
  --tw-border-opacity: 1;
  border-color: rgb(75 85 99 / var(--tw-border-opacity));
}
.dark\\:hover\\:bg-brand-400:hover:is(.dark *) {
  --tw-bg-opacity: 1;
  background-color: rgb(230 139 94 / var(--tw-bg-opacity));
}
.dark\\:hover\\:bg-brand-600:hover:is(.dark *) {
  --tw-bg-opacity: 1;
  background-color: rgb(196 61 27 / var(--tw-bg-opacity));
}
.dark\\:hover\\:bg-brand-700:hover:is(.dark *) {
  --tw-bg-opacity: 1;
  background-color: rgb(163 45 18 / var(--tw-bg-opacity));
}
.dark\\:hover\\:bg-brand-800:hover:is(.dark *) {
  --tw-bg-opacity: 1;
  background-color: rgb(133 32 12 / var(--tw-bg-opacity));
}
.dark\\:hover\\:bg-gray-500:hover:is(.dark *) {
  --tw-bg-opacity: 1;
  background-color: rgb(107 114 128 / var(--tw-bg-opacity));
}
.dark\\:hover\\:bg-gray-600:hover:is(.dark *) {
  --tw-bg-opacity: 1;
  background-color: rgb(75 85 99 / var(--tw-bg-opacity));
}
.dark\\:hover\\:bg-gray-700:hover:is(.dark *) {
  --tw-bg-opacity: 1;
  background-color: rgb(55 65 81 / var(--tw-bg-opacity));
}
.dark\\:hover\\:bg-indigo-400:hover:is(.dark *) {
  --tw-bg-opacity: 1;
  background-color: rgb(129 140 248 / var(--tw-bg-opacity));
}
.dark\\:hover\\:bg-red-800:hover:is(.dark *) {
  --tw-bg-opacity: 1;
  background-color: rgb(153 27 27 / var(--tw-bg-opacity));
}
.dark\\:hover\\:text-amber-50:hover:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(255 251 235 / var(--tw-text-opacity));
}
.dark\\:hover\\:text-brand-400:hover:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(230 139 94 / var(--tw-text-opacity));
}
.dark\\:hover\\:text-brand-50:hover:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(252 248 242 / var(--tw-text-opacity));
}
.dark\\:hover\\:text-brand-500:hover:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(220 74 34 / var(--tw-text-opacity));
}
.dark\\:hover\\:text-brandcomp-300:hover:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(160 230 242 / var(--tw-text-opacity));
}
.dark\\:hover\\:text-brandcomp-400:hover:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(95 207 232 / var(--tw-text-opacity));
}
.dark\\:hover\\:text-gray-100:hover:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(243 244 246 / var(--tw-text-opacity));
}
.dark\\:hover\\:text-gray-200:hover:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(229 231 235 / var(--tw-text-opacity));
}
.dark\\:hover\\:text-red-100:hover:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(254 226 226 / var(--tw-text-opacity));
}
.dark\\:hover\\:text-red-300:hover:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(252 165 165 / var(--tw-text-opacity));
}
.dark\\:hover\\:text-slate-300:hover:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(203 213 225 / var(--tw-text-opacity));
}
.dark\\:hover\\:text-white:hover:is(.dark *) {
  --tw-text-opacity: 1;
  color: rgb(255 255 255 / var(--tw-text-opacity));
}
.dark\\:hover\\:ring-gray-800:hover:is(.dark *) {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(31 41 55 / var(--tw-ring-opacity));
}
.dark\\:hover\\:ring-indigo-600:hover:is(.dark *) {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(79 70 229 / var(--tw-ring-opacity));
}
.dark\\:focus\\:ring-brand-400:focus:is(.dark *) {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(230 139 94 / var(--tw-ring-opacity));
}
.dark\\:focus\\:ring-brandcomp-500:focus:is(.dark *) {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(35 181 221 / var(--tw-ring-opacity));
}
.dark\\:focus\\:ring-brandcomp-600:focus:is(.dark *) {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(28 156 199 / var(--tw-ring-opacity));
}
.dark\\:focus\\:ring-offset-gray-800:focus:is(.dark *) {
  --tw-ring-offset-color: #1f2937;
}
.dark\\:focus\\:ring-offset-gray-900:focus:is(.dark *) {
  --tw-ring-offset-color: #111827;
}
.dark\\:focus-visible\\:outline-indigo-500:focus-visible:is(.dark *) {
  outline-color: #6366f1;
}
.dark\\:disabled\\:bg-gray-700:disabled:is(.dark *) {
  --tw-bg-opacity: 1;
  background-color: rgb(55 65 81 / var(--tw-bg-opacity));
}
.dark\\:disabled\\:hover\\:bg-gray-700:hover:disabled:is(.dark *) {
  --tw-bg-opacity: 1;
  background-color: rgb(55 65 81 / var(--tw-bg-opacity));
}
@media (min-width: 640px) {

  .sm\\:-top-12 {
    top: -3rem;
  }

  .sm\\:mx-0 {
    margin-left: 0px;
    margin-right: 0px;
  }

  .sm\\:mx-12 {
    margin-left: 3rem;
    margin-right: 3rem;
  }

  .sm\\:mx-2 {
    margin-left: 0.5rem;
    margin-right: 0.5rem;
  }

  .sm\\:mx-8 {
    margin-left: 2rem;
    margin-right: 2rem;
  }

  .sm\\:my-8 {
    margin-top: 2rem;
    margin-bottom: 2rem;
  }

  .sm\\:mb-0 {
    margin-bottom: 0px;
  }

  .sm\\:ml-16 {
    margin-left: 4rem;
  }

  .sm\\:ml-3 {
    margin-left: 0.75rem;
  }

  .sm\\:ml-4 {
    margin-left: 1rem;
  }

  .sm\\:ml-auto {
    margin-left: auto;
  }

  .sm\\:mt-0 {
    margin-top: 0px;
  }

  .sm\\:mt-10 {
    margin-top: 2.5rem;
  }

  .sm\\:mt-20 {
    margin-top: 5rem;
  }

  .sm\\:mt-4 {
    margin-top: 1rem;
  }

  .sm\\:block {
    display: block;
  }

  .sm\\:inline {
    display: inline;
  }

  .sm\\:flex {
    display: flex;
  }

  .sm\\:hidden {
    display: none;
  }

  .sm\\:h-10 {
    height: 2.5rem;
  }

  .sm\\:h-8 {
    height: 2rem;
  }

  .sm\\:w-10 {
    width: 2.5rem;
  }

  .sm\\:w-64 {
    width: 16rem;
  }

  .sm\\:w-8 {
    width: 2rem;
  }

  .sm\\:w-auto {
    width: auto;
  }

  .sm\\:w-full {
    width: 100%;
  }

  .sm\\:max-w-lg {
    max-width: 32rem;
  }

  .sm\\:flex-auto {
    flex: 1 1 auto;
  }

  .sm\\:flex-none {
    flex: none;
  }

  .sm\\:translate-y-0 {
    --tw-translate-y: 0px;
    transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
  }

  .sm\\:scale-100 {
    --tw-scale-x: 1;
    --tw-scale-y: 1;
    transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
  }

  .sm\\:scale-95 {
    --tw-scale-x: .95;
    --tw-scale-y: .95;
    transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
  }

  .sm\\:grid-cols-2 {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }

  .sm\\:flex-row {
    flex-direction: row;
  }

  .sm\\:flex-row-reverse {
    flex-direction: row-reverse;
  }

  .sm\\:items-start {
    align-items: flex-start;
  }

  .sm\\:items-center {
    align-items: center;
  }

  .sm\\:justify-end {
    justify-content: flex-end;
  }

  .sm\\:gap-y-0 {
    row-gap: 0px;
  }

  .sm\\:gap-y-10 {
    row-gap: 2.5rem;
  }

  .sm\\:rounded-lg {
    border-radius: 0.5rem;
  }

  .sm\\:rounded-b-none {
    border-bottom-right-radius: 0px;
    border-bottom-left-radius: 0px;
  }

  .sm\\:rounded-t-none {
    border-top-left-radius: 0px;
    border-top-right-radius: 0px;
  }

  .sm\\:p-0 {
    padding: 0px;
  }

  .sm\\:p-10 {
    padding: 2.5rem;
  }

  .sm\\:p-4 {
    padding: 1rem;
  }

  .sm\\:p-6 {
    padding: 1.5rem;
  }

  .sm\\:p-8 {
    padding: 2rem;
  }

  .sm\\:px-3\\.5 {
    padding-left: 0.875rem;
    padding-right: 0.875rem;
  }

  .sm\\:px-6 {
    padding-left: 1.5rem;
    padding-right: 1.5rem;
  }

  .sm\\:py-12 {
    padding-top: 3rem;
    padding-bottom: 3rem;
  }

  .sm\\:py-16 {
    padding-top: 4rem;
    padding-bottom: 4rem;
  }

  .sm\\:py-2 {
    padding-top: 0.5rem;
    padding-bottom: 0.5rem;
  }

  .sm\\:pb-32 {
    padding-bottom: 8rem;
  }

  .sm\\:pl-6 {
    padding-left: 1.5rem;
  }

  .sm\\:pr-6 {
    padding-right: 1.5rem;
  }

  .sm\\:pt-32 {
    padding-top: 8rem;
  }

  .sm\\:text-left {
    text-align: left;
  }

  .sm\\:text-3xl {
    font-size: 1.875rem;
    line-height: 2.25rem;
  }

  .sm\\:text-5xl {
    font-size: 3rem;
    line-height: 1;
  }

  .sm\\:text-base {
    font-size: 1rem;
    line-height: 1.5rem;
  }

  .sm\\:text-lg {
    font-size: 1.125rem;
    line-height: 1.75rem;
  }

  .sm\\:text-sm {
    font-size: 0.875rem;
    line-height: 1.25rem;
  }

  .sm\\:text-xl {
    font-size: 1.25rem;
    line-height: 1.75rem;
  }

  .sm\\:leading-6 {
    line-height: 1.5rem;
  }

  .sm\\:leading-8 {
    line-height: 2rem;
  }

  .sm\\:tracking-tight {
    letter-spacing: -0.025em;
  }

  .sm\\:before\\:flex-1::before {
    content: var(--tw-content);
    flex: 1 1 0%;
  }
}
@media (min-width: 768px) {

  .md\\:-top-20 {
    top: -5rem;
  }

  .md\\:mx-2 {
    margin-left: 0.5rem;
    margin-right: 0.5rem;
  }

  .md\\:mb-0 {
    margin-bottom: 0px;
  }

  .md\\:h-4 {
    height: 1rem;
  }

  .md\\:h-5 {
    height: 1.25rem;
  }

  .md\\:w-4 {
    width: 1rem;
  }

  .md\\:w-5 {
    width: 1.25rem;
  }

  .md\\:grid-cols-2 {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }

  .md\\:flex-row {
    flex-direction: row;
  }

  .md\\:space-x-4 > :not([hidden]) ~ :not([hidden]) {
    --tw-space-x-reverse: 0;
    margin-right: calc(1rem * var(--tw-space-x-reverse));
    margin-left: calc(1rem * calc(1 - var(--tw-space-x-reverse)));
  }

  .md\\:space-y-0 > :not([hidden]) ~ :not([hidden]) {
    --tw-space-y-reverse: 0;
    margin-top: calc(0px * calc(1 - var(--tw-space-y-reverse)));
    margin-bottom: calc(0px * var(--tw-space-y-reverse));
  }

  .md\\:px-4 {
    padding-left: 1rem;
    padding-right: 1rem;
  }

  .md\\:py-1 {
    padding-top: 0.25rem;
    padding-bottom: 0.25rem;
  }

  .md\\:text-6xl {
    font-size: 3.75rem;
    line-height: 1;
  }

  .md\\:text-sm {
    font-size: 0.875rem;
    line-height: 1.25rem;
  }

  .md\\:text-xl {
    font-size: 1.25rem;
    line-height: 1.75rem;
  }

  .md\\:text-xs {
    font-size: 0.75rem;
    line-height: 1rem;
  }
}
@media (min-width: 1024px) {

  .lg\\:-top-12 {
    top: -3rem;
  }

  .lg\\:col-span-2 {
    grid-column: span 2 / span 2;
  }

  .lg\\:mx-0 {
    margin-left: 0px;
    margin-right: 0px;
  }

  .lg\\:ml-10 {
    margin-left: 2.5rem;
  }

  .lg\\:mt-0 {
    margin-top: 0px;
  }

  .lg\\:flex {
    display: flex;
  }

  .lg\\:table-cell {
    display: table-cell;
  }

  .lg\\:grid {
    display: grid;
  }

  .lg\\:hidden {
    display: none;
  }

  .lg\\:min-w-0 {
    min-width: 0px;
  }

  .lg\\:max-w-4xl {
    max-width: 56rem;
  }

  .lg\\:max-w-xl {
    max-width: 36rem;
  }

  .lg\\:flex-1 {
    flex: 1 1 0%;
  }

  .lg\\:grid-cols-2 {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }

  .lg\\:grid-cols-3 {
    grid-template-columns: repeat(3, minmax(0, 1fr));
  }

  .lg\\:flex-row {
    flex-direction: row;
  }

  .lg\\:items-center {
    align-items: center;
  }

  .lg\\:justify-between {
    justify-content: space-between;
  }

  .lg\\:gap-8 {
    gap: 2rem;
  }

  .lg\\:rounded-bl-3xl {
    border-bottom-left-radius: 1.5rem;
  }

  .lg\\:rounded-bl-none {
    border-bottom-left-radius: 0px;
  }

  .lg\\:rounded-tr-3xl {
    border-top-right-radius: 1.5rem;
  }

  .lg\\:rounded-tr-none {
    border-top-right-radius: 0px;
  }

  .lg\\:px-8 {
    padding-left: 2rem;
    padding-right: 2rem;
  }

  .lg\\:py-12 {
    padding-top: 3rem;
    padding-bottom: 3rem;
  }

  .lg\\:text-4xl {
    font-size: 2.25rem;
    line-height: 2.5rem;
  }

  .lg\\:text-7xl {
    font-size: 4.5rem;
    line-height: 1;
  }
}
@media (min-width: 1280px) {

  .xl\\:top-0 {
    top: 0px;
  }
}

@keyframes fadeIn-9e123fa9 {
from { opacity: 0; transform: translateY(-10px);
}
to { opacity: 1; transform: translateY(0);
}
}
.api-token-container[data-v-9e123fa9] {
  animation: fadeIn-9e123fa9 0.5s ease-out;
}

.fade-enter-active[data-v-78233a39],
.fade-leave-active[data-v-78233a39] {
  transition: opacity 0.3s ease;
}
.fade-enter-from[data-v-78233a39],
.fade-leave-to[data-v-78233a39] {
  opacity: 0;
}

/* Add this new rule */
.fade-enter-to[data-v-78233a39],
.fade-leave-from[data-v-78233a39] {
  opacity: 1;
}

.gradient-text[data-v-bea3c294] {
  background-clip: text;
  -webkit-background-clip: text;
  color: transparent;
}

.github-corner:hover .octo-arm[data-v-e1941d89] {
  animation: octocat-wave-e1941d89 560ms ease-in-out
}
@keyframes octocat-wave-e1941d89 {
0%, 100% {transform: rotate(0)}
20%, 60% {transform: rotate(-25deg)}
40%, 80% {transform: rotate(10deg)}
}
@media (max-width:500px) {
.github-corner:hover .octo-arm[data-v-e1941d89] {
    animation: none
}
.github-corner .octo-arm[data-v-e1941d89] {
    animation: octocat-wave-e1941d89 560ms ease-in-out
}
}
`;
  document.head.appendChild(__vite_style__);
  const scriptRel = "modulepreload";
  const assetsURL = function(dep) {
    return "/dist/" + dep;
  };
  const seen$2 = {};
  const __vitePreload = function preload(baseModule, deps, importerUrl) {
    let promise = Promise.resolve();
    if (false) {
      document.getElementsByTagName("link");
      const cspNonceMeta = document.querySelector(
        "meta[property=csp-nonce]"
      );
      const cspNonce = (cspNonceMeta == null ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta == null ? void 0 : cspNonceMeta.getAttribute("nonce"));
      promise = Promise.all(
        deps.map((dep) => {
          dep = assetsURL(dep);
          if (dep in seen$2) return;
          seen$2[dep] = true;
          const isCss = dep.endsWith(".css");
          const cssSelector = isCss ? '[rel="stylesheet"]' : "";
          if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
            return;
          }
          const link = document.createElement("link");
          link.rel = isCss ? "stylesheet" : scriptRel;
          if (!isCss) {
            link.as = "script";
            link.crossOrigin = "";
          }
          link.href = dep;
          if (cspNonce) {
            link.setAttribute("nonce", cspNonce);
          }
          document.head.appendChild(link);
          if (isCss) {
            return new Promise((res, rej) => {
              link.addEventListener("load", res);
              link.addEventListener(
                "error",
                () => rej(new Error(`Unable to preload CSS for ${dep}`))
              );
            });
          }
        })
      );
    }
    return promise.then(() => baseModule()).catch((err) => {
      const e2 = new Event("vite:preloadError", { cancelable: true });
      e2.payload = err;
      window.dispatchEvent(e2);
      if (!e2.defaultPrevented) {
        throw err;
      }
    });
  };
  const __variableDynamicImportRuntimeHelper = (glob, path, segs) => {
    const v2 = glob[path];
    if (v2) {
      return typeof v2 === "function" ? v2() : Promise.resolve(v2);
    }
    return new Promise((_2, reject) => {
      (typeof queueMicrotask === "function" ? queueMicrotask : setTimeout)(
        reject.bind(
          null,
          new Error(
            "Unknown variable dynamic import: " + path + (path.split("/").length !== segs ? ". Note that variables only represent file names one level deep." : "")
          )
        )
      );
    });
  };
  /*!
    * shared v10.0.3
    * (c) 2024 kazuya kawaguchi
    * Released under the MIT License.
    */
  const inBrowser = typeof window !== "undefined";
  const makeSymbol = (name, shareable = false) => !shareable ? Symbol(name) : Symbol.for(name);
  const generateFormatCacheKey = (locale2, key, source) => friendlyJSONstringify({ l: locale2, k: key, s: source });
  const friendlyJSONstringify = (json) => JSON.stringify(json).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027");
  const isNumber$1 = (val) => typeof val === "number" && isFinite(val);
  const isDate$2 = (val) => toTypeString$1(val) === "[object Date]";
  const isRegExp$2 = (val) => toTypeString$1(val) === "[object RegExp]";
  const isEmptyObject = (val) => isPlainObject$3(val) && Object.keys(val).length === 0;
  const assign$2 = Object.assign;
  let _globalThis$1;
  const getGlobalThis$1 = () => {
    return _globalThis$1 || (_globalThis$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
  };
  function escapeHtml(rawText) {
    return rawText.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
  }
  const hasOwnProperty$3 = Object.prototype.hasOwnProperty;
  function hasOwn$1(obj, key) {
    return hasOwnProperty$3.call(obj, key);
  }
  const isArray$3 = Array.isArray;
  const isFunction$2 = (val) => typeof val === "function";
  const isString$2 = (val) => typeof val === "string";
  const isBoolean$1 = (val) => typeof val === "boolean";
  const isObject$2 = (val) => val !== null && typeof val === "object";
  const isPromise$1 = (val) => {
    return isObject$2(val) && isFunction$2(val.then) && isFunction$2(val.catch);
  };
  const objectToString$1 = Object.prototype.toString;
  const toTypeString$1 = (value) => objectToString$1.call(value);
  const isPlainObject$3 = (val) => toTypeString$1(val) === "[object Object]";
  const toDisplayString$1 = (val) => {
    return val == null ? "" : isArray$3(val) || isPlainObject$3(val) && val.toString === objectToString$1 ? JSON.stringify(val, null, 2) : String(val);
  };
  function join(items, separator2 = "") {
    return items.reduce((str, item, index) => index === 0 ? str + item : str + separator2 + item, "");
  }
  function warn$2(msg, err) {
    if (typeof console !== "undefined") {
      console.warn(`[intlify] ` + msg);
      if (err) {
        console.warn(err.stack);
      }
    }
  }
  const isNotObjectOrIsArray = (val) => !isObject$2(val) || isArray$3(val);
  function deepCopy(src, des) {
    if (isNotObjectOrIsArray(src) || isNotObjectOrIsArray(des)) {
      throw new Error("Invalid value");
    }
    const stack2 = [{ src, des }];
    while (stack2.length) {
      const { src: src2, des: des2 } = stack2.pop();
      Object.keys(src2).forEach((key) => {
        if (isObject$2(src2[key]) && !isObject$2(des2[key])) {
          des2[key] = Array.isArray(src2[key]) ? [] : {};
        }
        if (isNotObjectOrIsArray(des2[key]) || isNotObjectOrIsArray(src2[key])) {
          des2[key] = src2[key];
        } else {
          stack2.push({ src: src2[key], des: des2[key] });
        }
      });
    }
  }
  /*!
    * message-compiler v10.0.3
    * (c) 2024 kazuya kawaguchi
    * Released under the MIT License.
    */
  function createPosition(line, column, offset) {
    return { line, column, offset };
  }
  function createLocation(start, end, source) {
    const loc = { start, end };
    return loc;
  }
  const CompileErrorCodes = {
    // tokenizer error codes
    EXPECTED_TOKEN: 1,
    INVALID_TOKEN_IN_PLACEHOLDER: 2,
    UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
    UNKNOWN_ESCAPE_SEQUENCE: 4,
    INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
    UNBALANCED_CLOSING_BRACE: 6,
    UNTERMINATED_CLOSING_BRACE: 7,
    EMPTY_PLACEHOLDER: 8,
    NOT_ALLOW_NEST_PLACEHOLDER: 9,
    INVALID_LINKED_FORMAT: 10,
    // parser error codes
    MUST_HAVE_MESSAGES_IN_PLURAL: 11,
    UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
    UNEXPECTED_EMPTY_LINKED_KEY: 13,
    UNEXPECTED_LEXICAL_ANALYSIS: 14,
    // generator error codes
    UNHANDLED_CODEGEN_NODE_TYPE: 15,
    // minifier error codes
    UNHANDLED_MINIFIER_NODE_TYPE: 16
  };
  const COMPILE_ERROR_CODES_EXTEND_POINT = 17;
  function createCompileError(code, loc, options = {}) {
    const { domain, messages, args } = options;
    const msg = code;
    const error = new SyntaxError(String(msg));
    error.code = code;
    if (loc) {
      error.location = loc;
    }
    error.domain = domain;
    return error;
  }
  function defaultOnError$1(error) {
    throw error;
  }
  const CHAR_SP = " ";
  const CHAR_CR = "\r";
  const CHAR_LF = "\n";
  const CHAR_LS = String.fromCharCode(8232);
  const CHAR_PS = String.fromCharCode(8233);
  function createScanner(str) {
    const _buf = str;
    let _index = 0;
    let _line = 1;
    let _column = 1;
    let _peekOffset = 0;
    const isCRLF = (index2) => _buf[index2] === CHAR_CR && _buf[index2 + 1] === CHAR_LF;
    const isLF = (index2) => _buf[index2] === CHAR_LF;
    const isPS = (index2) => _buf[index2] === CHAR_PS;
    const isLS = (index2) => _buf[index2] === CHAR_LS;
    const isLineEnd = (index2) => isCRLF(index2) || isLF(index2) || isPS(index2) || isLS(index2);
    const index = () => _index;
    const line = () => _line;
    const column = () => _column;
    const peekOffset = () => _peekOffset;
    const charAt = (offset) => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];
    const currentChar = () => charAt(_index);
    const currentPeek = () => charAt(_index + _peekOffset);
    function next() {
      _peekOffset = 0;
      if (isLineEnd(_index)) {
        _line++;
        _column = 0;
      }
      if (isCRLF(_index)) {
        _index++;
      }
      _index++;
      _column++;
      return _buf[_index];
    }
    function peek() {
      if (isCRLF(_index + _peekOffset)) {
        _peekOffset++;
      }
      _peekOffset++;
      return _buf[_index + _peekOffset];
    }
    function reset2() {
      _index = 0;
      _line = 1;
      _column = 1;
      _peekOffset = 0;
    }
    function resetPeek(offset = 0) {
      _peekOffset = offset;
    }
    function skipToPeek() {
      const target = _index + _peekOffset;
      while (target !== _index) {
        next();
      }
      _peekOffset = 0;
    }
    return {
      index,
      line,
      column,
      peekOffset,
      charAt,
      currentChar,
      currentPeek,
      next,
      peek,
      reset: reset2,
      resetPeek,
      skipToPeek
    };
  }
  const EOF = void 0;
  const DOT = ".";
  const LITERAL_DELIMITER = "'";
  const ERROR_DOMAIN$3 = "tokenizer";
  function createTokenizer(source, options = {}) {
    const location2 = options.location !== false;
    const _scnr = createScanner(source);
    const currentOffset = () => _scnr.index();
    const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());
    const _initLoc = currentPosition();
    const _initOffset = currentOffset();
    const _context = {
      currentType: 13,
      offset: _initOffset,
      startLoc: _initLoc,
      endLoc: _initLoc,
      lastType: 13,
      lastOffset: _initOffset,
      lastStartLoc: _initLoc,
      lastEndLoc: _initLoc,
      braceNest: 0,
      inLinked: false,
      text: ""
    };
    const context = () => _context;
    const { onError } = options;
    function emitError2(code, pos, offset, ...args) {
      const ctx = context();
      pos.column += offset;
      pos.offset += offset;
      if (onError) {
        const loc = location2 ? createLocation(ctx.startLoc, pos) : null;
        const err = createCompileError(code, loc, {
          domain: ERROR_DOMAIN$3,
          args
        });
        onError(err);
      }
    }
    function getToken(context2, type, value) {
      context2.endLoc = currentPosition();
      context2.currentType = type;
      const token = { type };
      if (location2) {
        token.loc = createLocation(context2.startLoc, context2.endLoc);
      }
      if (value != null) {
        token.value = value;
      }
      return token;
    }
    const getEndToken = (context2) => getToken(
      context2,
      13
      /* TokenTypes.EOF */
    );
    function eat(scnr, ch) {
      if (scnr.currentChar() === ch) {
        scnr.next();
        return ch;
      } else {
        emitError2(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
        return "";
      }
    }
    function peekSpaces(scnr) {
      let buf = "";
      while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {
        buf += scnr.currentPeek();
        scnr.peek();
      }
      return buf;
    }
    function skipSpaces(scnr) {
      const buf = peekSpaces(scnr);
      scnr.skipToPeek();
      return buf;
    }
    function isIdentifierStart(ch) {
      if (ch === EOF) {
        return false;
      }
      const cc = ch.charCodeAt(0);
      return cc >= 97 && cc <= 122 || // a-z
      cc >= 65 && cc <= 90 || // A-Z
      cc === 95;
    }
    function isNumberStart(ch) {
      if (ch === EOF) {
        return false;
      }
      const cc = ch.charCodeAt(0);
      return cc >= 48 && cc <= 57;
    }
    function isNamedIdentifierStart(scnr, context2) {
      const { currentType } = context2;
      if (currentType !== 2) {
        return false;
      }
      peekSpaces(scnr);
      const ret = isIdentifierStart(scnr.currentPeek());
      scnr.resetPeek();
      return ret;
    }
    function isListIdentifierStart(scnr, context2) {
      const { currentType } = context2;
      if (currentType !== 2) {
        return false;
      }
      peekSpaces(scnr);
      const ch = scnr.currentPeek() === "-" ? scnr.peek() : scnr.currentPeek();
      const ret = isNumberStart(ch);
      scnr.resetPeek();
      return ret;
    }
    function isLiteralStart(scnr, context2) {
      const { currentType } = context2;
      if (currentType !== 2) {
        return false;
      }
      peekSpaces(scnr);
      const ret = scnr.currentPeek() === LITERAL_DELIMITER;
      scnr.resetPeek();
      return ret;
    }
    function isLinkedDotStart(scnr, context2) {
      const { currentType } = context2;
      if (currentType !== 7) {
        return false;
      }
      peekSpaces(scnr);
      const ret = scnr.currentPeek() === ".";
      scnr.resetPeek();
      return ret;
    }
    function isLinkedModifierStart(scnr, context2) {
      const { currentType } = context2;
      if (currentType !== 8) {
        return false;
      }
      peekSpaces(scnr);
      const ret = isIdentifierStart(scnr.currentPeek());
      scnr.resetPeek();
      return ret;
    }
    function isLinkedDelimiterStart(scnr, context2) {
      const { currentType } = context2;
      if (!(currentType === 7 || currentType === 11)) {
        return false;
      }
      peekSpaces(scnr);
      const ret = scnr.currentPeek() === ":";
      scnr.resetPeek();
      return ret;
    }
    function isLinkedReferStart(scnr, context2) {
      const { currentType } = context2;
      if (currentType !== 9) {
        return false;
      }
      const fn2 = () => {
        const ch = scnr.currentPeek();
        if (ch === "{") {
          return isIdentifierStart(scnr.peek());
        } else if (ch === "@" || ch === "|" || ch === ":" || ch === "." || ch === CHAR_SP || !ch) {
          return false;
        } else if (ch === CHAR_LF) {
          scnr.peek();
          return fn2();
        } else {
          return isTextStart(scnr, false);
        }
      };
      const ret = fn2();
      scnr.resetPeek();
      return ret;
    }
    function isPluralStart(scnr) {
      peekSpaces(scnr);
      const ret = scnr.currentPeek() === "|";
      scnr.resetPeek();
      return ret;
    }
    function isTextStart(scnr, reset2 = true) {
      const fn2 = (hasSpace = false, prev = "") => {
        const ch = scnr.currentPeek();
        if (ch === "{") {
          return hasSpace;
        } else if (ch === "@" || !ch) {
          return hasSpace;
        } else if (ch === "|") {
          return !(prev === CHAR_SP || prev === CHAR_LF);
        } else if (ch === CHAR_SP) {
          scnr.peek();
          return fn2(true, CHAR_SP);
        } else if (ch === CHAR_LF) {
          scnr.peek();
          return fn2(true, CHAR_LF);
        } else {
          return true;
        }
      };
      const ret = fn2();
      reset2 && scnr.resetPeek();
      return ret;
    }
    function takeChar(scnr, fn2) {
      const ch = scnr.currentChar();
      if (ch === EOF) {
        return EOF;
      }
      if (fn2(ch)) {
        scnr.next();
        return ch;
      }
      return null;
    }
    function isIdentifier(ch) {
      const cc = ch.charCodeAt(0);
      return cc >= 97 && cc <= 122 || // a-z
      cc >= 65 && cc <= 90 || // A-Z
      cc >= 48 && cc <= 57 || // 0-9
      cc === 95 || // _
      cc === 36;
    }
    function takeIdentifierChar(scnr) {
      return takeChar(scnr, isIdentifier);
    }
    function isNamedIdentifier(ch) {
      const cc = ch.charCodeAt(0);
      return cc >= 97 && cc <= 122 || // a-z
      cc >= 65 && cc <= 90 || // A-Z
      cc >= 48 && cc <= 57 || // 0-9
      cc === 95 || // _
      cc === 36 || // $
      cc === 45;
    }
    function takeNamedIdentifierChar(scnr) {
      return takeChar(scnr, isNamedIdentifier);
    }
    function isDigit(ch) {
      const cc = ch.charCodeAt(0);
      return cc >= 48 && cc <= 57;
    }
    function takeDigit(scnr) {
      return takeChar(scnr, isDigit);
    }
    function isHexDigit(ch) {
      const cc = ch.charCodeAt(0);
      return cc >= 48 && cc <= 57 || // 0-9
      cc >= 65 && cc <= 70 || // A-F
      cc >= 97 && cc <= 102;
    }
    function takeHexDigit(scnr) {
      return takeChar(scnr, isHexDigit);
    }
    function getDigits(scnr) {
      let ch = "";
      let num = "";
      while (ch = takeDigit(scnr)) {
        num += ch;
      }
      return num;
    }
    function readText(scnr) {
      let buf = "";
      while (true) {
        const ch = scnr.currentChar();
        if (ch === "{" || ch === "}" || ch === "@" || ch === "|" || !ch) {
          break;
        } else if (ch === CHAR_SP || ch === CHAR_LF) {
          if (isTextStart(scnr)) {
            buf += ch;
            scnr.next();
          } else if (isPluralStart(scnr)) {
            break;
          } else {
            buf += ch;
            scnr.next();
          }
        } else {
          buf += ch;
          scnr.next();
        }
      }
      return buf;
    }
    function readNamedIdentifier(scnr) {
      skipSpaces(scnr);
      let ch = "";
      let name = "";
      while (ch = takeNamedIdentifierChar(scnr)) {
        name += ch;
      }
      if (scnr.currentChar() === EOF) {
        emitError2(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
      }
      return name;
    }
    function readListIdentifier(scnr) {
      skipSpaces(scnr);
      let value = "";
      if (scnr.currentChar() === "-") {
        scnr.next();
        value += `-${getDigits(scnr)}`;
      } else {
        value += getDigits(scnr);
      }
      if (scnr.currentChar() === EOF) {
        emitError2(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
      }
      return value;
    }
    function isLiteral2(ch) {
      return ch !== LITERAL_DELIMITER && ch !== CHAR_LF;
    }
    function readLiteral(scnr) {
      skipSpaces(scnr);
      eat(scnr, `'`);
      let ch = "";
      let literal = "";
      while (ch = takeChar(scnr, isLiteral2)) {
        if (ch === "\\") {
          literal += readEscapeSequence(scnr);
        } else {
          literal += ch;
        }
      }
      const current = scnr.currentChar();
      if (current === CHAR_LF || current === EOF) {
        emitError2(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);
        if (current === CHAR_LF) {
          scnr.next();
          eat(scnr, `'`);
        }
        return literal;
      }
      eat(scnr, `'`);
      return literal;
    }
    function readEscapeSequence(scnr) {
      const ch = scnr.currentChar();
      switch (ch) {
        case "\\":
        case `'`:
          scnr.next();
          return `\\${ch}`;
        case "u":
          return readUnicodeEscapeSequence(scnr, ch, 4);
        case "U":
          return readUnicodeEscapeSequence(scnr, ch, 6);
        default:
          emitError2(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);
          return "";
      }
    }
    function readUnicodeEscapeSequence(scnr, unicode, digits) {
      eat(scnr, unicode);
      let sequence = "";
      for (let i2 = 0; i2 < digits; i2++) {
        const ch = takeHexDigit(scnr);
        if (!ch) {
          emitError2(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\${unicode}${sequence}${scnr.currentChar()}`);
          break;
        }
        sequence += ch;
      }
      return `\\${unicode}${sequence}`;
    }
    function isInvalidIdentifier(ch) {
      return ch !== "{" && ch !== "}" && ch !== CHAR_SP && ch !== CHAR_LF;
    }
    function readInvalidIdentifier(scnr) {
      skipSpaces(scnr);
      let ch = "";
      let identifiers = "";
      while (ch = takeChar(scnr, isInvalidIdentifier)) {
        identifiers += ch;
      }
      return identifiers;
    }
    function readLinkedModifier(scnr) {
      let ch = "";
      let name = "";
      while (ch = takeIdentifierChar(scnr)) {
        name += ch;
      }
      return name;
    }
    function readLinkedRefer(scnr) {
      const fn2 = (buf) => {
        const ch = scnr.currentChar();
        if (ch === "{" || ch === "@" || ch === "|" || ch === "(" || ch === ")" || !ch) {
          return buf;
        } else if (ch === CHAR_SP) {
          return buf;
        } else if (ch === CHAR_LF || ch === DOT) {
          buf += ch;
          scnr.next();
          return fn2(buf);
        } else {
          buf += ch;
          scnr.next();
          return fn2(buf);
        }
      };
      return fn2("");
    }
    function readPlural(scnr) {
      skipSpaces(scnr);
      const plural = eat(
        scnr,
        "|"
        /* TokenChars.Pipe */
      );
      skipSpaces(scnr);
      return plural;
    }
    function readTokenInPlaceholder(scnr, context2) {
      let token = null;
      const ch = scnr.currentChar();
      switch (ch) {
        case "{":
          if (context2.braceNest >= 1) {
            emitError2(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);
          }
          scnr.next();
          token = getToken(
            context2,
            2,
            "{"
            /* TokenChars.BraceLeft */
          );
          skipSpaces(scnr);
          context2.braceNest++;
          return token;
        case "}":
          if (context2.braceNest > 0 && context2.currentType === 2) {
            emitError2(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);
          }
          scnr.next();
          token = getToken(
            context2,
            3,
            "}"
            /* TokenChars.BraceRight */
          );
          context2.braceNest--;
          context2.braceNest > 0 && skipSpaces(scnr);
          if (context2.inLinked && context2.braceNest === 0) {
            context2.inLinked = false;
          }
          return token;
        case "@":
          if (context2.braceNest > 0) {
            emitError2(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          }
          token = readTokenInLinked(scnr, context2) || getEndToken(context2);
          context2.braceNest = 0;
          return token;
        default: {
          let validNamedIdentifier = true;
          let validListIdentifier = true;
          let validLiteral = true;
          if (isPluralStart(scnr)) {
            if (context2.braceNest > 0) {
              emitError2(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
            }
            token = getToken(context2, 1, readPlural(scnr));
            context2.braceNest = 0;
            context2.inLinked = false;
            return token;
          }
          if (context2.braceNest > 0 && (context2.currentType === 4 || context2.currentType === 5 || context2.currentType === 6)) {
            emitError2(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
            context2.braceNest = 0;
            return readToken(scnr, context2);
          }
          if (validNamedIdentifier = isNamedIdentifierStart(scnr, context2)) {
            token = getToken(context2, 4, readNamedIdentifier(scnr));
            skipSpaces(scnr);
            return token;
          }
          if (validListIdentifier = isListIdentifierStart(scnr, context2)) {
            token = getToken(context2, 5, readListIdentifier(scnr));
            skipSpaces(scnr);
            return token;
          }
          if (validLiteral = isLiteralStart(scnr, context2)) {
            token = getToken(context2, 6, readLiteral(scnr));
            skipSpaces(scnr);
            return token;
          }
          if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {
            token = getToken(context2, 12, readInvalidIdentifier(scnr));
            emitError2(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);
            skipSpaces(scnr);
            return token;
          }
          break;
        }
      }
      return token;
    }
    function readTokenInLinked(scnr, context2) {
      const { currentType } = context2;
      let token = null;
      const ch = scnr.currentChar();
      if ((currentType === 7 || currentType === 8 || currentType === 11 || currentType === 9) && (ch === CHAR_LF || ch === CHAR_SP)) {
        emitError2(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
      }
      switch (ch) {
        case "@":
          scnr.next();
          token = getToken(
            context2,
            7,
            "@"
            /* TokenChars.LinkedAlias */
          );
          context2.inLinked = true;
          return token;
        case ".":
          skipSpaces(scnr);
          scnr.next();
          return getToken(
            context2,
            8,
            "."
            /* TokenChars.LinkedDot */
          );
        case ":":
          skipSpaces(scnr);
          scnr.next();
          return getToken(
            context2,
            9,
            ":"
            /* TokenChars.LinkedDelimiter */
          );
        default:
          if (isPluralStart(scnr)) {
            token = getToken(context2, 1, readPlural(scnr));
            context2.braceNest = 0;
            context2.inLinked = false;
            return token;
          }
          if (isLinkedDotStart(scnr, context2) || isLinkedDelimiterStart(scnr, context2)) {
            skipSpaces(scnr);
            return readTokenInLinked(scnr, context2);
          }
          if (isLinkedModifierStart(scnr, context2)) {
            skipSpaces(scnr);
            return getToken(context2, 11, readLinkedModifier(scnr));
          }
          if (isLinkedReferStart(scnr, context2)) {
            skipSpaces(scnr);
            if (ch === "{") {
              return readTokenInPlaceholder(scnr, context2) || token;
            } else {
              return getToken(context2, 10, readLinkedRefer(scnr));
            }
          }
          if (currentType === 7) {
            emitError2(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
          }
          context2.braceNest = 0;
          context2.inLinked = false;
          return readToken(scnr, context2);
      }
    }
    function readToken(scnr, context2) {
      let token = {
        type: 13
        /* TokenTypes.EOF */
      };
      if (context2.braceNest > 0) {
        return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
      }
      if (context2.inLinked) {
        return readTokenInLinked(scnr, context2) || getEndToken(context2);
      }
      const ch = scnr.currentChar();
      switch (ch) {
        case "{":
          return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
        case "}":
          emitError2(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);
          scnr.next();
          return getToken(
            context2,
            3,
            "}"
            /* TokenChars.BraceRight */
          );
        case "@":
          return readTokenInLinked(scnr, context2) || getEndToken(context2);
        default: {
          if (isPluralStart(scnr)) {
            token = getToken(context2, 1, readPlural(scnr));
            context2.braceNest = 0;
            context2.inLinked = false;
            return token;
          }
          if (isTextStart(scnr)) {
            return getToken(context2, 0, readText(scnr));
          }
          break;
        }
      }
      return token;
    }
    function nextToken() {
      const { currentType, offset, startLoc, endLoc } = _context;
      _context.lastType = currentType;
      _context.lastOffset = offset;
      _context.lastStartLoc = startLoc;
      _context.lastEndLoc = endLoc;
      _context.offset = currentOffset();
      _context.startLoc = currentPosition();
      if (_scnr.currentChar() === EOF) {
        return getToken(
          _context,
          13
          /* TokenTypes.EOF */
        );
      }
      return readToken(_scnr, _context);
    }
    return {
      nextToken,
      currentOffset,
      currentPosition,
      context
    };
  }
  const ERROR_DOMAIN$2 = "parser";
  const KNOWN_ESCAPES = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
  function fromEscapeSequence(match, codePoint4, codePoint6) {
    switch (match) {
      case `\\\\`:
        return `\\`;
      case `\\'`:
        return `'`;
      default: {
        const codePoint = parseInt(codePoint4 || codePoint6, 16);
        if (codePoint <= 55295 || codePoint >= 57344) {
          return String.fromCodePoint(codePoint);
        }
        return "�";
      }
    }
  }
  function createParser(options = {}) {
    const location2 = options.location !== false;
    const { onError } = options;
    function emitError2(tokenzer, code, start, offset, ...args) {
      const end = tokenzer.currentPosition();
      end.offset += offset;
      end.column += offset;
      if (onError) {
        const loc = location2 ? createLocation(start, end) : null;
        const err = createCompileError(code, loc, {
          domain: ERROR_DOMAIN$2,
          args
        });
        onError(err);
      }
    }
    function startNode(type, offset, loc) {
      const node = { type };
      if (location2) {
        node.start = offset;
        node.end = offset;
        node.loc = { start: loc, end: loc };
      }
      return node;
    }
    function endNode(node, offset, pos, type) {
      if (location2) {
        node.end = offset;
        if (node.loc) {
          node.loc.end = pos;
        }
      }
    }
    function parseText(tokenizer2, value) {
      const context = tokenizer2.context();
      const node = startNode(3, context.offset, context.startLoc);
      node.value = value;
      endNode(node, tokenizer2.currentOffset(), tokenizer2.currentPosition());
      return node;
    }
    function parseList(tokenizer2, index) {
      const context = tokenizer2.context();
      const { lastOffset: offset, lastStartLoc: loc } = context;
      const node = startNode(5, offset, loc);
      node.index = parseInt(index, 10);
      tokenizer2.nextToken();
      endNode(node, tokenizer2.currentOffset(), tokenizer2.currentPosition());
      return node;
    }
    function parseNamed(tokenizer2, key) {
      const context = tokenizer2.context();
      const { lastOffset: offset, lastStartLoc: loc } = context;
      const node = startNode(4, offset, loc);
      node.key = key;
      tokenizer2.nextToken();
      endNode(node, tokenizer2.currentOffset(), tokenizer2.currentPosition());
      return node;
    }
    function parseLiteral(tokenizer2, value) {
      const context = tokenizer2.context();
      const { lastOffset: offset, lastStartLoc: loc } = context;
      const node = startNode(9, offset, loc);
      node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);
      tokenizer2.nextToken();
      endNode(node, tokenizer2.currentOffset(), tokenizer2.currentPosition());
      return node;
    }
    function parseLinkedModifier(tokenizer2) {
      const token = tokenizer2.nextToken();
      const context = tokenizer2.context();
      const { lastOffset: offset, lastStartLoc: loc } = context;
      const node = startNode(8, offset, loc);
      if (token.type !== 11) {
        emitError2(tokenizer2, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);
        node.value = "";
        endNode(node, offset, loc);
        return {
          nextConsumeToken: token,
          node
        };
      }
      if (token.value == null) {
        emitError2(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
      }
      node.value = token.value || "";
      endNode(node, tokenizer2.currentOffset(), tokenizer2.currentPosition());
      return {
        node
      };
    }
    function parseLinkedKey(tokenizer2, value) {
      const context = tokenizer2.context();
      const node = startNode(7, context.offset, context.startLoc);
      node.value = value;
      endNode(node, tokenizer2.currentOffset(), tokenizer2.currentPosition());
      return node;
    }
    function parseLinked(tokenizer2) {
      const context = tokenizer2.context();
      const linkedNode = startNode(6, context.offset, context.startLoc);
      let token = tokenizer2.nextToken();
      if (token.type === 8) {
        const parsed = parseLinkedModifier(tokenizer2);
        linkedNode.modifier = parsed.node;
        token = parsed.nextConsumeToken || tokenizer2.nextToken();
      }
      if (token.type !== 9) {
        emitError2(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
      }
      token = tokenizer2.nextToken();
      if (token.type === 2) {
        token = tokenizer2.nextToken();
      }
      switch (token.type) {
        case 10:
          if (token.value == null) {
            emitError2(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          linkedNode.key = parseLinkedKey(tokenizer2, token.value || "");
          break;
        case 4:
          if (token.value == null) {
            emitError2(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          linkedNode.key = parseNamed(tokenizer2, token.value || "");
          break;
        case 5:
          if (token.value == null) {
            emitError2(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          linkedNode.key = parseList(tokenizer2, token.value || "");
          break;
        case 6:
          if (token.value == null) {
            emitError2(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          linkedNode.key = parseLiteral(tokenizer2, token.value || "");
          break;
        default: {
          emitError2(tokenizer2, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);
          const nextContext = tokenizer2.context();
          const emptyLinkedKeyNode = startNode(7, nextContext.offset, nextContext.startLoc);
          emptyLinkedKeyNode.value = "";
          endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);
          linkedNode.key = emptyLinkedKeyNode;
          endNode(linkedNode, nextContext.offset, nextContext.startLoc);
          return {
            nextConsumeToken: token,
            node: linkedNode
          };
        }
      }
      endNode(linkedNode, tokenizer2.currentOffset(), tokenizer2.currentPosition());
      return {
        node: linkedNode
      };
    }
    function parseMessage(tokenizer2) {
      const context = tokenizer2.context();
      const startOffset = context.currentType === 1 ? tokenizer2.currentOffset() : context.offset;
      const startLoc = context.currentType === 1 ? context.endLoc : context.startLoc;
      const node = startNode(2, startOffset, startLoc);
      node.items = [];
      let nextToken = null;
      do {
        const token = nextToken || tokenizer2.nextToken();
        nextToken = null;
        switch (token.type) {
          case 0:
            if (token.value == null) {
              emitError2(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
            }
            node.items.push(parseText(tokenizer2, token.value || ""));
            break;
          case 5:
            if (token.value == null) {
              emitError2(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
            }
            node.items.push(parseList(tokenizer2, token.value || ""));
            break;
          case 4:
            if (token.value == null) {
              emitError2(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
            }
            node.items.push(parseNamed(tokenizer2, token.value || ""));
            break;
          case 6:
            if (token.value == null) {
              emitError2(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
            }
            node.items.push(parseLiteral(tokenizer2, token.value || ""));
            break;
          case 7: {
            const parsed = parseLinked(tokenizer2);
            node.items.push(parsed.node);
            nextToken = parsed.nextConsumeToken || null;
            break;
          }
        }
      } while (context.currentType !== 13 && context.currentType !== 1);
      const endOffset = context.currentType === 1 ? context.lastOffset : tokenizer2.currentOffset();
      const endLoc = context.currentType === 1 ? context.lastEndLoc : tokenizer2.currentPosition();
      endNode(node, endOffset, endLoc);
      return node;
    }
    function parsePlural(tokenizer2, offset, loc, msgNode) {
      const context = tokenizer2.context();
      let hasEmptyMessage = msgNode.items.length === 0;
      const node = startNode(1, offset, loc);
      node.cases = [];
      node.cases.push(msgNode);
      do {
        const msg = parseMessage(tokenizer2);
        if (!hasEmptyMessage) {
          hasEmptyMessage = msg.items.length === 0;
        }
        node.cases.push(msg);
      } while (context.currentType !== 13);
      if (hasEmptyMessage) {
        emitError2(tokenizer2, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);
      }
      endNode(node, tokenizer2.currentOffset(), tokenizer2.currentPosition());
      return node;
    }
    function parseResource(tokenizer2) {
      const context = tokenizer2.context();
      const { offset, startLoc } = context;
      const msgNode = parseMessage(tokenizer2);
      if (context.currentType === 13) {
        return msgNode;
      } else {
        return parsePlural(tokenizer2, offset, startLoc, msgNode);
      }
    }
    function parse2(source) {
      const tokenizer2 = createTokenizer(source, assign$2({}, options));
      const context = tokenizer2.context();
      const node = startNode(0, context.offset, context.startLoc);
      if (location2 && node.loc) {
        node.loc.source = source;
      }
      node.body = parseResource(tokenizer2);
      if (options.onCacheKey) {
        node.cacheKey = options.onCacheKey(source);
      }
      if (context.currentType !== 13) {
        emitError2(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || "");
      }
      endNode(node, tokenizer2.currentOffset(), tokenizer2.currentPosition());
      return node;
    }
    return { parse: parse2 };
  }
  function getTokenCaption(token) {
    if (token.type === 13) {
      return "EOF";
    }
    const name = (token.value || "").replace(/\r?\n/gu, "\\n");
    return name.length > 10 ? name.slice(0, 9) + "…" : name;
  }
  function createTransformer(ast, options = {}) {
    const _context = {
      ast,
      helpers: /* @__PURE__ */ new Set()
    };
    const context = () => _context;
    const helper = (name) => {
      _context.helpers.add(name);
      return name;
    };
    return { context, helper };
  }
  function traverseNodes(nodes, transformer) {
    for (let i2 = 0; i2 < nodes.length; i2++) {
      traverseNode$1(nodes[i2], transformer);
    }
  }
  function traverseNode$1(node, transformer) {
    switch (node.type) {
      case 1:
        traverseNodes(node.cases, transformer);
        transformer.helper(
          "plural"
          /* HelperNameMap.PLURAL */
        );
        break;
      case 2:
        traverseNodes(node.items, transformer);
        break;
      case 6: {
        const linked = node;
        traverseNode$1(linked.key, transformer);
        transformer.helper(
          "linked"
          /* HelperNameMap.LINKED */
        );
        transformer.helper(
          "type"
          /* HelperNameMap.TYPE */
        );
        break;
      }
      case 5:
        transformer.helper(
          "interpolate"
          /* HelperNameMap.INTERPOLATE */
        );
        transformer.helper(
          "list"
          /* HelperNameMap.LIST */
        );
        break;
      case 4:
        transformer.helper(
          "interpolate"
          /* HelperNameMap.INTERPOLATE */
        );
        transformer.helper(
          "named"
          /* HelperNameMap.NAMED */
        );
        break;
    }
  }
  function transform$1(ast, options = {}) {
    const transformer = createTransformer(ast);
    transformer.helper(
      "normalize"
      /* HelperNameMap.NORMALIZE */
    );
    ast.body && traverseNode$1(ast.body, transformer);
    const context = transformer.context();
    ast.helpers = Array.from(context.helpers);
  }
  function optimize(ast) {
    const body = ast.body;
    if (body.type === 2) {
      optimizeMessageNode(body);
    } else {
      body.cases.forEach((c2) => optimizeMessageNode(c2));
    }
    return ast;
  }
  function optimizeMessageNode(message) {
    if (message.items.length === 1) {
      const item = message.items[0];
      if (item.type === 3 || item.type === 9) {
        message.static = item.value;
        delete item.value;
      }
    } else {
      const values = [];
      for (let i2 = 0; i2 < message.items.length; i2++) {
        const item = message.items[i2];
        if (!(item.type === 3 || item.type === 9)) {
          break;
        }
        if (item.value == null) {
          break;
        }
        values.push(item.value);
      }
      if (values.length === message.items.length) {
        message.static = join(values);
        for (let i2 = 0; i2 < message.items.length; i2++) {
          const item = message.items[i2];
          if (item.type === 3 || item.type === 9) {
            delete item.value;
          }
        }
      }
    }
  }
  function minify(node) {
    node.t = node.type;
    switch (node.type) {
      case 0: {
        const resource = node;
        minify(resource.body);
        resource.b = resource.body;
        delete resource.body;
        break;
      }
      case 1: {
        const plural = node;
        const cases = plural.cases;
        for (let i2 = 0; i2 < cases.length; i2++) {
          minify(cases[i2]);
        }
        plural.c = cases;
        delete plural.cases;
        break;
      }
      case 2: {
        const message = node;
        const items = message.items;
        for (let i2 = 0; i2 < items.length; i2++) {
          minify(items[i2]);
        }
        message.i = items;
        delete message.items;
        if (message.static) {
          message.s = message.static;
          delete message.static;
        }
        break;
      }
      case 3:
      case 9:
      case 8:
      case 7: {
        const valueNode = node;
        if (valueNode.value) {
          valueNode.v = valueNode.value;
          delete valueNode.value;
        }
        break;
      }
      case 6: {
        const linked = node;
        minify(linked.key);
        linked.k = linked.key;
        delete linked.key;
        if (linked.modifier) {
          minify(linked.modifier);
          linked.m = linked.modifier;
          delete linked.modifier;
        }
        break;
      }
      case 5: {
        const list = node;
        list.i = list.index;
        delete list.index;
        break;
      }
      case 4: {
        const named = node;
        named.k = named.key;
        delete named.key;
        break;
      }
    }
    delete node.type;
  }
  function createCodeGenerator(ast, options) {
    const { sourceMap, filename, breakLineCode, needIndent: _needIndent } = options;
    const location2 = options.location !== false;
    const _context = {
      filename,
      code: "",
      column: 1,
      line: 1,
      offset: 0,
      map: void 0,
      breakLineCode,
      needIndent: _needIndent,
      indentLevel: 0
    };
    if (location2 && ast.loc) {
      _context.source = ast.loc.source;
    }
    const context = () => _context;
    function push(code, node) {
      _context.code += code;
    }
    function _newline(n2, withBreakLine = true) {
      const _breakLineCode = withBreakLine ? breakLineCode : "";
      push(_needIndent ? _breakLineCode + `  `.repeat(n2) : _breakLineCode);
    }
    function indent(withNewLine = true) {
      const level = ++_context.indentLevel;
      withNewLine && _newline(level);
    }
    function deindent(withNewLine = true) {
      const level = --_context.indentLevel;
      withNewLine && _newline(level);
    }
    function newline() {
      _newline(_context.indentLevel);
    }
    const helper = (key) => `_${key}`;
    const needIndent = () => _context.needIndent;
    return {
      context,
      push,
      indent,
      deindent,
      newline,
      helper,
      needIndent
    };
  }
  function generateLinkedNode(generator, node) {
    const { helper } = generator;
    generator.push(`${helper(
      "linked"
      /* HelperNameMap.LINKED */
    )}(`);
    generateNode(generator, node.key);
    if (node.modifier) {
      generator.push(`, `);
      generateNode(generator, node.modifier);
      generator.push(`, _type`);
    } else {
      generator.push(`, undefined, _type`);
    }
    generator.push(`)`);
  }
  function generateMessageNode(generator, node) {
    const { helper, needIndent } = generator;
    generator.push(`${helper(
      "normalize"
      /* HelperNameMap.NORMALIZE */
    )}([`);
    generator.indent(needIndent());
    const length = node.items.length;
    for (let i2 = 0; i2 < length; i2++) {
      generateNode(generator, node.items[i2]);
      if (i2 === length - 1) {
        break;
      }
      generator.push(", ");
    }
    generator.deindent(needIndent());
    generator.push("])");
  }
  function generatePluralNode(generator, node) {
    const { helper, needIndent } = generator;
    if (node.cases.length > 1) {
      generator.push(`${helper(
        "plural"
        /* HelperNameMap.PLURAL */
      )}([`);
      generator.indent(needIndent());
      const length = node.cases.length;
      for (let i2 = 0; i2 < length; i2++) {
        generateNode(generator, node.cases[i2]);
        if (i2 === length - 1) {
          break;
        }
        generator.push(", ");
      }
      generator.deindent(needIndent());
      generator.push(`])`);
    }
  }
  function generateResource(generator, node) {
    if (node.body) {
      generateNode(generator, node.body);
    } else {
      generator.push("null");
    }
  }
  function generateNode(generator, node) {
    const { helper } = generator;
    switch (node.type) {
      case 0:
        generateResource(generator, node);
        break;
      case 1:
        generatePluralNode(generator, node);
        break;
      case 2:
        generateMessageNode(generator, node);
        break;
      case 6:
        generateLinkedNode(generator, node);
        break;
      case 8:
        generator.push(JSON.stringify(node.value), node);
        break;
      case 7:
        generator.push(JSON.stringify(node.value), node);
        break;
      case 5:
        generator.push(`${helper(
          "interpolate"
          /* HelperNameMap.INTERPOLATE */
        )}(${helper(
          "list"
          /* HelperNameMap.LIST */
        )}(${node.index}))`, node);
        break;
      case 4:
        generator.push(`${helper(
          "interpolate"
          /* HelperNameMap.INTERPOLATE */
        )}(${helper(
          "named"
          /* HelperNameMap.NAMED */
        )}(${JSON.stringify(node.key)}))`, node);
        break;
      case 9:
        generator.push(JSON.stringify(node.value), node);
        break;
      case 3:
        generator.push(JSON.stringify(node.value), node);
        break;
    }
  }
  const generate$1 = (ast, options = {}) => {
    const mode = isString$2(options.mode) ? options.mode : "normal";
    const filename = isString$2(options.filename) ? options.filename : "message.intl";
    const sourceMap = !!options.sourceMap;
    const breakLineCode = options.breakLineCode != null ? options.breakLineCode : mode === "arrow" ? ";" : "\n";
    const needIndent = options.needIndent ? options.needIndent : mode !== "arrow";
    const helpers = ast.helpers || [];
    const generator = createCodeGenerator(ast, {
      mode,
      filename,
      sourceMap,
      breakLineCode,
      needIndent
    });
    generator.push(mode === "normal" ? `function __msg__ (ctx) {` : `(ctx) => {`);
    generator.indent(needIndent);
    if (helpers.length > 0) {
      generator.push(`const { ${join(helpers.map((s2) => `${s2}: _${s2}`), ", ")} } = ctx`);
      generator.newline();
    }
    generator.push(`return `);
    generateNode(generator, ast);
    generator.deindent(needIndent);
    generator.push(`}`);
    delete ast.helpers;
    const { code, map } = generator.context();
    return {
      ast,
      code,
      map: map ? map.toJSON() : void 0
      // eslint-disable-line @typescript-eslint/no-explicit-any
    };
  };
  function baseCompile$2(source, options = {}) {
    const assignedOptions = assign$2({}, options);
    const jit = !!assignedOptions.jit;
    const enalbeMinify = !!assignedOptions.minify;
    const enambeOptimize = assignedOptions.optimize == null ? true : assignedOptions.optimize;
    const parser = createParser(assignedOptions);
    const ast = parser.parse(source);
    if (!jit) {
      transform$1(ast, assignedOptions);
      return generate$1(ast, assignedOptions);
    } else {
      enambeOptimize && optimize(ast);
      enalbeMinify && minify(ast);
      return { ast, code: "" };
    }
  }
  /*!
    * core-base v10.0.3
    * (c) 2024 kazuya kawaguchi
    * Released under the MIT License.
    */
  function initFeatureFlags$1() {
    if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
      getGlobalThis$1().__INTLIFY_PROD_DEVTOOLS__ = false;
    }
    if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
      getGlobalThis$1().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
    }
  }
  function format(ast) {
    const msg = (ctx) => formatParts(ctx, ast);
    return msg;
  }
  function formatParts(ctx, ast) {
    const body = ast.b || ast.body;
    if ((body.t || body.type) === 1) {
      const plural = body;
      const cases = plural.c || plural.cases;
      return ctx.plural(cases.reduce((messages, c2) => [
        ...messages,
        formatMessageParts(ctx, c2)
      ], []));
    } else {
      return formatMessageParts(ctx, body);
    }
  }
  function formatMessageParts(ctx, node) {
    const _static = node.s || node.static;
    if (_static) {
      return ctx.type === "text" ? _static : ctx.normalize([_static]);
    } else {
      const messages = (node.i || node.items).reduce((acm, c2) => [...acm, formatMessagePart(ctx, c2)], []);
      return ctx.normalize(messages);
    }
  }
  function formatMessagePart(ctx, node) {
    const type = node.t || node.type;
    switch (type) {
      case 3: {
        const text = node;
        return text.v || text.value;
      }
      case 9: {
        const literal = node;
        return literal.v || literal.value;
      }
      case 4: {
        const named = node;
        return ctx.interpolate(ctx.named(named.k || named.key));
      }
      case 5: {
        const list = node;
        return ctx.interpolate(ctx.list(list.i != null ? list.i : list.index));
      }
      case 6: {
        const linked = node;
        const modifier = linked.m || linked.modifier;
        return ctx.linked(formatMessagePart(ctx, linked.k || linked.key), modifier ? formatMessagePart(ctx, modifier) : void 0, ctx.type);
      }
      case 7: {
        const linkedKey = node;
        return linkedKey.v || linkedKey.value;
      }
      case 8: {
        const linkedModifier = node;
        return linkedModifier.v || linkedModifier.value;
      }
      default:
        throw new Error(`unhandled node type on format message part: ${type}`);
    }
  }
  const defaultOnCacheKey = (message) => message;
  let compileCache$1 = /* @__PURE__ */ Object.create(null);
  const isMessageAST = (val) => isObject$2(val) && (val.t === 0 || val.type === 0) && ("b" in val || "body" in val);
  function baseCompile$1(message, options = {}) {
    let detectError = false;
    const onError = options.onError || defaultOnError$1;
    options.onError = (err) => {
      detectError = true;
      onError(err);
    };
    return { ...baseCompile$2(message, options), detectError };
  }
  // @__NO_SIDE_EFFECTS__
  function compile$2(message, context) {
    if (!__INTLIFY_DROP_MESSAGE_COMPILER__ && isString$2(message)) {
      isBoolean$1(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
      const onCacheKey = context.onCacheKey || defaultOnCacheKey;
      const cacheKey = onCacheKey(message);
      const cached = compileCache$1[cacheKey];
      if (cached) {
        return cached;
      }
      const { ast, detectError } = baseCompile$1(message, {
        ...context,
        location: false,
        jit: true
      });
      const msg = format(ast);
      return !detectError ? compileCache$1[cacheKey] = msg : msg;
    } else {
      const cacheKey = message.cacheKey;
      if (cacheKey) {
        const cached = compileCache$1[cacheKey];
        if (cached) {
          return cached;
        }
        return compileCache$1[cacheKey] = format(message);
      } else {
        return format(message);
      }
    }
  }
  let devtools$2 = null;
  function setDevToolsHook(hook) {
    devtools$2 = hook;
  }
  function initI18nDevTools(i18n2, version2, meta) {
    devtools$2 && devtools$2.emit("i18n:init", {
      timestamp: Date.now(),
      i18n: i18n2,
      version: version2,
      meta
    });
  }
  const translateDevTools = /* @__PURE__ */ createDevToolsHook("function:translate");
  function createDevToolsHook(hook) {
    return (payloads) => devtools$2 && devtools$2.emit(hook, payloads);
  }
  const CoreErrorCodes = {
    INVALID_ARGUMENT: COMPILE_ERROR_CODES_EXTEND_POINT,
    // 17
    INVALID_DATE_ARGUMENT: 18,
    INVALID_ISO_DATE_ARGUMENT: 19,
    NOT_SUPPORT_NON_STRING_MESSAGE: 20,
    NOT_SUPPORT_LOCALE_PROMISE_VALUE: 21,
    NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: 22,
    NOT_SUPPORT_LOCALE_TYPE: 23
  };
  const CORE_ERROR_CODES_EXTEND_POINT = 24;
  function createCoreError(code) {
    return createCompileError(code, null, void 0);
  }
  function getLocale(context, options) {
    return options.locale != null ? resolveLocale(options.locale) : resolveLocale(context.locale);
  }
  let _resolveLocale;
  function resolveLocale(locale2) {
    if (isString$2(locale2)) {
      return locale2;
    } else {
      if (isFunction$2(locale2)) {
        if (locale2.resolvedOnce && _resolveLocale != null) {
          return _resolveLocale;
        } else if (locale2.constructor.name === "Function") {
          const resolve2 = locale2();
          if (isPromise$1(resolve2)) {
            throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
          }
          return _resolveLocale = resolve2;
        } else {
          throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
        }
      } else {
        throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE);
      }
    }
  }
  function fallbackWithSimple(ctx, fallback, start) {
    return [.../* @__PURE__ */ new Set([
      start,
      ...isArray$3(fallback) ? fallback : isObject$2(fallback) ? Object.keys(fallback) : isString$2(fallback) ? [fallback] : [start]
    ])];
  }
  function fallbackWithLocaleChain(ctx, fallback, start) {
    const startLocale = isString$2(start) ? start : DEFAULT_LOCALE;
    const context = ctx;
    if (!context.__localeChainCache) {
      context.__localeChainCache = /* @__PURE__ */ new Map();
    }
    let chain = context.__localeChainCache.get(startLocale);
    if (!chain) {
      chain = [];
      let block = [start];
      while (isArray$3(block)) {
        block = appendBlockToChain(chain, block, fallback);
      }
      const defaults2 = isArray$3(fallback) || !isPlainObject$3(fallback) ? fallback : fallback["default"] ? fallback["default"] : null;
      block = isString$2(defaults2) ? [defaults2] : defaults2;
      if (isArray$3(block)) {
        appendBlockToChain(chain, block, false);
      }
      context.__localeChainCache.set(startLocale, chain);
    }
    return chain;
  }
  function appendBlockToChain(chain, block, blocks) {
    let follow = true;
    for (let i2 = 0; i2 < block.length && isBoolean$1(follow); i2++) {
      const locale2 = block[i2];
      if (isString$2(locale2)) {
        follow = appendLocaleToChain(chain, block[i2], blocks);
      }
    }
    return follow;
  }
  function appendLocaleToChain(chain, locale2, blocks) {
    let follow;
    const tokens = locale2.split("-");
    do {
      const target = tokens.join("-");
      follow = appendItemToChain(chain, target, blocks);
      tokens.splice(-1, 1);
    } while (tokens.length && follow === true);
    return follow;
  }
  function appendItemToChain(chain, target, blocks) {
    let follow = false;
    if (!chain.includes(target)) {
      follow = true;
      if (target) {
        follow = target[target.length - 1] !== "!";
        const locale2 = target.replace(/!/g, "");
        chain.push(locale2);
        if ((isArray$3(blocks) || isPlainObject$3(blocks)) && blocks[locale2]) {
          follow = blocks[locale2];
        }
      }
    }
    return follow;
  }
  const pathStateMachine = [];
  pathStateMachine[
    0
    /* States.BEFORE_PATH */
  ] = {
    [
      "w"
      /* PathCharTypes.WORKSPACE */
    ]: [
      0
      /* States.BEFORE_PATH */
    ],
    [
      "i"
      /* PathCharTypes.IDENT */
    ]: [
      3,
      0
      /* Actions.APPEND */
    ],
    [
      "["
      /* PathCharTypes.LEFT_BRACKET */
    ]: [
      4
      /* States.IN_SUB_PATH */
    ],
    [
      "o"
      /* PathCharTypes.END_OF_FAIL */
    ]: [
      7
      /* States.AFTER_PATH */
    ]
  };
  pathStateMachine[
    1
    /* States.IN_PATH */
  ] = {
    [
      "w"
      /* PathCharTypes.WORKSPACE */
    ]: [
      1
      /* States.IN_PATH */
    ],
    [
      "."
      /* PathCharTypes.DOT */
    ]: [
      2
      /* States.BEFORE_IDENT */
    ],
    [
      "["
      /* PathCharTypes.LEFT_BRACKET */
    ]: [
      4
      /* States.IN_SUB_PATH */
    ],
    [
      "o"
      /* PathCharTypes.END_OF_FAIL */
    ]: [
      7
      /* States.AFTER_PATH */
    ]
  };
  pathStateMachine[
    2
    /* States.BEFORE_IDENT */
  ] = {
    [
      "w"
      /* PathCharTypes.WORKSPACE */
    ]: [
      2
      /* States.BEFORE_IDENT */
    ],
    [
      "i"
      /* PathCharTypes.IDENT */
    ]: [
      3,
      0
      /* Actions.APPEND */
    ],
    [
      "0"
      /* PathCharTypes.ZERO */
    ]: [
      3,
      0
      /* Actions.APPEND */
    ]
  };
  pathStateMachine[
    3
    /* States.IN_IDENT */
  ] = {
    [
      "i"
      /* PathCharTypes.IDENT */
    ]: [
      3,
      0
      /* Actions.APPEND */
    ],
    [
      "0"
      /* PathCharTypes.ZERO */
    ]: [
      3,
      0
      /* Actions.APPEND */
    ],
    [
      "w"
      /* PathCharTypes.WORKSPACE */
    ]: [
      1,
      1
      /* Actions.PUSH */
    ],
    [
      "."
      /* PathCharTypes.DOT */
    ]: [
      2,
      1
      /* Actions.PUSH */
    ],
    [
      "["
      /* PathCharTypes.LEFT_BRACKET */
    ]: [
      4,
      1
      /* Actions.PUSH */
    ],
    [
      "o"
      /* PathCharTypes.END_OF_FAIL */
    ]: [
      7,
      1
      /* Actions.PUSH */
    ]
  };
  pathStateMachine[
    4
    /* States.IN_SUB_PATH */
  ] = {
    [
      "'"
      /* PathCharTypes.SINGLE_QUOTE */
    ]: [
      5,
      0
      /* Actions.APPEND */
    ],
    [
      '"'
      /* PathCharTypes.DOUBLE_QUOTE */
    ]: [
      6,
      0
      /* Actions.APPEND */
    ],
    [
      "["
      /* PathCharTypes.LEFT_BRACKET */
    ]: [
      4,
      2
      /* Actions.INC_SUB_PATH_DEPTH */
    ],
    [
      "]"
      /* PathCharTypes.RIGHT_BRACKET */
    ]: [
      1,
      3
      /* Actions.PUSH_SUB_PATH */
    ],
    [
      "o"
      /* PathCharTypes.END_OF_FAIL */
    ]: 8,
    [
      "l"
      /* PathCharTypes.ELSE */
    ]: [
      4,
      0
      /* Actions.APPEND */
    ]
  };
  pathStateMachine[
    5
    /* States.IN_SINGLE_QUOTE */
  ] = {
    [
      "'"
      /* PathCharTypes.SINGLE_QUOTE */
    ]: [
      4,
      0
      /* Actions.APPEND */
    ],
    [
      "o"
      /* PathCharTypes.END_OF_FAIL */
    ]: 8,
    [
      "l"
      /* PathCharTypes.ELSE */
    ]: [
      5,
      0
      /* Actions.APPEND */
    ]
  };
  pathStateMachine[
    6
    /* States.IN_DOUBLE_QUOTE */
  ] = {
    [
      '"'
      /* PathCharTypes.DOUBLE_QUOTE */
    ]: [
      4,
      0
      /* Actions.APPEND */
    ],
    [
      "o"
      /* PathCharTypes.END_OF_FAIL */
    ]: 8,
    [
      "l"
      /* PathCharTypes.ELSE */
    ]: [
      6,
      0
      /* Actions.APPEND */
    ]
  };
  const literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
  function isLiteral(exp) {
    return literalValueRE.test(exp);
  }
  function stripQuotes(str) {
    const a2 = str.charCodeAt(0);
    const b2 = str.charCodeAt(str.length - 1);
    return a2 === b2 && (a2 === 34 || a2 === 39) ? str.slice(1, -1) : str;
  }
  function getPathCharType(ch) {
    if (ch === void 0 || ch === null) {
      return "o";
    }
    const code = ch.charCodeAt(0);
    switch (code) {
      case 91:
      case 93:
      case 46:
      case 34:
      case 39:
        return ch;
      case 95:
      case 36:
      case 45:
        return "i";
      case 9:
      case 10:
      case 13:
      case 160:
      case 65279:
      case 8232:
      case 8233:
        return "w";
    }
    return "i";
  }
  function formatSubPath(path) {
    const trimmed = path.trim();
    if (path.charAt(0) === "0" && isNaN(parseInt(path))) {
      return false;
    }
    return isLiteral(trimmed) ? stripQuotes(trimmed) : "*" + trimmed;
  }
  function parse(path) {
    const keys = [];
    let index = -1;
    let mode = 0;
    let subPathDepth = 0;
    let c2;
    let key;
    let newChar;
    let type;
    let transition;
    let action;
    let typeMap;
    const actions = [];
    actions[
      0
      /* Actions.APPEND */
    ] = () => {
      if (key === void 0) {
        key = newChar;
      } else {
        key += newChar;
      }
    };
    actions[
      1
      /* Actions.PUSH */
    ] = () => {
      if (key !== void 0) {
        keys.push(key);
        key = void 0;
      }
    };
    actions[
      2
      /* Actions.INC_SUB_PATH_DEPTH */
    ] = () => {
      actions[
        0
        /* Actions.APPEND */
      ]();
      subPathDepth++;
    };
    actions[
      3
      /* Actions.PUSH_SUB_PATH */
    ] = () => {
      if (subPathDepth > 0) {
        subPathDepth--;
        mode = 4;
        actions[
          0
          /* Actions.APPEND */
        ]();
      } else {
        subPathDepth = 0;
        if (key === void 0) {
          return false;
        }
        key = formatSubPath(key);
        if (key === false) {
          return false;
        } else {
          actions[
            1
            /* Actions.PUSH */
          ]();
        }
      }
    };
    function maybeUnescapeQuote() {
      const nextChar = path[index + 1];
      if (mode === 5 && nextChar === "'" || mode === 6 && nextChar === '"') {
        index++;
        newChar = "\\" + nextChar;
        actions[
          0
          /* Actions.APPEND */
        ]();
        return true;
      }
    }
    while (mode !== null) {
      index++;
      c2 = path[index];
      if (c2 === "\\" && maybeUnescapeQuote()) {
        continue;
      }
      type = getPathCharType(c2);
      typeMap = pathStateMachine[mode];
      transition = typeMap[type] || typeMap[
        "l"
        /* PathCharTypes.ELSE */
      ] || 8;
      if (transition === 8) {
        return;
      }
      mode = transition[0];
      if (transition[1] !== void 0) {
        action = actions[transition[1]];
        if (action) {
          newChar = c2;
          if (action() === false) {
            return;
          }
        }
      }
      if (mode === 7) {
        return keys;
      }
    }
  }
  const cache$1 = /* @__PURE__ */ new Map();
  function resolveWithKeyValue(obj, path) {
    return isObject$2(obj) ? obj[path] : null;
  }
  function resolveValue(obj, path) {
    if (!isObject$2(obj)) {
      return null;
    }
    let hit = cache$1.get(path);
    if (!hit) {
      hit = parse(path);
      if (hit) {
        cache$1.set(path, hit);
      }
    }
    if (!hit) {
      return null;
    }
    const len = hit.length;
    let last = obj;
    let i2 = 0;
    while (i2 < len) {
      const val = last[hit[i2]];
      if (val === void 0) {
        return null;
      }
      if (isFunction$2(last)) {
        return null;
      }
      last = val;
      i2++;
    }
    return last;
  }
  const VERSION$2 = "10.0.3";
  const NOT_REOSLVED = -1;
  const DEFAULT_LOCALE = "en-US";
  const MISSING_RESOLVE_VALUE = "";
  const capitalize$1 = (str) => `${str.charAt(0).toLocaleUpperCase()}${str.substr(1)}`;
  function getDefaultLinkedModifiers() {
    return {
      upper: (val, type) => {
        return type === "text" && isString$2(val) ? val.toUpperCase() : type === "vnode" && isObject$2(val) && "__v_isVNode" in val ? val.children.toUpperCase() : val;
      },
      lower: (val, type) => {
        return type === "text" && isString$2(val) ? val.toLowerCase() : type === "vnode" && isObject$2(val) && "__v_isVNode" in val ? val.children.toLowerCase() : val;
      },
      capitalize: (val, type) => {
        return type === "text" && isString$2(val) ? capitalize$1(val) : type === "vnode" && isObject$2(val) && "__v_isVNode" in val ? capitalize$1(val.children) : val;
      }
    };
  }
  let _compiler;
  function registerMessageCompiler(compiler) {
    _compiler = compiler;
  }
  let _resolver;
  function registerMessageResolver(resolver) {
    _resolver = resolver;
  }
  let _fallbacker;
  function registerLocaleFallbacker(fallbacker) {
    _fallbacker = fallbacker;
  }
  let _additionalMeta = null;
  const setAdditionalMeta = /* @__NO_SIDE_EFFECTS__ */ (meta) => {
    _additionalMeta = meta;
  };
  const getAdditionalMeta = /* @__NO_SIDE_EFFECTS__ */ () => _additionalMeta;
  let _fallbackContext = null;
  const setFallbackContext = (context) => {
    _fallbackContext = context;
  };
  const getFallbackContext = () => _fallbackContext;
  let _cid = 0;
  function createCoreContext(options = {}) {
    const onWarn = isFunction$2(options.onWarn) ? options.onWarn : warn$2;
    const version2 = isString$2(options.version) ? options.version : VERSION$2;
    const locale2 = isString$2(options.locale) || isFunction$2(options.locale) ? options.locale : DEFAULT_LOCALE;
    const _locale = isFunction$2(locale2) ? DEFAULT_LOCALE : locale2;
    const fallbackLocale = isArray$3(options.fallbackLocale) || isPlainObject$3(options.fallbackLocale) || isString$2(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale;
    const messages = isPlainObject$3(options.messages) ? options.messages : { [_locale]: {} };
    const datetimeFormats = isPlainObject$3(options.datetimeFormats) ? options.datetimeFormats : { [_locale]: {} };
    const numberFormats = isPlainObject$3(options.numberFormats) ? options.numberFormats : { [_locale]: {} };
    const modifiers = assign$2({}, options.modifiers || {}, getDefaultLinkedModifiers());
    const pluralRules = options.pluralRules || {};
    const missing = isFunction$2(options.missing) ? options.missing : null;
    const missingWarn = isBoolean$1(options.missingWarn) || isRegExp$2(options.missingWarn) ? options.missingWarn : true;
    const fallbackWarn = isBoolean$1(options.fallbackWarn) || isRegExp$2(options.fallbackWarn) ? options.fallbackWarn : true;
    const fallbackFormat = !!options.fallbackFormat;
    const unresolving = !!options.unresolving;
    const postTranslation = isFunction$2(options.postTranslation) ? options.postTranslation : null;
    const processor = isPlainObject$3(options.processor) ? options.processor : null;
    const warnHtmlMessage = isBoolean$1(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
    const escapeParameter = !!options.escapeParameter;
    const messageCompiler = isFunction$2(options.messageCompiler) ? options.messageCompiler : _compiler;
    const messageResolver = isFunction$2(options.messageResolver) ? options.messageResolver : _resolver || resolveWithKeyValue;
    const localeFallbacker = isFunction$2(options.localeFallbacker) ? options.localeFallbacker : _fallbacker || fallbackWithSimple;
    const fallbackContext = isObject$2(options.fallbackContext) ? options.fallbackContext : void 0;
    const internalOptions = options;
    const __datetimeFormatters = isObject$2(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : /* @__PURE__ */ new Map();
    const __numberFormatters = isObject$2(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : /* @__PURE__ */ new Map();
    const __meta = isObject$2(internalOptions.__meta) ? internalOptions.__meta : {};
    _cid++;
    const context = {
      version: version2,
      cid: _cid,
      locale: locale2,
      fallbackLocale,
      messages,
      modifiers,
      pluralRules,
      missing,
      missingWarn,
      fallbackWarn,
      fallbackFormat,
      unresolving,
      postTranslation,
      processor,
      warnHtmlMessage,
      escapeParameter,
      messageCompiler,
      messageResolver,
      localeFallbacker,
      fallbackContext,
      onWarn,
      __meta
    };
    {
      context.datetimeFormats = datetimeFormats;
      context.numberFormats = numberFormats;
      context.__datetimeFormatters = __datetimeFormatters;
      context.__numberFormatters = __numberFormatters;
    }
    if (__INTLIFY_PROD_DEVTOOLS__) {
      initI18nDevTools(context, version2, __meta);
    }
    return context;
  }
  function handleMissing(context, key, locale2, missingWarn, type) {
    const { missing, onWarn } = context;
    if (missing !== null) {
      const ret = missing(context, locale2, key, type);
      return isString$2(ret) ? ret : key;
    } else {
      return key;
    }
  }
  function updateFallbackLocale(ctx, locale2, fallback) {
    const context = ctx;
    context.__localeChainCache = /* @__PURE__ */ new Map();
    ctx.localeFallbacker(ctx, fallback, locale2);
  }
  function isAlmostSameLocale(locale2, compareLocale) {
    if (locale2 === compareLocale)
      return false;
    return locale2.split("-")[0] === compareLocale.split("-")[0];
  }
  function isImplicitFallback(targetLocale, locales) {
    const index = locales.indexOf(targetLocale);
    if (index === -1) {
      return false;
    }
    for (let i2 = index + 1; i2 < locales.length; i2++) {
      if (isAlmostSameLocale(targetLocale, locales[i2])) {
        return true;
      }
    }
    return false;
  }
  function datetime(context, ...args) {
    const { datetimeFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
    const { __datetimeFormatters } = context;
    const [key, value, options, overrides] = parseDateTimeArgs(...args);
    const missingWarn = isBoolean$1(options.missingWarn) ? options.missingWarn : context.missingWarn;
    isBoolean$1(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
    const part = !!options.part;
    const locale2 = getLocale(context, options);
    const locales = localeFallbacker(
      context,
      // eslint-disable-line @typescript-eslint/no-explicit-any
      fallbackLocale,
      locale2
    );
    if (!isString$2(key) || key === "") {
      return new Intl.DateTimeFormat(locale2, overrides).format(value);
    }
    let datetimeFormat = {};
    let targetLocale;
    let format2 = null;
    const type = "datetime format";
    for (let i2 = 0; i2 < locales.length; i2++) {
      targetLocale = locales[i2];
      datetimeFormat = datetimeFormats[targetLocale] || {};
      format2 = datetimeFormat[key];
      if (isPlainObject$3(format2))
        break;
      handleMissing(context, key, targetLocale, missingWarn, type);
    }
    if (!isPlainObject$3(format2) || !isString$2(targetLocale)) {
      return unresolving ? NOT_REOSLVED : key;
    }
    let id = `${targetLocale}__${key}`;
    if (!isEmptyObject(overrides)) {
      id = `${id}__${JSON.stringify(overrides)}`;
    }
    let formatter = __datetimeFormatters.get(id);
    if (!formatter) {
      formatter = new Intl.DateTimeFormat(targetLocale, assign$2({}, format2, overrides));
      __datetimeFormatters.set(id, formatter);
    }
    return !part ? formatter.format(value) : formatter.formatToParts(value);
  }
  const DATETIME_FORMAT_OPTIONS_KEYS = [
    "localeMatcher",
    "weekday",
    "era",
    "year",
    "month",
    "day",
    "hour",
    "minute",
    "second",
    "timeZoneName",
    "formatMatcher",
    "hour12",
    "timeZone",
    "dateStyle",
    "timeStyle",
    "calendar",
    "dayPeriod",
    "numberingSystem",
    "hourCycle",
    "fractionalSecondDigits"
  ];
  function parseDateTimeArgs(...args) {
    const [arg1, arg2, arg3, arg4] = args;
    const options = {};
    let overrides = {};
    let value;
    if (isString$2(arg1)) {
      const matches2 = arg1.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
      if (!matches2) {
        throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
      }
      const dateTime = matches2[3] ? matches2[3].trim().startsWith("T") ? `${matches2[1].trim()}${matches2[3].trim()}` : `${matches2[1].trim()}T${matches2[3].trim()}` : matches2[1].trim();
      value = new Date(dateTime);
      try {
        value.toISOString();
      } catch {
        throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
      }
    } else if (isDate$2(arg1)) {
      if (isNaN(arg1.getTime())) {
        throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);
      }
      value = arg1;
    } else if (isNumber$1(arg1)) {
      value = arg1;
    } else {
      throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
    }
    if (isString$2(arg2)) {
      options.key = arg2;
    } else if (isPlainObject$3(arg2)) {
      Object.keys(arg2).forEach((key) => {
        if (DATETIME_FORMAT_OPTIONS_KEYS.includes(key)) {
          overrides[key] = arg2[key];
        } else {
          options[key] = arg2[key];
        }
      });
    }
    if (isString$2(arg3)) {
      options.locale = arg3;
    } else if (isPlainObject$3(arg3)) {
      overrides = arg3;
    }
    if (isPlainObject$3(arg4)) {
      overrides = arg4;
    }
    return [options.key || "", value, options, overrides];
  }
  function clearDateTimeFormat(ctx, locale2, format2) {
    const context = ctx;
    for (const key in format2) {
      const id = `${locale2}__${key}`;
      if (!context.__datetimeFormatters.has(id)) {
        continue;
      }
      context.__datetimeFormatters.delete(id);
    }
  }
  function number(context, ...args) {
    const { numberFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
    const { __numberFormatters } = context;
    const [key, value, options, overrides] = parseNumberArgs(...args);
    const missingWarn = isBoolean$1(options.missingWarn) ? options.missingWarn : context.missingWarn;
    isBoolean$1(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
    const part = !!options.part;
    const locale2 = getLocale(context, options);
    const locales = localeFallbacker(
      context,
      // eslint-disable-line @typescript-eslint/no-explicit-any
      fallbackLocale,
      locale2
    );
    if (!isString$2(key) || key === "") {
      return new Intl.NumberFormat(locale2, overrides).format(value);
    }
    let numberFormat = {};
    let targetLocale;
    let format2 = null;
    const type = "number format";
    for (let i2 = 0; i2 < locales.length; i2++) {
      targetLocale = locales[i2];
      numberFormat = numberFormats[targetLocale] || {};
      format2 = numberFormat[key];
      if (isPlainObject$3(format2))
        break;
      handleMissing(context, key, targetLocale, missingWarn, type);
    }
    if (!isPlainObject$3(format2) || !isString$2(targetLocale)) {
      return unresolving ? NOT_REOSLVED : key;
    }
    let id = `${targetLocale}__${key}`;
    if (!isEmptyObject(overrides)) {
      id = `${id}__${JSON.stringify(overrides)}`;
    }
    let formatter = __numberFormatters.get(id);
    if (!formatter) {
      formatter = new Intl.NumberFormat(targetLocale, assign$2({}, format2, overrides));
      __numberFormatters.set(id, formatter);
    }
    return !part ? formatter.format(value) : formatter.formatToParts(value);
  }
  const NUMBER_FORMAT_OPTIONS_KEYS = [
    "localeMatcher",
    "style",
    "currency",
    "currencyDisplay",
    "currencySign",
    "useGrouping",
    "minimumIntegerDigits",
    "minimumFractionDigits",
    "maximumFractionDigits",
    "minimumSignificantDigits",
    "maximumSignificantDigits",
    "compactDisplay",
    "notation",
    "signDisplay",
    "unit",
    "unitDisplay",
    "roundingMode",
    "roundingPriority",
    "roundingIncrement",
    "trailingZeroDisplay"
  ];
  function parseNumberArgs(...args) {
    const [arg1, arg2, arg3, arg4] = args;
    const options = {};
    let overrides = {};
    if (!isNumber$1(arg1)) {
      throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
    }
    const value = arg1;
    if (isString$2(arg2)) {
      options.key = arg2;
    } else if (isPlainObject$3(arg2)) {
      Object.keys(arg2).forEach((key) => {
        if (NUMBER_FORMAT_OPTIONS_KEYS.includes(key)) {
          overrides[key] = arg2[key];
        } else {
          options[key] = arg2[key];
        }
      });
    }
    if (isString$2(arg3)) {
      options.locale = arg3;
    } else if (isPlainObject$3(arg3)) {
      overrides = arg3;
    }
    if (isPlainObject$3(arg4)) {
      overrides = arg4;
    }
    return [options.key || "", value, options, overrides];
  }
  function clearNumberFormat(ctx, locale2, format2) {
    const context = ctx;
    for (const key in format2) {
      const id = `${locale2}__${key}`;
      if (!context.__numberFormatters.has(id)) {
        continue;
      }
      context.__numberFormatters.delete(id);
    }
  }
  const DEFAULT_MODIFIER = (str) => str;
  const DEFAULT_MESSAGE = (ctx) => "";
  const DEFAULT_MESSAGE_DATA_TYPE = "text";
  const DEFAULT_NORMALIZE = (values) => values.length === 0 ? "" : join(values);
  const DEFAULT_INTERPOLATE = toDisplayString$1;
  function pluralDefault(choice, choicesLength) {
    choice = Math.abs(choice);
    if (choicesLength === 2) {
      return choice ? choice > 1 ? 1 : 0 : 1;
    }
    return choice ? Math.min(choice, 2) : 0;
  }
  function getPluralIndex(options) {
    const index = isNumber$1(options.pluralIndex) ? options.pluralIndex : -1;
    return options.named && (isNumber$1(options.named.count) || isNumber$1(options.named.n)) ? isNumber$1(options.named.count) ? options.named.count : isNumber$1(options.named.n) ? options.named.n : index : index;
  }
  function normalizeNamed(pluralIndex, props) {
    if (!props.count) {
      props.count = pluralIndex;
    }
    if (!props.n) {
      props.n = pluralIndex;
    }
  }
  function createMessageContext(options = {}) {
    const locale2 = options.locale;
    const pluralIndex = getPluralIndex(options);
    const pluralRule = isObject$2(options.pluralRules) && isString$2(locale2) && isFunction$2(options.pluralRules[locale2]) ? options.pluralRules[locale2] : pluralDefault;
    const orgPluralRule = isObject$2(options.pluralRules) && isString$2(locale2) && isFunction$2(options.pluralRules[locale2]) ? pluralDefault : void 0;
    const plural = (messages) => {
      return messages[pluralRule(pluralIndex, messages.length, orgPluralRule)];
    };
    const _list = options.list || [];
    const list = (index) => _list[index];
    const _named = options.named || {};
    isNumber$1(options.pluralIndex) && normalizeNamed(pluralIndex, _named);
    const named = (key) => _named[key];
    function message(key, useLinked) {
      const msg = isFunction$2(options.messages) ? options.messages(key, !!useLinked) : isObject$2(options.messages) ? options.messages[key] : false;
      return !msg ? options.parent ? options.parent.message(key) : DEFAULT_MESSAGE : msg;
    }
    const _modifier = (name) => options.modifiers ? options.modifiers[name] : DEFAULT_MODIFIER;
    const normalize = isPlainObject$3(options.processor) && isFunction$2(options.processor.normalize) ? options.processor.normalize : DEFAULT_NORMALIZE;
    const interpolate = isPlainObject$3(options.processor) && isFunction$2(options.processor.interpolate) ? options.processor.interpolate : DEFAULT_INTERPOLATE;
    const type = isPlainObject$3(options.processor) && isString$2(options.processor.type) ? options.processor.type : DEFAULT_MESSAGE_DATA_TYPE;
    const linked = (key, ...args) => {
      const [arg1, arg2] = args;
      let type2 = "text";
      let modifier = "";
      if (args.length === 1) {
        if (isObject$2(arg1)) {
          modifier = arg1.modifier || modifier;
          type2 = arg1.type || type2;
        } else if (isString$2(arg1)) {
          modifier = arg1 || modifier;
        }
      } else if (args.length === 2) {
        if (isString$2(arg1)) {
          modifier = arg1 || modifier;
        }
        if (isString$2(arg2)) {
          type2 = arg2 || type2;
        }
      }
      const ret = message(key, true)(ctx);
      const msg = (
        // The message in vnode resolved with linked are returned as an array by processor.nomalize
        type2 === "vnode" && isArray$3(ret) && modifier ? ret[0] : ret
      );
      return modifier ? _modifier(modifier)(msg, type2) : msg;
    };
    const ctx = {
      [
        "list"
        /* HelperNameMap.LIST */
      ]: list,
      [
        "named"
        /* HelperNameMap.NAMED */
      ]: named,
      [
        "plural"
        /* HelperNameMap.PLURAL */
      ]: plural,
      [
        "linked"
        /* HelperNameMap.LINKED */
      ]: linked,
      [
        "message"
        /* HelperNameMap.MESSAGE */
      ]: message,
      [
        "type"
        /* HelperNameMap.TYPE */
      ]: type,
      [
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      ]: interpolate,
      [
        "normalize"
        /* HelperNameMap.NORMALIZE */
      ]: normalize,
      [
        "values"
        /* HelperNameMap.VALUES */
      ]: assign$2({}, _list, _named)
    };
    return ctx;
  }
  const NOOP_MESSAGE_FUNCTION = () => "";
  const isMessageFunction = (val) => isFunction$2(val);
  function translate(context, ...args) {
    const { fallbackFormat, postTranslation, unresolving, messageCompiler, fallbackLocale, messages } = context;
    const [key, options] = parseTranslateArgs(...args);
    const missingWarn = isBoolean$1(options.missingWarn) ? options.missingWarn : context.missingWarn;
    const fallbackWarn = isBoolean$1(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
    const escapeParameter = isBoolean$1(options.escapeParameter) ? options.escapeParameter : context.escapeParameter;
    const resolvedMessage = !!options.resolvedMessage;
    const defaultMsgOrKey = isString$2(options.default) || isBoolean$1(options.default) ? !isBoolean$1(options.default) ? options.default : !messageCompiler ? () => key : key : fallbackFormat ? !messageCompiler ? () => key : key : null;
    const enableDefaultMsg = fallbackFormat || defaultMsgOrKey != null && (isString$2(defaultMsgOrKey) || isFunction$2(defaultMsgOrKey));
    const locale2 = getLocale(context, options);
    escapeParameter && escapeParams(options);
    let [formatScope, targetLocale, message] = !resolvedMessage ? resolveMessageFormat(context, key, locale2, fallbackLocale, fallbackWarn, missingWarn) : [
      key,
      locale2,
      messages[locale2] || {}
    ];
    let format2 = formatScope;
    let cacheBaseKey = key;
    if (!resolvedMessage && !(isString$2(format2) || isMessageAST(format2) || isMessageFunction(format2))) {
      if (enableDefaultMsg) {
        format2 = defaultMsgOrKey;
        cacheBaseKey = format2;
      }
    }
    if (!resolvedMessage && (!(isString$2(format2) || isMessageAST(format2) || isMessageFunction(format2)) || !isString$2(targetLocale))) {
      return unresolving ? NOT_REOSLVED : key;
    }
    let occurred = false;
    const onError = () => {
      occurred = true;
    };
    const msg = !isMessageFunction(format2) ? compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) : format2;
    if (occurred) {
      return format2;
    }
    const ctxOptions = getMessageContextOptions(context, targetLocale, message, options);
    const msgContext = createMessageContext(ctxOptions);
    const messaged = evaluateMessage(context, msg, msgContext);
    const ret = postTranslation ? postTranslation(messaged, key) : messaged;
    if (__INTLIFY_PROD_DEVTOOLS__) {
      const payloads = {
        timestamp: Date.now(),
        key: isString$2(key) ? key : isMessageFunction(format2) ? format2.key : "",
        locale: targetLocale || (isMessageFunction(format2) ? format2.locale : ""),
        format: isString$2(format2) ? format2 : isMessageFunction(format2) ? format2.source : "",
        message: ret
      };
      payloads.meta = assign$2({}, context.__meta, /* @__PURE__ */ getAdditionalMeta() || {});
      translateDevTools(payloads);
    }
    return ret;
  }
  function escapeParams(options) {
    if (isArray$3(options.list)) {
      options.list = options.list.map((item) => isString$2(item) ? escapeHtml(item) : item);
    } else if (isObject$2(options.named)) {
      Object.keys(options.named).forEach((key) => {
        if (isString$2(options.named[key])) {
          options.named[key] = escapeHtml(options.named[key]);
        }
      });
    }
  }
  function resolveMessageFormat(context, key, locale2, fallbackLocale, fallbackWarn, missingWarn) {
    const { messages, onWarn, messageResolver: resolveValue2, localeFallbacker } = context;
    const locales = localeFallbacker(context, fallbackLocale, locale2);
    let message = {};
    let targetLocale;
    let format2 = null;
    const type = "translate";
    for (let i2 = 0; i2 < locales.length; i2++) {
      targetLocale = locales[i2];
      message = messages[targetLocale] || {};
      if ((format2 = resolveValue2(message, key)) === null) {
        format2 = message[key];
      }
      if (isString$2(format2) || isMessageAST(format2) || isMessageFunction(format2)) {
        break;
      }
      if (!isImplicitFallback(targetLocale, locales)) {
        const missingRet = handleMissing(
          context,
          // eslint-disable-line @typescript-eslint/no-explicit-any
          key,
          targetLocale,
          missingWarn,
          type
        );
        if (missingRet !== key) {
          format2 = missingRet;
        }
      }
    }
    return [format2, targetLocale, message];
  }
  function compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) {
    const { messageCompiler, warnHtmlMessage } = context;
    if (isMessageFunction(format2)) {
      const msg2 = format2;
      msg2.locale = msg2.locale || targetLocale;
      msg2.key = msg2.key || key;
      return msg2;
    }
    if (messageCompiler == null) {
      const msg2 = () => format2;
      msg2.locale = targetLocale;
      msg2.key = key;
      return msg2;
    }
    const msg = messageCompiler(format2, getCompileContext(context, targetLocale, cacheBaseKey, format2, warnHtmlMessage, onError));
    msg.locale = targetLocale;
    msg.key = key;
    msg.source = format2;
    return msg;
  }
  function evaluateMessage(context, msg, msgCtx) {
    const messaged = msg(msgCtx);
    return messaged;
  }
  function parseTranslateArgs(...args) {
    const [arg1, arg2, arg3] = args;
    const options = {};
    if (!isString$2(arg1) && !isNumber$1(arg1) && !isMessageFunction(arg1) && !isMessageAST(arg1)) {
      throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
    }
    const key = isNumber$1(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;
    if (isNumber$1(arg2)) {
      options.plural = arg2;
    } else if (isString$2(arg2)) {
      options.default = arg2;
    } else if (isPlainObject$3(arg2) && !isEmptyObject(arg2)) {
      options.named = arg2;
    } else if (isArray$3(arg2)) {
      options.list = arg2;
    }
    if (isNumber$1(arg3)) {
      options.plural = arg3;
    } else if (isString$2(arg3)) {
      options.default = arg3;
    } else if (isPlainObject$3(arg3)) {
      assign$2(options, arg3);
    }
    return [key, options];
  }
  function getCompileContext(context, locale2, key, source, warnHtmlMessage, onError) {
    return {
      locale: locale2,
      key,
      warnHtmlMessage,
      onError: (err) => {
        onError && onError(err);
        {
          throw err;
        }
      },
      onCacheKey: (source2) => generateFormatCacheKey(locale2, key, source2)
    };
  }
  function getMessageContextOptions(context, locale2, message, options) {
    const { modifiers, pluralRules, messageResolver: resolveValue2, fallbackLocale, fallbackWarn, missingWarn, fallbackContext } = context;
    const resolveMessage = (key, useLinked) => {
      let val = resolveValue2(message, key);
      if (val == null && (fallbackContext || useLinked)) {
        const [, , message2] = resolveMessageFormat(
          fallbackContext || context,
          // NOTE: if has fallbackContext, fallback to root, else if use linked, fallback to local context
          key,
          locale2,
          fallbackLocale,
          fallbackWarn,
          missingWarn
        );
        val = resolveValue2(message2, key);
      }
      if (isString$2(val) || isMessageAST(val)) {
        let occurred = false;
        const onError = () => {
          occurred = true;
        };
        const msg = compileMessageFormat(context, key, locale2, val, key, onError);
        return !occurred ? msg : NOOP_MESSAGE_FUNCTION;
      } else if (isMessageFunction(val)) {
        return val;
      } else {
        return NOOP_MESSAGE_FUNCTION;
      }
    };
    const ctxOptions = {
      locale: locale2,
      modifiers,
      pluralRules,
      messages: resolveMessage
    };
    if (context.processor) {
      ctxOptions.processor = context.processor;
    }
    if (options.list) {
      ctxOptions.list = options.list;
    }
    if (options.named) {
      ctxOptions.named = options.named;
    }
    if (isNumber$1(options.plural)) {
      ctxOptions.pluralIndex = options.plural;
    }
    return ctxOptions;
  }
  {
    initFeatureFlags$1();
  }
  /**
  * @vue/shared v3.4.32
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function makeMap(str, expectsLowerCase) {
    const set2 = new Set(str.split(","));
    return expectsLowerCase ? (val) => set2.has(val.toLowerCase()) : (val) => set2.has(val);
  }
  const EMPTY_OBJ = {};
  const EMPTY_ARR = [];
  const NOOP = () => {
  };
  const NO = () => false;
  const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
  (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
  const isModelListener = (key) => key.startsWith("onUpdate:");
  const extend$1 = Object.assign;
  const remove = (arr, el) => {
    const i2 = arr.indexOf(el);
    if (i2 > -1) {
      arr.splice(i2, 1);
    }
  };
  const hasOwnProperty$2 = Object.prototype.hasOwnProperty;
  const hasOwn = (val, key) => hasOwnProperty$2.call(val, key);
  const isArray$2 = Array.isArray;
  const isMap = (val) => toTypeString(val) === "[object Map]";
  const isSet = (val) => toTypeString(val) === "[object Set]";
  const isDate$1 = (val) => toTypeString(val) === "[object Date]";
  const isRegExp$1 = (val) => toTypeString(val) === "[object RegExp]";
  const isFunction$1 = (val) => typeof val === "function";
  const isString$1 = (val) => typeof val === "string";
  const isSymbol = (val) => typeof val === "symbol";
  const isObject$1 = (val) => val !== null && typeof val === "object";
  const isPromise = (val) => {
    return (isObject$1(val) || isFunction$1(val)) && isFunction$1(val.then) && isFunction$1(val.catch);
  };
  const objectToString = Object.prototype.toString;
  const toTypeString = (value) => objectToString.call(value);
  const toRawType = (value) => {
    return toTypeString(value).slice(8, -1);
  };
  const isPlainObject$2 = (val) => toTypeString(val) === "[object Object]";
  const isIntegerKey = (key) => isString$1(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
  const isReservedProp = /* @__PURE__ */ makeMap(
    // the leading comma is intentional so empty string "" is also included
    ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
  );
  const isBuiltInDirective = /* @__PURE__ */ makeMap(
    "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
  );
  const cacheStringFunction = (fn2) => {
    const cache2 = /* @__PURE__ */ Object.create(null);
    return (str) => {
      const hit = cache2[str];
      return hit || (cache2[str] = fn2(str));
    };
  };
  const camelizeRE = /-(\w)/g;
  const camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
  });
  const hyphenateRE = /\B([A-Z])/g;
  const hyphenate = cacheStringFunction(
    (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
  );
  const capitalize = cacheStringFunction((str) => {
    return str.charAt(0).toUpperCase() + str.slice(1);
  });
  const toHandlerKey = cacheStringFunction((str) => {
    const s2 = str ? `on${capitalize(str)}` : ``;
    return s2;
  });
  const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
  const invokeArrayFns = (fns, ...arg) => {
    for (let i2 = 0; i2 < fns.length; i2++) {
      fns[i2](...arg);
    }
  };
  const def = (obj, key, value, writable = false) => {
    Object.defineProperty(obj, key, {
      configurable: true,
      enumerable: false,
      writable,
      value
    });
  };
  const looseToNumber = (val) => {
    const n2 = parseFloat(val);
    return isNaN(n2) ? val : n2;
  };
  const toNumber = (val) => {
    const n2 = isString$1(val) ? Number(val) : NaN;
    return isNaN(n2) ? val : n2;
  };
  let _globalThis;
  const getGlobalThis = () => {
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
  };
  const GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error";
  const isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);
  function normalizeStyle(value) {
    if (isArray$2(value)) {
      const res = {};
      for (let i2 = 0; i2 < value.length; i2++) {
        const item = value[i2];
        const normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle(item);
        if (normalized) {
          for (const key in normalized) {
            res[key] = normalized[key];
          }
        }
      }
      return res;
    } else if (isString$1(value) || isObject$1(value)) {
      return value;
    }
  }
  const listDelimiterRE = /;(?![^(]*\))/g;
  const propertyDelimiterRE = /:([^]+)/;
  const styleCommentRE = /\/\*[^]*?\*\//g;
  function parseStringStyle(cssText) {
    const ret = {};
    cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
      if (item) {
        const tmp = item.split(propertyDelimiterRE);
        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return ret;
  }
  function normalizeClass(value) {
    let res = "";
    if (isString$1(value)) {
      res = value;
    } else if (isArray$2(value)) {
      for (let i2 = 0; i2 < value.length; i2++) {
        const normalized = normalizeClass(value[i2]);
        if (normalized) {
          res += normalized + " ";
        }
      }
    } else if (isObject$1(value)) {
      for (const name in value) {
        if (value[name]) {
          res += name + " ";
        }
      }
    }
    return res.trim();
  }
  function normalizeProps(props) {
    if (!props) return null;
    let { class: klass, style } = props;
    if (klass && !isString$1(klass)) {
      props.class = normalizeClass(klass);
    }
    if (style) {
      props.style = normalizeStyle(style);
    }
    return props;
  }
  const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
  const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
  const MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
  const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
  const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
  const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
  const isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);
  const isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
  const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
  const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
  function includeBooleanAttr(value) {
    return !!value || value === "";
  }
  function looseCompareArrays(a2, b2) {
    if (a2.length !== b2.length) return false;
    let equal = true;
    for (let i2 = 0; equal && i2 < a2.length; i2++) {
      equal = looseEqual(a2[i2], b2[i2]);
    }
    return equal;
  }
  function looseEqual(a2, b2) {
    if (a2 === b2) return true;
    let aValidType = isDate$1(a2);
    let bValidType = isDate$1(b2);
    if (aValidType || bValidType) {
      return aValidType && bValidType ? a2.getTime() === b2.getTime() : false;
    }
    aValidType = isSymbol(a2);
    bValidType = isSymbol(b2);
    if (aValidType || bValidType) {
      return a2 === b2;
    }
    aValidType = isArray$2(a2);
    bValidType = isArray$2(b2);
    if (aValidType || bValidType) {
      return aValidType && bValidType ? looseCompareArrays(a2, b2) : false;
    }
    aValidType = isObject$1(a2);
    bValidType = isObject$1(b2);
    if (aValidType || bValidType) {
      if (!aValidType || !bValidType) {
        return false;
      }
      const aKeysCount = Object.keys(a2).length;
      const bKeysCount = Object.keys(b2).length;
      if (aKeysCount !== bKeysCount) {
        return false;
      }
      for (const key in a2) {
        const aHasKey = a2.hasOwnProperty(key);
        const bHasKey = b2.hasOwnProperty(key);
        if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a2[key], b2[key])) {
          return false;
        }
      }
    }
    return String(a2) === String(b2);
  }
  function looseIndexOf(arr, val) {
    return arr.findIndex((item) => looseEqual(item, val));
  }
  const isRef$1 = (val) => {
    return !!(val && val.__v_isRef === true);
  };
  const toDisplayString = (val) => {
    return isString$1(val) ? val : val == null ? "" : isArray$2(val) || isObject$1(val) && (val.toString === objectToString || !isFunction$1(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
  };
  const replacer = (_key, val) => {
    if (isRef$1(val)) {
      return replacer(_key, val.value);
    } else if (isMap(val)) {
      return {
        [`Map(${val.size})`]: [...val.entries()].reduce(
          (entries, [key, val2], i2) => {
            entries[stringifySymbol(key, i2) + " =>"] = val2;
            return entries;
          },
          {}
        )
      };
    } else if (isSet(val)) {
      return {
        [`Set(${val.size})`]: [...val.values()].map((v2) => stringifySymbol(v2))
      };
    } else if (isSymbol(val)) {
      return stringifySymbol(val);
    } else if (isObject$1(val) && !isArray$2(val) && !isPlainObject$2(val)) {
      return String(val);
    }
    return val;
  };
  const stringifySymbol = (v2, i2 = "") => {
    var _a;
    return (
      // Symbol.description in es2019+ so we need to cast here to pass
      // the lib: es2016 check
      isSymbol(v2) ? `Symbol(${(_a = v2.description) != null ? _a : i2})` : v2
    );
  };
  /**
  * @vue/reactivity v3.4.32
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  let activeEffectScope;
  class EffectScope {
    constructor(detached = false) {
      this.detached = detached;
      this._active = true;
      this.effects = [];
      this.cleanups = [];
      this.parent = activeEffectScope;
      if (!detached && activeEffectScope) {
        this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
          this
        ) - 1;
      }
    }
    get active() {
      return this._active;
    }
    run(fn2) {
      if (this._active) {
        const currentEffectScope = activeEffectScope;
        try {
          activeEffectScope = this;
          return fn2();
        } finally {
          activeEffectScope = currentEffectScope;
        }
      }
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    on() {
      activeEffectScope = this;
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    off() {
      activeEffectScope = this.parent;
    }
    stop(fromParent) {
      if (this._active) {
        let i2, l2;
        for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
          this.effects[i2].stop();
        }
        for (i2 = 0, l2 = this.cleanups.length; i2 < l2; i2++) {
          this.cleanups[i2]();
        }
        if (this.scopes) {
          for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
            this.scopes[i2].stop(true);
          }
        }
        if (!this.detached && this.parent && !fromParent) {
          const last = this.parent.scopes.pop();
          if (last && last !== this) {
            this.parent.scopes[this.index] = last;
            last.index = this.index;
          }
        }
        this.parent = void 0;
        this._active = false;
      }
    }
  }
  function effectScope(detached) {
    return new EffectScope(detached);
  }
  function recordEffectScope(effect2, scope = activeEffectScope) {
    if (scope && scope.active) {
      scope.effects.push(effect2);
    }
  }
  function getCurrentScope() {
    return activeEffectScope;
  }
  function onScopeDispose(fn2) {
    if (activeEffectScope) {
      activeEffectScope.cleanups.push(fn2);
    }
  }
  let activeEffect;
  class ReactiveEffect {
    constructor(fn2, trigger2, scheduler, scope) {
      this.fn = fn2;
      this.trigger = trigger2;
      this.scheduler = scheduler;
      this.active = true;
      this.deps = [];
      this._dirtyLevel = 4;
      this._trackId = 0;
      this._runnings = 0;
      this._shouldSchedule = false;
      this._depsLength = 0;
      recordEffectScope(this, scope);
    }
    get dirty() {
      if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
        this._dirtyLevel = 1;
        pauseTracking();
        for (let i2 = 0; i2 < this._depsLength; i2++) {
          const dep = this.deps[i2];
          if (dep.computed) {
            triggerComputed(dep.computed);
            if (this._dirtyLevel >= 4) {
              break;
            }
          }
        }
        if (this._dirtyLevel === 1) {
          this._dirtyLevel = 0;
        }
        resetTracking();
      }
      return this._dirtyLevel >= 4;
    }
    set dirty(v2) {
      this._dirtyLevel = v2 ? 4 : 0;
    }
    run() {
      this._dirtyLevel = 0;
      if (!this.active) {
        return this.fn();
      }
      let lastShouldTrack = shouldTrack;
      let lastEffect = activeEffect;
      try {
        shouldTrack = true;
        activeEffect = this;
        this._runnings++;
        preCleanupEffect(this);
        return this.fn();
      } finally {
        postCleanupEffect(this);
        this._runnings--;
        activeEffect = lastEffect;
        shouldTrack = lastShouldTrack;
      }
    }
    stop() {
      if (this.active) {
        preCleanupEffect(this);
        postCleanupEffect(this);
        this.onStop && this.onStop();
        this.active = false;
      }
    }
  }
  function triggerComputed(computed2) {
    return computed2.value;
  }
  function preCleanupEffect(effect2) {
    effect2._trackId++;
    effect2._depsLength = 0;
  }
  function postCleanupEffect(effect2) {
    if (effect2.deps.length > effect2._depsLength) {
      for (let i2 = effect2._depsLength; i2 < effect2.deps.length; i2++) {
        cleanupDepEffect(effect2.deps[i2], effect2);
      }
      effect2.deps.length = effect2._depsLength;
    }
  }
  function cleanupDepEffect(dep, effect2) {
    const trackId = dep.get(effect2);
    if (trackId !== void 0 && effect2._trackId !== trackId) {
      dep.delete(effect2);
      if (dep.size === 0) {
        dep.cleanup();
      }
    }
  }
  function effect(fn2, options) {
    if (fn2.effect instanceof ReactiveEffect) {
      fn2 = fn2.effect.fn;
    }
    const _effect = new ReactiveEffect(fn2, NOOP, () => {
      if (_effect.dirty) {
        _effect.run();
      }
    });
    if (options) {
      extend$1(_effect, options);
      if (options.scope) recordEffectScope(_effect, options.scope);
    }
    if (!options || !options.lazy) {
      _effect.run();
    }
    const runner = _effect.run.bind(_effect);
    runner.effect = _effect;
    return runner;
  }
  function stop(runner) {
    runner.effect.stop();
  }
  let shouldTrack = true;
  let pauseScheduleStack = 0;
  const trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
  }
  function pauseScheduling() {
    pauseScheduleStack++;
  }
  function resetScheduling() {
    pauseScheduleStack--;
    while (!pauseScheduleStack && queueEffectSchedulers.length) {
      queueEffectSchedulers.shift()();
    }
  }
  function trackEffect(effect2, dep, debuggerEventExtraInfo) {
    if (dep.get(effect2) !== effect2._trackId) {
      dep.set(effect2, effect2._trackId);
      const oldDep = effect2.deps[effect2._depsLength];
      if (oldDep !== dep) {
        if (oldDep) {
          cleanupDepEffect(oldDep, effect2);
        }
        effect2.deps[effect2._depsLength++] = dep;
      } else {
        effect2._depsLength++;
      }
    }
  }
  const queueEffectSchedulers = [];
  function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
    pauseScheduling();
    for (const effect2 of dep.keys()) {
      let tracking;
      if (effect2._dirtyLevel < dirtyLevel && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
        effect2._shouldSchedule || (effect2._shouldSchedule = effect2._dirtyLevel === 0);
        effect2._dirtyLevel = dirtyLevel;
      }
      if (effect2._shouldSchedule && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
        effect2.trigger();
        if ((!effect2._runnings || effect2.allowRecurse) && effect2._dirtyLevel !== 2) {
          effect2._shouldSchedule = false;
          if (effect2.scheduler) {
            queueEffectSchedulers.push(effect2.scheduler);
          }
        }
      }
    }
    resetScheduling();
  }
  const createDep = (cleanup, computed2) => {
    const dep = /* @__PURE__ */ new Map();
    dep.cleanup = cleanup;
    dep.computed = computed2;
    return dep;
  };
  const targetMap = /* @__PURE__ */ new WeakMap();
  const ITERATE_KEY = Symbol("");
  const MAP_KEY_ITERATE_KEY = Symbol("");
  function track(target, type, key) {
    if (shouldTrack && activeEffect) {
      let depsMap = targetMap.get(target);
      if (!depsMap) {
        targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
      }
      let dep = depsMap.get(key);
      if (!dep) {
        depsMap.set(key, dep = createDep(() => depsMap.delete(key)));
      }
      trackEffect(
        activeEffect,
        dep
      );
    }
  }
  function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
      return;
    }
    let deps = [];
    if (type === "clear") {
      deps = [...depsMap.values()];
    } else if (key === "length" && isArray$2(target)) {
      const newLength = Number(newValue);
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || !isSymbol(key2) && key2 >= newLength) {
          deps.push(dep);
        }
      });
    } else {
      if (key !== void 0) {
        deps.push(depsMap.get(key));
      }
      switch (type) {
        case "add":
          if (!isArray$2(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isIntegerKey(key)) {
            deps.push(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!isArray$2(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
    pauseScheduling();
    for (const dep of deps) {
      if (dep) {
        triggerEffects(
          dep,
          4
        );
      }
    }
    resetScheduling();
  }
  function getDepFromReactive(object, key) {
    const depsMap = targetMap.get(object);
    return depsMap && depsMap.get(key);
  }
  const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
  const builtInSymbols = new Set(
    /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
  );
  const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
  function createArrayInstrumentations() {
    const instrumentations = {};
    ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
      instrumentations[key] = function(...args) {
        const arr = toRaw(this);
        for (let i2 = 0, l2 = this.length; i2 < l2; i2++) {
          track(arr, "get", i2 + "");
        }
        const res = arr[key](...args);
        if (res === -1 || res === false) {
          return arr[key](...args.map(toRaw));
        } else {
          return res;
        }
      };
    });
    ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
      instrumentations[key] = function(...args) {
        pauseTracking();
        pauseScheduling();
        const res = toRaw(this)[key].apply(this, args);
        resetScheduling();
        resetTracking();
        return res;
      };
    });
    return instrumentations;
  }
  function hasOwnProperty$1(key) {
    if (!isSymbol(key)) key = String(key);
    const obj = toRaw(this);
    track(obj, "has", key);
    return obj.hasOwnProperty(key);
  }
  class BaseReactiveHandler {
    constructor(_isReadonly = false, _isShallow = false) {
      this._isReadonly = _isReadonly;
      this._isShallow = _isShallow;
    }
    get(target, key, receiver) {
      const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_isShallow") {
        return isShallow2;
      } else if (key === "__v_raw") {
        if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
        // this means the reciever is a user proxy of the reactive proxy
        Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
          return target;
        }
        return;
      }
      const targetIsArray = isArray$2(target);
      if (!isReadonly2) {
        if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
          return Reflect.get(arrayInstrumentations, key, receiver);
        }
        if (key === "hasOwnProperty") {
          return hasOwnProperty$1;
        }
      }
      const res = Reflect.get(target, key, receiver);
      if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
        return res;
      }
      if (!isReadonly2) {
        track(target, "get", key);
      }
      if (isShallow2) {
        return res;
      }
      if (isRef(res)) {
        return targetIsArray && isIntegerKey(key) ? res : res.value;
      }
      if (isObject$1(res)) {
        return isReadonly2 ? readonly(res) : reactive(res);
      }
      return res;
    }
  }
  class MutableReactiveHandler extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
      super(false, isShallow2);
    }
    set(target, key, value, receiver) {
      let oldValue = target[key];
      if (!this._isShallow) {
        const isOldValueReadonly = isReadonly(oldValue);
        if (!isShallow(value) && !isReadonly(value)) {
          oldValue = toRaw(oldValue);
          value = toRaw(value);
        }
        if (!isArray$2(target) && isRef(oldValue) && !isRef(value)) {
          if (isOldValueReadonly) {
            return false;
          } else {
            oldValue.value = value;
            return true;
          }
        }
      }
      const hadKey = isArray$2(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
      const result = Reflect.set(target, key, value, receiver);
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value);
        }
      }
      return result;
    }
    deleteProperty(target, key) {
      const hadKey = hasOwn(target, key);
      target[key];
      const result = Reflect.deleteProperty(target, key);
      if (result && hadKey) {
        trigger(target, "delete", key, void 0);
      }
      return result;
    }
    has(target, key) {
      const result = Reflect.has(target, key);
      if (!isSymbol(key) || !builtInSymbols.has(key)) {
        track(target, "has", key);
      }
      return result;
    }
    ownKeys(target) {
      track(
        target,
        "iterate",
        isArray$2(target) ? "length" : ITERATE_KEY
      );
      return Reflect.ownKeys(target);
    }
  }
  class ReadonlyReactiveHandler extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
      super(true, isShallow2);
    }
    set(target, key) {
      return true;
    }
    deleteProperty(target, key) {
      return true;
    }
  }
  const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
  const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
  const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(
    true
  );
  const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
  const toShallow = (value) => value;
  const getProto = (v2) => Reflect.getPrototypeOf(v2);
  function get(target, key, isReadonly2 = false, isShallow2 = false) {
    target = target["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly2) {
      if (hasChanged(key, rawKey)) {
        track(rawTarget, "get", key);
      }
      track(rawTarget, "get", rawKey);
    }
    const { has: has2 } = getProto(rawTarget);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    if (has2.call(rawTarget, key)) {
      return wrap(target.get(key));
    } else if (has2.call(rawTarget, rawKey)) {
      return wrap(target.get(rawKey));
    } else if (target !== rawTarget) {
      target.get(key);
    }
  }
  function has(key, isReadonly2 = false) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly2) {
      if (hasChanged(key, rawKey)) {
        track(rawTarget, "has", key);
      }
      track(rawTarget, "has", rawKey);
    }
    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
  }
  function size(target, isReadonly2 = false) {
    target = target["__v_raw"];
    !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
    return Reflect.get(target, "size", target);
  }
  function add(value, _isShallow = false) {
    if (!_isShallow && !isShallow(value) && !isReadonly(value)) {
      value = toRaw(value);
    }
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
      target.add(value);
      trigger(target, "add", value, value);
    }
    return this;
  }
  function set(key, value, _isShallow = false) {
    if (!_isShallow && !isShallow(value) && !isReadonly(value)) {
      value = toRaw(value);
    }
    const target = toRaw(this);
    const { has: has2, get: get2 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    }
    const oldValue = get2.call(target, key);
    target.set(key, value);
    if (!hadKey) {
      trigger(target, "add", key, value);
    } else if (hasChanged(value, oldValue)) {
      trigger(target, "set", key, value);
    }
    return this;
  }
  function deleteEntry(key) {
    const target = toRaw(this);
    const { has: has2, get: get2 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    }
    get2 ? get2.call(target, key) : void 0;
    const result = target.delete(key);
    if (hadKey) {
      trigger(target, "delete", key, void 0);
    }
    return result;
  }
  function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const result = target.clear();
    if (hadItems) {
      trigger(target, "clear", void 0, void 0);
    }
    return result;
  }
  function createForEach(isReadonly2, isShallow2) {
    return function forEach2(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    };
  }
  function createIterableMethod(method, isReadonly2, isShallow2) {
    return function(...args) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const targetIsMap = isMap(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target[method](...args);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(
        rawTarget,
        "iterate",
        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
      );
      return {
        // iterator protocol
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        },
        // iterable protocol
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type) {
    return function(...args) {
      return type === "delete" ? false : type === "clear" ? void 0 : this;
    };
  }
  function createInstrumentations() {
    const mutableInstrumentations2 = {
      get(key) {
        return get(this, key);
      },
      get size() {
        return size(this);
      },
      has,
      add,
      set,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, false)
    };
    const shallowInstrumentations2 = {
      get(key) {
        return get(this, key, false, true);
      },
      get size() {
        return size(this);
      },
      has,
      add(value) {
        return add.call(this, value, true);
      },
      set(key, value) {
        return set.call(this, key, value, true);
      },
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, true)
    };
    const readonlyInstrumentations2 = {
      get(key) {
        return get(this, key, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has.call(this, key, true);
      },
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear"),
      forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations2 = {
      get(key) {
        return get(this, key, true, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has.call(this, key, true);
      },
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear"),
      forEach: createForEach(true, true)
    };
    const iteratorMethods = [
      "keys",
      "values",
      "entries",
      Symbol.iterator
    ];
    iteratorMethods.forEach((method) => {
      mutableInstrumentations2[method] = createIterableMethod(method, false, false);
      readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
      shallowInstrumentations2[method] = createIterableMethod(method, false, true);
      shallowReadonlyInstrumentations2[method] = createIterableMethod(
        method,
        true,
        true
      );
    });
    return [
      mutableInstrumentations2,
      readonlyInstrumentations2,
      shallowInstrumentations2,
      shallowReadonlyInstrumentations2
    ];
  }
  const [
    mutableInstrumentations,
    readonlyInstrumentations,
    shallowInstrumentations,
    shallowReadonlyInstrumentations
  ] = /* @__PURE__ */ createInstrumentations();
  function createInstrumentationGetter(isReadonly2, shallow) {
    const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
    return (target, key, receiver) => {
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_raw") {
        return target;
      }
      return Reflect.get(
        hasOwn(instrumentations, key) && key in target ? instrumentations : target,
        key,
        receiver
      );
    };
  }
  const mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, false)
  };
  const shallowCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, true)
  };
  const readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, false)
  };
  const shallowReadonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, true)
  };
  const reactiveMap = /* @__PURE__ */ new WeakMap();
  const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
  const readonlyMap = /* @__PURE__ */ new WeakMap();
  const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
  }
  function reactive(target) {
    if (isReadonly(target)) {
      return target;
    }
    return createReactiveObject(
      target,
      false,
      mutableHandlers,
      mutableCollectionHandlers,
      reactiveMap
    );
  }
  function shallowReactive(target) {
    return createReactiveObject(
      target,
      false,
      shallowReactiveHandlers,
      shallowCollectionHandlers,
      shallowReactiveMap
    );
  }
  function readonly(target) {
    return createReactiveObject(
      target,
      true,
      readonlyHandlers,
      readonlyCollectionHandlers,
      readonlyMap
    );
  }
  function shallowReadonly(target) {
    return createReactiveObject(
      target,
      true,
      shallowReadonlyHandlers,
      shallowReadonlyCollectionHandlers,
      shallowReadonlyMap
    );
  }
  function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject$1(target)) {
      return target;
    }
    if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
      return target;
    }
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    const targetType = getTargetType(target);
    if (targetType === 0) {
      return target;
    }
    const proxy = new Proxy(
      target,
      targetType === 2 ? collectionHandlers : baseHandlers
    );
    proxyMap.set(target, proxy);
    return proxy;
  }
  function isReactive(value) {
    if (isReadonly(value)) {
      return isReactive(value["__v_raw"]);
    }
    return !!(value && value["__v_isReactive"]);
  }
  function isReadonly(value) {
    return !!(value && value["__v_isReadonly"]);
  }
  function isShallow(value) {
    return !!(value && value["__v_isShallow"]);
  }
  function isProxy(value) {
    return value ? !!value["__v_raw"] : false;
  }
  function toRaw(observed) {
    const raw = observed && observed["__v_raw"];
    return raw ? toRaw(raw) : observed;
  }
  function markRaw(value) {
    if (Object.isExtensible(value)) {
      def(value, "__v_skip", true);
    }
    return value;
  }
  const toReactive = (value) => isObject$1(value) ? reactive(value) : value;
  const toReadonly = (value) => isObject$1(value) ? readonly(value) : value;
  class ComputedRefImpl {
    constructor(getter, _setter, isReadonly2, isSSR) {
      this.getter = getter;
      this._setter = _setter;
      this.dep = void 0;
      this.__v_isRef = true;
      this["__v_isReadonly"] = false;
      this.effect = new ReactiveEffect(
        () => getter(this._value),
        () => triggerRefValue(
          this,
          this.effect._dirtyLevel === 2 ? 2 : 3
        )
      );
      this.effect.computed = this;
      this.effect.active = this._cacheable = !isSSR;
      this["__v_isReadonly"] = isReadonly2;
    }
    get value() {
      const self2 = toRaw(this);
      if ((!self2._cacheable || self2.effect.dirty) && hasChanged(self2._value, self2._value = self2.effect.run())) {
        triggerRefValue(self2, 4);
      }
      trackRefValue(self2);
      if (self2.effect._dirtyLevel >= 2) {
        triggerRefValue(self2, 2);
      }
      return self2._value;
    }
    set value(newValue) {
      this._setter(newValue);
    }
    // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
    get _dirty() {
      return this.effect.dirty;
    }
    set _dirty(v2) {
      this.effect.dirty = v2;
    }
    // #endregion
  }
  function computed$1(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    const onlyGetter = isFunction$1(getterOrOptions);
    if (onlyGetter) {
      getter = getterOrOptions;
      setter = NOOP;
    } else {
      getter = getterOrOptions.get;
      setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
    return cRef;
  }
  function trackRefValue(ref2) {
    var _a;
    if (shouldTrack && activeEffect) {
      ref2 = toRaw(ref2);
      trackEffect(
        activeEffect,
        (_a = ref2.dep) != null ? _a : ref2.dep = createDep(
          () => ref2.dep = void 0,
          ref2 instanceof ComputedRefImpl ? ref2 : void 0
        )
      );
    }
  }
  function triggerRefValue(ref2, dirtyLevel = 4, newVal, oldVal) {
    ref2 = toRaw(ref2);
    const dep = ref2.dep;
    if (dep) {
      triggerEffects(
        dep,
        dirtyLevel
      );
    }
  }
  function isRef(r2) {
    return !!(r2 && r2.__v_isRef === true);
  }
  function ref(value) {
    return createRef(value, false);
  }
  function shallowRef(value) {
    return createRef(value, true);
  }
  function createRef(rawValue, shallow) {
    if (isRef(rawValue)) {
      return rawValue;
    }
    return new RefImpl(rawValue, shallow);
  }
  class RefImpl {
    constructor(value, __v_isShallow) {
      this.__v_isShallow = __v_isShallow;
      this.dep = void 0;
      this.__v_isRef = true;
      this._rawValue = __v_isShallow ? value : toRaw(value);
      this._value = __v_isShallow ? value : toReactive(value);
    }
    get value() {
      trackRefValue(this);
      return this._value;
    }
    set value(newVal) {
      const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
      newVal = useDirectValue ? newVal : toRaw(newVal);
      if (hasChanged(newVal, this._rawValue)) {
        this._rawValue;
        this._rawValue = newVal;
        this._value = useDirectValue ? newVal : toReactive(newVal);
        triggerRefValue(this, 4);
      }
    }
  }
  function triggerRef(ref2) {
    triggerRefValue(ref2, 4);
  }
  function unref(ref2) {
    return isRef(ref2) ? ref2.value : ref2;
  }
  function toValue(source) {
    return isFunction$1(source) ? source() : unref(source);
  }
  const shallowUnwrapHandlers = {
    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver) => {
      const oldValue = target[key];
      if (isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      } else {
        return Reflect.set(target, key, value, receiver);
      }
    }
  };
  function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
  }
  class CustomRefImpl {
    constructor(factory) {
      this.dep = void 0;
      this.__v_isRef = true;
      const { get: get2, set: set2 } = factory(
        () => trackRefValue(this),
        () => triggerRefValue(this)
      );
      this._get = get2;
      this._set = set2;
    }
    get value() {
      return this._get();
    }
    set value(newVal) {
      this._set(newVal);
    }
  }
  function customRef(factory) {
    return new CustomRefImpl(factory);
  }
  function toRefs(object) {
    const ret = isArray$2(object) ? new Array(object.length) : {};
    for (const key in object) {
      ret[key] = propertyToRef(object, key);
    }
    return ret;
  }
  class ObjectRefImpl {
    constructor(_object, _key, _defaultValue) {
      this._object = _object;
      this._key = _key;
      this._defaultValue = _defaultValue;
      this.__v_isRef = true;
    }
    get value() {
      const val = this._object[this._key];
      return val === void 0 ? this._defaultValue : val;
    }
    set value(newVal) {
      this._object[this._key] = newVal;
    }
    get dep() {
      return getDepFromReactive(toRaw(this._object), this._key);
    }
  }
  class GetterRefImpl {
    constructor(_getter) {
      this._getter = _getter;
      this.__v_isRef = true;
      this.__v_isReadonly = true;
    }
    get value() {
      return this._getter();
    }
  }
  function toRef(source, key, defaultValue) {
    if (isRef(source)) {
      return source;
    } else if (isFunction$1(source)) {
      return new GetterRefImpl(source);
    } else if (isObject$1(source) && arguments.length > 1) {
      return propertyToRef(source, key, defaultValue);
    } else {
      return ref(source);
    }
  }
  function propertyToRef(source, key, defaultValue) {
    const val = source[key];
    return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
  }
  const TrackOpTypes = {
    "GET": "get",
    "HAS": "has",
    "ITERATE": "iterate"
  };
  const TriggerOpTypes = {
    "SET": "set",
    "ADD": "add",
    "DELETE": "delete",
    "CLEAR": "clear"
  };
  /**
  * @vue/runtime-core v3.4.32
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  const stack$1 = [];
  let isWarning = false;
  function warn$1(msg, ...args) {
    if (isWarning) return;
    isWarning = true;
    pauseTracking();
    const instance = stack$1.length ? stack$1[stack$1.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
      callWithErrorHandling(
        appWarnHandler,
        instance,
        11,
        [
          // eslint-disable-next-line no-restricted-syntax
          msg + args.map((a2) => {
            var _a, _b;
            return (_b = (_a = a2.toString) == null ? void 0 : _a.call(a2)) != null ? _b : JSON.stringify(a2);
          }).join(""),
          instance && instance.proxy,
          trace.map(
            ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
          ).join("\n"),
          trace
        ]
      );
    } else {
      const warnArgs = [`[Vue warn]: ${msg}`, ...args];
      if (trace.length && // avoid spamming console during tests
      true) {
        warnArgs.push(`
`, ...formatTrace(trace));
      }
      console.warn(...warnArgs);
    }
    resetTracking();
    isWarning = false;
  }
  function getComponentTrace() {
    let currentVNode = stack$1[stack$1.length - 1];
    if (!currentVNode) {
      return [];
    }
    const normalizedStack = [];
    while (currentVNode) {
      const last = normalizedStack[0];
      if (last && last.vnode === currentVNode) {
        last.recurseCount++;
      } else {
        normalizedStack.push({
          vnode: currentVNode,
          recurseCount: 0
        });
      }
      const parentInstance = currentVNode.component && currentVNode.component.parent;
      currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
  }
  function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i2) => {
      logs.push(...i2 === 0 ? [] : [`
`], ...formatTraceEntry(entry));
    });
    return logs;
  }
  function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(
      vnode.component,
      vnode.type,
      isRoot
    )}`;
    const close = `>` + postfix;
    return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
  }
  function formatProps(props) {
    const res = [];
    const keys = Object.keys(props);
    keys.slice(0, 3).forEach((key) => {
      res.push(...formatProp(key, props[key]));
    });
    if (keys.length > 3) {
      res.push(` ...`);
    }
    return res;
  }
  function formatProp(key, value, raw) {
    if (isString$1(value)) {
      value = JSON.stringify(value);
      return raw ? value : [`${key}=${value}`];
    } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
      return raw ? value : [`${key}=${value}`];
    } else if (isRef(value)) {
      value = formatProp(key, toRaw(value.value), true);
      return raw ? value : [`${key}=Ref<`, value, `>`];
    } else if (isFunction$1(value)) {
      return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
    } else {
      value = toRaw(value);
      return raw ? value : [`${key}=`, value];
    }
  }
  function assertNumber(val, type) {
    return;
  }
  const ErrorCodes = {
    "SETUP_FUNCTION": 0,
    "0": "SETUP_FUNCTION",
    "RENDER_FUNCTION": 1,
    "1": "RENDER_FUNCTION",
    "WATCH_GETTER": 2,
    "2": "WATCH_GETTER",
    "WATCH_CALLBACK": 3,
    "3": "WATCH_CALLBACK",
    "WATCH_CLEANUP": 4,
    "4": "WATCH_CLEANUP",
    "NATIVE_EVENT_HANDLER": 5,
    "5": "NATIVE_EVENT_HANDLER",
    "COMPONENT_EVENT_HANDLER": 6,
    "6": "COMPONENT_EVENT_HANDLER",
    "VNODE_HOOK": 7,
    "7": "VNODE_HOOK",
    "DIRECTIVE_HOOK": 8,
    "8": "DIRECTIVE_HOOK",
    "TRANSITION_HOOK": 9,
    "9": "TRANSITION_HOOK",
    "APP_ERROR_HANDLER": 10,
    "10": "APP_ERROR_HANDLER",
    "APP_WARN_HANDLER": 11,
    "11": "APP_WARN_HANDLER",
    "FUNCTION_REF": 12,
    "12": "FUNCTION_REF",
    "ASYNC_COMPONENT_LOADER": 13,
    "13": "ASYNC_COMPONENT_LOADER",
    "SCHEDULER": 14,
    "14": "SCHEDULER",
    "COMPONENT_UPDATE": 15,
    "15": "COMPONENT_UPDATE"
  };
  const ErrorTypeStrings$1 = {
    ["sp"]: "serverPrefetch hook",
    ["bc"]: "beforeCreate hook",
    ["c"]: "created hook",
    ["bm"]: "beforeMount hook",
    ["m"]: "mounted hook",
    ["bu"]: "beforeUpdate hook",
    ["u"]: "updated",
    ["bum"]: "beforeUnmount hook",
    ["um"]: "unmounted hook",
    ["a"]: "activated hook",
    ["da"]: "deactivated hook",
    ["ec"]: "errorCaptured hook",
    ["rtc"]: "renderTracked hook",
    ["rtg"]: "renderTriggered hook",
    [0]: "setup function",
    [1]: "render function",
    [2]: "watcher getter",
    [3]: "watcher callback",
    [4]: "watcher cleanup function",
    [5]: "native event handler",
    [6]: "component event handler",
    [7]: "vnode hook",
    [8]: "directive hook",
    [9]: "transition hook",
    [10]: "app errorHandler",
    [11]: "app warnHandler",
    [12]: "ref function",
    [13]: "async component loader",
    [14]: "scheduler flush",
    [15]: "component update"
  };
  function callWithErrorHandling(fn2, instance, type, args) {
    try {
      return args ? fn2(...args) : fn2();
    } catch (err) {
      handleError(err, instance, type);
    }
  }
  function callWithAsyncErrorHandling(fn2, instance, type, args) {
    if (isFunction$1(fn2)) {
      const res = callWithErrorHandling(fn2, instance, type, args);
      if (res && isPromise(res)) {
        res.catch((err) => {
          handleError(err, instance, type);
        });
      }
      return res;
    }
    if (isArray$2(fn2)) {
      const values = [];
      for (let i2 = 0; i2 < fn2.length; i2++) {
        values.push(callWithAsyncErrorHandling(fn2[i2], instance, type, args));
      }
      return values;
    }
  }
  function handleError(err, instance, type, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    if (instance) {
      let cur = instance.parent;
      const exposedInstance = instance.proxy;
      const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
      while (cur) {
        const errorCapturedHooks = cur.ec;
        if (errorCapturedHooks) {
          for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
            if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
              return;
            }
          }
        }
        cur = cur.parent;
      }
      const appErrorHandler = instance.appContext.config.errorHandler;
      if (appErrorHandler) {
        pauseTracking();
        callWithErrorHandling(
          appErrorHandler,
          null,
          10,
          [err, exposedInstance, errorInfo]
        );
        resetTracking();
        return;
      }
    }
    logError(err, type, contextVNode, throwInDev);
  }
  function logError(err, type, contextVNode, throwInDev = true) {
    {
      console.error(err);
    }
  }
  let isFlushing = false;
  let isFlushPending = false;
  const queue = [];
  let flushIndex = 0;
  const pendingPostFlushCbs = [];
  let activePostFlushCbs = null;
  let postFlushIndex = 0;
  const resolvedPromise = /* @__PURE__ */ Promise.resolve();
  let currentFlushPromise = null;
  function nextTick(fn2) {
    const p2 = currentFlushPromise || resolvedPromise;
    return fn2 ? p2.then(this ? fn2.bind(this) : fn2) : p2;
  }
  function findInsertionIndex$1(id) {
    let start = flushIndex + 1;
    let end = queue.length;
    while (start < end) {
      const middle = start + end >>> 1;
      const middleJob = queue[middle];
      const middleJobId = getId(middleJob);
      if (middleJobId < id || middleJobId === id && middleJob.pre) {
        start = middle + 1;
      } else {
        end = middle;
      }
    }
    return start;
  }
  function queueJob(job) {
    if (!queue.length || !queue.includes(
      job,
      isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
    )) {
      if (job.id == null) {
        queue.push(job);
      } else {
        queue.splice(findInsertionIndex$1(job.id), 0, job);
      }
      queueFlush();
    }
  }
  function queueFlush() {
    if (!isFlushing && !isFlushPending) {
      isFlushPending = true;
      currentFlushPromise = resolvedPromise.then(flushJobs);
    }
  }
  function invalidateJob(job) {
    const i2 = queue.indexOf(job);
    if (i2 > flushIndex) {
      queue.splice(i2, 1);
    }
  }
  function queuePostFlushCb(cb) {
    if (!isArray$2(cb)) {
      if (!activePostFlushCbs || !activePostFlushCbs.includes(
        cb,
        cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
      )) {
        pendingPostFlushCbs.push(cb);
      }
    } else {
      pendingPostFlushCbs.push(...cb);
    }
    queueFlush();
  }
  function flushPreFlushCbs(instance, seen2, i2 = isFlushing ? flushIndex + 1 : 0) {
    for (; i2 < queue.length; i2++) {
      const cb = queue[i2];
      if (cb && cb.pre) {
        if (instance && cb.id !== instance.uid) {
          continue;
        }
        queue.splice(i2, 1);
        i2--;
        cb();
      }
    }
  }
  function flushPostFlushCbs(seen2) {
    if (pendingPostFlushCbs.length) {
      const deduped = [...new Set(pendingPostFlushCbs)].sort(
        (a2, b2) => getId(a2) - getId(b2)
      );
      pendingPostFlushCbs.length = 0;
      if (activePostFlushCbs) {
        activePostFlushCbs.push(...deduped);
        return;
      }
      activePostFlushCbs = deduped;
      for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
        const cb = activePostFlushCbs[postFlushIndex];
        if (cb.active !== false) cb();
      }
      activePostFlushCbs = null;
      postFlushIndex = 0;
    }
  }
  const getId = (job) => job.id == null ? Infinity : job.id;
  const comparator = (a2, b2) => {
    const diff = getId(a2) - getId(b2);
    if (diff === 0) {
      if (a2.pre && !b2.pre) return -1;
      if (b2.pre && !a2.pre) return 1;
    }
    return diff;
  };
  function flushJobs(seen2) {
    isFlushPending = false;
    isFlushing = true;
    queue.sort(comparator);
    try {
      for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
        const job = queue[flushIndex];
        if (job && job.active !== false) {
          if (false) ;
          callWithErrorHandling(
            job,
            job.i,
            job.i ? 15 : 14
          );
        }
      }
    } finally {
      flushIndex = 0;
      queue.length = 0;
      flushPostFlushCbs();
      isFlushing = false;
      currentFlushPromise = null;
      if (queue.length || pendingPostFlushCbs.length) {
        flushJobs();
      }
    }
  }
  let devtools$1;
  let buffer = [];
  function setDevtoolsHook$1(hook, target) {
    var _a, _b;
    devtools$1 = hook;
    if (devtools$1) {
      devtools$1.enabled = true;
      buffer.forEach(({ event, args }) => devtools$1.emit(event, ...args));
      buffer = [];
    } else if (
      // handle late devtools injection - only do this if we are in an actual
      // browser environment to avoid the timer handle stalling test runner exit
      // (#4815)
      typeof window !== "undefined" && // some envs mock window but not fully
      window.HTMLElement && // also exclude jsdom
      // eslint-disable-next-line no-restricted-syntax
      !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))
    ) {
      const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
      replay.push((newHook) => {
        setDevtoolsHook$1(newHook, target);
      });
      setTimeout(() => {
        if (!devtools$1) {
          target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
          buffer = [];
        }
      }, 3e3);
    } else {
      buffer = [];
    }
  }
  let currentRenderingInstance = null;
  let currentScopeId = null;
  function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev;
  }
  function pushScopeId(id) {
    currentScopeId = id;
  }
  function popScopeId() {
    currentScopeId = null;
  }
  const withScopeId = (_id) => withCtx;
  function withCtx(fn2, ctx = currentRenderingInstance, isNonScopedSlot) {
    if (!ctx) return fn2;
    if (fn2._n) {
      return fn2;
    }
    const renderFnWithContext = (...args) => {
      if (renderFnWithContext._d) {
        setBlockTracking(-1);
      }
      const prevInstance = setCurrentRenderingInstance(ctx);
      let res;
      try {
        res = fn2(...args);
      } finally {
        setCurrentRenderingInstance(prevInstance);
        if (renderFnWithContext._d) {
          setBlockTracking(1);
        }
      }
      return res;
    };
    renderFnWithContext._n = true;
    renderFnWithContext._c = true;
    renderFnWithContext._d = true;
    return renderFnWithContext;
  }
  function withDirectives(vnode, directives) {
    if (currentRenderingInstance === null) {
      return vnode;
    }
    const instance = getComponentPublicInstance(currentRenderingInstance);
    const bindings = vnode.dirs || (vnode.dirs = []);
    for (let i2 = 0; i2 < directives.length; i2++) {
      let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i2];
      if (dir) {
        if (isFunction$1(dir)) {
          dir = {
            mounted: dir,
            updated: dir
          };
        }
        if (dir.deep) {
          traverse(value);
        }
        bindings.push({
          dir,
          instance,
          value,
          oldValue: void 0,
          arg,
          modifiers
        });
      }
    }
    return vnode;
  }
  function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i2 = 0; i2 < bindings.length; i2++) {
      const binding = bindings[i2];
      if (oldBindings) {
        binding.oldValue = oldBindings[i2].value;
      }
      let hook = binding.dir[name];
      if (hook) {
        pauseTracking();
        callWithAsyncErrorHandling(hook, instance, 8, [
          vnode.el,
          binding,
          vnode,
          prevVNode
        ]);
        resetTracking();
      }
    }
  }
  const leaveCbKey = Symbol("_leaveCb");
  const enterCbKey$1 = Symbol("_enterCb");
  function useTransitionState() {
    const state = {
      isMounted: false,
      isLeaving: false,
      isUnmounting: false,
      leavingVNodes: /* @__PURE__ */ new Map()
    };
    onMounted(() => {
      state.isMounted = true;
    });
    onBeforeUnmount(() => {
      state.isUnmounting = true;
    });
    return state;
  }
  const TransitionHookValidator = [Function, Array];
  const BaseTransitionPropsValidators = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    // enter
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    // leave
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    // appear
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  };
  const recursiveGetSubtree = (instance) => {
    const subTree = instance.subTree;
    return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
  };
  const BaseTransitionImpl = {
    name: `BaseTransition`,
    props: BaseTransitionPropsValidators,
    setup(props, { slots }) {
      const instance = getCurrentInstance();
      const state = useTransitionState();
      return () => {
        const children = slots.default && getTransitionRawChildren(slots.default(), true);
        if (!children || !children.length) {
          return;
        }
        let child = children[0];
        if (children.length > 1) {
          for (const c2 of children) {
            if (c2.type !== Comment) {
              child = c2;
              break;
            }
          }
        }
        const rawProps = toRaw(props);
        const { mode } = rawProps;
        if (state.isLeaving) {
          return emptyPlaceholder(child);
        }
        const innerChild = getKeepAliveChild(child);
        if (!innerChild) {
          return emptyPlaceholder(child);
        }
        let enterHooks = resolveTransitionHooks(
          innerChild,
          rawProps,
          state,
          instance,
          // #11061, ensure enterHooks is fresh after clone
          (hooks) => enterHooks = hooks
        );
        setTransitionHooks(innerChild, enterHooks);
        const oldChild = instance.subTree;
        const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
        if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
          const leavingHooks = resolveTransitionHooks(
            oldInnerChild,
            rawProps,
            state,
            instance
          );
          setTransitionHooks(oldInnerChild, leavingHooks);
          if (mode === "out-in" && innerChild.type !== Comment) {
            state.isLeaving = true;
            leavingHooks.afterLeave = () => {
              state.isLeaving = false;
              if (instance.update.active !== false) {
                instance.effect.dirty = true;
                instance.update();
              }
            };
            return emptyPlaceholder(child);
          } else if (mode === "in-out" && innerChild.type !== Comment) {
            leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
              const leavingVNodesCache = getLeavingNodesForType(
                state,
                oldInnerChild
              );
              leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
              el[leaveCbKey] = () => {
                earlyRemove();
                el[leaveCbKey] = void 0;
                delete enterHooks.delayedLeave;
              };
              enterHooks.delayedLeave = delayedLeave;
            };
          }
        }
        return child;
      };
    }
  };
  const BaseTransition = BaseTransitionImpl;
  function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
      leavingVNodesCache = /* @__PURE__ */ Object.create(null);
      leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
  }
  function resolveTransitionHooks(vnode, props, state, instance, postClone) {
    const {
      appear,
      mode,
      persisted = false,
      onBeforeEnter,
      onEnter,
      onAfterEnter,
      onEnterCancelled,
      onBeforeLeave,
      onLeave,
      onAfterLeave,
      onLeaveCancelled,
      onBeforeAppear,
      onAppear,
      onAfterAppear,
      onAppearCancelled
    } = props;
    const key = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook2 = (hook, args) => {
      hook && callWithAsyncErrorHandling(
        hook,
        instance,
        9,
        args
      );
    };
    const callAsyncHook = (hook, args) => {
      const done = args[1];
      callHook2(hook, args);
      if (isArray$2(hook)) {
        if (hook.every((hook2) => hook2.length <= 1)) done();
      } else if (hook.length <= 1) {
        done();
      }
    };
    const hooks = {
      mode,
      persisted,
      beforeEnter(el) {
        let hook = onBeforeEnter;
        if (!state.isMounted) {
          if (appear) {
            hook = onBeforeAppear || onBeforeEnter;
          } else {
            return;
          }
        }
        if (el[leaveCbKey]) {
          el[leaveCbKey](
            true
            /* cancelled */
          );
        }
        const leavingVNode = leavingVNodesCache[key];
        if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
          leavingVNode.el[leaveCbKey]();
        }
        callHook2(hook, [el]);
      },
      enter(el) {
        let hook = onEnter;
        let afterHook = onAfterEnter;
        let cancelHook = onEnterCancelled;
        if (!state.isMounted) {
          if (appear) {
            hook = onAppear || onEnter;
            afterHook = onAfterAppear || onAfterEnter;
            cancelHook = onAppearCancelled || onEnterCancelled;
          } else {
            return;
          }
        }
        let called = false;
        const done = el[enterCbKey$1] = (cancelled) => {
          if (called) return;
          called = true;
          if (cancelled) {
            callHook2(cancelHook, [el]);
          } else {
            callHook2(afterHook, [el]);
          }
          if (hooks.delayedLeave) {
            hooks.delayedLeave();
          }
          el[enterCbKey$1] = void 0;
        };
        if (hook) {
          callAsyncHook(hook, [el, done]);
        } else {
          done();
        }
      },
      leave(el, remove2) {
        const key2 = String(vnode.key);
        if (el[enterCbKey$1]) {
          el[enterCbKey$1](
            true
            /* cancelled */
          );
        }
        if (state.isUnmounting) {
          return remove2();
        }
        callHook2(onBeforeLeave, [el]);
        let called = false;
        const done = el[leaveCbKey] = (cancelled) => {
          if (called) return;
          called = true;
          remove2();
          if (cancelled) {
            callHook2(onLeaveCancelled, [el]);
          } else {
            callHook2(onAfterLeave, [el]);
          }
          el[leaveCbKey] = void 0;
          if (leavingVNodesCache[key2] === vnode) {
            delete leavingVNodesCache[key2];
          }
        };
        leavingVNodesCache[key2] = vnode;
        if (onLeave) {
          callAsyncHook(onLeave, [el, done]);
        } else {
          done();
        }
      },
      clone(vnode2) {
        const hooks2 = resolveTransitionHooks(
          vnode2,
          props,
          state,
          instance,
          postClone
        );
        if (postClone) postClone(hooks2);
        return hooks2;
      }
    };
    return hooks;
  }
  function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
      vnode = cloneVNode(vnode);
      vnode.children = null;
      return vnode;
    }
  }
  function getKeepAliveChild(vnode) {
    if (!isKeepAlive(vnode)) {
      return vnode;
    }
    const { shapeFlag, children } = vnode;
    if (children) {
      if (shapeFlag & 16) {
        return children[0];
      }
      if (shapeFlag & 32 && isFunction$1(children.default)) {
        return children.default();
      }
    }
  }
  function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 && vnode.component) {
      setTransitionHooks(vnode.component.subTree, hooks);
    } else if (vnode.shapeFlag & 128) {
      vnode.ssContent.transition = hooks.clone(vnode.ssContent);
      vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else {
      vnode.transition = hooks;
    }
  }
  function getTransitionRawChildren(children, keepComment = false, parentKey) {
    let ret = [];
    let keyedFragmentCount = 0;
    for (let i2 = 0; i2 < children.length; i2++) {
      let child = children[i2];
      const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i2);
      if (child.type === Fragment) {
        if (child.patchFlag & 128) keyedFragmentCount++;
        ret = ret.concat(
          getTransitionRawChildren(child.children, keepComment, key)
        );
      } else if (keepComment || child.type !== Comment) {
        ret.push(key != null ? cloneVNode(child, { key }) : child);
      }
    }
    if (keyedFragmentCount > 1) {
      for (let i2 = 0; i2 < ret.length; i2++) {
        ret[i2].patchFlag = -2;
      }
    }
    return ret;
  }
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function defineComponent(options, extraOptions) {
    return isFunction$1(options) ? (
      // #8326: extend call and options.name access are considered side-effects
      // by Rollup, so we have to wrap it in a pure-annotated IIFE.
      /* @__PURE__ */ (() => extend$1({ name: options.name }, extraOptions, { setup: options }))()
    ) : options;
  }
  const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function defineAsyncComponent(source) {
    if (isFunction$1(source)) {
      source = { loader: source };
    }
    const {
      loader,
      loadingComponent,
      errorComponent,
      delay = 200,
      timeout,
      // undefined = never times out
      suspensible = true,
      onError: userOnError
    } = source;
    let pendingRequest = null;
    let resolvedComp;
    let retries = 0;
    const retry = () => {
      retries++;
      pendingRequest = null;
      return load();
    };
    const load = () => {
      let thisRequest;
      return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
        err = err instanceof Error ? err : new Error(String(err));
        if (userOnError) {
          return new Promise((resolve2, reject) => {
            const userRetry = () => resolve2(retry());
            const userFail = () => reject(err);
            userOnError(err, userRetry, userFail, retries + 1);
          });
        } else {
          throw err;
        }
      }).then((comp) => {
        if (thisRequest !== pendingRequest && pendingRequest) {
          return pendingRequest;
        }
        if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
          comp = comp.default;
        }
        resolvedComp = comp;
        return comp;
      }));
    };
    return /* @__PURE__ */ defineComponent({
      name: "AsyncComponentWrapper",
      __asyncLoader: load,
      get __asyncResolved() {
        return resolvedComp;
      },
      setup() {
        const instance = currentInstance;
        if (resolvedComp) {
          return () => createInnerComp(resolvedComp, instance);
        }
        const onError = (err) => {
          pendingRequest = null;
          handleError(
            err,
            instance,
            13,
            !errorComponent
          );
        };
        if (suspensible && instance.suspense || isInSSRComponentSetup) {
          return load().then((comp) => {
            return () => createInnerComp(comp, instance);
          }).catch((err) => {
            onError(err);
            return () => errorComponent ? createVNode(errorComponent, {
              error: err
            }) : null;
          });
        }
        const loaded = ref(false);
        const error = ref();
        const delayed = ref(!!delay);
        if (delay) {
          setTimeout(() => {
            delayed.value = false;
          }, delay);
        }
        if (timeout != null) {
          setTimeout(() => {
            if (!loaded.value && !error.value) {
              const err = new Error(
                `Async component timed out after ${timeout}ms.`
              );
              onError(err);
              error.value = err;
            }
          }, timeout);
        }
        load().then(() => {
          loaded.value = true;
          if (instance.parent && isKeepAlive(instance.parent.vnode)) {
            instance.parent.effect.dirty = true;
            queueJob(instance.parent.update);
          }
        }).catch((err) => {
          onError(err);
          error.value = err;
        });
        return () => {
          if (loaded.value && resolvedComp) {
            return createInnerComp(resolvedComp, instance);
          } else if (error.value && errorComponent) {
            return createVNode(errorComponent, {
              error: error.value
            });
          } else if (loadingComponent && !delayed.value) {
            return createVNode(loadingComponent);
          }
        };
      }
    });
  }
  function createInnerComp(comp, parent) {
    const { ref: ref22, props, children, ce: ce2 } = parent.vnode;
    const vnode = createVNode(comp, props, children);
    vnode.ref = ref22;
    vnode.ce = ce2;
    delete parent.vnode.ce;
    return vnode;
  }
  const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
  const KeepAliveImpl = {
    name: `KeepAlive`,
    // Marker for special handling inside the renderer. We are not using a ===
    // check directly on KeepAlive in the renderer, because importing it directly
    // would prevent it from being tree-shaken.
    __isKeepAlive: true,
    props: {
      include: [String, RegExp, Array],
      exclude: [String, RegExp, Array],
      max: [String, Number]
    },
    setup(props, { slots }) {
      const instance = getCurrentInstance();
      const sharedContext = instance.ctx;
      if (!sharedContext.renderer) {
        return () => {
          const children = slots.default && slots.default();
          return children && children.length === 1 ? children[0] : children;
        };
      }
      const cache2 = /* @__PURE__ */ new Map();
      const keys = /* @__PURE__ */ new Set();
      let current = null;
      const parentSuspense = instance.suspense;
      const {
        renderer: {
          p: patch,
          m: move,
          um: _unmount,
          o: { createElement }
        }
      } = sharedContext;
      const storageContainer = createElement("div");
      sharedContext.activate = (vnode, container, anchor, namespace, optimized) => {
        const instance2 = vnode.component;
        move(vnode, container, anchor, 0, parentSuspense);
        patch(
          instance2.vnode,
          vnode,
          container,
          anchor,
          instance2,
          parentSuspense,
          namespace,
          vnode.slotScopeIds,
          optimized
        );
        queuePostRenderEffect(() => {
          instance2.isDeactivated = false;
          if (instance2.a) {
            invokeArrayFns(instance2.a);
          }
          const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
          if (vnodeHook) {
            invokeVNodeHook(vnodeHook, instance2.parent, vnode);
          }
        }, parentSuspense);
      };
      sharedContext.deactivate = (vnode) => {
        const instance2 = vnode.component;
        invalidateMount(instance2.m);
        invalidateMount(instance2.a);
        move(vnode, storageContainer, null, 1, parentSuspense);
        queuePostRenderEffect(() => {
          if (instance2.da) {
            invokeArrayFns(instance2.da);
          }
          const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
          if (vnodeHook) {
            invokeVNodeHook(vnodeHook, instance2.parent, vnode);
          }
          instance2.isDeactivated = true;
        }, parentSuspense);
      };
      function unmount(vnode) {
        resetShapeFlag(vnode);
        _unmount(vnode, instance, parentSuspense, true);
      }
      function pruneCache(filter) {
        cache2.forEach((vnode, key) => {
          const name = getComponentName(vnode.type);
          if (name && (!filter || !filter(name))) {
            pruneCacheEntry(key);
          }
        });
      }
      function pruneCacheEntry(key) {
        const cached = cache2.get(key);
        if (!current || !isSameVNodeType(cached, current)) {
          unmount(cached);
        } else if (current) {
          resetShapeFlag(current);
        }
        cache2.delete(key);
        keys.delete(key);
      }
      watch(
        () => [props.include, props.exclude],
        ([include, exclude]) => {
          include && pruneCache((name) => matches(include, name));
          exclude && pruneCache((name) => !matches(exclude, name));
        },
        // prune post-render after `current` has been updated
        { flush: "post", deep: true }
      );
      let pendingCacheKey = null;
      const cacheSubtree = () => {
        if (pendingCacheKey != null) {
          if (isSuspense(instance.subTree.type)) {
            queuePostRenderEffect(() => {
              cache2.set(pendingCacheKey, getInnerChild(instance.subTree));
            }, instance.subTree.suspense);
          } else {
            cache2.set(pendingCacheKey, getInnerChild(instance.subTree));
          }
        }
      };
      onMounted(cacheSubtree);
      onUpdated(cacheSubtree);
      onBeforeUnmount(() => {
        cache2.forEach((cached) => {
          const { subTree, suspense } = instance;
          const vnode = getInnerChild(subTree);
          if (cached.type === vnode.type && cached.key === vnode.key) {
            resetShapeFlag(vnode);
            const da = vnode.component.da;
            da && queuePostRenderEffect(da, suspense);
            return;
          }
          unmount(cached);
        });
      });
      return () => {
        pendingCacheKey = null;
        if (!slots.default) {
          return null;
        }
        const children = slots.default();
        const rawVNode = children[0];
        if (children.length > 1) {
          current = null;
          return children;
        } else if (!isVNode$1(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
          current = null;
          return rawVNode;
        }
        let vnode = getInnerChild(rawVNode);
        const comp = vnode.type;
        const name = getComponentName(
          isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp
        );
        const { include, exclude, max } = props;
        if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
          current = vnode;
          return rawVNode;
        }
        const key = vnode.key == null ? comp : vnode.key;
        const cachedVNode = cache2.get(key);
        if (vnode.el) {
          vnode = cloneVNode(vnode);
          if (rawVNode.shapeFlag & 128) {
            rawVNode.ssContent = vnode;
          }
        }
        pendingCacheKey = key;
        if (cachedVNode) {
          vnode.el = cachedVNode.el;
          vnode.component = cachedVNode.component;
          if (vnode.transition) {
            setTransitionHooks(vnode, vnode.transition);
          }
          vnode.shapeFlag |= 512;
          keys.delete(key);
          keys.add(key);
        } else {
          keys.add(key);
          if (max && keys.size > parseInt(max, 10)) {
            pruneCacheEntry(keys.values().next().value);
          }
        }
        vnode.shapeFlag |= 256;
        current = vnode;
        return isSuspense(rawVNode.type) ? rawVNode : vnode;
      };
    }
  };
  const KeepAlive = KeepAliveImpl;
  function matches(pattern, name) {
    if (isArray$2(pattern)) {
      return pattern.some((p2) => matches(p2, name));
    } else if (isString$1(pattern)) {
      return pattern.split(",").includes(name);
    } else if (isRegExp$1(pattern)) {
      return pattern.test(name);
    }
    return false;
  }
  function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a", target);
  }
  function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da", target);
  }
  function registerKeepAliveHook(hook, type, target = currentInstance) {
    const wrappedHook = hook.__wdc || (hook.__wdc = () => {
      let current = target;
      while (current) {
        if (current.isDeactivated) {
          return;
        }
        current = current.parent;
      }
      return hook();
    });
    injectHook(type, wrappedHook, target);
    if (target) {
      let current = target.parent;
      while (current && current.parent) {
        if (isKeepAlive(current.parent.vnode)) {
          injectToKeepAliveRoot(wrappedHook, type, target, current);
        }
        current = current.parent;
      }
    }
  }
  function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    const injected = injectHook(
      type,
      hook,
      keepAliveRoot,
      true
      /* prepend */
    );
    onUnmounted(() => {
      remove(keepAliveRoot[type], injected);
    }, target);
  }
  function resetShapeFlag(vnode) {
    vnode.shapeFlag &= ~256;
    vnode.shapeFlag &= ~512;
  }
  function getInnerChild(vnode) {
    return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
  }
  function injectHook(type, hook, target = currentInstance, prepend = false) {
    if (target) {
      const hooks = target[type] || (target[type] = []);
      const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
        pauseTracking();
        const reset2 = setCurrentInstance(target);
        const res = callWithAsyncErrorHandling(hook, target, type, args);
        reset2();
        resetTracking();
        return res;
      });
      if (prepend) {
        hooks.unshift(wrappedHook);
      } else {
        hooks.push(wrappedHook);
      }
      return wrappedHook;
    }
  }
  const createHook = (lifecycle) => (hook, target = currentInstance) => {
    if (!isInSSRComponentSetup || lifecycle === "sp") {
      injectHook(lifecycle, (...args) => hook(...args), target);
    }
  };
  const onBeforeMount = createHook("bm");
  const onMounted = createHook("m");
  const onBeforeUpdate = createHook("bu");
  const onUpdated = createHook("u");
  const onBeforeUnmount = createHook("bum");
  const onUnmounted = createHook("um");
  const onServerPrefetch = createHook("sp");
  const onRenderTriggered = createHook(
    "rtg"
  );
  const onRenderTracked = createHook(
    "rtc"
  );
  function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec", hook, target);
  }
  const COMPONENTS = "components";
  const DIRECTIVES = "directives";
  function resolveComponent(name, maybeSelfReference) {
    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
  }
  const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
  function resolveDynamicComponent(component) {
    if (isString$1(component)) {
      return resolveAsset(COMPONENTS, component, false) || component;
    } else {
      return component || NULL_DYNAMIC_COMPONENT;
    }
  }
  function resolveDirective(name) {
    return resolveAsset(DIRECTIVES, name);
  }
  function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
      const Component = instance.type;
      if (type === COMPONENTS) {
        const selfName = getComponentName(
          Component,
          false
        );
        if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
          return Component;
        }
      }
      const res = (
        // local registration
        // check instance[type] first which is resolved for options API
        resolve(instance[type] || Component[type], name) || // global registration
        resolve(instance.appContext[type], name)
      );
      if (!res && maybeSelfReference) {
        return Component;
      }
      return res;
    }
  }
  function resolve(registry, name) {
    return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
  }
  function renderList(source, renderItem, cache2, index) {
    let ret;
    const cached = cache2 && cache2[index];
    if (isArray$2(source) || isString$1(source)) {
      ret = new Array(source.length);
      for (let i2 = 0, l2 = source.length; i2 < l2; i2++) {
        ret[i2] = renderItem(source[i2], i2, void 0, cached && cached[i2]);
      }
    } else if (typeof source === "number") {
      ret = new Array(source);
      for (let i2 = 0; i2 < source; i2++) {
        ret[i2] = renderItem(i2 + 1, i2, void 0, cached && cached[i2]);
      }
    } else if (isObject$1(source)) {
      if (source[Symbol.iterator]) {
        ret = Array.from(
          source,
          (item, i2) => renderItem(item, i2, void 0, cached && cached[i2])
        );
      } else {
        const keys = Object.keys(source);
        ret = new Array(keys.length);
        for (let i2 = 0, l2 = keys.length; i2 < l2; i2++) {
          const key = keys[i2];
          ret[i2] = renderItem(source[key], key, i2, cached && cached[i2]);
        }
      }
    } else {
      ret = [];
    }
    if (cache2) {
      cache2[index] = ret;
    }
    return ret;
  }
  function createSlots(slots, dynamicSlots) {
    for (let i2 = 0; i2 < dynamicSlots.length; i2++) {
      const slot = dynamicSlots[i2];
      if (isArray$2(slot)) {
        for (let j2 = 0; j2 < slot.length; j2++) {
          slots[slot[j2].name] = slot[j2].fn;
        }
      } else if (slot) {
        slots[slot.name] = slot.key ? (...args) => {
          const res = slot.fn(...args);
          if (res) res.key = slot.key;
          return res;
        } : slot.fn;
      }
    }
    return slots;
  }
  function renderSlot(slots, name, props = {}, fallback, noSlotted) {
    if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
      if (name !== "default") props.name = name;
      return createVNode("slot", props, fallback && fallback());
    }
    let slot = slots[name];
    if (slot && slot._c) {
      slot._d = false;
    }
    openBlock();
    const validSlotContent = slot && ensureValidVNode(slot(props));
    const rendered = createBlock(
      Fragment,
      {
        key: (props.key || // slot content array of a dynamic conditional slot may have a branch
        // key attached in the `createSlots` helper, respect that
        validSlotContent && validSlotContent.key || `_${name}`) + // #7256 force differentiate fallback content from actual content
        (!validSlotContent && fallback ? "_fb" : "")
      },
      validSlotContent || (fallback ? fallback() : []),
      validSlotContent && slots._ === 1 ? 64 : -2
    );
    if (!noSlotted && rendered.scopeId) {
      rendered.slotScopeIds = [rendered.scopeId + "-s"];
    }
    if (slot && slot._c) {
      slot._d = true;
    }
    return rendered;
  }
  function ensureValidVNode(vnodes) {
    return vnodes.some((child) => {
      if (!isVNode$1(child)) return true;
      if (child.type === Comment) return false;
      if (child.type === Fragment && !ensureValidVNode(child.children))
        return false;
      return true;
    }) ? vnodes : null;
  }
  function toHandlers(obj, preserveCaseIfNecessary) {
    const ret = {};
    for (const key in obj) {
      ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : toHandlerKey(key)] = obj[key];
    }
    return ret;
  }
  const getPublicInstance = (i2) => {
    if (!i2) return null;
    if (isStatefulComponent(i2)) return getComponentPublicInstance(i2);
    return getPublicInstance(i2.parent);
  };
  const publicPropertiesMap = (
    // Move PURE marker to new line to workaround compiler discarding it
    // due to type annotation
    /* @__PURE__ */ extend$1(/* @__PURE__ */ Object.create(null), {
      $: (i2) => i2,
      $el: (i2) => i2.vnode.el,
      $data: (i2) => i2.data,
      $props: (i2) => i2.props,
      $attrs: (i2) => i2.attrs,
      $slots: (i2) => i2.slots,
      $refs: (i2) => i2.refs,
      $parent: (i2) => getPublicInstance(i2.parent),
      $root: (i2) => getPublicInstance(i2.root),
      $emit: (i2) => i2.emit,
      $options: (i2) => resolveMergedOptions(i2),
      $forceUpdate: (i2) => i2.f || (i2.f = () => {
        i2.effect.dirty = true;
        queueJob(i2.update);
      }),
      $nextTick: (i2) => i2.n || (i2.n = nextTick.bind(i2.proxy)),
      $watch: (i2) => instanceWatch.bind(i2)
    })
  );
  const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
  const PublicInstanceProxyHandlers = {
    get({ _: instance }, key) {
      if (key === "__v_skip") {
        return true;
      }
      const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
      let normalizedProps;
      if (key[0] !== "$") {
        const n2 = accessCache[key];
        if (n2 !== void 0) {
          switch (n2) {
            case 1:
              return setupState[key];
            case 2:
              return data[key];
            case 4:
              return ctx[key];
            case 3:
              return props[key];
          }
        } else if (hasSetupBinding(setupState, key)) {
          accessCache[key] = 1;
          return setupState[key];
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          accessCache[key] = 2;
          return data[key];
        } else if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
        ) {
          accessCache[key] = 3;
          return props[key];
        } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
          accessCache[key] = 4;
          return ctx[key];
        } else if (shouldCacheAccess) {
          accessCache[key] = 0;
        }
      }
      const publicGetter = publicPropertiesMap[key];
      let cssModule, globalProperties;
      if (publicGetter) {
        if (key === "$attrs") {
          track(instance.attrs, "get", "");
        }
        return publicGetter(instance);
      } else if (
        // css module (injected by vue-loader)
        (cssModule = type.__cssModules) && (cssModule = cssModule[key])
      ) {
        return cssModule;
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (
        // global properties
        globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
      ) {
        {
          return globalProperties[key];
        }
      } else ;
    },
    set({ _: instance }, key, value) {
      const { data, setupState, ctx } = instance;
      if (hasSetupBinding(setupState, key)) {
        setupState[key] = value;
        return true;
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        data[key] = value;
        return true;
      } else if (hasOwn(instance.props, key)) {
        return false;
      }
      if (key[0] === "$" && key.slice(1) in instance) {
        return false;
      } else {
        {
          ctx[key] = value;
        }
      }
      return true;
    },
    has({
      _: { data, setupState, accessCache, ctx, appContext, propsOptions }
    }, key) {
      let normalizedProps;
      return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
    },
    defineProperty(target, key, descriptor) {
      if (descriptor.get != null) {
        target._.accessCache[key] = 0;
      } else if (hasOwn(descriptor, "value")) {
        this.set(target, key, descriptor.value, null);
      }
      return Reflect.defineProperty(target, key, descriptor);
    }
  };
  const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ extend$1(
    {},
    PublicInstanceProxyHandlers,
    {
      get(target, key) {
        if (key === Symbol.unscopables) {
          return;
        }
        return PublicInstanceProxyHandlers.get(target, key, target);
      },
      has(_2, key) {
        const has2 = key[0] !== "_" && !isGloballyAllowed(key);
        return has2;
      }
    }
  );
  function defineProps() {
    return null;
  }
  function defineEmits() {
    return null;
  }
  function defineExpose(exposed) {
  }
  function defineOptions(options) {
  }
  function defineSlots() {
    return null;
  }
  function defineModel() {
  }
  function withDefaults(props, defaults2) {
    return null;
  }
  function useSlots() {
    return getContext().slots;
  }
  function useAttrs() {
    return getContext().attrs;
  }
  function getContext() {
    const i2 = getCurrentInstance();
    return i2.setupContext || (i2.setupContext = createSetupContext(i2));
  }
  function normalizePropsOrEmits(props) {
    return isArray$2(props) ? props.reduce(
      (normalized, p2) => (normalized[p2] = null, normalized),
      {}
    ) : props;
  }
  function mergeDefaults(raw, defaults2) {
    const props = normalizePropsOrEmits(raw);
    for (const key in defaults2) {
      if (key.startsWith("__skip")) continue;
      let opt = props[key];
      if (opt) {
        if (isArray$2(opt) || isFunction$1(opt)) {
          opt = props[key] = { type: opt, default: defaults2[key] };
        } else {
          opt.default = defaults2[key];
        }
      } else if (opt === null) {
        opt = props[key] = { default: defaults2[key] };
      } else ;
      if (opt && defaults2[`__skip_${key}`]) {
        opt.skipFactory = true;
      }
    }
    return props;
  }
  function mergeModels(a2, b2) {
    if (!a2 || !b2) return a2 || b2;
    if (isArray$2(a2) && isArray$2(b2)) return a2.concat(b2);
    return extend$1({}, normalizePropsOrEmits(a2), normalizePropsOrEmits(b2));
  }
  function createPropsRestProxy(props, excludedKeys) {
    const ret = {};
    for (const key in props) {
      if (!excludedKeys.includes(key)) {
        Object.defineProperty(ret, key, {
          enumerable: true,
          get: () => props[key]
        });
      }
    }
    return ret;
  }
  function withAsyncContext(getAwaitable) {
    const ctx = getCurrentInstance();
    let awaitable = getAwaitable();
    unsetCurrentInstance();
    if (isPromise(awaitable)) {
      awaitable = awaitable.catch((e2) => {
        setCurrentInstance(ctx);
        throw e2;
      });
    }
    return [awaitable, () => setCurrentInstance(ctx)];
  }
  let shouldCacheAccess = true;
  function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    shouldCacheAccess = false;
    if (options.beforeCreate) {
      callHook$1(options.beforeCreate, instance, "bc");
    }
    const {
      // state
      data: dataOptions,
      computed: computedOptions,
      methods,
      watch: watchOptions,
      provide: provideOptions,
      inject: injectOptions,
      // lifecycle
      created,
      beforeMount,
      mounted,
      beforeUpdate,
      updated,
      activated,
      deactivated,
      beforeDestroy,
      beforeUnmount,
      destroyed,
      unmounted,
      render: render2,
      renderTracked,
      renderTriggered,
      errorCaptured,
      serverPrefetch,
      // public API
      expose,
      inheritAttrs,
      // assets
      components,
      directives,
      filters
    } = options;
    const checkDuplicateProperties = null;
    if (injectOptions) {
      resolveInjections(injectOptions, ctx, checkDuplicateProperties);
    }
    if (methods) {
      for (const key in methods) {
        const methodHandler = methods[key];
        if (isFunction$1(methodHandler)) {
          {
            ctx[key] = methodHandler.bind(publicThis);
          }
        }
      }
    }
    if (dataOptions) {
      const data = dataOptions.call(publicThis, publicThis);
      if (!isObject$1(data)) ;
      else {
        instance.data = reactive(data);
      }
    }
    shouldCacheAccess = true;
    if (computedOptions) {
      for (const key in computedOptions) {
        const opt = computedOptions[key];
        const get2 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
        const set2 = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
        const c2 = computed({
          get: get2,
          set: set2
        });
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => c2.value,
          set: (v2) => c2.value = v2
        });
      }
    }
    if (watchOptions) {
      for (const key in watchOptions) {
        createWatcher(watchOptions[key], ctx, publicThis, key);
      }
    }
    if (provideOptions) {
      const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
      Reflect.ownKeys(provides).forEach((key) => {
        provide(key, provides[key]);
      });
    }
    if (created) {
      callHook$1(created, instance, "c");
    }
    function registerLifecycleHook(register, hook) {
      if (isArray$2(hook)) {
        hook.forEach((_hook) => register(_hook.bind(publicThis)));
      } else if (hook) {
        register(hook.bind(publicThis));
      }
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if (isArray$2(expose)) {
      if (expose.length) {
        const exposed = instance.exposed || (instance.exposed = {});
        expose.forEach((key) => {
          Object.defineProperty(exposed, key, {
            get: () => publicThis[key],
            set: (val) => publicThis[key] = val
          });
        });
      } else if (!instance.exposed) {
        instance.exposed = {};
      }
    }
    if (render2 && instance.render === NOOP) {
      instance.render = render2;
    }
    if (inheritAttrs != null) {
      instance.inheritAttrs = inheritAttrs;
    }
    if (components) instance.components = components;
    if (directives) instance.directives = directives;
  }
  function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
    if (isArray$2(injectOptions)) {
      injectOptions = normalizeInject(injectOptions);
    }
    for (const key in injectOptions) {
      const opt = injectOptions[key];
      let injected;
      if (isObject$1(opt)) {
        if ("default" in opt) {
          injected = inject(
            opt.from || key,
            opt.default,
            true
          );
        } else {
          injected = inject(opt.from || key);
        }
      } else {
        injected = inject(opt);
      }
      if (isRef(injected)) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v2) => injected.value = v2
        });
      } else {
        ctx[key] = injected;
      }
    }
  }
  function callHook$1(hook, instance, type) {
    callWithAsyncErrorHandling(
      isArray$2(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
      instance,
      type
    );
  }
  function createWatcher(raw, ctx, publicThis, key) {
    const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
    if (isString$1(raw)) {
      const handler = ctx[raw];
      if (isFunction$1(handler)) {
        watch(getter, handler);
      }
    } else if (isFunction$1(raw)) {
      watch(getter, raw.bind(publicThis));
    } else if (isObject$1(raw)) {
      if (isArray$2(raw)) {
        raw.forEach((r2) => createWatcher(r2, ctx, publicThis, key));
      } else {
        const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
        if (isFunction$1(handler)) {
          watch(getter, handler, raw);
        }
      }
    } else ;
  }
  function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins, extends: extendsOptions } = base;
    const {
      mixins: globalMixins,
      optionsCache: cache2,
      config: { optionMergeStrategies }
    } = instance.appContext;
    const cached = cache2.get(base);
    let resolved;
    if (cached) {
      resolved = cached;
    } else if (!globalMixins.length && !mixins && !extendsOptions) {
      {
        resolved = base;
      }
    } else {
      resolved = {};
      if (globalMixins.length) {
        globalMixins.forEach(
          (m2) => mergeOptions$1(resolved, m2, optionMergeStrategies, true)
        );
      }
      mergeOptions$1(resolved, base, optionMergeStrategies);
    }
    if (isObject$1(base)) {
      cache2.set(base, resolved);
    }
    return resolved;
  }
  function mergeOptions$1(to, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) {
      mergeOptions$1(to, extendsOptions, strats, true);
    }
    if (mixins) {
      mixins.forEach(
        (m2) => mergeOptions$1(to, m2, strats, true)
      );
    }
    for (const key in from) {
      if (asMixin && key === "expose") ;
      else {
        const strat = internalOptionMergeStrats[key] || strats && strats[key];
        to[key] = strat ? strat(to[key], from[key]) : from[key];
      }
    }
    return to;
  }
  const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeEmitsOrPropsOptions,
    emits: mergeEmitsOrPropsOptions,
    // objects
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    // lifecycle
    beforeCreate: mergeAsArray$1,
    created: mergeAsArray$1,
    beforeMount: mergeAsArray$1,
    mounted: mergeAsArray$1,
    beforeUpdate: mergeAsArray$1,
    updated: mergeAsArray$1,
    beforeDestroy: mergeAsArray$1,
    beforeUnmount: mergeAsArray$1,
    destroyed: mergeAsArray$1,
    unmounted: mergeAsArray$1,
    activated: mergeAsArray$1,
    deactivated: mergeAsArray$1,
    errorCaptured: mergeAsArray$1,
    serverPrefetch: mergeAsArray$1,
    // assets
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    // watch
    watch: mergeWatchOptions,
    // provide / inject
    provide: mergeDataFn,
    inject: mergeInject
  };
  function mergeDataFn(to, from) {
    if (!from) {
      return to;
    }
    if (!to) {
      return from;
    }
    return function mergedDataFn() {
      return extend$1(
        isFunction$1(to) ? to.call(this, this) : to,
        isFunction$1(from) ? from.call(this, this) : from
      );
    };
  }
  function mergeInject(to, from) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
  }
  function normalizeInject(raw) {
    if (isArray$2(raw)) {
      const res = {};
      for (let i2 = 0; i2 < raw.length; i2++) {
        res[raw[i2]] = raw[i2];
      }
      return res;
    }
    return raw;
  }
  function mergeAsArray$1(to, from) {
    return to ? [...new Set([].concat(to, from))] : from;
  }
  function mergeObjectOptions(to, from) {
    return to ? extend$1(/* @__PURE__ */ Object.create(null), to, from) : from;
  }
  function mergeEmitsOrPropsOptions(to, from) {
    if (to) {
      if (isArray$2(to) && isArray$2(from)) {
        return [.../* @__PURE__ */ new Set([...to, ...from])];
      }
      return extend$1(
        /* @__PURE__ */ Object.create(null),
        normalizePropsOrEmits(to),
        normalizePropsOrEmits(from != null ? from : {})
      );
    } else {
      return from;
    }
  }
  function mergeWatchOptions(to, from) {
    if (!to) return from;
    if (!from) return to;
    const merged = extend$1(/* @__PURE__ */ Object.create(null), to);
    for (const key in from) {
      merged[key] = mergeAsArray$1(to[key], from[key]);
    }
    return merged;
  }
  function createAppContext() {
    return {
      app: null,
      config: {
        isNativeTag: NO,
        performance: false,
        globalProperties: {},
        optionMergeStrategies: {},
        errorHandler: void 0,
        warnHandler: void 0,
        compilerOptions: {}
      },
      mixins: [],
      components: {},
      directives: {},
      provides: /* @__PURE__ */ Object.create(null),
      optionsCache: /* @__PURE__ */ new WeakMap(),
      propsCache: /* @__PURE__ */ new WeakMap(),
      emitsCache: /* @__PURE__ */ new WeakMap()
    };
  }
  let uid$1 = 0;
  function createAppAPI(render2, hydrate2) {
    return function createApp2(rootComponent, rootProps = null) {
      if (!isFunction$1(rootComponent)) {
        rootComponent = extend$1({}, rootComponent);
      }
      if (rootProps != null && !isObject$1(rootProps)) {
        rootProps = null;
      }
      const context = createAppContext();
      const installedPlugins = /* @__PURE__ */ new WeakSet();
      let isMounted = false;
      const app = context.app = {
        _uid: uid$1++,
        _component: rootComponent,
        _props: rootProps,
        _container: null,
        _context: context,
        _instance: null,
        version,
        get config() {
          return context.config;
        },
        set config(v2) {
        },
        use(plugin, ...options) {
          if (installedPlugins.has(plugin)) ;
          else if (plugin && isFunction$1(plugin.install)) {
            installedPlugins.add(plugin);
            plugin.install(app, ...options);
          } else if (isFunction$1(plugin)) {
            installedPlugins.add(plugin);
            plugin(app, ...options);
          } else ;
          return app;
        },
        mixin(mixin) {
          {
            if (!context.mixins.includes(mixin)) {
              context.mixins.push(mixin);
            }
          }
          return app;
        },
        component(name, component) {
          if (!component) {
            return context.components[name];
          }
          context.components[name] = component;
          return app;
        },
        directive(name, directive) {
          if (!directive) {
            return context.directives[name];
          }
          context.directives[name] = directive;
          return app;
        },
        mount(rootContainer, isHydrate, namespace) {
          if (!isMounted) {
            const vnode = createVNode(rootComponent, rootProps);
            vnode.appContext = context;
            if (namespace === true) {
              namespace = "svg";
            } else if (namespace === false) {
              namespace = void 0;
            }
            if (isHydrate && hydrate2) {
              hydrate2(vnode, rootContainer);
            } else {
              render2(vnode, rootContainer, namespace);
            }
            isMounted = true;
            app._container = rootContainer;
            rootContainer.__vue_app__ = app;
            return getComponentPublicInstance(vnode.component);
          }
        },
        unmount() {
          if (isMounted) {
            render2(null, app._container);
            delete app._container.__vue_app__;
          }
        },
        provide(key, value) {
          context.provides[key] = value;
          return app;
        },
        runWithContext(fn2) {
          const lastApp = currentApp;
          currentApp = app;
          try {
            return fn2();
          } finally {
            currentApp = lastApp;
          }
        }
      };
      return app;
    };
  }
  let currentApp = null;
  function provide(key, value) {
    if (!currentInstance) ;
    else {
      let provides = currentInstance.provides;
      const parentProvides = currentInstance.parent && currentInstance.parent.provides;
      if (parentProvides === provides) {
        provides = currentInstance.provides = Object.create(parentProvides);
      }
      provides[key] = value;
    }
  }
  function inject(key, defaultValue, treatDefaultAsFactory = false) {
    const instance = currentInstance || currentRenderingInstance;
    if (instance || currentApp) {
      const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
      if (provides && key in provides) {
        return provides[key];
      } else if (arguments.length > 1) {
        return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
      } else ;
    }
  }
  function hasInjectionContext() {
    return !!(currentInstance || currentRenderingInstance || currentApp);
  }
  const internalObjectProto = {};
  const createInternalObject = () => Object.create(internalObjectProto);
  const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
  function initProps(instance, rawProps, isStateful, isSSR = false) {
    const props = {};
    const attrs = createInternalObject();
    instance.propsDefaults = /* @__PURE__ */ Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    for (const key in instance.propsOptions[0]) {
      if (!(key in props)) {
        props[key] = void 0;
      }
    }
    if (isStateful) {
      instance.props = isSSR ? props : shallowReactive(props);
    } else {
      if (!instance.type.props) {
        instance.props = attrs;
      } else {
        instance.props = props;
      }
    }
    instance.attrs = attrs;
  }
  function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const {
      props,
      attrs,
      vnode: { patchFlag }
    } = instance;
    const rawCurrentProps = toRaw(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (
      // always force full diff in dev
      // - #1942 if hmr is enabled with sfc component
      // - vite#872 non-sfc component used by sfc component
      (optimized || patchFlag > 0) && !(patchFlag & 16)
    ) {
      if (patchFlag & 8) {
        const propsToUpdate = instance.vnode.dynamicProps;
        for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
          let key = propsToUpdate[i2];
          if (isEmitListener(instance.emitsOptions, key)) {
            continue;
          }
          const value = rawProps[key];
          if (options) {
            if (hasOwn(attrs, key)) {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            } else {
              const camelizedKey = camelize(key);
              props[camelizedKey] = resolvePropValue(
                options,
                rawCurrentProps,
                camelizedKey,
                value,
                instance,
                false
              );
            }
          } else {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
    } else {
      if (setFullProps(instance, rawProps, props, attrs)) {
        hasAttrsChanged = true;
      }
      let kebabKey;
      for (const key in rawCurrentProps) {
        if (!rawProps || // for camelCase
        !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
        // and converted to camelCase (#955)
        ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
          if (options) {
            if (rawPrevProps && // for camelCase
            (rawPrevProps[key] !== void 0 || // for kebab-case
            rawPrevProps[kebabKey] !== void 0)) {
              props[key] = resolvePropValue(
                options,
                rawCurrentProps,
                key,
                void 0,
                instance,
                true
              );
            }
          } else {
            delete props[key];
          }
        }
      }
      if (attrs !== rawCurrentProps) {
        for (const key in attrs) {
          if (!rawProps || !hasOwn(rawProps, key) && true) {
            delete attrs[key];
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (hasAttrsChanged) {
      trigger(instance.attrs, "set", "");
    }
  }
  function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) {
      for (let key in rawProps) {
        if (isReservedProp(key)) {
          continue;
        }
        const value = rawProps[key];
        let camelKey;
        if (options && hasOwn(options, camelKey = camelize(key))) {
          if (!needCastKeys || !needCastKeys.includes(camelKey)) {
            props[camelKey] = value;
          } else {
            (rawCastValues || (rawCastValues = {}))[camelKey] = value;
          }
        } else if (!isEmitListener(instance.emitsOptions, key)) {
          if (!(key in attrs) || value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (needCastKeys) {
      const rawCurrentProps = toRaw(props);
      const castValues = rawCastValues || EMPTY_OBJ;
      for (let i2 = 0; i2 < needCastKeys.length; i2++) {
        const key = needCastKeys[i2];
        props[key] = resolvePropValue(
          options,
          rawCurrentProps,
          key,
          castValues[key],
          instance,
          !hasOwn(castValues, key)
        );
      }
    }
    return hasAttrsChanged;
  }
  function resolvePropValue(options, props, key, value, instance, isAbsent) {
    const opt = options[key];
    if (opt != null) {
      const hasDefault = hasOwn(opt, "default");
      if (hasDefault && value === void 0) {
        const defaultValue = opt.default;
        if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue)) {
          const { propsDefaults } = instance;
          if (key in propsDefaults) {
            value = propsDefaults[key];
          } else {
            const reset2 = setCurrentInstance(instance);
            value = propsDefaults[key] = defaultValue.call(
              null,
              props
            );
            reset2();
          }
        } else {
          value = defaultValue;
        }
      }
      if (opt[
        0
        /* shouldCast */
      ]) {
        if (isAbsent && !hasDefault) {
          value = false;
        } else if (opt[
          1
          /* shouldCastTrue */
        ] && (value === "" || value === hyphenate(key))) {
          value = true;
        }
      }
    }
    return value;
  }
  const mixinPropsCache = /* @__PURE__ */ new WeakMap();
  function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache2 = asMixin ? mixinPropsCache : appContext.propsCache;
    const cached = cache2.get(comp);
    if (cached) {
      return cached;
    }
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    let hasExtends = false;
    if (!isFunction$1(comp)) {
      const extendProps = (raw2) => {
        hasExtends = true;
        const [props, keys] = normalizePropsOptions(raw2, appContext, true);
        extend$1(normalized, props);
        if (keys) needCastKeys.push(...keys);
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendProps);
      }
      if (comp.extends) {
        extendProps(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendProps);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject$1(comp)) {
        cache2.set(comp, EMPTY_ARR);
      }
      return EMPTY_ARR;
    }
    if (isArray$2(raw)) {
      for (let i2 = 0; i2 < raw.length; i2++) {
        const normalizedKey = camelize(raw[i2]);
        if (validatePropName(normalizedKey)) {
          normalized[normalizedKey] = EMPTY_OBJ;
        }
      }
    } else if (raw) {
      for (const key in raw) {
        const normalizedKey = camelize(key);
        if (validatePropName(normalizedKey)) {
          const opt = raw[key];
          const prop = normalized[normalizedKey] = isArray$2(opt) || isFunction$1(opt) ? { type: opt } : extend$1({}, opt);
          if (prop) {
            const booleanIndex = getTypeIndex(Boolean, prop.type);
            const stringIndex = getTypeIndex(String, prop.type);
            prop[
              0
              /* shouldCast */
            ] = booleanIndex > -1;
            prop[
              1
              /* shouldCastTrue */
            ] = stringIndex < 0 || booleanIndex < stringIndex;
            if (booleanIndex > -1 || hasOwn(prop, "default")) {
              needCastKeys.push(normalizedKey);
            }
          }
        }
      }
    }
    const res = [normalized, needCastKeys];
    if (isObject$1(comp)) {
      cache2.set(comp, res);
    }
    return res;
  }
  function validatePropName(key) {
    if (key[0] !== "$" && !isReservedProp(key)) {
      return true;
    }
    return false;
  }
  function getType(ctor) {
    if (ctor === null) {
      return "null";
    }
    if (typeof ctor === "function") {
      return ctor.name || "";
    } else if (typeof ctor === "object") {
      const name = ctor.constructor && ctor.constructor.name;
      return name || "";
    }
    return "";
  }
  function isSameType(a2, b2) {
    return getType(a2) === getType(b2);
  }
  function getTypeIndex(type, expectedTypes) {
    if (isArray$2(expectedTypes)) {
      return expectedTypes.findIndex((t2) => isSameType(t2, type));
    } else if (isFunction$1(expectedTypes)) {
      return isSameType(expectedTypes, type) ? 0 : -1;
    }
    return -1;
  }
  const isInternalKey = (key) => key[0] === "_" || key === "$stable";
  const normalizeSlotValue = (value) => isArray$2(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
  const normalizeSlot$1 = (key, rawSlot, ctx) => {
    if (rawSlot._n) {
      return rawSlot;
    }
    const normalized = withCtx((...args) => {
      if (false) ;
      return normalizeSlotValue(rawSlot(...args));
    }, ctx);
    normalized._c = false;
    return normalized;
  };
  const normalizeObjectSlots = (rawSlots, slots, instance) => {
    const ctx = rawSlots._ctx;
    for (const key in rawSlots) {
      if (isInternalKey(key)) continue;
      const value = rawSlots[key];
      if (isFunction$1(value)) {
        slots[key] = normalizeSlot$1(key, value, ctx);
      } else if (value != null) {
        const normalized = normalizeSlotValue(value);
        slots[key] = () => normalized;
      }
    }
  };
  const normalizeVNodeSlots = (instance, children) => {
    const normalized = normalizeSlotValue(children);
    instance.slots.default = () => normalized;
  };
  const assignSlots = (slots, children, optimized) => {
    for (const key in children) {
      if (optimized || key !== "_") {
        slots[key] = children[key];
      }
    }
  };
  const initSlots = (instance, children, optimized) => {
    const slots = instance.slots = createInternalObject();
    if (instance.vnode.shapeFlag & 32) {
      const type = children._;
      if (type) {
        assignSlots(slots, children, optimized);
        if (optimized) {
          def(slots, "_", type, true);
        }
      } else {
        normalizeObjectSlots(children, slots);
      }
    } else if (children) {
      normalizeVNodeSlots(instance, children);
    }
  };
  const updateSlots = (instance, children, optimized) => {
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = EMPTY_OBJ;
    if (vnode.shapeFlag & 32) {
      const type = children._;
      if (type) {
        if (optimized && type === 1) {
          needDeletionCheck = false;
        } else {
          assignSlots(slots, children, optimized);
        }
      } else {
        needDeletionCheck = !children.$stable;
        normalizeObjectSlots(children, slots);
      }
      deletionComparisonTarget = children;
    } else if (children) {
      normalizeVNodeSlots(instance, children);
      deletionComparisonTarget = { default: 1 };
    }
    if (needDeletionCheck) {
      for (const key in slots) {
        if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
          delete slots[key];
        }
      }
    }
  };
  function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if (isArray$2(rawRef)) {
      rawRef.forEach(
        (r2, i2) => setRef(
          r2,
          oldRawRef && (isArray$2(oldRawRef) ? oldRawRef[i2] : oldRawRef),
          parentSuspense,
          vnode,
          isUnmount
        )
      );
      return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
      return;
    }
    const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner, r: ref3 } = rawRef;
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
    const setupState = owner.setupState;
    if (oldRef != null && oldRef !== ref3) {
      if (isString$1(oldRef)) {
        refs[oldRef] = null;
        if (hasOwn(setupState, oldRef)) {
          setupState[oldRef] = null;
        }
      } else if (isRef(oldRef)) {
        oldRef.value = null;
      }
    }
    if (isFunction$1(ref3)) {
      callWithErrorHandling(ref3, owner, 12, [value, refs]);
    } else {
      const _isString = isString$1(ref3);
      const _isRef = isRef(ref3);
      if (_isString || _isRef) {
        const doSet = () => {
          if (rawRef.f) {
            const existing = _isString ? hasOwn(setupState, ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
            if (isUnmount) {
              isArray$2(existing) && remove(existing, refValue);
            } else {
              if (!isArray$2(existing)) {
                if (_isString) {
                  refs[ref3] = [refValue];
                  if (hasOwn(setupState, ref3)) {
                    setupState[ref3] = refs[ref3];
                  }
                } else {
                  ref3.value = [refValue];
                  if (rawRef.k) refs[rawRef.k] = ref3.value;
                }
              } else if (!existing.includes(refValue)) {
                existing.push(refValue);
              }
            }
          } else if (_isString) {
            refs[ref3] = value;
            if (hasOwn(setupState, ref3)) {
              setupState[ref3] = value;
            }
          } else if (_isRef) {
            ref3.value = value;
            if (rawRef.k) refs[rawRef.k] = value;
          } else ;
        };
        if (value) {
          doSet.id = -1;
          queuePostRenderEffect(doSet, parentSuspense);
        } else {
          doSet();
        }
      }
    }
  }
  const TeleportEndKey = Symbol("_vte");
  const isTeleport = (type) => type.__isTeleport;
  const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
  const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
  const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
  const resolveTarget = (props, select) => {
    const targetSelector = props && props.to;
    if (isString$1(targetSelector)) {
      if (!select) {
        return null;
      } else {
        const target = select(targetSelector);
        return target;
      }
    } else {
      return targetSelector;
    }
  };
  const TeleportImpl = {
    name: "Teleport",
    __isTeleport: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
      const {
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        o: { insert, querySelector, createText, createComment }
      } = internals;
      const disabled = isTeleportDisabled(n2.props);
      let { shapeFlag, children, dynamicChildren } = n2;
      if (n1 == null) {
        const placeholder = n2.el = createText("");
        const mainAnchor = n2.anchor = createText("");
        const target = n2.target = resolveTarget(n2.props, querySelector);
        const targetStart = n2.targetStart = createText("");
        const targetAnchor = n2.targetAnchor = createText("");
        insert(placeholder, container, anchor);
        insert(mainAnchor, container, anchor);
        targetStart[TeleportEndKey] = targetAnchor;
        if (target) {
          insert(targetStart, target);
          insert(targetAnchor, target);
          if (namespace === "svg" || isTargetSVG(target)) {
            namespace = "svg";
          } else if (namespace === "mathml" || isTargetMathML(target)) {
            namespace = "mathml";
          }
        }
        const mount = (container2, anchor2) => {
          if (shapeFlag & 16) {
            mountChildren(
              children,
              container2,
              anchor2,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        };
        if (disabled) {
          mount(container, mainAnchor);
        } else if (target) {
          mount(target, targetAnchor);
        }
      } else {
        n2.el = n1.el;
        n2.targetStart = n1.targetStart;
        const mainAnchor = n2.anchor = n1.anchor;
        const target = n2.target = n1.target;
        const targetAnchor = n2.targetAnchor = n1.targetAnchor;
        const wasDisabled = isTeleportDisabled(n1.props);
        const currentContainer = wasDisabled ? container : target;
        const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
        if (namespace === "svg" || isTargetSVG(target)) {
          namespace = "svg";
        } else if (namespace === "mathml" || isTargetMathML(target)) {
          namespace = "mathml";
        }
        if (dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            currentContainer,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds
          );
          traverseStaticChildren(n1, n2, true);
        } else if (!optimized) {
          patchChildren(
            n1,
            n2,
            currentContainer,
            currentAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            false
          );
        }
        if (disabled) {
          if (!wasDisabled) {
            moveTeleport(
              n2,
              container,
              mainAnchor,
              internals,
              1
            );
          } else {
            if (n2.props && n1.props && n2.props.to !== n1.props.to) {
              n2.props.to = n1.props.to;
            }
          }
        } else {
          if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
            const nextTarget = n2.target = resolveTarget(
              n2.props,
              querySelector
            );
            if (nextTarget) {
              moveTeleport(
                n2,
                nextTarget,
                null,
                internals,
                0
              );
            }
          } else if (wasDisabled) {
            moveTeleport(
              n2,
              target,
              targetAnchor,
              internals,
              1
            );
          }
        }
      }
      updateCssVars(n2);
    },
    remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
      const {
        shapeFlag,
        children,
        anchor,
        targetStart,
        targetAnchor,
        target,
        props
      } = vnode;
      if (target) {
        hostRemove(targetStart);
        hostRemove(targetAnchor);
      }
      doRemove && hostRemove(anchor);
      if (shapeFlag & 16) {
        const shouldRemove = doRemove || !isTeleportDisabled(props);
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          unmount(
            child,
            parentComponent,
            parentSuspense,
            shouldRemove,
            !!child.dynamicChildren
          );
        }
      }
    },
    move: moveTeleport,
    hydrate: hydrateTeleport
  };
  function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
    if (moveType === 0) {
      insert(vnode.targetAnchor, container, parentAnchor);
    }
    const { el, anchor, shapeFlag, children, props } = vnode;
    const isReorder = moveType === 2;
    if (isReorder) {
      insert(el, container, parentAnchor);
    }
    if (!isReorder || isTeleportDisabled(props)) {
      if (shapeFlag & 16) {
        for (let i2 = 0; i2 < children.length; i2++) {
          move(
            children[i2],
            container,
            parentAnchor,
            2
          );
        }
      }
    }
    if (isReorder) {
      insert(anchor, container, parentAnchor);
    }
  }
  function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
    o: { nextSibling, parentNode, querySelector }
  }, hydrateChildren) {
    const target = vnode.target = resolveTarget(
      vnode.props,
      querySelector
    );
    if (target) {
      const targetNode = target._lpa || target.firstChild;
      if (vnode.shapeFlag & 16) {
        if (isTeleportDisabled(vnode.props)) {
          vnode.anchor = hydrateChildren(
            nextSibling(node),
            vnode,
            parentNode(node),
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
          vnode.targetAnchor = targetNode;
        } else {
          vnode.anchor = nextSibling(node);
          let targetAnchor = targetNode;
          while (targetAnchor) {
            targetAnchor = nextSibling(targetAnchor);
            if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
              vnode.targetAnchor = targetAnchor;
              target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
              break;
            }
          }
          hydrateChildren(
            targetNode,
            vnode,
            target,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
        }
      }
      updateCssVars(vnode);
    }
    return vnode.anchor && nextSibling(vnode.anchor);
  }
  const Teleport = TeleportImpl;
  function updateCssVars(vnode) {
    const ctx = vnode.ctx;
    if (ctx && ctx.ut) {
      let node = vnode.children[0].el;
      while (node && node !== vnode.targetAnchor) {
        if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
        node = node.nextSibling;
      }
      ctx.ut();
    }
  }
  let hasLoggedMismatchError = false;
  const logMismatchError = () => {
    if (hasLoggedMismatchError) {
      return;
    }
    console.error("Hydration completed but contains mismatches.");
    hasLoggedMismatchError = true;
  };
  const isSVGContainer = (container) => container.namespaceURI.includes("svg") && container.tagName !== "foreignObject";
  const isMathMLContainer = (container) => container.namespaceURI.includes("MathML");
  const getContainerType = (container) => {
    if (isSVGContainer(container)) return "svg";
    if (isMathMLContainer(container)) return "mathml";
    return void 0;
  };
  const isComment = (node) => node.nodeType === 8;
  function createHydrationFunctions(rendererInternals) {
    const {
      mt: mountComponent,
      p: patch,
      o: {
        patchProp: patchProp2,
        createText,
        nextSibling,
        parentNode,
        remove: remove2,
        insert,
        createComment
      }
    } = rendererInternals;
    const hydrate2 = (vnode, container) => {
      if (!container.hasChildNodes()) {
        patch(null, vnode, container);
        flushPostFlushCbs();
        container._vnode = vnode;
        return;
      }
      hydrateNode(container.firstChild, vnode, null, null, null);
      flushPostFlushCbs();
      container._vnode = vnode;
    };
    const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
      optimized = optimized || !!vnode.dynamicChildren;
      const isFragmentStart = isComment(node) && node.data === "[";
      const onMismatch = () => handleMismatch(
        node,
        vnode,
        parentComponent,
        parentSuspense,
        slotScopeIds,
        isFragmentStart
      );
      const { type, ref: ref3, shapeFlag, patchFlag } = vnode;
      let domType = node.nodeType;
      vnode.el = node;
      if (patchFlag === -2) {
        optimized = false;
        vnode.dynamicChildren = null;
      }
      let nextNode = null;
      switch (type) {
        case Text:
          if (domType !== 3) {
            if (vnode.children === "") {
              insert(vnode.el = createText(""), parentNode(node), node);
              nextNode = node;
            } else {
              nextNode = onMismatch();
            }
          } else {
            if (node.data !== vnode.children) {
              logMismatchError();
              node.data = vnode.children;
            }
            nextNode = nextSibling(node);
          }
          break;
        case Comment:
          if (isTemplateNode2(node)) {
            nextNode = nextSibling(node);
            replaceNode(
              vnode.el = node.content.firstChild,
              node,
              parentComponent
            );
          } else if (domType !== 8 || isFragmentStart) {
            nextNode = onMismatch();
          } else {
            nextNode = nextSibling(node);
          }
          break;
        case Static:
          if (isFragmentStart) {
            node = nextSibling(node);
            domType = node.nodeType;
          }
          if (domType === 1 || domType === 3) {
            nextNode = node;
            const needToAdoptContent = !vnode.children.length;
            for (let i2 = 0; i2 < vnode.staticCount; i2++) {
              if (needToAdoptContent)
                vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;
              if (i2 === vnode.staticCount - 1) {
                vnode.anchor = nextNode;
              }
              nextNode = nextSibling(nextNode);
            }
            return isFragmentStart ? nextSibling(nextNode) : nextNode;
          } else {
            onMismatch();
          }
          break;
        case Fragment:
          if (!isFragmentStart) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateFragment(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
          break;
        default:
          if (shapeFlag & 1) {
            if ((domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) && !isTemplateNode2(node)) {
              nextNode = onMismatch();
            } else {
              nextNode = hydrateElement(
                node,
                vnode,
                parentComponent,
                parentSuspense,
                slotScopeIds,
                optimized
              );
            }
          } else if (shapeFlag & 6) {
            vnode.slotScopeIds = slotScopeIds;
            const container = parentNode(node);
            if (isFragmentStart) {
              nextNode = locateClosingAnchor(node);
            } else if (isComment(node) && node.data === "teleport start") {
              nextNode = locateClosingAnchor(node, node.data, "teleport end");
            } else {
              nextNode = nextSibling(node);
            }
            mountComponent(
              vnode,
              container,
              null,
              parentComponent,
              parentSuspense,
              getContainerType(container),
              optimized
            );
            if (isAsyncWrapper(vnode)) {
              let subTree;
              if (isFragmentStart) {
                subTree = createVNode(Fragment);
                subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
              } else {
                subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
              }
              subTree.el = node;
              vnode.component.subTree = subTree;
            }
          } else if (shapeFlag & 64) {
            if (domType !== 8) {
              nextNode = onMismatch();
            } else {
              nextNode = vnode.type.hydrate(
                node,
                vnode,
                parentComponent,
                parentSuspense,
                slotScopeIds,
                optimized,
                rendererInternals,
                hydrateChildren
              );
            }
          } else if (shapeFlag & 128) {
            nextNode = vnode.type.hydrate(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              getContainerType(parentNode(node)),
              slotScopeIds,
              optimized,
              rendererInternals,
              hydrateNode
            );
          } else ;
      }
      if (ref3 != null) {
        setRef(ref3, null, parentSuspense, vnode);
      }
      return nextNode;
    };
    const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
      optimized = optimized || !!vnode.dynamicChildren;
      const { type, props, patchFlag, shapeFlag, dirs, transition } = vnode;
      const forcePatch = type === "input" || type === "option";
      if (forcePatch || patchFlag !== -1) {
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "created");
        }
        let needCallTransitionHooks = false;
        if (isTemplateNode2(el)) {
          needCallTransitionHooks = needTransition(parentSuspense, transition) && parentComponent && parentComponent.vnode.props && parentComponent.vnode.props.appear;
          const content = el.content.firstChild;
          if (needCallTransitionHooks) {
            transition.beforeEnter(content);
          }
          replaceNode(content, el, parentComponent);
          vnode.el = el = content;
        }
        if (shapeFlag & 16 && // skip if element has innerHTML / textContent
        !(props && (props.innerHTML || props.textContent))) {
          let next = hydrateChildren(
            el.firstChild,
            vnode,
            el,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
          while (next) {
            logMismatchError();
            const cur = next;
            next = next.nextSibling;
            remove2(cur);
          }
        } else if (shapeFlag & 8) {
          if (el.textContent !== vnode.children) {
            logMismatchError();
            el.textContent = vnode.children;
          }
        }
        if (props) {
          if (forcePatch || !optimized || patchFlag & (16 | 32)) {
            for (const key in props) {
              if (forcePatch && (key.endsWith("value") || key === "indeterminate") || isOn(key) && !isReservedProp(key) || // force hydrate v-bind with .prop modifiers
              key[0] === ".") {
                patchProp2(el, key, null, props[key], void 0, parentComponent);
              }
            }
          } else if (props.onClick) {
            patchProp2(
              el,
              "onClick",
              null,
              props.onClick,
              void 0,
              parentComponent
            );
          } else if (patchFlag & 4 && isReactive(props.style)) {
            for (const key in props.style) props.style[key];
          }
        }
        let vnodeHooks;
        if (vnodeHooks = props && props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHooks, parentComponent, vnode);
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        }
        if ((vnodeHooks = props && props.onVnodeMounted) || dirs || needCallTransitionHooks) {
          queueEffectWithSuspense(() => {
            vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
            needCallTransitionHooks && transition.enter(el);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
          }, parentSuspense);
        }
      }
      return el.nextSibling;
    };
    const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
      optimized = optimized || !!parentVNode.dynamicChildren;
      const children = parentVNode.children;
      const l2 = children.length;
      for (let i2 = 0; i2 < l2; i2++) {
        const vnode = optimized ? children[i2] : children[i2] = normalizeVNode(children[i2]);
        const isText = vnode.type === Text;
        if (node) {
          if (isText && !optimized) {
            let next = children[i2 + 1];
            if (next && (next = normalizeVNode(next)).type === Text) {
              insert(
                createText(
                  node.data.slice(vnode.children.length)
                ),
                container,
                nextSibling(node)
              );
              node.data = vnode.children;
            }
          }
          node = hydrateNode(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
        } else if (isText && !vnode.children) {
          insert(vnode.el = createText(""), container);
        } else {
          logMismatchError();
          patch(
            null,
            vnode,
            container,
            null,
            parentComponent,
            parentSuspense,
            getContainerType(container),
            slotScopeIds
          );
        }
      }
      return node;
    };
    const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
      const { slotScopeIds: fragmentSlotScopeIds } = vnode;
      if (fragmentSlotScopeIds) {
        slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
      }
      const container = parentNode(node);
      const next = hydrateChildren(
        nextSibling(node),
        vnode,
        container,
        parentComponent,
        parentSuspense,
        slotScopeIds,
        optimized
      );
      if (next && isComment(next) && next.data === "]") {
        return nextSibling(vnode.anchor = next);
      } else {
        logMismatchError();
        insert(vnode.anchor = createComment(`]`), container, next);
        return next;
      }
    };
    const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
      logMismatchError();
      vnode.el = null;
      if (isFragment) {
        const end = locateClosingAnchor(node);
        while (true) {
          const next2 = nextSibling(node);
          if (next2 && next2 !== end) {
            remove2(next2);
          } else {
            break;
          }
        }
      }
      const next = nextSibling(node);
      const container = parentNode(node);
      remove2(node);
      patch(
        null,
        vnode,
        container,
        next,
        parentComponent,
        parentSuspense,
        getContainerType(container),
        slotScopeIds
      );
      return next;
    };
    const locateClosingAnchor = (node, open = "[", close = "]") => {
      let match = 0;
      while (node) {
        node = nextSibling(node);
        if (node && isComment(node)) {
          if (node.data === open) match++;
          if (node.data === close) {
            if (match === 0) {
              return nextSibling(node);
            } else {
              match--;
            }
          }
        }
      }
      return node;
    };
    const replaceNode = (newNode, oldNode, parentComponent) => {
      const parentNode2 = oldNode.parentNode;
      if (parentNode2) {
        parentNode2.replaceChild(newNode, oldNode);
      }
      let parent = parentComponent;
      while (parent) {
        if (parent.vnode.el === oldNode) {
          parent.vnode.el = parent.subTree.el = newNode;
        }
        parent = parent.parent;
      }
    };
    const isTemplateNode2 = (node) => {
      return node.nodeType === 1 && node.tagName.toLowerCase() === "template";
    };
    return [hydrate2, hydrateNode];
  }
  const queuePostRenderEffect = queueEffectWithSuspense;
  function createRenderer(options) {
    return baseCreateRenderer(options);
  }
  function createHydrationRenderer(options) {
    return baseCreateRenderer(options, createHydrationFunctions);
  }
  function baseCreateRenderer(options, createHydrationFns) {
    const target = getGlobalThis();
    target.__VUE__ = true;
    const {
      insert: hostInsert,
      remove: hostRemove,
      patchProp: hostPatchProp,
      createElement: hostCreateElement,
      createText: hostCreateText,
      createComment: hostCreateComment,
      setText: hostSetText,
      setElementText: hostSetElementText,
      parentNode: hostParentNode,
      nextSibling: hostNextSibling,
      setScopeId: hostSetScopeId = NOOP,
      insertStaticContent: hostInsertStaticContent
    } = options;
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
      if (n1 === n2) {
        return;
      }
      if (n1 && !isSameVNodeType(n1, n2)) {
        anchor = getNextHostNode(n1);
        unmount(n1, parentComponent, parentSuspense, true);
        n1 = null;
      }
      if (n2.patchFlag === -2) {
        optimized = false;
        n2.dynamicChildren = null;
      }
      const { type, ref: ref3, shapeFlag } = n2;
      switch (type) {
        case Text:
          processText(n1, n2, container, anchor);
          break;
        case Comment:
          processCommentNode(n1, n2, container, anchor);
          break;
        case Static:
          if (n1 == null) {
            mountStaticNode(n2, container, anchor, namespace);
          }
          break;
        case Fragment:
          processFragment(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          break;
        default:
          if (shapeFlag & 1) {
            processElement(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 6) {
            processComponent(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 64) {
            type.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          } else if (shapeFlag & 128) {
            type.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          } else ;
      }
      if (ref3 != null && parentComponent) {
        setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
      }
    };
    const processText = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n2.el = hostCreateText(n2.children),
          container,
          anchor
        );
      } else {
        const el = n2.el = n1.el;
        if (n2.children !== n1.children) {
          hostSetText(el, n2.children);
        }
      }
    };
    const processCommentNode = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n2.el = hostCreateComment(n2.children || ""),
          container,
          anchor
        );
      } else {
        n2.el = n1.el;
      }
    };
    const mountStaticNode = (n2, container, anchor, namespace) => {
      [n2.el, n2.anchor] = hostInsertStaticContent(
        n2.children,
        container,
        anchor,
        namespace,
        n2.el,
        n2.anchor
      );
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostInsert(el, container, nextSibling);
        el = next;
      }
      hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor }) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostRemove(el);
        el = next;
      }
      hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      if (n2.type === "svg") {
        namespace = "svg";
      } else if (n2.type === "math") {
        namespace = "mathml";
      }
      if (n1 == null) {
        mountElement(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        patchElement(
          n1,
          n2,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      let el;
      let vnodeHook;
      const { props, shapeFlag, transition, dirs } = vnode;
      el = vnode.el = hostCreateElement(
        vnode.type,
        namespace,
        props && props.is,
        props
      );
      if (shapeFlag & 8) {
        hostSetElementText(el, vnode.children);
      } else if (shapeFlag & 16) {
        mountChildren(
          vnode.children,
          el,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(vnode, namespace),
          slotScopeIds,
          optimized
        );
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
      if (props) {
        for (const key in props) {
          if (key !== "value" && !isReservedProp(key)) {
            hostPatchProp(el, key, null, props[key], namespace, parentComponent);
          }
        }
        if ("value" in props) {
          hostPatchProp(el, "value", null, props.value, namespace);
        }
        if (vnodeHook = props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      const needCallTransitionHooks = needTransition(parentSuspense, transition);
      if (needCallTransitionHooks) {
        transition.beforeEnter(el);
      }
      hostInsert(el, container, anchor);
      if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
      if (scopeId) {
        hostSetScopeId(el, scopeId);
      }
      if (slotScopeIds) {
        for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
          hostSetScopeId(el, slotScopeIds[i2]);
        }
      }
      if (parentComponent) {
        let subTree = parentComponent.subTree;
        if (vnode === subTree) {
          const parentVNode = parentComponent.vnode;
          setScopeId(
            el,
            parentVNode,
            parentVNode.scopeId,
            parentVNode.slotScopeIds,
            parentComponent.parent
          );
        }
      }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
      for (let i2 = start; i2 < children.length; i2++) {
        const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
        patch(
          null,
          child,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      const el = n2.el = n1.el;
      let { patchFlag, dynamicChildren, dirs } = n2;
      patchFlag |= n1.patchFlag & 16;
      const oldProps = n1.props || EMPTY_OBJ;
      const newProps = n2.props || EMPTY_OBJ;
      let vnodeHook;
      parentComponent && toggleRecurse(parentComponent, false);
      if (vnodeHook = newProps.onVnodeBeforeUpdate) {
        invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
      }
      if (dirs) {
        invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
      }
      parentComponent && toggleRecurse(parentComponent, true);
      if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
        hostSetElementText(el, "");
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          el,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n2, namespace),
          slotScopeIds
        );
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          el,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n2, namespace),
          slotScopeIds,
          false
        );
      }
      if (patchFlag > 0) {
        if (patchFlag & 16) {
          patchProps(el, oldProps, newProps, parentComponent, namespace);
        } else {
          if (patchFlag & 2) {
            if (oldProps.class !== newProps.class) {
              hostPatchProp(el, "class", null, newProps.class, namespace);
            }
          }
          if (patchFlag & 4) {
            hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
          }
          if (patchFlag & 8) {
            const propsToUpdate = n2.dynamicProps;
            for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
              const key = propsToUpdate[i2];
              const prev = oldProps[key];
              const next = newProps[key];
              if (next !== prev || key === "value") {
                hostPatchProp(el, key, prev, next, namespace, parentComponent);
              }
            }
          }
        }
        if (patchFlag & 1) {
          if (n1.children !== n2.children) {
            hostSetElementText(el, n2.children);
          }
        }
      } else if (!optimized && dynamicChildren == null) {
        patchProps(el, oldProps, newProps, parentComponent, namespace);
      }
      if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
          dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
        }, parentSuspense);
      }
    };
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
      for (let i2 = 0; i2 < newChildren.length; i2++) {
        const oldVNode = oldChildren[i2];
        const newVNode = newChildren[i2];
        const container = (
          // oldVNode may be an errored async setup() component inside Suspense
          // which will not have a mounted element
          oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
          // of the Fragment itself so it can move its children.
          (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
          // which also requires the correct parent container
          !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
          oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
            // In other cases, the parent container is not actually used so we
            // just pass the block element here to avoid a DOM parentNode call.
            fallbackContainer
          )
        );
        patch(
          oldVNode,
          newVNode,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          true
        );
      }
    };
    const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
      if (oldProps !== newProps) {
        if (oldProps !== EMPTY_OBJ) {
          for (const key in oldProps) {
            if (!isReservedProp(key) && !(key in newProps)) {
              hostPatchProp(
                el,
                key,
                oldProps[key],
                null,
                namespace,
                parentComponent
              );
            }
          }
        }
        for (const key in newProps) {
          if (isReservedProp(key)) continue;
          const next = newProps[key];
          const prev = oldProps[key];
          if (next !== prev && key !== "value") {
            hostPatchProp(el, key, prev, next, namespace, parentComponent);
          }
        }
        if ("value" in newProps) {
          hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
        }
      }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
      const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
      let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
      if (fragmentSlotScopeIds) {
        slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
      }
      if (n1 == null) {
        hostInsert(fragmentStartAnchor, container, anchor);
        hostInsert(fragmentEndAnchor, container, anchor);
        mountChildren(
          // #10007
          // such fragment like `<></>` will be compiled into
          // a fragment which doesn't have a children.
          // In this case fallback to an empty array
          n2.children || [],
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
        // of renderSlot() with no valid children
        n1.dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            container,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds
          );
          if (
            // #2080 if the stable fragment has a key, it's a <template v-for> that may
            //  get moved around. Make sure all root level vnodes inherit el.
            // #2134 or if it's a component root, it may also get moved around
            // as the component is being moved.
            n2.key != null || parentComponent && n2 === parentComponent.subTree
          ) {
            traverseStaticChildren(
              n1,
              n2,
              true
              /* shallow */
            );
          }
        } else {
          patchChildren(
            n1,
            n2,
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      n2.slotScopeIds = slotScopeIds;
      if (n1 == null) {
        if (n2.shapeFlag & 512) {
          parentComponent.ctx.activate(
            n2,
            container,
            anchor,
            namespace,
            optimized
          );
        } else {
          mountComponent(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            optimized
          );
        }
      } else {
        updateComponent(n1, n2, optimized);
      }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
      const instance = initialVNode.component = createComponentInstance(
        initialVNode,
        parentComponent,
        parentSuspense
      );
      if (isKeepAlive(initialVNode)) {
        instance.ctx.renderer = internals;
      }
      {
        setupComponent(instance, false, optimized);
      }
      if (instance.asyncDep) {
        parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
        if (!initialVNode.el) {
          const placeholder = instance.subTree = createVNode(Comment);
          processCommentNode(null, placeholder, container, anchor);
        }
      } else {
        setupRenderEffect(
          instance,
          initialVNode,
          container,
          anchor,
          parentSuspense,
          namespace,
          optimized
        );
      }
    };
    const updateComponent = (n1, n2, optimized) => {
      const instance = n2.component = n1.component;
      if (shouldUpdateComponent(n1, n2, optimized)) {
        if (instance.asyncDep && !instance.asyncResolved) {
          updateComponentPreRender(instance, n2, optimized);
          return;
        } else {
          instance.next = n2;
          invalidateJob(instance.update);
          instance.effect.dirty = true;
          instance.update();
        }
      } else {
        n2.el = n1.el;
        instance.vnode = n2;
      }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
      const componentUpdateFn = () => {
        if (!instance.isMounted) {
          let vnodeHook;
          const { el, props } = initialVNode;
          const { bm, m: m2, parent } = instance;
          const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
          toggleRecurse(instance, false);
          if (bm) {
            invokeArrayFns(bm);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
            invokeVNodeHook(vnodeHook, parent, initialVNode);
          }
          toggleRecurse(instance, true);
          if (el && hydrateNode) {
            const hydrateSubTree = () => {
              instance.subTree = renderComponentRoot(instance);
              hydrateNode(
                el,
                instance.subTree,
                instance,
                parentSuspense,
                null
              );
            };
            if (isAsyncWrapperVNode) {
              initialVNode.type.__asyncLoader().then(
                // note: we are moving the render call into an async callback,
                // which means it won't track dependencies - but it's ok because
                // a server-rendered async wrapper is already in resolved state
                // and it will never need to change.
                () => !instance.isUnmounted && hydrateSubTree()
              );
            } else {
              hydrateSubTree();
            }
          } else {
            const subTree = instance.subTree = renderComponentRoot(instance);
            patch(
              null,
              subTree,
              container,
              anchor,
              instance,
              parentSuspense,
              namespace
            );
            initialVNode.el = subTree.el;
          }
          if (m2) {
            queuePostRenderEffect(m2, parentSuspense);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
            const scopedInitialVNode = initialVNode;
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
              parentSuspense
            );
          }
          if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
            instance.a && queuePostRenderEffect(instance.a, parentSuspense);
          }
          instance.isMounted = true;
          initialVNode = container = anchor = null;
        } else {
          let { next, bu, u: u2, parent, vnode } = instance;
          {
            const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
            if (nonHydratedAsyncRoot) {
              if (next) {
                next.el = vnode.el;
                updateComponentPreRender(instance, next, optimized);
              }
              nonHydratedAsyncRoot.asyncDep.then(() => {
                if (!instance.isUnmounted) {
                  componentUpdateFn();
                }
              });
              return;
            }
          }
          let originNext = next;
          let vnodeHook;
          toggleRecurse(instance, false);
          if (next) {
            next.el = vnode.el;
            updateComponentPreRender(instance, next, optimized);
          } else {
            next = vnode;
          }
          if (bu) {
            invokeArrayFns(bu);
          }
          if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parent, next, vnode);
          }
          toggleRecurse(instance, true);
          const nextTree = renderComponentRoot(instance);
          const prevTree = instance.subTree;
          instance.subTree = nextTree;
          patch(
            prevTree,
            nextTree,
            // parent may have changed if it's in a teleport
            hostParentNode(prevTree.el),
            // anchor may have changed if it's in a fragment
            getNextHostNode(prevTree),
            instance,
            parentSuspense,
            namespace
          );
          next.el = nextTree.el;
          if (originNext === null) {
            updateHOCHostEl(instance, nextTree.el);
          }
          if (u2) {
            queuePostRenderEffect(u2, parentSuspense);
          }
          if (vnodeHook = next.props && next.props.onVnodeUpdated) {
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent, next, vnode),
              parentSuspense
            );
          }
        }
      };
      const effect2 = instance.effect = new ReactiveEffect(
        componentUpdateFn,
        NOOP,
        () => queueJob(update),
        instance.scope
        // track it in component's effect scope
      );
      const update = instance.update = () => {
        if (effect2.dirty) {
          effect2.run();
        }
      };
      update.i = instance;
      update.id = instance.uid;
      toggleRecurse(instance, true);
      update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
      nextVNode.component = instance;
      const prevProps = instance.vnode.props;
      instance.vnode = nextVNode;
      instance.next = null;
      updateProps(instance, nextVNode.props, prevProps, optimized);
      updateSlots(instance, nextVNode.children, optimized);
      pauseTracking();
      flushPreFlushCbs(instance);
      resetTracking();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
      const c1 = n1 && n1.children;
      const prevShapeFlag = n1 ? n1.shapeFlag : 0;
      const c2 = n2.children;
      const { patchFlag, shapeFlag } = n2;
      if (patchFlag > 0) {
        if (patchFlag & 128) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          return;
        } else if (patchFlag & 256) {
          patchUnkeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          return;
        }
      }
      if (shapeFlag & 8) {
        if (prevShapeFlag & 16) {
          unmountChildren(c1, parentComponent, parentSuspense);
        }
        if (c2 !== c1) {
          hostSetElementText(container, c2);
        }
      } else {
        if (prevShapeFlag & 16) {
          if (shapeFlag & 16) {
            patchKeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            unmountChildren(c1, parentComponent, parentSuspense, true);
          }
        } else {
          if (prevShapeFlag & 8) {
            hostSetElementText(container, "");
          }
          if (shapeFlag & 16) {
            mountChildren(
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        }
      }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      c1 = c1 || EMPTY_ARR;
      c2 = c2 || EMPTY_ARR;
      const oldLength = c1.length;
      const newLength = c2.length;
      const commonLength = Math.min(oldLength, newLength);
      let i2;
      for (i2 = 0; i2 < commonLength; i2++) {
        const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
        patch(
          c1[i2],
          nextChild,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
      if (oldLength > newLength) {
        unmountChildren(
          c1,
          parentComponent,
          parentSuspense,
          true,
          false,
          commonLength
        );
      } else {
        mountChildren(
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized,
          commonLength
        );
      }
    };
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      let i2 = 0;
      const l2 = c2.length;
      let e1 = c1.length - 1;
      let e2 = l2 - 1;
      while (i2 <= e1 && i2 <= e2) {
        const n1 = c1[i2];
        const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
        if (isSameVNodeType(n1, n2)) {
          patch(
            n1,
            n2,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        i2++;
      }
      while (i2 <= e1 && i2 <= e2) {
        const n1 = c1[e1];
        const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
        if (isSameVNodeType(n1, n2)) {
          patch(
            n1,
            n2,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        e1--;
        e2--;
      }
      if (i2 > e1) {
        if (i2 <= e2) {
          const nextPos = e2 + 1;
          const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
          while (i2 <= e2) {
            patch(
              null,
              c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]),
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            i2++;
          }
        }
      } else if (i2 > e2) {
        while (i2 <= e1) {
          unmount(c1[i2], parentComponent, parentSuspense, true);
          i2++;
        }
      } else {
        const s1 = i2;
        const s2 = i2;
        const keyToNewIndexMap = /* @__PURE__ */ new Map();
        for (i2 = s2; i2 <= e2; i2++) {
          const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
          if (nextChild.key != null) {
            keyToNewIndexMap.set(nextChild.key, i2);
          }
        }
        let j2;
        let patched = 0;
        const toBePatched = e2 - s2 + 1;
        let moved = false;
        let maxNewIndexSoFar = 0;
        const newIndexToOldIndexMap = new Array(toBePatched);
        for (i2 = 0; i2 < toBePatched; i2++) newIndexToOldIndexMap[i2] = 0;
        for (i2 = s1; i2 <= e1; i2++) {
          const prevChild = c1[i2];
          if (patched >= toBePatched) {
            unmount(prevChild, parentComponent, parentSuspense, true);
            continue;
          }
          let newIndex;
          if (prevChild.key != null) {
            newIndex = keyToNewIndexMap.get(prevChild.key);
          } else {
            for (j2 = s2; j2 <= e2; j2++) {
              if (newIndexToOldIndexMap[j2 - s2] === 0 && isSameVNodeType(prevChild, c2[j2])) {
                newIndex = j2;
                break;
              }
            }
          }
          if (newIndex === void 0) {
            unmount(prevChild, parentComponent, parentSuspense, true);
          } else {
            newIndexToOldIndexMap[newIndex - s2] = i2 + 1;
            if (newIndex >= maxNewIndexSoFar) {
              maxNewIndexSoFar = newIndex;
            } else {
              moved = true;
            }
            patch(
              prevChild,
              c2[newIndex],
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            patched++;
          }
        }
        const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
        j2 = increasingNewIndexSequence.length - 1;
        for (i2 = toBePatched - 1; i2 >= 0; i2--) {
          const nextIndex = s2 + i2;
          const nextChild = c2[nextIndex];
          const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
          if (newIndexToOldIndexMap[i2] === 0) {
            patch(
              null,
              nextChild,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (moved) {
            if (j2 < 0 || i2 !== increasingNewIndexSequence[j2]) {
              move(nextChild, container, anchor, 2);
            } else {
              j2--;
            }
          }
        }
      }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
      const { el, type, transition, children, shapeFlag } = vnode;
      if (shapeFlag & 6) {
        move(vnode.component.subTree, container, anchor, moveType);
        return;
      }
      if (shapeFlag & 128) {
        vnode.suspense.move(container, anchor, moveType);
        return;
      }
      if (shapeFlag & 64) {
        type.move(vnode, container, anchor, internals);
        return;
      }
      if (type === Fragment) {
        hostInsert(el, container, anchor);
        for (let i2 = 0; i2 < children.length; i2++) {
          move(children[i2], container, anchor, moveType);
        }
        hostInsert(vnode.anchor, container, anchor);
        return;
      }
      if (type === Static) {
        moveStaticNode(vnode, container, anchor);
        return;
      }
      const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
      if (needTransition2) {
        if (moveType === 0) {
          transition.beforeEnter(el);
          hostInsert(el, container, anchor);
          queuePostRenderEffect(() => transition.enter(el), parentSuspense);
        } else {
          const { leave, delayLeave, afterLeave } = transition;
          const remove22 = () => hostInsert(el, container, anchor);
          const performLeave = () => {
            leave(el, () => {
              remove22();
              afterLeave && afterLeave();
            });
          };
          if (delayLeave) {
            delayLeave(el, remove22, performLeave);
          } else {
            performLeave();
          }
        }
      } else {
        hostInsert(el, container, anchor);
      }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
      const {
        type,
        props,
        ref: ref3,
        children,
        dynamicChildren,
        shapeFlag,
        patchFlag,
        dirs,
        cacheIndex
      } = vnode;
      if (patchFlag === -2) {
        optimized = false;
      }
      if (ref3 != null) {
        setRef(ref3, null, parentSuspense, vnode, true);
      }
      if (cacheIndex != null) {
        parentComponent.renderCache[cacheIndex] = void 0;
      }
      if (shapeFlag & 256) {
        parentComponent.ctx.deactivate(vnode);
        return;
      }
      const shouldInvokeDirs = shapeFlag & 1 && dirs;
      const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
      let vnodeHook;
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
      if (shapeFlag & 6) {
        unmountComponent(vnode.component, parentSuspense, doRemove);
      } else {
        if (shapeFlag & 128) {
          vnode.suspense.unmount(parentSuspense, doRemove);
          return;
        }
        if (shouldInvokeDirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
        }
        if (shapeFlag & 64) {
          vnode.type.remove(
            vnode,
            parentComponent,
            parentSuspense,
            internals,
            doRemove
          );
        } else if (dynamicChildren && // #5154
        // when v-once is used inside a block, setBlockTracking(-1) marks the
        // parent block with hasOnce: true
        // so that it doesn't take the fast path during unmount - otherwise
        // components nested in v-once are never unmounted.
        !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
        (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
          unmountChildren(
            dynamicChildren,
            parentComponent,
            parentSuspense,
            false,
            true
          );
        } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
          unmountChildren(children, parentComponent, parentSuspense);
        }
        if (doRemove) {
          remove2(vnode);
        }
      }
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
        }, parentSuspense);
      }
    };
    const remove2 = (vnode) => {
      const { type, el, anchor, transition } = vnode;
      if (type === Fragment) {
        {
          removeFragment(el, anchor);
        }
        return;
      }
      if (type === Static) {
        removeStaticNode(vnode);
        return;
      }
      const performRemove = () => {
        hostRemove(el);
        if (transition && !transition.persisted && transition.afterLeave) {
          transition.afterLeave();
        }
      };
      if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
        const { leave, delayLeave } = transition;
        const performLeave = () => leave(el, performRemove);
        if (delayLeave) {
          delayLeave(vnode.el, performRemove, performLeave);
        } else {
          performLeave();
        }
      } else {
        performRemove();
      }
    };
    const removeFragment = (cur, end) => {
      let next;
      while (cur !== end) {
        next = hostNextSibling(cur);
        hostRemove(cur);
        cur = next;
      }
      hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
      const { bum, scope, update, subTree, um, m: m2, a: a2 } = instance;
      invalidateMount(m2);
      invalidateMount(a2);
      if (bum) {
        invokeArrayFns(bum);
      }
      scope.stop();
      if (update) {
        update.active = false;
        unmount(subTree, instance, parentSuspense, doRemove);
      }
      if (um) {
        queuePostRenderEffect(um, parentSuspense);
      }
      queuePostRenderEffect(() => {
        instance.isUnmounted = true;
      }, parentSuspense);
      if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
        parentSuspense.deps--;
        if (parentSuspense.deps === 0) {
          parentSuspense.resolve();
        }
      }
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
      for (let i2 = start; i2 < children.length; i2++) {
        unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
      }
    };
    const getNextHostNode = (vnode) => {
      if (vnode.shapeFlag & 6) {
        return getNextHostNode(vnode.component.subTree);
      }
      if (vnode.shapeFlag & 128) {
        return vnode.suspense.next();
      }
      const el = hostNextSibling(vnode.anchor || vnode.el);
      const teleportEnd = el && el[TeleportEndKey];
      return teleportEnd ? hostNextSibling(teleportEnd) : el;
    };
    let isFlushing2 = false;
    const render2 = (vnode, container, namespace) => {
      if (vnode == null) {
        if (container._vnode) {
          unmount(container._vnode, null, null, true);
        }
      } else {
        patch(
          container._vnode || null,
          vnode,
          container,
          null,
          null,
          null,
          namespace
        );
      }
      if (!isFlushing2) {
        isFlushing2 = true;
        flushPreFlushCbs();
        flushPostFlushCbs();
        isFlushing2 = false;
      }
      container._vnode = vnode;
    };
    const internals = {
      p: patch,
      um: unmount,
      m: move,
      r: remove2,
      mt: mountComponent,
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      n: getNextHostNode,
      o: options
    };
    let hydrate2;
    let hydrateNode;
    if (createHydrationFns) {
      [hydrate2, hydrateNode] = createHydrationFns(
        internals
      );
    }
    return {
      render: render2,
      hydrate: hydrate2,
      createApp: createAppAPI(render2, hydrate2)
    };
  }
  function resolveChildrenNamespace({ type, props }, currentNamespace) {
    return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
  }
  function toggleRecurse({ effect: effect2, update }, allowed) {
    effect2.allowRecurse = update.allowRecurse = allowed;
  }
  function needTransition(parentSuspense, transition) {
    return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
  }
  function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if (isArray$2(ch1) && isArray$2(ch2)) {
      for (let i2 = 0; i2 < ch1.length; i2++) {
        const c1 = ch1[i2];
        let c2 = ch2[i2];
        if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
          if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
            c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
            c2.el = c1.el;
          }
          if (!shallow && c2.patchFlag !== -2)
            traverseStaticChildren(c1, c2);
        }
        if (c2.type === Text) {
          c2.el = c1.el;
        }
      }
    }
  }
  function getSequence(arr) {
    const p2 = arr.slice();
    const result = [0];
    let i2, j2, u2, v2, c2;
    const len = arr.length;
    for (i2 = 0; i2 < len; i2++) {
      const arrI = arr[i2];
      if (arrI !== 0) {
        j2 = result[result.length - 1];
        if (arr[j2] < arrI) {
          p2[i2] = j2;
          result.push(i2);
          continue;
        }
        u2 = 0;
        v2 = result.length - 1;
        while (u2 < v2) {
          c2 = u2 + v2 >> 1;
          if (arr[result[c2]] < arrI) {
            u2 = c2 + 1;
          } else {
            v2 = c2;
          }
        }
        if (arrI < arr[result[u2]]) {
          if (u2 > 0) {
            p2[i2] = result[u2 - 1];
          }
          result[u2] = i2;
        }
      }
    }
    u2 = result.length;
    v2 = result[u2 - 1];
    while (u2-- > 0) {
      result[u2] = v2;
      v2 = p2[v2];
    }
    return result;
  }
  function locateNonHydratedAsyncRoot(instance) {
    const subComponent = instance.subTree.component;
    if (subComponent) {
      if (subComponent.asyncDep && !subComponent.asyncResolved) {
        return subComponent;
      } else {
        return locateNonHydratedAsyncRoot(subComponent);
      }
    }
  }
  function invalidateMount(hooks) {
    if (hooks) {
      for (let i2 = 0; i2 < hooks.length; i2++) hooks[i2].active = false;
    }
  }
  const ssrContextKey = Symbol.for("v-scx");
  const useSSRContext = () => {
    {
      const ctx = inject(ssrContextKey);
      return ctx;
    }
  };
  function watchEffect(effect2, options) {
    return doWatch(effect2, null, options);
  }
  function watchPostEffect(effect2, options) {
    return doWatch(
      effect2,
      null,
      { flush: "post" }
    );
  }
  function watchSyncEffect(effect2, options) {
    return doWatch(
      effect2,
      null,
      { flush: "sync" }
    );
  }
  const INITIAL_WATCHER_VALUE = {};
  function watch(source, cb, options) {
    return doWatch(source, cb, options);
  }
  function doWatch(source, cb, {
    immediate,
    deep,
    flush,
    once,
    onTrack,
    onTrigger
  } = EMPTY_OBJ) {
    if (cb && once) {
      const _cb = cb;
      cb = (...args) => {
        _cb(...args);
        unwatch();
      };
    }
    const instance = currentInstance;
    const reactiveGetter = (source2) => deep === true ? source2 : (
      // for deep: false, only traverse root-level properties
      traverse(source2, deep === false ? 1 : void 0)
    );
    let getter;
    let forceTrigger = false;
    let isMultiSource = false;
    if (isRef(source)) {
      getter = () => source.value;
      forceTrigger = isShallow(source);
    } else if (isReactive(source)) {
      getter = () => reactiveGetter(source);
      forceTrigger = true;
    } else if (isArray$2(source)) {
      isMultiSource = true;
      forceTrigger = source.some((s2) => isReactive(s2) || isShallow(s2));
      getter = () => source.map((s2) => {
        if (isRef(s2)) {
          return s2.value;
        } else if (isReactive(s2)) {
          return reactiveGetter(s2);
        } else if (isFunction$1(s2)) {
          return callWithErrorHandling(s2, instance, 2);
        } else ;
      });
    } else if (isFunction$1(source)) {
      if (cb) {
        getter = () => callWithErrorHandling(source, instance, 2);
      } else {
        getter = () => {
          if (cleanup) {
            cleanup();
          }
          return callWithAsyncErrorHandling(
            source,
            instance,
            3,
            [onCleanup]
          );
        };
      }
    } else {
      getter = NOOP;
    }
    if (cb && deep) {
      const baseGetter = getter;
      getter = () => traverse(baseGetter());
    }
    let cleanup;
    let onCleanup = (fn2) => {
      cleanup = effect2.onStop = () => {
        callWithErrorHandling(fn2, instance, 4);
        cleanup = effect2.onStop = void 0;
      };
    };
    let ssrCleanup;
    if (isInSSRComponentSetup) {
      onCleanup = NOOP;
      if (!cb) {
        getter();
      } else if (immediate) {
        callWithAsyncErrorHandling(cb, instance, 3, [
          getter(),
          isMultiSource ? [] : void 0,
          onCleanup
        ]);
      }
      if (flush === "sync") {
        const ctx = useSSRContext();
        ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
      } else {
        return NOOP;
      }
    }
    let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
    const job = () => {
      if (!effect2.active || !effect2.dirty) {
        return;
      }
      if (cb) {
        const newValue = effect2.run();
        if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i2) => hasChanged(v2, oldValue[i2])) : hasChanged(newValue, oldValue)) || false) {
          if (cleanup) {
            cleanup();
          }
          callWithAsyncErrorHandling(cb, instance, 3, [
            newValue,
            // pass undefined as the old value when it's changed for the first time
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
            onCleanup
          ]);
          oldValue = newValue;
        }
      } else {
        effect2.run();
      }
    };
    job.allowRecurse = !!cb;
    let scheduler;
    if (flush === "sync") {
      scheduler = job;
    } else if (flush === "post") {
      scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
    } else {
      job.pre = true;
      if (instance) job.id = instance.uid;
      scheduler = () => queueJob(job);
    }
    const effect2 = new ReactiveEffect(getter, NOOP, scheduler);
    const scope = getCurrentScope();
    const unwatch = () => {
      effect2.stop();
      if (scope) {
        remove(scope.effects, effect2);
      }
    };
    if (cb) {
      if (immediate) {
        job();
      } else {
        oldValue = effect2.run();
      }
    } else if (flush === "post") {
      queuePostRenderEffect(
        effect2.run.bind(effect2),
        instance && instance.suspense
      );
    } else {
      effect2.run();
    }
    if (ssrCleanup) ssrCleanup.push(unwatch);
    return unwatch;
  }
  function instanceWatch(source, value, options) {
    const publicThis = this.proxy;
    const getter = isString$1(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
    let cb;
    if (isFunction$1(value)) {
      cb = value;
    } else {
      cb = value.handler;
      options = value;
    }
    const reset2 = setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    reset2();
    return res;
  }
  function createPathGetter(ctx, path) {
    const segments = path.split(".");
    return () => {
      let cur = ctx;
      for (let i2 = 0; i2 < segments.length && cur; i2++) {
        cur = cur[segments[i2]];
      }
      return cur;
    };
  }
  function traverse(value, depth = Infinity, seen2) {
    if (depth <= 0 || !isObject$1(value) || value["__v_skip"]) {
      return value;
    }
    seen2 = seen2 || /* @__PURE__ */ new Set();
    if (seen2.has(value)) {
      return value;
    }
    seen2.add(value);
    depth--;
    if (isRef(value)) {
      traverse(value.value, depth, seen2);
    } else if (isArray$2(value)) {
      for (let i2 = 0; i2 < value.length; i2++) {
        traverse(value[i2], depth, seen2);
      }
    } else if (isSet(value) || isMap(value)) {
      value.forEach((v2) => {
        traverse(v2, depth, seen2);
      });
    } else if (isPlainObject$2(value)) {
      for (const key in value) {
        traverse(value[key], depth, seen2);
      }
      for (const key of Object.getOwnPropertySymbols(value)) {
        if (Object.prototype.propertyIsEnumerable.call(value, key)) {
          traverse(value[key], depth, seen2);
        }
      }
    }
    return value;
  }
  function useModel(props, name, options = EMPTY_OBJ) {
    const i2 = getCurrentInstance();
    const camelizedName = camelize(name);
    const hyphenatedName = hyphenate(name);
    const modifiers = getModelModifiers(props, name);
    const res = customRef((track2, trigger2) => {
      let localValue;
      let prevSetValue;
      let prevEmittedValue;
      watchSyncEffect(() => {
        const propValue = props[name];
        if (hasChanged(localValue, propValue)) {
          localValue = propValue;
          trigger2();
        }
      });
      return {
        get() {
          track2();
          return options.get ? options.get(localValue) : localValue;
        },
        set(value) {
          if (!hasChanged(value, localValue)) {
            return;
          }
          const rawProps = i2.vnode.props;
          if (!(rawProps && // check if parent has passed v-model
          (name in rawProps || camelizedName in rawProps || hyphenatedName in rawProps) && (`onUpdate:${name}` in rawProps || `onUpdate:${camelizedName}` in rawProps || `onUpdate:${hyphenatedName}` in rawProps))) {
            localValue = value;
            trigger2();
          }
          const emittedValue = options.set ? options.set(value) : value;
          i2.emit(`update:${name}`, emittedValue);
          if (value !== emittedValue && value !== prevSetValue && emittedValue === prevEmittedValue) {
            trigger2();
          }
          prevSetValue = value;
          prevEmittedValue = emittedValue;
        }
      };
    });
    res[Symbol.iterator] = () => {
      let i22 = 0;
      return {
        next() {
          if (i22 < 2) {
            return { value: i22++ ? modifiers || EMPTY_OBJ : res, done: false };
          } else {
            return { done: true };
          }
        }
      };
    };
    return res;
  }
  const getModelModifiers = (props, modelName) => {
    return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
  };
  function emit(instance, event, ...rawArgs) {
    if (instance.isUnmounted) return;
    const props = instance.vnode.props || EMPTY_OBJ;
    let args = rawArgs;
    const isModelListener2 = event.startsWith("update:");
    const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
    if (modifiers) {
      if (modifiers.trim) {
        args = rawArgs.map((a2) => isString$1(a2) ? a2.trim() : a2);
      }
      if (modifiers.number) {
        args = rawArgs.map(looseToNumber);
      }
    }
    let handlerName;
    let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
    props[handlerName = toHandlerKey(camelize(event))];
    if (!handler && isModelListener2) {
      handler = props[handlerName = toHandlerKey(hyphenate(event))];
    }
    if (handler) {
      callWithAsyncErrorHandling(
        handler,
        instance,
        6,
        args
      );
    }
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
      if (!instance.emitted) {
        instance.emitted = {};
      } else if (instance.emitted[handlerName]) {
        return;
      }
      instance.emitted[handlerName] = true;
      callWithAsyncErrorHandling(
        onceHandler,
        instance,
        6,
        args
      );
    }
  }
  function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache2 = appContext.emitsCache;
    const cached = cache2.get(comp);
    if (cached !== void 0) {
      return cached;
    }
    const raw = comp.emits;
    let normalized = {};
    let hasExtends = false;
    if (!isFunction$1(comp)) {
      const extendEmits = (raw2) => {
        const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
        if (normalizedFromExtend) {
          hasExtends = true;
          extend$1(normalized, normalizedFromExtend);
        }
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendEmits);
      }
      if (comp.extends) {
        extendEmits(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendEmits);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject$1(comp)) {
        cache2.set(comp, null);
      }
      return null;
    }
    if (isArray$2(raw)) {
      raw.forEach((key) => normalized[key] = null);
    } else {
      extend$1(normalized, raw);
    }
    if (isObject$1(comp)) {
      cache2.set(comp, normalized);
    }
    return normalized;
  }
  function isEmitListener(options, key) {
    if (!options || !isOn(key)) {
      return false;
    }
    key = key.slice(2).replace(/Once$/, "");
    return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
  }
  function markAttrsAccessed() {
  }
  function renderComponentRoot(instance) {
    const {
      type: Component,
      vnode,
      proxy,
      withProxy,
      propsOptions: [propsOptions],
      slots,
      attrs,
      emit: emit2,
      render: render2,
      renderCache,
      props,
      data,
      setupState,
      ctx,
      inheritAttrs
    } = instance;
    const prev = setCurrentRenderingInstance(instance);
    let result;
    let fallthroughAttrs;
    try {
      if (vnode.shapeFlag & 4) {
        const proxyToUse = withProxy || proxy;
        const thisProxy = false ? new Proxy(proxyToUse, {
          get(target, key, receiver) {
            warn$1(
              `Property '${String(
                key
              )}' was accessed via 'this'. Avoid using 'this' in templates.`
            );
            return Reflect.get(target, key, receiver);
          }
        }) : proxyToUse;
        result = normalizeVNode(
          render2.call(
            thisProxy,
            proxyToUse,
            renderCache,
            false ? shallowReadonly(props) : props,
            setupState,
            data,
            ctx
          )
        );
        fallthroughAttrs = attrs;
      } else {
        const render22 = Component;
        if (false) ;
        result = normalizeVNode(
          render22.length > 1 ? render22(
            false ? shallowReadonly(props) : props,
            false ? {
              get attrs() {
                markAttrsAccessed();
                return shallowReadonly(attrs);
              },
              slots,
              emit: emit2
            } : { attrs, slots, emit: emit2 }
          ) : render22(
            false ? shallowReadonly(props) : props,
            null
          )
        );
        fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
      }
    } catch (err) {
      blockStack.length = 0;
      handleError(err, instance, 1);
      result = createVNode(Comment);
    }
    let root = result;
    if (fallthroughAttrs && inheritAttrs !== false) {
      const keys = Object.keys(fallthroughAttrs);
      const { shapeFlag } = root;
      if (keys.length) {
        if (shapeFlag & (1 | 6)) {
          if (propsOptions && keys.some(isModelListener)) {
            fallthroughAttrs = filterModelListeners(
              fallthroughAttrs,
              propsOptions
            );
          }
          root = cloneVNode(root, fallthroughAttrs, false, true);
        }
      }
    }
    if (vnode.dirs) {
      root = cloneVNode(root, null, false, true);
      root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    if (vnode.transition) {
      root.transition = vnode.transition;
    }
    {
      result = root;
    }
    setCurrentRenderingInstance(prev);
    return result;
  }
  function filterSingleRoot(children, recurse = true) {
    let singleRoot;
    for (let i2 = 0; i2 < children.length; i2++) {
      const child = children[i2];
      if (isVNode$1(child)) {
        if (child.type !== Comment || child.children === "v-if") {
          if (singleRoot) {
            return;
          } else {
            singleRoot = child;
          }
        }
      } else {
        return;
      }
    }
    return singleRoot;
  }
  const getFunctionalFallthrough = (attrs) => {
    let res;
    for (const key in attrs) {
      if (key === "class" || key === "style" || isOn(key)) {
        (res || (res = {}))[key] = attrs[key];
      }
    }
    return res;
  };
  const filterModelListeners = (attrs, props) => {
    const res = {};
    for (const key in attrs) {
      if (!isModelListener(key) || !(key.slice(9) in props)) {
        res[key] = attrs[key];
      }
    }
    return res;
  };
  function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    if (nextVNode.dirs || nextVNode.transition) {
      return true;
    }
    if (optimized && patchFlag >= 0) {
      if (patchFlag & 1024) {
        return true;
      }
      if (patchFlag & 16) {
        if (!prevProps) {
          return !!nextProps;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      } else if (patchFlag & 8) {
        const dynamicProps = nextVNode.dynamicProps;
        for (let i2 = 0; i2 < dynamicProps.length; i2++) {
          const key = dynamicProps[i2];
          if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
            return true;
          }
        }
      }
    } else {
      if (prevChildren || nextChildren) {
        if (!nextChildren || !nextChildren.$stable) {
          return true;
        }
      }
      if (prevProps === nextProps) {
        return false;
      }
      if (!prevProps) {
        return !!nextProps;
      }
      if (!nextProps) {
        return true;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
  }
  function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
      return true;
    }
    for (let i2 = 0; i2 < nextKeys.length; i2++) {
      const key = nextKeys[i2];
      if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
        return true;
      }
    }
    return false;
  }
  function updateHOCHostEl({ vnode, parent }, el) {
    while (parent) {
      const root = parent.subTree;
      if (root.suspense && root.suspense.activeBranch === vnode) {
        root.el = vnode.el;
      }
      if (root === vnode) {
        (vnode = parent.vnode).el = el;
        parent = parent.parent;
      } else {
        break;
      }
    }
  }
  const isSuspense = (type) => type.__isSuspense;
  let suspenseId = 0;
  const SuspenseImpl = {
    name: "Suspense",
    // In order to make Suspense tree-shakable, we need to avoid importing it
    // directly in the renderer. The renderer checks for the __isSuspense flag
    // on a vnode's type and calls the `process` method, passing in renderer
    // internals.
    __isSuspense: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
      if (n1 == null) {
        mountSuspense(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized,
          rendererInternals
        );
      } else {
        if (parentSuspense && parentSuspense.deps > 0 && !n1.suspense.isInFallback) {
          n2.suspense = n1.suspense;
          n2.suspense.vnode = n2;
          n2.el = n1.el;
          return;
        }
        patchSuspense(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          namespace,
          slotScopeIds,
          optimized,
          rendererInternals
        );
      }
    },
    hydrate: hydrateSuspense,
    normalize: normalizeSuspenseChildren
  };
  const Suspense = SuspenseImpl;
  function triggerEvent(vnode, name) {
    const eventListener = vnode.props && vnode.props[name];
    if (isFunction$1(eventListener)) {
      eventListener();
    }
  }
  function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
    const {
      p: patch,
      o: { createElement }
    } = rendererInternals;
    const hiddenContainer = createElement("div");
    const suspense = vnode.suspense = createSuspenseBoundary(
      vnode,
      parentSuspense,
      parentComponent,
      container,
      hiddenContainer,
      anchor,
      namespace,
      slotScopeIds,
      optimized,
      rendererInternals
    );
    patch(
      null,
      suspense.pendingBranch = vnode.ssContent,
      hiddenContainer,
      null,
      parentComponent,
      suspense,
      namespace,
      slotScopeIds
    );
    if (suspense.deps > 0) {
      triggerEvent(vnode, "onPending");
      triggerEvent(vnode, "onFallback");
      patch(
        null,
        vnode.ssFallback,
        container,
        anchor,
        parentComponent,
        null,
        // fallback tree will not have suspense context
        namespace,
        slotScopeIds
      );
      setActiveBranch(suspense, vnode.ssFallback);
    } else {
      suspense.resolve(false, true);
    }
  }
  function patchSuspense(n1, n2, container, anchor, parentComponent, namespace, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
    const suspense = n2.suspense = n1.suspense;
    suspense.vnode = n2;
    n2.el = n1.el;
    const newBranch = n2.ssContent;
    const newFallback = n2.ssFallback;
    const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
    if (pendingBranch) {
      suspense.pendingBranch = newBranch;
      if (isSameVNodeType(newBranch, pendingBranch)) {
        patch(
          pendingBranch,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else if (isInFallback) {
          if (!isHydrating) {
            patch(
              activeBranch,
              newFallback,
              container,
              anchor,
              parentComponent,
              null,
              // fallback tree will not have suspense context
              namespace,
              slotScopeIds,
              optimized
            );
            setActiveBranch(suspense, newFallback);
          }
        }
      } else {
        suspense.pendingId = suspenseId++;
        if (isHydrating) {
          suspense.isHydrating = false;
          suspense.activeBranch = pendingBranch;
        } else {
          unmount(pendingBranch, parentComponent, suspense);
        }
        suspense.deps = 0;
        suspense.effects.length = 0;
        suspense.hiddenContainer = createElement("div");
        if (isInFallback) {
          patch(
            null,
            newBranch,
            suspense.hiddenContainer,
            null,
            parentComponent,
            suspense,
            namespace,
            slotScopeIds,
            optimized
          );
          if (suspense.deps <= 0) {
            suspense.resolve();
          } else {
            patch(
              activeBranch,
              newFallback,
              container,
              anchor,
              parentComponent,
              null,
              // fallback tree will not have suspense context
              namespace,
              slotScopeIds,
              optimized
            );
            setActiveBranch(suspense, newFallback);
          }
        } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
          patch(
            activeBranch,
            newBranch,
            container,
            anchor,
            parentComponent,
            suspense,
            namespace,
            slotScopeIds,
            optimized
          );
          suspense.resolve(true);
        } else {
          patch(
            null,
            newBranch,
            suspense.hiddenContainer,
            null,
            parentComponent,
            suspense,
            namespace,
            slotScopeIds,
            optimized
          );
          if (suspense.deps <= 0) {
            suspense.resolve();
          }
        }
      }
    } else {
      if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(
          activeBranch,
          newBranch,
          container,
          anchor,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        setActiveBranch(suspense, newBranch);
      } else {
        triggerEvent(n2, "onPending");
        suspense.pendingBranch = newBranch;
        if (newBranch.shapeFlag & 512) {
          suspense.pendingId = newBranch.component.suspenseId;
        } else {
          suspense.pendingId = suspenseId++;
        }
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          const { timeout, pendingId } = suspense;
          if (timeout > 0) {
            setTimeout(() => {
              if (suspense.pendingId === pendingId) {
                suspense.fallback(newFallback);
              }
            }, timeout);
          } else if (timeout === 0) {
            suspense.fallback(newFallback);
          }
        }
      }
    }
  }
  function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
    const {
      p: patch,
      m: move,
      um: unmount,
      n: next,
      o: { parentNode, remove: remove2 }
    } = rendererInternals;
    let parentSuspenseId;
    const isSuspensible = isVNodeSuspensible(vnode);
    if (isSuspensible) {
      if (parentSuspense && parentSuspense.pendingBranch) {
        parentSuspenseId = parentSuspense.pendingId;
        parentSuspense.deps++;
      }
    }
    const timeout = vnode.props ? toNumber(vnode.props.timeout) : void 0;
    const initialAnchor = anchor;
    const suspense = {
      vnode,
      parent: parentSuspense,
      parentComponent,
      namespace,
      container,
      hiddenContainer,
      deps: 0,
      pendingId: suspenseId++,
      timeout: typeof timeout === "number" ? timeout : -1,
      activeBranch: null,
      pendingBranch: null,
      isInFallback: !isHydrating,
      isHydrating,
      isUnmounted: false,
      effects: [],
      resolve(resume = false, sync = false) {
        const {
          vnode: vnode2,
          activeBranch,
          pendingBranch,
          pendingId,
          effects,
          parentComponent: parentComponent2,
          container: container2
        } = suspense;
        let delayEnter = false;
        if (suspense.isHydrating) {
          suspense.isHydrating = false;
        } else if (!resume) {
          delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
          if (delayEnter) {
            activeBranch.transition.afterLeave = () => {
              if (pendingId === suspense.pendingId) {
                move(
                  pendingBranch,
                  container2,
                  anchor === initialAnchor ? next(activeBranch) : anchor,
                  0
                );
                queuePostFlushCb(effects);
              }
            };
          }
          if (activeBranch) {
            if (parentNode(activeBranch.el) !== suspense.hiddenContainer) {
              anchor = next(activeBranch);
            }
            unmount(activeBranch, parentComponent2, suspense, true);
          }
          if (!delayEnter) {
            move(pendingBranch, container2, anchor, 0);
          }
        }
        setActiveBranch(suspense, pendingBranch);
        suspense.pendingBranch = null;
        suspense.isInFallback = false;
        let parent = suspense.parent;
        let hasUnresolvedAncestor = false;
        while (parent) {
          if (parent.pendingBranch) {
            parent.effects.push(...effects);
            hasUnresolvedAncestor = true;
            break;
          }
          parent = parent.parent;
        }
        if (!hasUnresolvedAncestor && !delayEnter) {
          queuePostFlushCb(effects);
        }
        suspense.effects = [];
        if (isSuspensible) {
          if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
            parentSuspense.deps--;
            if (parentSuspense.deps === 0 && !sync) {
              parentSuspense.resolve();
            }
          }
        }
        triggerEvent(vnode2, "onResolve");
      },
      fallback(fallbackVNode) {
        if (!suspense.pendingBranch) {
          return;
        }
        const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, namespace: namespace2 } = suspense;
        triggerEvent(vnode2, "onFallback");
        const anchor2 = next(activeBranch);
        const mountFallback = () => {
          if (!suspense.isInFallback) {
            return;
          }
          patch(
            null,
            fallbackVNode,
            container2,
            anchor2,
            parentComponent2,
            null,
            // fallback tree will not have suspense context
            namespace2,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, fallbackVNode);
        };
        const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = mountFallback;
        }
        suspense.isInFallback = true;
        unmount(
          activeBranch,
          parentComponent2,
          null,
          // no suspense so unmount hooks fire now
          true
          // shouldRemove
        );
        if (!delayEnter) {
          mountFallback();
        }
      },
      move(container2, anchor2, type) {
        suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
        suspense.container = container2;
      },
      next() {
        return suspense.activeBranch && next(suspense.activeBranch);
      },
      registerDep(instance, setupRenderEffect, optimized2) {
        const isInPendingSuspense = !!suspense.pendingBranch;
        if (isInPendingSuspense) {
          suspense.deps++;
        }
        const hydratedEl = instance.vnode.el;
        instance.asyncDep.catch((err) => {
          handleError(err, instance, 0);
        }).then((asyncSetupResult) => {
          if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
            return;
          }
          instance.asyncResolved = true;
          const { vnode: vnode2 } = instance;
          handleSetupResult(instance, asyncSetupResult, false);
          if (hydratedEl) {
            vnode2.el = hydratedEl;
          }
          const placeholder = !hydratedEl && instance.subTree.el;
          setupRenderEffect(
            instance,
            vnode2,
            // component may have been moved before resolve.
            // if this is not a hydration, instance.subTree will be the comment
            // placeholder.
            parentNode(hydratedEl || instance.subTree.el),
            // anchor will not be used if this is hydration, so only need to
            // consider the comment placeholder case.
            hydratedEl ? null : next(instance.subTree),
            suspense,
            namespace,
            optimized2
          );
          if (placeholder) {
            remove2(placeholder);
          }
          updateHOCHostEl(instance, vnode2.el);
          if (isInPendingSuspense && --suspense.deps === 0) {
            suspense.resolve();
          }
        });
      },
      unmount(parentSuspense2, doRemove) {
        suspense.isUnmounted = true;
        if (suspense.activeBranch) {
          unmount(
            suspense.activeBranch,
            parentComponent,
            parentSuspense2,
            doRemove
          );
        }
        if (suspense.pendingBranch) {
          unmount(
            suspense.pendingBranch,
            parentComponent,
            parentSuspense2,
            doRemove
          );
        }
      }
    };
    return suspense;
  }
  function hydrateSuspense(node, vnode, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals, hydrateNode) {
    const suspense = vnode.suspense = createSuspenseBoundary(
      vnode,
      parentSuspense,
      parentComponent,
      node.parentNode,
      // eslint-disable-next-line no-restricted-globals
      document.createElement("div"),
      null,
      namespace,
      slotScopeIds,
      optimized,
      rendererInternals,
      true
    );
    const result = hydrateNode(
      node,
      suspense.pendingBranch = vnode.ssContent,
      parentComponent,
      suspense,
      slotScopeIds,
      optimized
    );
    if (suspense.deps === 0) {
      suspense.resolve(false, true);
    }
    return result;
  }
  function normalizeSuspenseChildren(vnode) {
    const { shapeFlag, children } = vnode;
    const isSlotChildren = shapeFlag & 32;
    vnode.ssContent = normalizeSuspenseSlot(
      isSlotChildren ? children.default : children
    );
    vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
  }
  function normalizeSuspenseSlot(s2) {
    let block;
    if (isFunction$1(s2)) {
      const trackBlock = isBlockTreeEnabled && s2._c;
      if (trackBlock) {
        s2._d = false;
        openBlock();
      }
      s2 = s2();
      if (trackBlock) {
        s2._d = true;
        block = currentBlock;
        closeBlock();
      }
    }
    if (isArray$2(s2)) {
      const singleChild = filterSingleRoot(s2);
      s2 = singleChild;
    }
    s2 = normalizeVNode(s2);
    if (block && !s2.dynamicChildren) {
      s2.dynamicChildren = block.filter((c2) => c2 !== s2);
    }
    return s2;
  }
  function queueEffectWithSuspense(fn2, suspense) {
    if (suspense && suspense.pendingBranch) {
      if (isArray$2(fn2)) {
        suspense.effects.push(...fn2);
      } else {
        suspense.effects.push(fn2);
      }
    } else {
      queuePostFlushCb(fn2);
    }
  }
  function setActiveBranch(suspense, branch) {
    suspense.activeBranch = branch;
    const { vnode, parentComponent } = suspense;
    let el = branch.el;
    while (!el && branch.component) {
      branch = branch.component.subTree;
      el = branch.el;
    }
    vnode.el = el;
    if (parentComponent && parentComponent.subTree === vnode) {
      parentComponent.vnode.el = el;
      updateHOCHostEl(parentComponent, el);
    }
  }
  function isVNodeSuspensible(vnode) {
    const suspensible = vnode.props && vnode.props.suspensible;
    return suspensible != null && suspensible !== false;
  }
  const Fragment = Symbol.for("v-fgt");
  const Text = Symbol.for("v-txt");
  const Comment = Symbol.for("v-cmt");
  const Static = Symbol.for("v-stc");
  const blockStack = [];
  let currentBlock = null;
  function openBlock(disableTracking = false) {
    blockStack.push(currentBlock = disableTracking ? null : []);
  }
  function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
  }
  let isBlockTreeEnabled = 1;
  function setBlockTracking(value) {
    isBlockTreeEnabled += value;
    if (value < 0 && currentBlock) {
      currentBlock.hasOnce = true;
    }
  }
  function setupBlock(vnode) {
    vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
    closeBlock();
    if (isBlockTreeEnabled > 0 && currentBlock) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(
      createBaseVNode(
        type,
        props,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        true
      )
    );
  }
  function createBlock(type, props, children, patchFlag, dynamicProps) {
    return setupBlock(
      createVNode(
        type,
        props,
        children,
        patchFlag,
        dynamicProps,
        true
      )
    );
  }
  function isVNode$1(value) {
    return value ? value.__v_isVNode === true : false;
  }
  function isSameVNodeType(n1, n2) {
    return n1.type === n2.type && n1.key === n2.key;
  }
  function transformVNodeArgs(transformer) {
  }
  const normalizeKey = ({ key }) => key != null ? key : null;
  const normalizeRef = ({
    ref: ref3,
    ref_key,
    ref_for
  }) => {
    if (typeof ref3 === "number") {
      ref3 = "" + ref3;
    }
    return ref3 != null ? isString$1(ref3) || isRef(ref3) || isFunction$1(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
  };
  function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
      __v_isVNode: true,
      __v_skip: true,
      type,
      props,
      key: props && normalizeKey(props),
      ref: props && normalizeRef(props),
      scopeId: currentScopeId,
      slotScopeIds: null,
      children,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetStart: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag,
      patchFlag,
      dynamicProps,
      dynamicChildren: null,
      appContext: null,
      ctx: currentRenderingInstance
    };
    if (needFullChildrenNormalization) {
      normalizeChildren(vnode, children);
      if (shapeFlag & 128) {
        type.normalize(vnode);
      }
    } else if (children) {
      vnode.shapeFlag |= isString$1(children) ? 8 : 16;
    }
    if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
    !isBlockNode && // has current parent block
    currentBlock && // presence of a patch flag indicates this node needs patching on updates.
    // component nodes also should always be patched, because even if the
    // component doesn't need to update, it needs to persist the instance on to
    // the next vnode so that it can be properly unmounted later.
    (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
    // vnode should not be considered dynamic due to handler caching.
    vnode.patchFlag !== 32) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  const createVNode = _createVNode;
  function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
      type = Comment;
    }
    if (isVNode$1(type)) {
      const cloned = cloneVNode(
        type,
        props,
        true
        /* mergeRef: true */
      );
      if (children) {
        normalizeChildren(cloned, children);
      }
      if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
        if (cloned.shapeFlag & 6) {
          currentBlock[currentBlock.indexOf(type)] = cloned;
        } else {
          currentBlock.push(cloned);
        }
      }
      cloned.patchFlag = -2;
      return cloned;
    }
    if (isClassComponent(type)) {
      type = type.__vccOpts;
    }
    if (props) {
      props = guardReactiveProps(props);
      let { class: klass, style } = props;
      if (klass && !isString$1(klass)) {
        props.class = normalizeClass(klass);
      }
      if (isObject$1(style)) {
        if (isProxy(style) && !isArray$2(style)) {
          style = extend$1({}, style);
        }
        props.style = normalizeStyle(style);
      }
    }
    const shapeFlag = isString$1(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$1(type) ? 4 : isFunction$1(type) ? 2 : 0;
    return createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      isBlockNode,
      true
    );
  }
  function guardReactiveProps(props) {
    if (!props) return null;
    return isProxy(props) || isInternalObject(props) ? extend$1({}, props) : props;
  }
  function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
    const { props, ref: ref3, patchFlag, children, transition } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
      __v_isVNode: true,
      __v_skip: true,
      type: vnode.type,
      props: mergedProps,
      key: mergedProps && normalizeKey(mergedProps),
      ref: extraProps && extraProps.ref ? (
        // #2078 in the case of <component :is="vnode" ref="extra"/>
        // if the vnode itself already has a ref, cloneVNode will need to merge
        // the refs so the single vnode can be set on multiple refs
        mergeRef && ref3 ? isArray$2(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
      ) : ref3,
      scopeId: vnode.scopeId,
      slotScopeIds: vnode.slotScopeIds,
      children,
      target: vnode.target,
      targetStart: vnode.targetStart,
      targetAnchor: vnode.targetAnchor,
      staticCount: vnode.staticCount,
      shapeFlag: vnode.shapeFlag,
      // if the vnode is cloned with extra props, we can no longer assume its
      // existing patch flag to be reliable and need to add the FULL_PROPS flag.
      // note: preserve flag for fragments since they use the flag for children
      // fast paths only.
      patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
      dynamicProps: vnode.dynamicProps,
      dynamicChildren: vnode.dynamicChildren,
      appContext: vnode.appContext,
      dirs: vnode.dirs,
      transition,
      // These should technically only be non-null on mounted VNodes. However,
      // they *should* be copied for kept-alive vnodes. So we just always copy
      // them since them being non-null during a mount doesn't affect the logic as
      // they will simply be overwritten.
      component: vnode.component,
      suspense: vnode.suspense,
      ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
      ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
      el: vnode.el,
      anchor: vnode.anchor,
      ctx: vnode.ctx,
      ce: vnode.ce
    };
    if (transition && cloneTransition) {
      setTransitionHooks(
        cloned,
        transition.clone(cloned)
      );
    }
    return cloned;
  }
  function createTextVNode(text = " ", flag = 0) {
    return createVNode(Text, null, text, flag);
  }
  function createStaticVNode(content, numberOfNodes) {
    const vnode = createVNode(Static, null, content);
    vnode.staticCount = numberOfNodes;
    return vnode;
  }
  function createCommentVNode(text = "", asBlock = false) {
    return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
  }
  function normalizeVNode(child) {
    if (child == null || typeof child === "boolean") {
      return createVNode(Comment);
    } else if (isArray$2(child)) {
      return createVNode(
        Fragment,
        null,
        // #3666, avoid reference pollution when reusing vnode
        child.slice()
      );
    } else if (typeof child === "object") {
      return cloneIfMounted(child);
    } else {
      return createVNode(Text, null, String(child));
    }
  }
  function cloneIfMounted(child) {
    return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
  }
  function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
      children = null;
    } else if (isArray$2(children)) {
      type = 16;
    } else if (typeof children === "object") {
      if (shapeFlag & (1 | 64)) {
        const slot = children.default;
        if (slot) {
          slot._c && (slot._d = false);
          normalizeChildren(vnode, slot());
          slot._c && (slot._d = true);
        }
        return;
      } else {
        type = 32;
        const slotFlag = children._;
        if (!slotFlag && !isInternalObject(children)) {
          children._ctx = currentRenderingInstance;
        } else if (slotFlag === 3 && currentRenderingInstance) {
          if (currentRenderingInstance.slots._ === 1) {
            children._ = 1;
          } else {
            children._ = 2;
            vnode.patchFlag |= 1024;
          }
        }
      }
    } else if (isFunction$1(children)) {
      children = { default: children, _ctx: currentRenderingInstance };
      type = 32;
    } else {
      children = String(children);
      if (shapeFlag & 64) {
        type = 16;
        children = [createTextVNode(children)];
      } else {
        type = 8;
      }
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
  }
  function mergeProps(...args) {
    const ret = {};
    for (let i2 = 0; i2 < args.length; i2++) {
      const toMerge = args[i2];
      for (const key in toMerge) {
        if (key === "class") {
          if (ret.class !== toMerge.class) {
            ret.class = normalizeClass([ret.class, toMerge.class]);
          }
        } else if (key === "style") {
          ret.style = normalizeStyle([ret.style, toMerge.style]);
        } else if (isOn(key)) {
          const existing = ret[key];
          const incoming = toMerge[key];
          if (incoming && existing !== incoming && !(isArray$2(existing) && existing.includes(incoming))) {
            ret[key] = existing ? [].concat(existing, incoming) : incoming;
          }
        } else if (key !== "") {
          ret[key] = toMerge[key];
        }
      }
    }
    return ret;
  }
  function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7, [
      vnode,
      prevVNode
    ]);
  }
  const emptyAppContext = createAppContext();
  let uid = 0;
  function createComponentInstance(vnode, parent, suspense) {
    const type = vnode.type;
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
      uid: uid++,
      vnode,
      type,
      parent,
      appContext,
      root: null,
      // to be immediately set
      next: null,
      subTree: null,
      // will be set synchronously right after creation
      effect: null,
      update: null,
      // will be set synchronously right after creation
      scope: new EffectScope(
        true
        /* detached */
      ),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: parent ? parent.provides : Object.create(appContext.provides),
      accessCache: null,
      renderCache: [],
      // local resolved assets
      components: null,
      directives: null,
      // resolved props and emits options
      propsOptions: normalizePropsOptions(type, appContext),
      emitsOptions: normalizeEmitsOptions(type, appContext),
      // emit
      emit: null,
      // to be set immediately
      emitted: null,
      // props default value
      propsDefaults: EMPTY_OBJ,
      // inheritAttrs
      inheritAttrs: type.inheritAttrs,
      // state
      ctx: EMPTY_OBJ,
      data: EMPTY_OBJ,
      props: EMPTY_OBJ,
      attrs: EMPTY_OBJ,
      slots: EMPTY_OBJ,
      refs: EMPTY_OBJ,
      setupState: EMPTY_OBJ,
      setupContext: null,
      attrsProxy: null,
      slotsProxy: null,
      // suspense related
      suspense,
      suspenseId: suspense ? suspense.pendingId : 0,
      asyncDep: null,
      asyncResolved: false,
      // lifecycle hooks
      // not using enums here because it results in computed properties
      isMounted: false,
      isUnmounted: false,
      isDeactivated: false,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    };
    {
      instance.ctx = { _: instance };
    }
    instance.root = parent ? parent.root : instance;
    instance.emit = emit.bind(null, instance);
    if (vnode.ce) {
      vnode.ce(instance);
    }
    return instance;
  }
  let currentInstance = null;
  const getCurrentInstance = () => currentInstance || currentRenderingInstance;
  let internalSetCurrentInstance;
  let setInSSRSetupState;
  {
    const g2 = getGlobalThis();
    const registerGlobalSetter = (key, setter) => {
      let setters;
      if (!(setters = g2[key])) setters = g2[key] = [];
      setters.push(setter);
      return (v2) => {
        if (setters.length > 1) setters.forEach((set2) => set2(v2));
        else setters[0](v2);
      };
    };
    internalSetCurrentInstance = registerGlobalSetter(
      `__VUE_INSTANCE_SETTERS__`,
      (v2) => currentInstance = v2
    );
    setInSSRSetupState = registerGlobalSetter(
      `__VUE_SSR_SETTERS__`,
      (v2) => isInSSRComponentSetup = v2
    );
  }
  const setCurrentInstance = (instance) => {
    const prev = currentInstance;
    internalSetCurrentInstance(instance);
    instance.scope.on();
    return () => {
      instance.scope.off();
      internalSetCurrentInstance(prev);
    };
  };
  const unsetCurrentInstance = () => {
    currentInstance && currentInstance.scope.off();
    internalSetCurrentInstance(null);
  };
  function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4;
  }
  let isInSSRComponentSetup = false;
  function setupComponent(instance, isSSR = false, optimized = false) {
    isSSR && setInSSRSetupState(isSSR);
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children, optimized);
    const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
    isSSR && setInSSRSetupState(false);
    return setupResult;
  }
  function setupStatefulComponent(instance, isSSR) {
    const Component = instance.type;
    instance.accessCache = /* @__PURE__ */ Object.create(null);
    instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
    const { setup } = Component;
    if (setup) {
      const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
      const reset2 = setCurrentInstance(instance);
      pauseTracking();
      const setupResult = callWithErrorHandling(
        setup,
        instance,
        0,
        [
          instance.props,
          setupContext
        ]
      );
      resetTracking();
      reset2();
      if (isPromise(setupResult)) {
        setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
        if (isSSR) {
          return setupResult.then((resolvedResult) => {
            handleSetupResult(instance, resolvedResult, isSSR);
          }).catch((e2) => {
            handleError(e2, instance, 0);
          });
        } else {
          instance.asyncDep = setupResult;
        }
      } else {
        handleSetupResult(instance, setupResult, isSSR);
      }
    } else {
      finishComponentSetup(instance, isSSR);
    }
  }
  function handleSetupResult(instance, setupResult, isSSR) {
    if (isFunction$1(setupResult)) {
      if (instance.type.__ssrInlineRender) {
        instance.ssrRender = setupResult;
      } else {
        instance.render = setupResult;
      }
    } else if (isObject$1(setupResult)) {
      instance.setupState = proxyRefs(setupResult);
    } else ;
    finishComponentSetup(instance, isSSR);
  }
  let compile$1;
  let installWithProxy;
  function registerRuntimeCompiler(_compile) {
    compile$1 = _compile;
    installWithProxy = (i2) => {
      if (i2.render._rc) {
        i2.withProxy = new Proxy(i2.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
      }
    };
  }
  const isRuntimeOnly = () => !compile$1;
  function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    if (!instance.render) {
      if (!isSSR && compile$1 && !Component.render) {
        const template = Component.template || resolveMergedOptions(instance).template;
        if (template) {
          const { isCustomElement, compilerOptions } = instance.appContext.config;
          const { delimiters, compilerOptions: componentCompilerOptions } = Component;
          const finalCompilerOptions = extend$1(
            extend$1(
              {
                isCustomElement,
                delimiters
              },
              compilerOptions
            ),
            componentCompilerOptions
          );
          Component.render = compile$1(template, finalCompilerOptions);
        }
      }
      instance.render = Component.render || NOOP;
      if (installWithProxy) {
        installWithProxy(instance);
      }
    }
    {
      const reset2 = setCurrentInstance(instance);
      pauseTracking();
      try {
        applyOptions(instance);
      } finally {
        resetTracking();
        reset2();
      }
    }
  }
  const attrsProxyHandlers = {
    get(target, key) {
      track(target, "get", "");
      return target[key];
    }
  };
  function createSetupContext(instance) {
    const expose = (exposed) => {
      instance.exposed = exposed || {};
    };
    {
      return {
        attrs: new Proxy(instance.attrs, attrsProxyHandlers),
        slots: instance.slots,
        emit: instance.emit,
        expose
      };
    }
  }
  function getComponentPublicInstance(instance) {
    if (instance.exposed) {
      return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
        get(target, key) {
          if (key in target) {
            return target[key];
          } else if (key in publicPropertiesMap) {
            return publicPropertiesMap[key](instance);
          }
        },
        has(target, key) {
          return key in target || key in publicPropertiesMap;
        }
      }));
    } else {
      return instance.proxy;
    }
  }
  const classifyRE = /(?:^|[-_])(\w)/g;
  const classify = (str) => str.replace(classifyRE, (c2) => c2.toUpperCase()).replace(/[-_]/g, "");
  function getComponentName(Component, includeInferred = true) {
    return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
  }
  function formatComponentName(instance, Component, isRoot = false) {
    let name = getComponentName(Component);
    if (!name && Component.__file) {
      const match = Component.__file.match(/([^/\\]+)\.\w+$/);
      if (match) {
        name = match[1];
      }
    }
    if (!name && instance && instance.parent) {
      const inferFromRegistry = (registry) => {
        for (const key in registry) {
          if (registry[key] === Component) {
            return key;
          }
        }
      };
      name = inferFromRegistry(
        instance.components || instance.parent.type.components
      ) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
  }
  function isClassComponent(value) {
    return isFunction$1(value) && "__vccOpts" in value;
  }
  const computed = (getterOrOptions, debugOptions) => {
    const c2 = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
    return c2;
  };
  function h$1(type, propsOrChildren, children) {
    const l2 = arguments.length;
    if (l2 === 2) {
      if (isObject$1(propsOrChildren) && !isArray$2(propsOrChildren)) {
        if (isVNode$1(propsOrChildren)) {
          return createVNode(type, null, [propsOrChildren]);
        }
        return createVNode(type, propsOrChildren);
      } else {
        return createVNode(type, null, propsOrChildren);
      }
    } else {
      if (l2 > 3) {
        children = Array.prototype.slice.call(arguments, 2);
      } else if (l2 === 3 && isVNode$1(children)) {
        children = [children];
      }
      return createVNode(type, propsOrChildren, children);
    }
  }
  function initCustomFormatter() {
    {
      return;
    }
  }
  function withMemo(memo, render2, cache2, index) {
    const cached = cache2[index];
    if (cached && isMemoSame(cached, memo)) {
      return cached;
    }
    const ret = render2();
    ret.memo = memo.slice();
    ret.cacheIndex = index;
    return cache2[index] = ret;
  }
  function isMemoSame(cached, memo) {
    const prev = cached.memo;
    if (prev.length != memo.length) {
      return false;
    }
    for (let i2 = 0; i2 < prev.length; i2++) {
      if (hasChanged(prev[i2], memo[i2])) {
        return false;
      }
    }
    if (isBlockTreeEnabled > 0 && currentBlock) {
      currentBlock.push(cached);
    }
    return true;
  }
  const version = "3.4.32";
  const warn = NOOP;
  const ErrorTypeStrings = ErrorTypeStrings$1;
  const devtools = devtools$1;
  const setDevtoolsHook = setDevtoolsHook$1;
  const _ssrUtils = {
    createComponentInstance,
    setupComponent,
    renderComponentRoot,
    setCurrentRenderingInstance,
    isVNode: isVNode$1,
    normalizeVNode,
    getComponentPublicInstance
  };
  const ssrUtils = _ssrUtils;
  const resolveFilter = null;
  const compatUtils = null;
  const DeprecationTypes = null;
  /**
  * @vue/runtime-dom v3.4.32
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  const svgNS = "http://www.w3.org/2000/svg";
  const mathmlNS = "http://www.w3.org/1998/Math/MathML";
  const doc = typeof document !== "undefined" ? document : null;
  const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
  const nodeOps = {
    insert: (child, parent, anchor) => {
      parent.insertBefore(child, anchor || null);
    },
    remove: (child) => {
      const parent = child.parentNode;
      if (parent) {
        parent.removeChild(child);
      }
    },
    createElement: (tag, namespace, is, props) => {
      const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
      if (tag === "select" && props && props.multiple != null) {
        el.setAttribute("multiple", props.multiple);
      }
      return el;
    },
    createText: (text) => doc.createTextNode(text),
    createComment: (text) => doc.createComment(text),
    setText: (node, text) => {
      node.nodeValue = text;
    },
    setElementText: (el, text) => {
      el.textContent = text;
    },
    parentNode: (node) => node.parentNode,
    nextSibling: (node) => node.nextSibling,
    querySelector: (selector) => doc.querySelector(selector),
    setScopeId(el, id) {
      el.setAttribute(id, "");
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent(content, parent, anchor, namespace, start, end) {
      const before = anchor ? anchor.previousSibling : parent.lastChild;
      if (start && (start === end || start.nextSibling)) {
        while (true) {
          parent.insertBefore(start.cloneNode(true), anchor);
          if (start === end || !(start = start.nextSibling)) break;
        }
      } else {
        templateContainer.innerHTML = namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content;
        const template = templateContainer.content;
        if (namespace === "svg" || namespace === "mathml") {
          const wrapper = template.firstChild;
          while (wrapper.firstChild) {
            template.appendChild(wrapper.firstChild);
          }
          template.removeChild(wrapper);
        }
        parent.insertBefore(template, anchor);
      }
      return [
        // first
        before ? before.nextSibling : parent.firstChild,
        // last
        anchor ? anchor.previousSibling : parent.lastChild
      ];
    }
  };
  const TRANSITION$1 = "transition";
  const ANIMATION = "animation";
  const vtcKey = Symbol("_vtc");
  const Transition = (props, { slots }) => h$1(BaseTransition, resolveTransitionProps(props), slots);
  Transition.displayName = "Transition";
  const DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: {
      type: Boolean,
      default: true
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
  };
  const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend$1(
    {},
    BaseTransitionPropsValidators,
    DOMTransitionPropsValidators
  );
  const callHook = (hook, args = []) => {
    if (isArray$2(hook)) {
      hook.forEach((h2) => h2(...args));
    } else if (hook) {
      hook(...args);
    }
  };
  const hasExplicitCallback = (hook) => {
    return hook ? isArray$2(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
  };
  function resolveTransitionProps(rawProps) {
    const baseProps = {};
    for (const key in rawProps) {
      if (!(key in DOMTransitionPropsValidators)) {
        baseProps[key] = rawProps[key];
      }
    }
    if (rawProps.css === false) {
      return baseProps;
    }
    const {
      name = "v",
      type,
      duration,
      enterFromClass = `${name}-enter-from`,
      enterActiveClass = `${name}-enter-active`,
      enterToClass = `${name}-enter-to`,
      appearFromClass = enterFromClass,
      appearActiveClass = enterActiveClass,
      appearToClass = enterToClass,
      leaveFromClass = `${name}-leave-from`,
      leaveActiveClass = `${name}-leave-active`,
      leaveToClass = `${name}-leave-to`
    } = rawProps;
    const durations = normalizeDuration(duration);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const {
      onBeforeEnter,
      onEnter,
      onEnterCancelled,
      onLeave,
      onLeaveCancelled,
      onBeforeAppear = onBeforeEnter,
      onAppear = onEnter,
      onAppearCancelled = onEnterCancelled
    } = baseProps;
    const finishEnter = (el, isAppear, done) => {
      removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
      removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
      done && done();
    };
    const finishLeave = (el, done) => {
      el._isLeaving = false;
      removeTransitionClass(el, leaveFromClass);
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
      done && done();
    };
    const makeEnterHook = (isAppear) => {
      return (el, done) => {
        const hook = isAppear ? onAppear : onEnter;
        const resolve2 = () => finishEnter(el, isAppear, done);
        callHook(hook, [el, resolve2]);
        nextFrame(() => {
          removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
          addTransitionClass(el, isAppear ? appearToClass : enterToClass);
          if (!hasExplicitCallback(hook)) {
            whenTransitionEnds(el, type, enterDuration, resolve2);
          }
        });
      };
    };
    return extend$1(baseProps, {
      onBeforeEnter(el) {
        callHook(onBeforeEnter, [el]);
        addTransitionClass(el, enterFromClass);
        addTransitionClass(el, enterActiveClass);
      },
      onBeforeAppear(el) {
        callHook(onBeforeAppear, [el]);
        addTransitionClass(el, appearFromClass);
        addTransitionClass(el, appearActiveClass);
      },
      onEnter: makeEnterHook(false),
      onAppear: makeEnterHook(true),
      onLeave(el, done) {
        el._isLeaving = true;
        const resolve2 = () => finishLeave(el, done);
        addTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveActiveClass);
        forceReflow();
        nextFrame(() => {
          if (!el._isLeaving) {
            return;
          }
          removeTransitionClass(el, leaveFromClass);
          addTransitionClass(el, leaveToClass);
          if (!hasExplicitCallback(onLeave)) {
            whenTransitionEnds(el, type, leaveDuration, resolve2);
          }
        });
        callHook(onLeave, [el, resolve2]);
      },
      onEnterCancelled(el) {
        finishEnter(el, false);
        callHook(onEnterCancelled, [el]);
      },
      onAppearCancelled(el) {
        finishEnter(el, true);
        callHook(onAppearCancelled, [el]);
      },
      onLeaveCancelled(el) {
        finishLeave(el);
        callHook(onLeaveCancelled, [el]);
      }
    });
  }
  function normalizeDuration(duration) {
    if (duration == null) {
      return null;
    } else if (isObject$1(duration)) {
      return [NumberOf(duration.enter), NumberOf(duration.leave)];
    } else {
      const n2 = NumberOf(duration);
      return [n2, n2];
    }
  }
  function NumberOf(val) {
    const res = toNumber(val);
    return res;
  }
  function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c2) => c2 && el.classList.add(c2));
    (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
  }
  function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c2) => c2 && el.classList.remove(c2));
    const _vtc = el[vtcKey];
    if (_vtc) {
      _vtc.delete(cls);
      if (!_vtc.size) {
        el[vtcKey] = void 0;
      }
    }
  }
  function nextFrame(cb) {
    requestAnimationFrame(() => {
      requestAnimationFrame(cb);
    });
  }
  let endId = 0;
  function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
    const id = el._endId = ++endId;
    const resolveIfNotStale = () => {
      if (id === el._endId) {
        resolve2();
      }
    };
    if (explicitTimeout) {
      return setTimeout(resolveIfNotStale, explicitTimeout);
    }
    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
    if (!type) {
      return resolve2();
    }
    const endEvent = type + "end";
    let ended = 0;
    const end = () => {
      el.removeEventListener(endEvent, onEnd);
      resolveIfNotStale();
    };
    const onEnd = (e2) => {
      if (e2.target === el && ++ended >= propCount) {
        end();
      }
    };
    setTimeout(() => {
      if (ended < propCount) {
        end();
      }
    }, timeout + 1);
    el.addEventListener(endEvent, onEnd);
  }
  function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    const getStyleProperties = (key) => (styles[key] || "").split(", ");
    const transitionDelays = getStyleProperties(`${TRANSITION$1}Delay`);
    const transitionDurations = getStyleProperties(`${TRANSITION$1}Duration`);
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
    const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type = null;
    let timeout = 0;
    let propCount = 0;
    if (expectedType === TRANSITION$1) {
      if (transitionTimeout > 0) {
        type = TRANSITION$1;
        timeout = transitionTimeout;
        propCount = transitionDurations.length;
      }
    } else if (expectedType === ANIMATION) {
      if (animationTimeout > 0) {
        type = ANIMATION;
        timeout = animationTimeout;
        propCount = animationDurations.length;
      }
    } else {
      timeout = Math.max(transitionTimeout, animationTimeout);
      type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION$1 : ANIMATION : null;
      propCount = type ? type === TRANSITION$1 ? transitionDurations.length : animationDurations.length : 0;
    }
    const hasTransform = type === TRANSITION$1 && /\b(transform|all)(,|$)/.test(
      getStyleProperties(`${TRANSITION$1}Property`).toString()
    );
    return {
      type,
      timeout,
      propCount,
      hasTransform
    };
  }
  function getTimeout(delays, durations) {
    while (delays.length < durations.length) {
      delays = delays.concat(delays);
    }
    return Math.max(...durations.map((d2, i2) => toMs(d2) + toMs(delays[i2])));
  }
  function toMs(s2) {
    if (s2 === "auto") return 0;
    return Number(s2.slice(0, -1).replace(",", ".")) * 1e3;
  }
  function forceReflow() {
    return document.body.offsetHeight;
  }
  function patchClass(el, value, isSVG) {
    const transitionClasses = el[vtcKey];
    if (transitionClasses) {
      value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
    }
    if (value == null) {
      el.removeAttribute("class");
    } else if (isSVG) {
      el.setAttribute("class", value);
    } else {
      el.className = value;
    }
  }
  const vShowOriginalDisplay = Symbol("_vod");
  const vShowHidden = Symbol("_vsh");
  const vShow = {
    beforeMount(el, { value }, { transition }) {
      el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
      if (transition && value) {
        transition.beforeEnter(el);
      } else {
        setDisplay(el, value);
      }
    },
    mounted(el, { value }, { transition }) {
      if (transition && value) {
        transition.enter(el);
      }
    },
    updated(el, { value, oldValue }, { transition }) {
      if (!value === !oldValue) return;
      if (transition) {
        if (value) {
          transition.beforeEnter(el);
          setDisplay(el, true);
          transition.enter(el);
        } else {
          transition.leave(el, () => {
            setDisplay(el, false);
          });
        }
      } else {
        setDisplay(el, value);
      }
    },
    beforeUnmount(el, { value }) {
      setDisplay(el, value);
    }
  };
  function setDisplay(el, value) {
    el.style.display = value ? el[vShowOriginalDisplay] : "none";
    el[vShowHidden] = !value;
  }
  function initVShowForSSR() {
    vShow.getSSRProps = ({ value }) => {
      if (!value) {
        return { style: { display: "none" } };
      }
    };
  }
  const CSS_VAR_TEXT = Symbol("");
  function useCssVars(getter) {
    const instance = getCurrentInstance();
    if (!instance) {
      return;
    }
    const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {
      Array.from(
        document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)
      ).forEach((node) => setVarsOnNode(node, vars));
    };
    const setVars = () => {
      const vars = getter(instance.proxy);
      setVarsOnVNode(instance.subTree, vars);
      updateTeleports(vars);
    };
    onMounted(() => {
      watchPostEffect(setVars);
      const ob = new MutationObserver(setVars);
      ob.observe(instance.subTree.el.parentNode, { childList: true });
      onUnmounted(() => ob.disconnect());
    });
  }
  function setVarsOnVNode(vnode, vars) {
    if (vnode.shapeFlag & 128) {
      const suspense = vnode.suspense;
      vnode = suspense.activeBranch;
      if (suspense.pendingBranch && !suspense.isHydrating) {
        suspense.effects.push(() => {
          setVarsOnVNode(suspense.activeBranch, vars);
        });
      }
    }
    while (vnode.component) {
      vnode = vnode.component.subTree;
    }
    if (vnode.shapeFlag & 1 && vnode.el) {
      setVarsOnNode(vnode.el, vars);
    } else if (vnode.type === Fragment) {
      vnode.children.forEach((c2) => setVarsOnVNode(c2, vars));
    } else if (vnode.type === Static) {
      let { el, anchor } = vnode;
      while (el) {
        setVarsOnNode(el, vars);
        if (el === anchor) break;
        el = el.nextSibling;
      }
    }
  }
  function setVarsOnNode(el, vars) {
    if (el.nodeType === 1) {
      const style = el.style;
      let cssText = "";
      for (const key in vars) {
        style.setProperty(`--${key}`, vars[key]);
        cssText += `--${key}: ${vars[key]};`;
      }
      style[CSS_VAR_TEXT] = cssText;
    }
  }
  const displayRE = /(^|;)\s*display\s*:/;
  function patchStyle(el, prev, next) {
    const style = el.style;
    const isCssString = isString$1(next);
    let hasControlledDisplay = false;
    if (next && !isCssString) {
      if (prev) {
        if (!isString$1(prev)) {
          for (const key in prev) {
            if (next[key] == null) {
              setStyle(style, key, "");
            }
          }
        } else {
          for (const prevStyle of prev.split(";")) {
            const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
            if (next[key] == null) {
              setStyle(style, key, "");
            }
          }
        }
      }
      for (const key in next) {
        if (key === "display") {
          hasControlledDisplay = true;
        }
        setStyle(style, key, next[key]);
      }
    } else {
      if (isCssString) {
        if (prev !== next) {
          const cssVarText = style[CSS_VAR_TEXT];
          if (cssVarText) {
            next += ";" + cssVarText;
          }
          style.cssText = next;
          hasControlledDisplay = displayRE.test(next);
        }
      } else if (prev) {
        el.removeAttribute("style");
      }
    }
    if (vShowOriginalDisplay in el) {
      el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
      if (el[vShowHidden]) {
        style.display = "none";
      }
    }
  }
  const importantRE = /\s*!important$/;
  function setStyle(style, name, val) {
    if (isArray$2(val)) {
      val.forEach((v2) => setStyle(style, name, v2));
    } else {
      if (val == null) val = "";
      if (name.startsWith("--")) {
        style.setProperty(name, val);
      } else {
        const prefixed = autoPrefix(style, name);
        if (importantRE.test(val)) {
          style.setProperty(
            hyphenate(prefixed),
            val.replace(importantRE, ""),
            "important"
          );
        } else {
          style[prefixed] = val;
        }
      }
    }
  }
  const prefixes = ["Webkit", "Moz", "ms"];
  const prefixCache = {};
  function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) {
      return cached;
    }
    let name = camelize(rawName);
    if (name !== "filter" && name in style) {
      return prefixCache[rawName] = name;
    }
    name = capitalize(name);
    for (let i2 = 0; i2 < prefixes.length; i2++) {
      const prefixed = prefixes[i2] + name;
      if (prefixed in style) {
        return prefixCache[rawName] = prefixed;
      }
    }
    return rawName;
  }
  const xlinkNS = "http://www.w3.org/1999/xlink";
  function patchAttr(el, key, value, isSVG, instance, isBoolean2 = isSpecialBooleanAttr(key)) {
    if (isSVG && key.startsWith("xlink:")) {
      if (value == null) {
        el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
      } else {
        el.setAttributeNS(xlinkNS, key, value);
      }
    } else {
      if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
        el.removeAttribute(key);
      } else {
        el.setAttribute(
          key,
          isBoolean2 ? "" : isSymbol(value) ? String(value) : value
        );
      }
    }
  }
  function patchDOMProp(el, key, value, parentComponent) {
    if (key === "innerHTML" || key === "textContent") {
      if (value === null) return;
      el[key] = value;
      return;
    }
    const tag = el.tagName;
    if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
    !tag.includes("-")) {
      const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
      const newValue = value == null ? "" : String(value);
      if (oldValue !== newValue || !("_value" in el)) {
        el.value = newValue;
      }
      if (value == null) {
        el.removeAttribute(key);
      }
      el._value = value;
      return;
    }
    let needRemove = false;
    if (value === "" || value == null) {
      const type = typeof el[key];
      if (type === "boolean") {
        value = includeBooleanAttr(value);
      } else if (value == null && type === "string") {
        value = "";
        needRemove = true;
      } else if (type === "number") {
        value = 0;
        needRemove = true;
      }
    }
    try {
      el[key] = value;
    } catch (e2) {
    }
    needRemove && el.removeAttribute(key);
  }
  function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
  }
  function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
  }
  const veiKey = Symbol("_vei");
  function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    const invokers = el[veiKey] || (el[veiKey] = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
      existingInvoker.value = nextValue;
    } else {
      const [name, options] = parseName(rawName);
      if (nextValue) {
        const invoker = invokers[rawName] = createInvoker(
          nextValue,
          instance
        );
        addEventListener(el, name, invoker, options);
      } else if (existingInvoker) {
        removeEventListener(el, name, existingInvoker, options);
        invokers[rawName] = void 0;
      }
    }
  }
  const optionsModifierRE = /(?:Once|Passive|Capture)$/;
  function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
      options = {};
      let m2;
      while (m2 = name.match(optionsModifierRE)) {
        name = name.slice(0, name.length - m2[0].length);
        options[m2[0].toLowerCase()] = true;
      }
    }
    const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
    return [event, options];
  }
  let cachedNow = 0;
  const p$2 = /* @__PURE__ */ Promise.resolve();
  const getNow = () => cachedNow || (p$2.then(() => cachedNow = 0), cachedNow = Date.now());
  function createInvoker(initialValue, instance) {
    const invoker = (e2) => {
      if (!e2._vts) {
        e2._vts = Date.now();
      } else if (e2._vts <= invoker.attached) {
        return;
      }
      callWithAsyncErrorHandling(
        patchStopImmediatePropagation(e2, invoker.value),
        instance,
        5,
        [e2]
      );
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
  }
  function patchStopImmediatePropagation(e2, value) {
    if (isArray$2(value)) {
      const originalStop = e2.stopImmediatePropagation;
      e2.stopImmediatePropagation = () => {
        originalStop.call(e2);
        e2._stopped = true;
      };
      return value.map(
        (fn2) => (e22) => !e22._stopped && fn2 && fn2(e22)
      );
    } else {
      return value;
    }
  }
  const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
  key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
  const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
    const isSVG = namespace === "svg";
    if (key === "class") {
      patchClass(el, nextValue, isSVG);
    } else if (key === "style") {
      patchStyle(el, prevValue, nextValue);
    } else if (isOn(key)) {
      if (!isModelListener(key)) {
        patchEvent(el, key, prevValue, nextValue, parentComponent);
      }
    } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
      patchDOMProp(el, key, nextValue);
      if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
        patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
      }
    } else {
      if (key === "true-value") {
        el._trueValue = nextValue;
      } else if (key === "false-value") {
        el._falseValue = nextValue;
      }
      patchAttr(el, key, nextValue, isSVG);
    }
  };
  function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
      if (key === "innerHTML" || key === "textContent") {
        return true;
      }
      if (key in el && isNativeOn(key) && isFunction$1(value)) {
        return true;
      }
      return false;
    }
    if (key === "spellcheck" || key === "draggable" || key === "translate") {
      return false;
    }
    if (key === "form") {
      return false;
    }
    if (key === "list" && el.tagName === "INPUT") {
      return false;
    }
    if (key === "type" && el.tagName === "TEXTAREA") {
      return false;
    }
    if (key === "width" || key === "height") {
      const tag = el.tagName;
      if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
        return false;
      }
    }
    if (isNativeOn(key) && isString$1(value)) {
      return false;
    }
    return key in el;
  }
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function defineCustomElement(options, extraOptions, hydrate2) {
    const Comp = /* @__PURE__ */ defineComponent(options, extraOptions);
    class VueCustomElement extends VueElement {
      constructor(initialProps) {
        super(Comp, initialProps, hydrate2);
      }
    }
    VueCustomElement.def = Comp;
    return VueCustomElement;
  }
  /*! #__NO_SIDE_EFFECTS__ */
  const defineSSRCustomElement = /* @__NO_SIDE_EFFECTS__ */ (options, extraOptions) => {
    return /* @__PURE__ */ defineCustomElement(options, extraOptions, hydrate);
  };
  const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
  };
  class VueElement extends BaseClass {
    constructor(_def, _props = {}, hydrate2) {
      super();
      this._def = _def;
      this._props = _props;
      this._instance = null;
      this._connected = false;
      this._resolved = false;
      this._numberProps = null;
      this._ob = null;
      if (this.shadowRoot && hydrate2) {
        hydrate2(this._createVNode(), this.shadowRoot);
      } else {
        this.attachShadow({ mode: "open" });
        if (!this._def.__asyncLoader) {
          this._resolveProps(this._def);
        }
      }
    }
    connectedCallback() {
      this._connected = true;
      if (!this._instance) {
        if (this._resolved) {
          this._update();
        } else {
          this._resolveDef();
        }
      }
    }
    disconnectedCallback() {
      this._connected = false;
      nextTick(() => {
        if (!this._connected) {
          if (this._ob) {
            this._ob.disconnect();
            this._ob = null;
          }
          render$1(null, this.shadowRoot);
          this._instance = null;
        }
      });
    }
    /**
     * resolve inner component definition (handle possible async component)
     */
    _resolveDef() {
      this._resolved = true;
      for (let i2 = 0; i2 < this.attributes.length; i2++) {
        this._setAttr(this.attributes[i2].name);
      }
      this._ob = new MutationObserver((mutations) => {
        for (const m2 of mutations) {
          this._setAttr(m2.attributeName);
        }
      });
      this._ob.observe(this, { attributes: true });
      const resolve2 = (def2, isAsync = false) => {
        const { props, styles } = def2;
        let numberProps;
        if (props && !isArray$2(props)) {
          for (const key in props) {
            const opt = props[key];
            if (opt === Number || opt && opt.type === Number) {
              if (key in this._props) {
                this._props[key] = toNumber(this._props[key]);
              }
              (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[camelize(key)] = true;
            }
          }
        }
        this._numberProps = numberProps;
        if (isAsync) {
          this._resolveProps(def2);
        }
        this._applyStyles(styles);
        this._update();
      };
      const asyncDef = this._def.__asyncLoader;
      if (asyncDef) {
        asyncDef().then((def2) => resolve2(def2, true));
      } else {
        resolve2(this._def);
      }
    }
    _resolveProps(def2) {
      const { props } = def2;
      const declaredPropKeys = isArray$2(props) ? props : Object.keys(props || {});
      for (const key of Object.keys(this)) {
        if (key[0] !== "_" && declaredPropKeys.includes(key)) {
          this._setProp(key, this[key], true, false);
        }
      }
      for (const key of declaredPropKeys.map(camelize)) {
        Object.defineProperty(this, key, {
          get() {
            return this._getProp(key);
          },
          set(val) {
            this._setProp(key, val);
          }
        });
      }
    }
    _setAttr(key) {
      let value = this.hasAttribute(key) ? this.getAttribute(key) : void 0;
      const camelKey = camelize(key);
      if (this._numberProps && this._numberProps[camelKey]) {
        value = toNumber(value);
      }
      this._setProp(camelKey, value, false);
    }
    /**
     * @internal
     */
    _getProp(key) {
      return this._props[key];
    }
    /**
     * @internal
     */
    _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
      if (val !== this._props[key]) {
        this._props[key] = val;
        if (shouldUpdate && this._instance) {
          this._update();
        }
        if (shouldReflect) {
          if (val === true) {
            this.setAttribute(hyphenate(key), "");
          } else if (typeof val === "string" || typeof val === "number") {
            this.setAttribute(hyphenate(key), val + "");
          } else if (!val) {
            this.removeAttribute(hyphenate(key));
          }
        }
      }
    }
    _update() {
      render$1(this._createVNode(), this.shadowRoot);
    }
    _createVNode() {
      const vnode = createVNode(this._def, extend$1({}, this._props));
      if (!this._instance) {
        vnode.ce = (instance) => {
          this._instance = instance;
          instance.isCE = true;
          const dispatch = (event, args) => {
            this.dispatchEvent(
              new CustomEvent(event, {
                detail: args
              })
            );
          };
          instance.emit = (event, ...args) => {
            dispatch(event, args);
            if (hyphenate(event) !== event) {
              dispatch(hyphenate(event), args);
            }
          };
          let parent = this;
          while (parent = parent && (parent.parentNode || parent.host)) {
            if (parent instanceof VueElement) {
              instance.parent = parent._instance;
              instance.provides = parent._instance.provides;
              break;
            }
          }
        };
      }
      return vnode;
    }
    _applyStyles(styles) {
      if (styles) {
        styles.forEach((css) => {
          const s2 = document.createElement("style");
          s2.textContent = css;
          this.shadowRoot.appendChild(s2);
        });
      }
    }
  }
  function useCssModule(name = "$style") {
    {
      const instance = getCurrentInstance();
      if (!instance) {
        return EMPTY_OBJ;
      }
      const modules = instance.type.__cssModules;
      if (!modules) {
        return EMPTY_OBJ;
      }
      const mod = modules[name];
      if (!mod) {
        return EMPTY_OBJ;
      }
      return mod;
    }
  }
  const positionMap = /* @__PURE__ */ new WeakMap();
  const newPositionMap = /* @__PURE__ */ new WeakMap();
  const moveCbKey = Symbol("_moveCb");
  const enterCbKey = Symbol("_enterCb");
  const TransitionGroupImpl = {
    name: "TransitionGroup",
    props: /* @__PURE__ */ extend$1({}, TransitionPropsValidators, {
      tag: String,
      moveClass: String
    }),
    setup(props, { slots }) {
      const instance = getCurrentInstance();
      const state = useTransitionState();
      let prevChildren;
      let children;
      onUpdated(() => {
        if (!prevChildren.length) {
          return;
        }
        const moveClass = props.moveClass || `${props.name || "v"}-move`;
        if (!hasCSSTransform(
          prevChildren[0].el,
          instance.vnode.el,
          moveClass
        )) {
          return;
        }
        prevChildren.forEach(callPendingCbs);
        prevChildren.forEach(recordPosition);
        const movedChildren = prevChildren.filter(applyTranslation);
        forceReflow();
        movedChildren.forEach((c2) => {
          const el = c2.el;
          const style = el.style;
          addTransitionClass(el, moveClass);
          style.transform = style.webkitTransform = style.transitionDuration = "";
          const cb = el[moveCbKey] = (e2) => {
            if (e2 && e2.target !== el) {
              return;
            }
            if (!e2 || /transform$/.test(e2.propertyName)) {
              el.removeEventListener("transitionend", cb);
              el[moveCbKey] = null;
              removeTransitionClass(el, moveClass);
            }
          };
          el.addEventListener("transitionend", cb);
        });
      });
      return () => {
        const rawProps = toRaw(props);
        const cssTransitionProps = resolveTransitionProps(rawProps);
        let tag = rawProps.tag || Fragment;
        prevChildren = [];
        if (children) {
          for (let i2 = 0; i2 < children.length; i2++) {
            const child = children[i2];
            if (child.el && child.el instanceof Element) {
              prevChildren.push(child);
              setTransitionHooks(
                child,
                resolveTransitionHooks(
                  child,
                  cssTransitionProps,
                  state,
                  instance
                )
              );
              positionMap.set(
                child,
                child.el.getBoundingClientRect()
              );
            }
          }
        }
        children = slots.default ? getTransitionRawChildren(slots.default()) : [];
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          if (child.key != null) {
            setTransitionHooks(
              child,
              resolveTransitionHooks(child, cssTransitionProps, state, instance)
            );
          }
        }
        return createVNode(tag, null, children);
      };
    }
  };
  const removeMode = (props) => delete props.mode;
  /* @__PURE__ */ removeMode(TransitionGroupImpl.props);
  const TransitionGroup = TransitionGroupImpl;
  function callPendingCbs(c2) {
    const el = c2.el;
    if (el[moveCbKey]) {
      el[moveCbKey]();
    }
    if (el[enterCbKey]) {
      el[enterCbKey]();
    }
  }
  function recordPosition(c2) {
    newPositionMap.set(c2, c2.el.getBoundingClientRect());
  }
  function applyTranslation(c2) {
    const oldPos = positionMap.get(c2);
    const newPos = newPositionMap.get(c2);
    const dx = oldPos.left - newPos.left;
    const dy = oldPos.top - newPos.top;
    if (dx || dy) {
      const s2 = c2.el.style;
      s2.transform = s2.webkitTransform = `translate(${dx}px,${dy}px)`;
      s2.transitionDuration = "0s";
      return c2;
    }
  }
  function hasCSSTransform(el, root, moveClass) {
    const clone = el.cloneNode();
    const _vtc = el[vtcKey];
    if (_vtc) {
      _vtc.forEach((cls) => {
        cls.split(/\s+/).forEach((c2) => c2 && clone.classList.remove(c2));
      });
    }
    moveClass.split(/\s+/).forEach((c2) => c2 && clone.classList.add(c2));
    clone.style.display = "none";
    const container = root.nodeType === 1 ? root : root.parentNode;
    container.appendChild(clone);
    const { hasTransform } = getTransitionInfo(clone);
    container.removeChild(clone);
    return hasTransform;
  }
  const getModelAssigner = (vnode) => {
    const fn2 = vnode.props["onUpdate:modelValue"] || false;
    return isArray$2(fn2) ? (value) => invokeArrayFns(fn2, value) : fn2;
  };
  function onCompositionStart(e2) {
    e2.target.composing = true;
  }
  function onCompositionEnd(e2) {
    const target = e2.target;
    if (target.composing) {
      target.composing = false;
      target.dispatchEvent(new Event("input"));
    }
  }
  const assignKey = Symbol("_assign");
  const vModelText = {
    created(el, { modifiers: { lazy, trim: trim2, number: number2 } }, vnode) {
      el[assignKey] = getModelAssigner(vnode);
      const castToNumber = number2 || vnode.props && vnode.props.type === "number";
      addEventListener(el, lazy ? "change" : "input", (e2) => {
        if (e2.target.composing) return;
        let domValue = el.value;
        if (trim2) {
          domValue = domValue.trim();
        }
        if (castToNumber) {
          domValue = looseToNumber(domValue);
        }
        el[assignKey](domValue);
      });
      if (trim2) {
        addEventListener(el, "change", () => {
          el.value = el.value.trim();
        });
      }
      if (!lazy) {
        addEventListener(el, "compositionstart", onCompositionStart);
        addEventListener(el, "compositionend", onCompositionEnd);
        addEventListener(el, "change", onCompositionEnd);
      }
    },
    // set value on mounted so it's after min/max for type="range"
    mounted(el, { value }) {
      el.value = value == null ? "" : value;
    },
    beforeUpdate(el, { value, oldValue, modifiers: { lazy, trim: trim2, number: number2 } }, vnode) {
      el[assignKey] = getModelAssigner(vnode);
      if (el.composing) return;
      const elValue = (number2 || el.type === "number") && !/^0\d/.test(el.value) ? looseToNumber(el.value) : el.value;
      const newValue = value == null ? "" : value;
      if (elValue === newValue) {
        return;
      }
      if (document.activeElement === el && el.type !== "range") {
        if (lazy && value === oldValue) {
          return;
        }
        if (trim2 && el.value.trim() === newValue) {
          return;
        }
      }
      el.value = newValue;
    }
  };
  const vModelCheckbox = {
    // #4096 array checkboxes need to be deep traversed
    deep: true,
    created(el, _2, vnode) {
      el[assignKey] = getModelAssigner(vnode);
      addEventListener(el, "change", () => {
        const modelValue = el._modelValue;
        const elementValue = getValue(el);
        const checked = el.checked;
        const assign2 = el[assignKey];
        if (isArray$2(modelValue)) {
          const index = looseIndexOf(modelValue, elementValue);
          const found = index !== -1;
          if (checked && !found) {
            assign2(modelValue.concat(elementValue));
          } else if (!checked && found) {
            const filtered = [...modelValue];
            filtered.splice(index, 1);
            assign2(filtered);
          }
        } else if (isSet(modelValue)) {
          const cloned = new Set(modelValue);
          if (checked) {
            cloned.add(elementValue);
          } else {
            cloned.delete(elementValue);
          }
          assign2(cloned);
        } else {
          assign2(getCheckboxValue(el, checked));
        }
      });
    },
    // set initial checked on mount to wait for true-value/false-value
    mounted: setChecked,
    beforeUpdate(el, binding, vnode) {
      el[assignKey] = getModelAssigner(vnode);
      setChecked(el, binding, vnode);
    }
  };
  function setChecked(el, { value, oldValue }, vnode) {
    el._modelValue = value;
    if (isArray$2(value)) {
      el.checked = looseIndexOf(value, vnode.props.value) > -1;
    } else if (isSet(value)) {
      el.checked = value.has(vnode.props.value);
    } else if (value !== oldValue) {
      el.checked = looseEqual(value, getCheckboxValue(el, true));
    }
  }
  const vModelRadio = {
    created(el, { value }, vnode) {
      el.checked = looseEqual(value, vnode.props.value);
      el[assignKey] = getModelAssigner(vnode);
      addEventListener(el, "change", () => {
        el[assignKey](getValue(el));
      });
    },
    beforeUpdate(el, { value, oldValue }, vnode) {
      el[assignKey] = getModelAssigner(vnode);
      if (value !== oldValue) {
        el.checked = looseEqual(value, vnode.props.value);
      }
    }
  };
  const vModelSelect = {
    // <select multiple> value need to be deep traversed
    deep: true,
    created(el, { value, modifiers: { number: number2 } }, vnode) {
      const isSetModel = isSet(value);
      addEventListener(el, "change", () => {
        const selectedVal = Array.prototype.filter.call(el.options, (o2) => o2.selected).map(
          (o2) => number2 ? looseToNumber(getValue(o2)) : getValue(o2)
        );
        el[assignKey](
          el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
        );
        el._assigning = true;
        nextTick(() => {
          el._assigning = false;
        });
      });
      el[assignKey] = getModelAssigner(vnode);
    },
    // set value in mounted & updated because <select> relies on its children
    // <option>s.
    mounted(el, { value, modifiers: { number: number2 } }) {
      setSelected(el, value);
    },
    beforeUpdate(el, _binding, vnode) {
      el[assignKey] = getModelAssigner(vnode);
    },
    updated(el, { value, modifiers: { number: number2 } }) {
      if (!el._assigning) {
        setSelected(el, value);
      }
    }
  };
  function setSelected(el, value, number2) {
    const isMultiple = el.multiple;
    const isArrayValue = isArray$2(value);
    if (isMultiple && !isArrayValue && !isSet(value)) {
      return;
    }
    for (let i2 = 0, l2 = el.options.length; i2 < l2; i2++) {
      const option = el.options[i2];
      const optionValue = getValue(option);
      if (isMultiple) {
        if (isArrayValue) {
          const optionType = typeof optionValue;
          if (optionType === "string" || optionType === "number") {
            option.selected = value.some((v2) => String(v2) === String(optionValue));
          } else {
            option.selected = looseIndexOf(value, optionValue) > -1;
          }
        } else {
          option.selected = value.has(optionValue);
        }
      } else if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i2) el.selectedIndex = i2;
        return;
      }
    }
    if (!isMultiple && el.selectedIndex !== -1) {
      el.selectedIndex = -1;
    }
  }
  function getValue(el) {
    return "_value" in el ? el._value : el.value;
  }
  function getCheckboxValue(el, checked) {
    const key = checked ? "_trueValue" : "_falseValue";
    return key in el ? el[key] : checked;
  }
  const vModelDynamic = {
    created(el, binding, vnode) {
      callModelHook(el, binding, vnode, null, "created");
    },
    mounted(el, binding, vnode) {
      callModelHook(el, binding, vnode, null, "mounted");
    },
    beforeUpdate(el, binding, vnode, prevVNode) {
      callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
    },
    updated(el, binding, vnode, prevVNode) {
      callModelHook(el, binding, vnode, prevVNode, "updated");
    }
  };
  function resolveDynamicModel(tagName, type) {
    switch (tagName) {
      case "SELECT":
        return vModelSelect;
      case "TEXTAREA":
        return vModelText;
      default:
        switch (type) {
          case "checkbox":
            return vModelCheckbox;
          case "radio":
            return vModelRadio;
          default:
            return vModelText;
        }
    }
  }
  function callModelHook(el, binding, vnode, prevVNode, hook) {
    const modelToUse = resolveDynamicModel(
      el.tagName,
      vnode.props && vnode.props.type
    );
    const fn2 = modelToUse[hook];
    fn2 && fn2(el, binding, vnode, prevVNode);
  }
  function initVModelForSSR() {
    vModelText.getSSRProps = ({ value }) => ({ value });
    vModelRadio.getSSRProps = ({ value }, vnode) => {
      if (vnode.props && looseEqual(vnode.props.value, value)) {
        return { checked: true };
      }
    };
    vModelCheckbox.getSSRProps = ({ value }, vnode) => {
      if (isArray$2(value)) {
        if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {
          return { checked: true };
        }
      } else if (isSet(value)) {
        if (vnode.props && value.has(vnode.props.value)) {
          return { checked: true };
        }
      } else if (value) {
        return { checked: true };
      }
    };
    vModelDynamic.getSSRProps = (binding, vnode) => {
      if (typeof vnode.type !== "string") {
        return;
      }
      const modelToUse = resolveDynamicModel(
        // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
        vnode.type.toUpperCase(),
        vnode.props && vnode.props.type
      );
      if (modelToUse.getSSRProps) {
        return modelToUse.getSSRProps(binding, vnode);
      }
    };
  }
  const systemModifiers = ["ctrl", "shift", "alt", "meta"];
  const modifierGuards = {
    stop: (e2) => e2.stopPropagation(),
    prevent: (e2) => e2.preventDefault(),
    self: (e2) => e2.target !== e2.currentTarget,
    ctrl: (e2) => !e2.ctrlKey,
    shift: (e2) => !e2.shiftKey,
    alt: (e2) => !e2.altKey,
    meta: (e2) => !e2.metaKey,
    left: (e2) => "button" in e2 && e2.button !== 0,
    middle: (e2) => "button" in e2 && e2.button !== 1,
    right: (e2) => "button" in e2 && e2.button !== 2,
    exact: (e2, modifiers) => systemModifiers.some((m2) => e2[`${m2}Key`] && !modifiers.includes(m2))
  };
  const withModifiers = (fn2, modifiers) => {
    const cache2 = fn2._withMods || (fn2._withMods = {});
    const cacheKey = modifiers.join(".");
    return cache2[cacheKey] || (cache2[cacheKey] = (event, ...args) => {
      for (let i2 = 0; i2 < modifiers.length; i2++) {
        const guard = modifierGuards[modifiers[i2]];
        if (guard && guard(event, modifiers)) return;
      }
      return fn2(event, ...args);
    });
  };
  const keyNames = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
  };
  const withKeys = (fn2, modifiers) => {
    const cache2 = fn2._withKeys || (fn2._withKeys = {});
    const cacheKey = modifiers.join(".");
    return cache2[cacheKey] || (cache2[cacheKey] = (event) => {
      if (!("key" in event)) {
        return;
      }
      const eventKey = hyphenate(event.key);
      if (modifiers.some((k2) => k2 === eventKey || keyNames[k2] === eventKey)) {
        return fn2(event);
      }
    });
  };
  const rendererOptions = /* @__PURE__ */ extend$1({ patchProp }, nodeOps);
  let renderer;
  let enabledHydration = false;
  function ensureRenderer() {
    return renderer || (renderer = createRenderer(rendererOptions));
  }
  function ensureHydrationRenderer() {
    renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions);
    enabledHydration = true;
    return renderer;
  }
  const render$1 = (...args) => {
    ensureRenderer().render(...args);
  };
  const hydrate = (...args) => {
    ensureHydrationRenderer().hydrate(...args);
  };
  const createApp = (...args) => {
    const app = ensureRenderer().createApp(...args);
    const { mount } = app;
    app.mount = (containerOrSelector) => {
      const container = normalizeContainer(containerOrSelector);
      if (!container) return;
      const component = app._component;
      if (!isFunction$1(component) && !component.render && !component.template) {
        component.template = container.innerHTML;
      }
      container.innerHTML = "";
      const proxy = mount(container, false, resolveRootNamespace(container));
      if (container instanceof Element) {
        container.removeAttribute("v-cloak");
        container.setAttribute("data-v-app", "");
      }
      return proxy;
    };
    return app;
  };
  const createSSRApp = (...args) => {
    const app = ensureHydrationRenderer().createApp(...args);
    const { mount } = app;
    app.mount = (containerOrSelector) => {
      const container = normalizeContainer(containerOrSelector);
      if (container) {
        return mount(container, true, resolveRootNamespace(container));
      }
    };
    return app;
  };
  function resolveRootNamespace(container) {
    if (container instanceof SVGElement) {
      return "svg";
    }
    if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
      return "mathml";
    }
  }
  function normalizeContainer(container) {
    if (isString$1(container)) {
      const res = document.querySelector(container);
      return res;
    }
    return container;
  }
  let ssrDirectiveInitialized = false;
  const initDirectivesForSSR = () => {
    if (!ssrDirectiveInitialized) {
      ssrDirectiveInitialized = true;
      initVModelForSSR();
      initVShowForSSR();
    }
  };
  const runtimeDom = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    BaseTransition,
    BaseTransitionPropsValidators,
    Comment,
    DeprecationTypes,
    EffectScope,
    ErrorCodes,
    ErrorTypeStrings,
    Fragment,
    KeepAlive,
    ReactiveEffect,
    Static,
    Suspense,
    Teleport,
    Text,
    TrackOpTypes,
    Transition,
    TransitionGroup,
    TriggerOpTypes,
    VueElement,
    assertNumber,
    callWithAsyncErrorHandling,
    callWithErrorHandling,
    camelize,
    capitalize,
    cloneVNode,
    compatUtils,
    computed,
    createApp,
    createBlock,
    createCommentVNode,
    createElementBlock,
    createElementVNode: createBaseVNode,
    createHydrationRenderer,
    createPropsRestProxy,
    createRenderer,
    createSSRApp,
    createSlots,
    createStaticVNode,
    createTextVNode,
    createVNode,
    customRef,
    defineAsyncComponent,
    defineComponent,
    defineCustomElement,
    defineEmits,
    defineExpose,
    defineModel,
    defineOptions,
    defineProps,
    defineSSRCustomElement,
    defineSlots,
    devtools,
    effect,
    effectScope,
    getCurrentInstance,
    getCurrentScope,
    getTransitionRawChildren,
    guardReactiveProps,
    h: h$1,
    handleError,
    hasInjectionContext,
    hydrate,
    initCustomFormatter,
    initDirectivesForSSR,
    inject,
    isMemoSame,
    isProxy,
    isReactive,
    isReadonly,
    isRef,
    isRuntimeOnly,
    isShallow,
    isVNode: isVNode$1,
    markRaw,
    mergeDefaults,
    mergeModels,
    mergeProps,
    nextTick,
    normalizeClass,
    normalizeProps,
    normalizeStyle,
    onActivated,
    onBeforeMount,
    onBeforeUnmount,
    onBeforeUpdate,
    onDeactivated,
    onErrorCaptured,
    onMounted,
    onRenderTracked,
    onRenderTriggered,
    onScopeDispose,
    onServerPrefetch,
    onUnmounted,
    onUpdated,
    openBlock,
    popScopeId,
    provide,
    proxyRefs,
    pushScopeId,
    queuePostFlushCb,
    reactive,
    readonly,
    ref,
    registerRuntimeCompiler,
    render: render$1,
    renderList,
    renderSlot,
    resolveComponent,
    resolveDirective,
    resolveDynamicComponent,
    resolveFilter,
    resolveTransitionHooks,
    setBlockTracking,
    setDevtoolsHook,
    setTransitionHooks,
    shallowReactive,
    shallowReadonly,
    shallowRef,
    ssrContextKey,
    ssrUtils,
    stop,
    toDisplayString,
    toHandlerKey,
    toHandlers,
    toRaw,
    toRef,
    toRefs,
    toValue,
    transformVNodeArgs,
    triggerRef,
    unref,
    useAttrs,
    useCssModule,
    useCssVars,
    useModel,
    useSSRContext,
    useSlots,
    useTransitionState,
    vModelCheckbox,
    vModelDynamic,
    vModelRadio,
    vModelSelect,
    vModelText,
    vShow,
    version,
    warn,
    watch,
    watchEffect,
    watchPostEffect,
    watchSyncEffect,
    withAsyncContext,
    withCtx,
    withDefaults,
    withDirectives,
    withKeys,
    withMemo,
    withModifiers,
    withScopeId
  }, Symbol.toStringTag, { value: "Module" }));
  /**
  * @vue/compiler-core v3.4.32
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  const FRAGMENT = Symbol(``);
  const TELEPORT = Symbol(``);
  const SUSPENSE = Symbol(``);
  const KEEP_ALIVE = Symbol(``);
  const BASE_TRANSITION = Symbol(``);
  const OPEN_BLOCK = Symbol(``);
  const CREATE_BLOCK = Symbol(``);
  const CREATE_ELEMENT_BLOCK = Symbol(``);
  const CREATE_VNODE = Symbol(``);
  const CREATE_ELEMENT_VNODE = Symbol(``);
  const CREATE_COMMENT = Symbol(``);
  const CREATE_TEXT = Symbol(``);
  const CREATE_STATIC = Symbol(``);
  const RESOLVE_COMPONENT = Symbol(``);
  const RESOLVE_DYNAMIC_COMPONENT = Symbol(
    ``
  );
  const RESOLVE_DIRECTIVE = Symbol(``);
  const RESOLVE_FILTER = Symbol(``);
  const WITH_DIRECTIVES = Symbol(``);
  const RENDER_LIST = Symbol(``);
  const RENDER_SLOT = Symbol(``);
  const CREATE_SLOTS = Symbol(``);
  const TO_DISPLAY_STRING = Symbol(``);
  const MERGE_PROPS = Symbol(``);
  const NORMALIZE_CLASS = Symbol(``);
  const NORMALIZE_STYLE = Symbol(``);
  const NORMALIZE_PROPS = Symbol(``);
  const GUARD_REACTIVE_PROPS = Symbol(``);
  const TO_HANDLERS = Symbol(``);
  const CAMELIZE = Symbol(``);
  const CAPITALIZE = Symbol(``);
  const TO_HANDLER_KEY = Symbol(``);
  const SET_BLOCK_TRACKING = Symbol(``);
  const PUSH_SCOPE_ID = Symbol(``);
  const POP_SCOPE_ID = Symbol(``);
  const WITH_CTX = Symbol(``);
  const UNREF = Symbol(``);
  const IS_REF = Symbol(``);
  const WITH_MEMO = Symbol(``);
  const IS_MEMO_SAME = Symbol(``);
  const helperNameMap = {
    [FRAGMENT]: `Fragment`,
    [TELEPORT]: `Teleport`,
    [SUSPENSE]: `Suspense`,
    [KEEP_ALIVE]: `KeepAlive`,
    [BASE_TRANSITION]: `BaseTransition`,
    [OPEN_BLOCK]: `openBlock`,
    [CREATE_BLOCK]: `createBlock`,
    [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
    [CREATE_VNODE]: `createVNode`,
    [CREATE_ELEMENT_VNODE]: `createElementVNode`,
    [CREATE_COMMENT]: `createCommentVNode`,
    [CREATE_TEXT]: `createTextVNode`,
    [CREATE_STATIC]: `createStaticVNode`,
    [RESOLVE_COMPONENT]: `resolveComponent`,
    [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
    [RESOLVE_DIRECTIVE]: `resolveDirective`,
    [RESOLVE_FILTER]: `resolveFilter`,
    [WITH_DIRECTIVES]: `withDirectives`,
    [RENDER_LIST]: `renderList`,
    [RENDER_SLOT]: `renderSlot`,
    [CREATE_SLOTS]: `createSlots`,
    [TO_DISPLAY_STRING]: `toDisplayString`,
    [MERGE_PROPS]: `mergeProps`,
    [NORMALIZE_CLASS]: `normalizeClass`,
    [NORMALIZE_STYLE]: `normalizeStyle`,
    [NORMALIZE_PROPS]: `normalizeProps`,
    [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
    [TO_HANDLERS]: `toHandlers`,
    [CAMELIZE]: `camelize`,
    [CAPITALIZE]: `capitalize`,
    [TO_HANDLER_KEY]: `toHandlerKey`,
    [SET_BLOCK_TRACKING]: `setBlockTracking`,
    [PUSH_SCOPE_ID]: `pushScopeId`,
    [POP_SCOPE_ID]: `popScopeId`,
    [WITH_CTX]: `withCtx`,
    [UNREF]: `unref`,
    [IS_REF]: `isRef`,
    [WITH_MEMO]: `withMemo`,
    [IS_MEMO_SAME]: `isMemoSame`
  };
  function registerRuntimeHelpers(helpers) {
    Object.getOwnPropertySymbols(helpers).forEach((s2) => {
      helperNameMap[s2] = helpers[s2];
    });
  }
  const locStub = {
    start: { line: 1, column: 1, offset: 0 },
    end: { line: 1, column: 1, offset: 0 },
    source: ""
  };
  function createRoot(children, source = "") {
    return {
      type: 0,
      source,
      children,
      helpers: /* @__PURE__ */ new Set(),
      components: [],
      directives: [],
      hoists: [],
      imports: [],
      cached: 0,
      temps: 0,
      codegenNode: void 0,
      loc: locStub
    };
  }
  function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent2 = false, loc = locStub) {
    if (context) {
      if (isBlock) {
        context.helper(OPEN_BLOCK);
        context.helper(getVNodeBlockHelper(context.inSSR, isComponent2));
      } else {
        context.helper(getVNodeHelper(context.inSSR, isComponent2));
      }
      if (directives) {
        context.helper(WITH_DIRECTIVES);
      }
    }
    return {
      type: 13,
      tag,
      props,
      children,
      patchFlag,
      dynamicProps,
      directives,
      isBlock,
      disableTracking,
      isComponent: isComponent2,
      loc
    };
  }
  function createArrayExpression(elements, loc = locStub) {
    return {
      type: 17,
      loc,
      elements
    };
  }
  function createObjectExpression(properties, loc = locStub) {
    return {
      type: 15,
      loc,
      properties
    };
  }
  function createObjectProperty(key, value) {
    return {
      type: 16,
      loc: locStub,
      key: isString$1(key) ? createSimpleExpression(key, true) : key,
      value
    };
  }
  function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
    return {
      type: 4,
      loc,
      content,
      isStatic,
      constType: isStatic ? 3 : constType
    };
  }
  function createCompoundExpression(children, loc = locStub) {
    return {
      type: 8,
      loc,
      children
    };
  }
  function createCallExpression(callee, args = [], loc = locStub) {
    return {
      type: 14,
      loc,
      callee,
      arguments: args
    };
  }
  function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
    return {
      type: 18,
      params,
      returns,
      newline,
      isSlot,
      loc
    };
  }
  function createConditionalExpression(test2, consequent, alternate, newline = true) {
    return {
      type: 19,
      test: test2,
      consequent,
      alternate,
      newline,
      loc: locStub
    };
  }
  function createCacheExpression(index, value, isVOnce = false) {
    return {
      type: 20,
      index,
      value,
      isVOnce,
      loc: locStub
    };
  }
  function createBlockStatement(body) {
    return {
      type: 21,
      body,
      loc: locStub
    };
  }
  function getVNodeHelper(ssr, isComponent2) {
    return ssr || isComponent2 ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
  }
  function getVNodeBlockHelper(ssr, isComponent2) {
    return ssr || isComponent2 ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
  }
  function convertToBlock(node, { helper, removeHelper, inSSR }) {
    if (!node.isBlock) {
      node.isBlock = true;
      removeHelper(getVNodeHelper(inSSR, node.isComponent));
      helper(OPEN_BLOCK);
      helper(getVNodeBlockHelper(inSSR, node.isComponent));
    }
  }
  const defaultDelimitersOpen = new Uint8Array([123, 123]);
  const defaultDelimitersClose = new Uint8Array([125, 125]);
  function isTagStartChar(c2) {
    return c2 >= 97 && c2 <= 122 || c2 >= 65 && c2 <= 90;
  }
  function isWhitespace(c2) {
    return c2 === 32 || c2 === 10 || c2 === 9 || c2 === 12 || c2 === 13;
  }
  function isEndOfTagSection(c2) {
    return c2 === 47 || c2 === 62 || isWhitespace(c2);
  }
  function toCharCodes(str) {
    const ret = new Uint8Array(str.length);
    for (let i2 = 0; i2 < str.length; i2++) {
      ret[i2] = str.charCodeAt(i2);
    }
    return ret;
  }
  const Sequences = {
    Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
    // CDATA[
    CdataEnd: new Uint8Array([93, 93, 62]),
    // ]]>
    CommentEnd: new Uint8Array([45, 45, 62]),
    // `-->`
    ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
    // `<\/script`
    StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
    // `</style`
    TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
    // `</title`
    TextareaEnd: new Uint8Array([
      60,
      47,
      116,
      101,
      120,
      116,
      97,
      114,
      101,
      97
    ])
    // `</textarea
  };
  class Tokenizer {
    constructor(stack2, cbs) {
      this.stack = stack2;
      this.cbs = cbs;
      this.state = 1;
      this.buffer = "";
      this.sectionStart = 0;
      this.index = 0;
      this.entityStart = 0;
      this.baseState = 1;
      this.inRCDATA = false;
      this.inXML = false;
      this.inVPre = false;
      this.newlines = [];
      this.mode = 0;
      this.delimiterOpen = defaultDelimitersOpen;
      this.delimiterClose = defaultDelimitersClose;
      this.delimiterIndex = -1;
      this.currentSequence = void 0;
      this.sequenceIndex = 0;
    }
    get inSFCRoot() {
      return this.mode === 2 && this.stack.length === 0;
    }
    reset() {
      this.state = 1;
      this.mode = 0;
      this.buffer = "";
      this.sectionStart = 0;
      this.index = 0;
      this.baseState = 1;
      this.inRCDATA = false;
      this.currentSequence = void 0;
      this.newlines.length = 0;
      this.delimiterOpen = defaultDelimitersOpen;
      this.delimiterClose = defaultDelimitersClose;
    }
    /**
     * Generate Position object with line / column information using recorded
     * newline positions. We know the index is always going to be an already
     * processed index, so all the newlines up to this index should have been
     * recorded.
     */
    getPos(index) {
      let line = 1;
      let column = index + 1;
      for (let i2 = this.newlines.length - 1; i2 >= 0; i2--) {
        const newlineIndex = this.newlines[i2];
        if (index > newlineIndex) {
          line = i2 + 2;
          column = index - newlineIndex;
          break;
        }
      }
      return {
        column,
        line,
        offset: index
      };
    }
    peek() {
      return this.buffer.charCodeAt(this.index + 1);
    }
    stateText(c2) {
      if (c2 === 60) {
        if (this.index > this.sectionStart) {
          this.cbs.ontext(this.sectionStart, this.index);
        }
        this.state = 5;
        this.sectionStart = this.index;
      } else if (!this.inVPre && c2 === this.delimiterOpen[0]) {
        this.state = 2;
        this.delimiterIndex = 0;
        this.stateInterpolationOpen(c2);
      }
    }
    stateInterpolationOpen(c2) {
      if (c2 === this.delimiterOpen[this.delimiterIndex]) {
        if (this.delimiterIndex === this.delimiterOpen.length - 1) {
          const start = this.index + 1 - this.delimiterOpen.length;
          if (start > this.sectionStart) {
            this.cbs.ontext(this.sectionStart, start);
          }
          this.state = 3;
          this.sectionStart = start;
        } else {
          this.delimiterIndex++;
        }
      } else if (this.inRCDATA) {
        this.state = 32;
        this.stateInRCDATA(c2);
      } else {
        this.state = 1;
        this.stateText(c2);
      }
    }
    stateInterpolation(c2) {
      if (c2 === this.delimiterClose[0]) {
        this.state = 4;
        this.delimiterIndex = 0;
        this.stateInterpolationClose(c2);
      }
    }
    stateInterpolationClose(c2) {
      if (c2 === this.delimiterClose[this.delimiterIndex]) {
        if (this.delimiterIndex === this.delimiterClose.length - 1) {
          this.cbs.oninterpolation(this.sectionStart, this.index + 1);
          if (this.inRCDATA) {
            this.state = 32;
          } else {
            this.state = 1;
          }
          this.sectionStart = this.index + 1;
        } else {
          this.delimiterIndex++;
        }
      } else {
        this.state = 3;
        this.stateInterpolation(c2);
      }
    }
    stateSpecialStartSequence(c2) {
      const isEnd = this.sequenceIndex === this.currentSequence.length;
      const isMatch = isEnd ? (
        // If we are at the end of the sequence, make sure the tag name has ended
        isEndOfTagSection(c2)
      ) : (
        // Otherwise, do a case-insensitive comparison
        (c2 | 32) === this.currentSequence[this.sequenceIndex]
      );
      if (!isMatch) {
        this.inRCDATA = false;
      } else if (!isEnd) {
        this.sequenceIndex++;
        return;
      }
      this.sequenceIndex = 0;
      this.state = 6;
      this.stateInTagName(c2);
    }
    /** Look for an end tag. For <title> and <textarea>, also decode entities. */
    stateInRCDATA(c2) {
      if (this.sequenceIndex === this.currentSequence.length) {
        if (c2 === 62 || isWhitespace(c2)) {
          const endOfText = this.index - this.currentSequence.length;
          if (this.sectionStart < endOfText) {
            const actualIndex = this.index;
            this.index = endOfText;
            this.cbs.ontext(this.sectionStart, endOfText);
            this.index = actualIndex;
          }
          this.sectionStart = endOfText + 2;
          this.stateInClosingTagName(c2);
          this.inRCDATA = false;
          return;
        }
        this.sequenceIndex = 0;
      }
      if ((c2 | 32) === this.currentSequence[this.sequenceIndex]) {
        this.sequenceIndex += 1;
      } else if (this.sequenceIndex === 0) {
        if (this.currentSequence === Sequences.TitleEnd || this.currentSequence === Sequences.TextareaEnd && !this.inSFCRoot) {
          if (c2 === this.delimiterOpen[0]) {
            this.state = 2;
            this.delimiterIndex = 0;
            this.stateInterpolationOpen(c2);
          }
        } else if (this.fastForwardTo(60)) {
          this.sequenceIndex = 1;
        }
      } else {
        this.sequenceIndex = Number(c2 === 60);
      }
    }
    stateCDATASequence(c2) {
      if (c2 === Sequences.Cdata[this.sequenceIndex]) {
        if (++this.sequenceIndex === Sequences.Cdata.length) {
          this.state = 28;
          this.currentSequence = Sequences.CdataEnd;
          this.sequenceIndex = 0;
          this.sectionStart = this.index + 1;
        }
      } else {
        this.sequenceIndex = 0;
        this.state = 23;
        this.stateInDeclaration(c2);
      }
    }
    /**
     * When we wait for one specific character, we can speed things up
     * by skipping through the buffer until we find it.
     *
     * @returns Whether the character was found.
     */
    fastForwardTo(c2) {
      while (++this.index < this.buffer.length) {
        const cc = this.buffer.charCodeAt(this.index);
        if (cc === 10) {
          this.newlines.push(this.index);
        }
        if (cc === c2) {
          return true;
        }
      }
      this.index = this.buffer.length - 1;
      return false;
    }
    /**
     * Comments and CDATA end with `-->` and `]]>`.
     *
     * Their common qualities are:
     * - Their end sequences have a distinct character they start with.
     * - That character is then repeated, so we have to check multiple repeats.
     * - All characters but the start character of the sequence can be skipped.
     */
    stateInCommentLike(c2) {
      if (c2 === this.currentSequence[this.sequenceIndex]) {
        if (++this.sequenceIndex === this.currentSequence.length) {
          if (this.currentSequence === Sequences.CdataEnd) {
            this.cbs.oncdata(this.sectionStart, this.index - 2);
          } else {
            this.cbs.oncomment(this.sectionStart, this.index - 2);
          }
          this.sequenceIndex = 0;
          this.sectionStart = this.index + 1;
          this.state = 1;
        }
      } else if (this.sequenceIndex === 0) {
        if (this.fastForwardTo(this.currentSequence[0])) {
          this.sequenceIndex = 1;
        }
      } else if (c2 !== this.currentSequence[this.sequenceIndex - 1]) {
        this.sequenceIndex = 0;
      }
    }
    startSpecial(sequence, offset) {
      this.enterRCDATA(sequence, offset);
      this.state = 31;
    }
    enterRCDATA(sequence, offset) {
      this.inRCDATA = true;
      this.currentSequence = sequence;
      this.sequenceIndex = offset;
    }
    stateBeforeTagName(c2) {
      if (c2 === 33) {
        this.state = 22;
        this.sectionStart = this.index + 1;
      } else if (c2 === 63) {
        this.state = 24;
        this.sectionStart = this.index + 1;
      } else if (isTagStartChar(c2)) {
        this.sectionStart = this.index;
        if (this.mode === 0) {
          this.state = 6;
        } else if (this.inSFCRoot) {
          this.state = 34;
        } else if (!this.inXML) {
          if (c2 === 116) {
            this.state = 30;
          } else {
            this.state = c2 === 115 ? 29 : 6;
          }
        } else {
          this.state = 6;
        }
      } else if (c2 === 47) {
        this.state = 8;
      } else {
        this.state = 1;
        this.stateText(c2);
      }
    }
    stateInTagName(c2) {
      if (isEndOfTagSection(c2)) {
        this.handleTagName(c2);
      }
    }
    stateInSFCRootTagName(c2) {
      if (isEndOfTagSection(c2)) {
        const tag = this.buffer.slice(this.sectionStart, this.index);
        if (tag !== "template") {
          this.enterRCDATA(toCharCodes(`</` + tag), 0);
        }
        this.handleTagName(c2);
      }
    }
    handleTagName(c2) {
      this.cbs.onopentagname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = 11;
      this.stateBeforeAttrName(c2);
    }
    stateBeforeClosingTagName(c2) {
      if (isWhitespace(c2)) ;
      else if (c2 === 62) {
        this.state = 1;
        this.sectionStart = this.index + 1;
      } else {
        this.state = isTagStartChar(c2) ? 9 : 27;
        this.sectionStart = this.index;
      }
    }
    stateInClosingTagName(c2) {
      if (c2 === 62 || isWhitespace(c2)) {
        this.cbs.onclosetag(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.state = 10;
        this.stateAfterClosingTagName(c2);
      }
    }
    stateAfterClosingTagName(c2) {
      if (c2 === 62) {
        this.state = 1;
        this.sectionStart = this.index + 1;
      }
    }
    stateBeforeAttrName(c2) {
      if (c2 === 62) {
        this.cbs.onopentagend(this.index);
        if (this.inRCDATA) {
          this.state = 32;
        } else {
          this.state = 1;
        }
        this.sectionStart = this.index + 1;
      } else if (c2 === 47) {
        this.state = 7;
      } else if (c2 === 60 && this.peek() === 47) {
        this.cbs.onopentagend(this.index);
        this.state = 5;
        this.sectionStart = this.index;
      } else if (!isWhitespace(c2)) {
        this.handleAttrStart(c2);
      }
    }
    handleAttrStart(c2) {
      if (c2 === 118 && this.peek() === 45) {
        this.state = 13;
        this.sectionStart = this.index;
      } else if (c2 === 46 || c2 === 58 || c2 === 64 || c2 === 35) {
        this.cbs.ondirname(this.index, this.index + 1);
        this.state = 14;
        this.sectionStart = this.index + 1;
      } else {
        this.state = 12;
        this.sectionStart = this.index;
      }
    }
    stateInSelfClosingTag(c2) {
      if (c2 === 62) {
        this.cbs.onselfclosingtag(this.index);
        this.state = 1;
        this.sectionStart = this.index + 1;
        this.inRCDATA = false;
      } else if (!isWhitespace(c2)) {
        this.state = 11;
        this.stateBeforeAttrName(c2);
      }
    }
    stateInAttrName(c2) {
      if (c2 === 61 || isEndOfTagSection(c2)) {
        this.cbs.onattribname(this.sectionStart, this.index);
        this.handleAttrNameEnd(c2);
      }
    }
    stateInDirName(c2) {
      if (c2 === 61 || isEndOfTagSection(c2)) {
        this.cbs.ondirname(this.sectionStart, this.index);
        this.handleAttrNameEnd(c2);
      } else if (c2 === 58) {
        this.cbs.ondirname(this.sectionStart, this.index);
        this.state = 14;
        this.sectionStart = this.index + 1;
      } else if (c2 === 46) {
        this.cbs.ondirname(this.sectionStart, this.index);
        this.state = 16;
        this.sectionStart = this.index + 1;
      }
    }
    stateInDirArg(c2) {
      if (c2 === 61 || isEndOfTagSection(c2)) {
        this.cbs.ondirarg(this.sectionStart, this.index);
        this.handleAttrNameEnd(c2);
      } else if (c2 === 91) {
        this.state = 15;
      } else if (c2 === 46) {
        this.cbs.ondirarg(this.sectionStart, this.index);
        this.state = 16;
        this.sectionStart = this.index + 1;
      }
    }
    stateInDynamicDirArg(c2) {
      if (c2 === 93) {
        this.state = 14;
      } else if (c2 === 61 || isEndOfTagSection(c2)) {
        this.cbs.ondirarg(this.sectionStart, this.index + 1);
        this.handleAttrNameEnd(c2);
      }
    }
    stateInDirModifier(c2) {
      if (c2 === 61 || isEndOfTagSection(c2)) {
        this.cbs.ondirmodifier(this.sectionStart, this.index);
        this.handleAttrNameEnd(c2);
      } else if (c2 === 46) {
        this.cbs.ondirmodifier(this.sectionStart, this.index);
        this.sectionStart = this.index + 1;
      }
    }
    handleAttrNameEnd(c2) {
      this.sectionStart = this.index;
      this.state = 17;
      this.cbs.onattribnameend(this.index);
      this.stateAfterAttrName(c2);
    }
    stateAfterAttrName(c2) {
      if (c2 === 61) {
        this.state = 18;
      } else if (c2 === 47 || c2 === 62) {
        this.cbs.onattribend(0, this.sectionStart);
        this.sectionStart = -1;
        this.state = 11;
        this.stateBeforeAttrName(c2);
      } else if (!isWhitespace(c2)) {
        this.cbs.onattribend(0, this.sectionStart);
        this.handleAttrStart(c2);
      }
    }
    stateBeforeAttrValue(c2) {
      if (c2 === 34) {
        this.state = 19;
        this.sectionStart = this.index + 1;
      } else if (c2 === 39) {
        this.state = 20;
        this.sectionStart = this.index + 1;
      } else if (!isWhitespace(c2)) {
        this.sectionStart = this.index;
        this.state = 21;
        this.stateInAttrValueNoQuotes(c2);
      }
    }
    handleInAttrValue(c2, quote) {
      if (c2 === quote || this.fastForwardTo(quote)) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.cbs.onattribend(
          quote === 34 ? 3 : 2,
          this.index + 1
        );
        this.state = 11;
      }
    }
    stateInAttrValueDoubleQuotes(c2) {
      this.handleInAttrValue(c2, 34);
    }
    stateInAttrValueSingleQuotes(c2) {
      this.handleInAttrValue(c2, 39);
    }
    stateInAttrValueNoQuotes(c2) {
      if (isWhitespace(c2) || c2 === 62) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.cbs.onattribend(1, this.index);
        this.state = 11;
        this.stateBeforeAttrName(c2);
      } else if (c2 === 39 || c2 === 60 || c2 === 61 || c2 === 96) {
        this.cbs.onerr(
          18,
          this.index
        );
      } else ;
    }
    stateBeforeDeclaration(c2) {
      if (c2 === 91) {
        this.state = 26;
        this.sequenceIndex = 0;
      } else {
        this.state = c2 === 45 ? 25 : 23;
      }
    }
    stateInDeclaration(c2) {
      if (c2 === 62 || this.fastForwardTo(62)) {
        this.state = 1;
        this.sectionStart = this.index + 1;
      }
    }
    stateInProcessingInstruction(c2) {
      if (c2 === 62 || this.fastForwardTo(62)) {
        this.cbs.onprocessinginstruction(this.sectionStart, this.index);
        this.state = 1;
        this.sectionStart = this.index + 1;
      }
    }
    stateBeforeComment(c2) {
      if (c2 === 45) {
        this.state = 28;
        this.currentSequence = Sequences.CommentEnd;
        this.sequenceIndex = 2;
        this.sectionStart = this.index + 1;
      } else {
        this.state = 23;
      }
    }
    stateInSpecialComment(c2) {
      if (c2 === 62 || this.fastForwardTo(62)) {
        this.cbs.oncomment(this.sectionStart, this.index);
        this.state = 1;
        this.sectionStart = this.index + 1;
      }
    }
    stateBeforeSpecialS(c2) {
      if (c2 === Sequences.ScriptEnd[3]) {
        this.startSpecial(Sequences.ScriptEnd, 4);
      } else if (c2 === Sequences.StyleEnd[3]) {
        this.startSpecial(Sequences.StyleEnd, 4);
      } else {
        this.state = 6;
        this.stateInTagName(c2);
      }
    }
    stateBeforeSpecialT(c2) {
      if (c2 === Sequences.TitleEnd[3]) {
        this.startSpecial(Sequences.TitleEnd, 4);
      } else if (c2 === Sequences.TextareaEnd[3]) {
        this.startSpecial(Sequences.TextareaEnd, 4);
      } else {
        this.state = 6;
        this.stateInTagName(c2);
      }
    }
    startEntity() {
    }
    stateInEntity() {
    }
    /**
     * Iterates through the buffer, calling the function corresponding to the current state.
     *
     * States that are more likely to be hit are higher up, as a performance improvement.
     */
    parse(input) {
      this.buffer = input;
      while (this.index < this.buffer.length) {
        const c2 = this.buffer.charCodeAt(this.index);
        if (c2 === 10) {
          this.newlines.push(this.index);
        }
        switch (this.state) {
          case 1: {
            this.stateText(c2);
            break;
          }
          case 2: {
            this.stateInterpolationOpen(c2);
            break;
          }
          case 3: {
            this.stateInterpolation(c2);
            break;
          }
          case 4: {
            this.stateInterpolationClose(c2);
            break;
          }
          case 31: {
            this.stateSpecialStartSequence(c2);
            break;
          }
          case 32: {
            this.stateInRCDATA(c2);
            break;
          }
          case 26: {
            this.stateCDATASequence(c2);
            break;
          }
          case 19: {
            this.stateInAttrValueDoubleQuotes(c2);
            break;
          }
          case 12: {
            this.stateInAttrName(c2);
            break;
          }
          case 13: {
            this.stateInDirName(c2);
            break;
          }
          case 14: {
            this.stateInDirArg(c2);
            break;
          }
          case 15: {
            this.stateInDynamicDirArg(c2);
            break;
          }
          case 16: {
            this.stateInDirModifier(c2);
            break;
          }
          case 28: {
            this.stateInCommentLike(c2);
            break;
          }
          case 27: {
            this.stateInSpecialComment(c2);
            break;
          }
          case 11: {
            this.stateBeforeAttrName(c2);
            break;
          }
          case 6: {
            this.stateInTagName(c2);
            break;
          }
          case 34: {
            this.stateInSFCRootTagName(c2);
            break;
          }
          case 9: {
            this.stateInClosingTagName(c2);
            break;
          }
          case 5: {
            this.stateBeforeTagName(c2);
            break;
          }
          case 17: {
            this.stateAfterAttrName(c2);
            break;
          }
          case 20: {
            this.stateInAttrValueSingleQuotes(c2);
            break;
          }
          case 18: {
            this.stateBeforeAttrValue(c2);
            break;
          }
          case 8: {
            this.stateBeforeClosingTagName(c2);
            break;
          }
          case 10: {
            this.stateAfterClosingTagName(c2);
            break;
          }
          case 29: {
            this.stateBeforeSpecialS(c2);
            break;
          }
          case 30: {
            this.stateBeforeSpecialT(c2);
            break;
          }
          case 21: {
            this.stateInAttrValueNoQuotes(c2);
            break;
          }
          case 7: {
            this.stateInSelfClosingTag(c2);
            break;
          }
          case 23: {
            this.stateInDeclaration(c2);
            break;
          }
          case 22: {
            this.stateBeforeDeclaration(c2);
            break;
          }
          case 25: {
            this.stateBeforeComment(c2);
            break;
          }
          case 24: {
            this.stateInProcessingInstruction(c2);
            break;
          }
          case 33: {
            this.stateInEntity();
            break;
          }
        }
        this.index++;
      }
      this.cleanup();
      this.finish();
    }
    /**
     * Remove data that has already been consumed from the buffer.
     */
    cleanup() {
      if (this.sectionStart !== this.index) {
        if (this.state === 1 || this.state === 32 && this.sequenceIndex === 0) {
          this.cbs.ontext(this.sectionStart, this.index);
          this.sectionStart = this.index;
        } else if (this.state === 19 || this.state === 20 || this.state === 21) {
          this.cbs.onattribdata(this.sectionStart, this.index);
          this.sectionStart = this.index;
        }
      }
    }
    finish() {
      this.handleTrailingData();
      this.cbs.onend();
    }
    /** Handle any trailing data. */
    handleTrailingData() {
      const endIndex = this.buffer.length;
      if (this.sectionStart >= endIndex) {
        return;
      }
      if (this.state === 28) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, endIndex);
        } else {
          this.cbs.oncomment(this.sectionStart, endIndex);
        }
      } else if (this.state === 6 || this.state === 11 || this.state === 18 || this.state === 17 || this.state === 12 || this.state === 13 || this.state === 14 || this.state === 15 || this.state === 16 || this.state === 20 || this.state === 19 || this.state === 21 || this.state === 9) ;
      else {
        this.cbs.ontext(this.sectionStart, endIndex);
      }
    }
    emitCodePoint(cp, consumed) {
    }
  }
  function getCompatValue(key, { compatConfig }) {
    const value = compatConfig && compatConfig[key];
    if (key === "MODE") {
      return value || 3;
    } else {
      return value;
    }
  }
  function isCompatEnabled(key, context) {
    const mode = getCompatValue("MODE", context);
    const value = getCompatValue(key, context);
    return mode === 3 ? value === true : value !== false;
  }
  function checkCompatEnabled(key, context, loc, ...args) {
    const enabled = isCompatEnabled(key, context);
    return enabled;
  }
  function defaultOnError(error) {
    throw error;
  }
  function defaultOnWarn(msg) {
  }
  function createCompilerError(code, loc, messages, additionalMessage) {
    const msg = `https://vuejs.org/error-reference/#compiler-${code}`;
    const error = new SyntaxError(String(msg));
    error.code = code;
    error.loc = loc;
    return error;
  }
  const isStaticExp = (p2) => p2.type === 4 && p2.isStatic;
  function isCoreComponent(tag) {
    switch (tag) {
      case "Teleport":
      case "teleport":
        return TELEPORT;
      case "Suspense":
      case "suspense":
        return SUSPENSE;
      case "KeepAlive":
      case "keep-alive":
        return KEEP_ALIVE;
      case "BaseTransition":
      case "base-transition":
        return BASE_TRANSITION;
    }
  }
  const nonIdentifierRE = /^\d|[^\$\w\xA0-\uFFFF]/;
  const isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
  const validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
  const validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
  const whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
  const isMemberExpressionBrowser = (path) => {
    path = path.trim().replace(whitespaceRE, (s2) => s2.trim());
    let state = 0;
    let stateStack = [];
    let currentOpenBracketCount = 0;
    let currentOpenParensCount = 0;
    let currentStringType = null;
    for (let i2 = 0; i2 < path.length; i2++) {
      const char = path.charAt(i2);
      switch (state) {
        case 0:
          if (char === "[") {
            stateStack.push(state);
            state = 1;
            currentOpenBracketCount++;
          } else if (char === "(") {
            stateStack.push(state);
            state = 2;
            currentOpenParensCount++;
          } else if (!(i2 === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
            return false;
          }
          break;
        case 1:
          if (char === `'` || char === `"` || char === "`") {
            stateStack.push(state);
            state = 3;
            currentStringType = char;
          } else if (char === `[`) {
            currentOpenBracketCount++;
          } else if (char === `]`) {
            if (!--currentOpenBracketCount) {
              state = stateStack.pop();
            }
          }
          break;
        case 2:
          if (char === `'` || char === `"` || char === "`") {
            stateStack.push(state);
            state = 3;
            currentStringType = char;
          } else if (char === `(`) {
            currentOpenParensCount++;
          } else if (char === `)`) {
            if (i2 === path.length - 1) {
              return false;
            }
            if (!--currentOpenParensCount) {
              state = stateStack.pop();
            }
          }
          break;
        case 3:
          if (char === currentStringType) {
            state = stateStack.pop();
            currentStringType = null;
          }
          break;
      }
    }
    return !currentOpenBracketCount && !currentOpenParensCount;
  };
  const isMemberExpression = isMemberExpressionBrowser;
  function findDir(node, name, allowEmpty = false) {
    for (let i2 = 0; i2 < node.props.length; i2++) {
      const p2 = node.props[i2];
      if (p2.type === 7 && (allowEmpty || p2.exp) && (isString$1(name) ? p2.name === name : name.test(p2.name))) {
        return p2;
      }
    }
  }
  function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
    for (let i2 = 0; i2 < node.props.length; i2++) {
      const p2 = node.props[i2];
      if (p2.type === 6) {
        if (dynamicOnly) continue;
        if (p2.name === name && (p2.value || allowEmpty)) {
          return p2;
        }
      } else if (p2.name === "bind" && (p2.exp || allowEmpty) && isStaticArgOf(p2.arg, name)) {
        return p2;
      }
    }
  }
  function isStaticArgOf(arg, name) {
    return !!(arg && isStaticExp(arg) && arg.content === name);
  }
  function hasDynamicKeyVBind(node) {
    return node.props.some(
      (p2) => p2.type === 7 && p2.name === "bind" && (!p2.arg || // v-bind="obj"
      p2.arg.type !== 4 || // v-bind:[_ctx.foo]
      !p2.arg.isStatic)
      // v-bind:[foo]
    );
  }
  function isText$1(node) {
    return node.type === 5 || node.type === 2;
  }
  function isVSlot(p2) {
    return p2.type === 7 && p2.name === "slot";
  }
  function isTemplateNode(node) {
    return node.type === 1 && node.tagType === 3;
  }
  function isSlotOutlet(node) {
    return node.type === 1 && node.tagType === 2;
  }
  const propsHelperSet = /* @__PURE__ */ new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
  function getUnnormalizedProps(props, callPath = []) {
    if (props && !isString$1(props) && props.type === 14) {
      const callee = props.callee;
      if (!isString$1(callee) && propsHelperSet.has(callee)) {
        return getUnnormalizedProps(
          props.arguments[0],
          callPath.concat(props)
        );
      }
    }
    return [props, callPath];
  }
  function injectProp(node, prop, context) {
    let propsWithInjection;
    let props = node.type === 13 ? node.props : node.arguments[2];
    let callPath = [];
    let parentCall;
    if (props && !isString$1(props) && props.type === 14) {
      const ret = getUnnormalizedProps(props);
      props = ret[0];
      callPath = ret[1];
      parentCall = callPath[callPath.length - 1];
    }
    if (props == null || isString$1(props)) {
      propsWithInjection = createObjectExpression([prop]);
    } else if (props.type === 14) {
      const first = props.arguments[0];
      if (!isString$1(first) && first.type === 15) {
        if (!hasProp(prop, first)) {
          first.properties.unshift(prop);
        }
      } else {
        if (props.callee === TO_HANDLERS) {
          propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
            createObjectExpression([prop]),
            props
          ]);
        } else {
          props.arguments.unshift(createObjectExpression([prop]));
        }
      }
      !propsWithInjection && (propsWithInjection = props);
    } else if (props.type === 15) {
      if (!hasProp(prop, props)) {
        props.properties.unshift(prop);
      }
      propsWithInjection = props;
    } else {
      propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
        createObjectExpression([prop]),
        props
      ]);
      if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
        parentCall = callPath[callPath.length - 2];
      }
    }
    if (node.type === 13) {
      if (parentCall) {
        parentCall.arguments[0] = propsWithInjection;
      } else {
        node.props = propsWithInjection;
      }
    } else {
      if (parentCall) {
        parentCall.arguments[0] = propsWithInjection;
      } else {
        node.arguments[2] = propsWithInjection;
      }
    }
  }
  function hasProp(prop, props) {
    let result = false;
    if (prop.key.type === 4) {
      const propKeyName = prop.key.content;
      result = props.properties.some(
        (p2) => p2.key.type === 4 && p2.key.content === propKeyName
      );
    }
    return result;
  }
  function toValidAssetId(name, type) {
    return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
      return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
    })}`;
  }
  function getMemoedVNodeCall(node) {
    if (node.type === 14 && node.callee === WITH_MEMO) {
      return node.arguments[1].returns;
    } else {
      return node;
    }
  }
  const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+(\S[\s\S]*)/;
  const defaultParserOptions = {
    parseMode: "base",
    ns: 0,
    delimiters: [`{{`, `}}`],
    getNamespace: () => 0,
    isVoidTag: NO,
    isPreTag: NO,
    isCustomElement: NO,
    onError: defaultOnError,
    onWarn: defaultOnWarn,
    comments: false,
    prefixIdentifiers: false
  };
  let currentOptions = defaultParserOptions;
  let currentRoot = null;
  let currentInput = "";
  let currentOpenTag = null;
  let currentProp = null;
  let currentAttrValue = "";
  let currentAttrStartIndex = -1;
  let currentAttrEndIndex = -1;
  let inPre = 0;
  let inVPre = false;
  let currentVPreBoundary = null;
  const stack = [];
  const tokenizer = new Tokenizer(stack, {
    onerr: emitError,
    ontext(start, end) {
      onText(getSlice(start, end), start, end);
    },
    ontextentity(char, start, end) {
      onText(char, start, end);
    },
    oninterpolation(start, end) {
      if (inVPre) {
        return onText(getSlice(start, end), start, end);
      }
      let innerStart = start + tokenizer.delimiterOpen.length;
      let innerEnd = end - tokenizer.delimiterClose.length;
      while (isWhitespace(currentInput.charCodeAt(innerStart))) {
        innerStart++;
      }
      while (isWhitespace(currentInput.charCodeAt(innerEnd - 1))) {
        innerEnd--;
      }
      let exp = getSlice(innerStart, innerEnd);
      if (exp.includes("&")) {
        {
          exp = currentOptions.decodeEntities(exp, false);
        }
      }
      addNode({
        type: 5,
        content: createExp(exp, false, getLoc(innerStart, innerEnd)),
        loc: getLoc(start, end)
      });
    },
    onopentagname(start, end) {
      const name = getSlice(start, end);
      currentOpenTag = {
        type: 1,
        tag: name,
        ns: currentOptions.getNamespace(name, stack[0], currentOptions.ns),
        tagType: 0,
        // will be refined on tag close
        props: [],
        children: [],
        loc: getLoc(start - 1, end),
        codegenNode: void 0
      };
    },
    onopentagend(end) {
      endOpenTag(end);
    },
    onclosetag(start, end) {
      const name = getSlice(start, end);
      if (!currentOptions.isVoidTag(name)) {
        let found = false;
        for (let i2 = 0; i2 < stack.length; i2++) {
          const e2 = stack[i2];
          if (e2.tag.toLowerCase() === name.toLowerCase()) {
            found = true;
            if (i2 > 0) {
              emitError(24, stack[0].loc.start.offset);
            }
            for (let j2 = 0; j2 <= i2; j2++) {
              const el = stack.shift();
              onCloseTag(el, end, j2 < i2);
            }
            break;
          }
        }
        if (!found) {
          emitError(23, backTrack(start, 60));
        }
      }
    },
    onselfclosingtag(end) {
      const name = currentOpenTag.tag;
      currentOpenTag.isSelfClosing = true;
      endOpenTag(end);
      if (stack[0] && stack[0].tag === name) {
        onCloseTag(stack.shift(), end);
      }
    },
    onattribname(start, end) {
      currentProp = {
        type: 6,
        name: getSlice(start, end),
        nameLoc: getLoc(start, end),
        value: void 0,
        loc: getLoc(start)
      };
    },
    ondirname(start, end) {
      const raw = getSlice(start, end);
      const name = raw === "." || raw === ":" ? "bind" : raw === "@" ? "on" : raw === "#" ? "slot" : raw.slice(2);
      if (!inVPre && name === "") {
        emitError(26, start);
      }
      if (inVPre || name === "") {
        currentProp = {
          type: 6,
          name: raw,
          nameLoc: getLoc(start, end),
          value: void 0,
          loc: getLoc(start)
        };
      } else {
        currentProp = {
          type: 7,
          name,
          rawName: raw,
          exp: void 0,
          arg: void 0,
          modifiers: raw === "." ? ["prop"] : [],
          loc: getLoc(start)
        };
        if (name === "pre") {
          inVPre = tokenizer.inVPre = true;
          currentVPreBoundary = currentOpenTag;
          const props = currentOpenTag.props;
          for (let i2 = 0; i2 < props.length; i2++) {
            if (props[i2].type === 7) {
              props[i2] = dirToAttr(props[i2]);
            }
          }
        }
      }
    },
    ondirarg(start, end) {
      if (start === end) return;
      const arg = getSlice(start, end);
      if (inVPre) {
        currentProp.name += arg;
        setLocEnd(currentProp.nameLoc, end);
      } else {
        const isStatic = arg[0] !== `[`;
        currentProp.arg = createExp(
          isStatic ? arg : arg.slice(1, -1),
          isStatic,
          getLoc(start, end),
          isStatic ? 3 : 0
        );
      }
    },
    ondirmodifier(start, end) {
      const mod = getSlice(start, end);
      if (inVPre) {
        currentProp.name += "." + mod;
        setLocEnd(currentProp.nameLoc, end);
      } else if (currentProp.name === "slot") {
        const arg = currentProp.arg;
        if (arg) {
          arg.content += "." + mod;
          setLocEnd(arg.loc, end);
        }
      } else {
        currentProp.modifiers.push(mod);
      }
    },
    onattribdata(start, end) {
      currentAttrValue += getSlice(start, end);
      if (currentAttrStartIndex < 0) currentAttrStartIndex = start;
      currentAttrEndIndex = end;
    },
    onattribentity(char, start, end) {
      currentAttrValue += char;
      if (currentAttrStartIndex < 0) currentAttrStartIndex = start;
      currentAttrEndIndex = end;
    },
    onattribnameend(end) {
      const start = currentProp.loc.start.offset;
      const name = getSlice(start, end);
      if (currentProp.type === 7) {
        currentProp.rawName = name;
      }
      if (currentOpenTag.props.some(
        (p2) => (p2.type === 7 ? p2.rawName : p2.name) === name
      )) {
        emitError(2, start);
      }
    },
    onattribend(quote, end) {
      if (currentOpenTag && currentProp) {
        setLocEnd(currentProp.loc, end);
        if (quote !== 0) {
          if (currentAttrValue.includes("&")) {
            currentAttrValue = currentOptions.decodeEntities(
              currentAttrValue,
              true
            );
          }
          if (currentProp.type === 6) {
            if (currentProp.name === "class") {
              currentAttrValue = condense(currentAttrValue).trim();
            }
            if (quote === 1 && !currentAttrValue) {
              emitError(13, end);
            }
            currentProp.value = {
              type: 2,
              content: currentAttrValue,
              loc: quote === 1 ? getLoc(currentAttrStartIndex, currentAttrEndIndex) : getLoc(currentAttrStartIndex - 1, currentAttrEndIndex + 1)
            };
            if (tokenizer.inSFCRoot && currentOpenTag.tag === "template" && currentProp.name === "lang" && currentAttrValue && currentAttrValue !== "html") {
              tokenizer.enterRCDATA(toCharCodes(`</template`), 0);
            }
          } else {
            let expParseMode = 0;
            currentProp.exp = createExp(
              currentAttrValue,
              false,
              getLoc(currentAttrStartIndex, currentAttrEndIndex),
              0,
              expParseMode
            );
            if (currentProp.name === "for") {
              currentProp.forParseResult = parseForExpression(currentProp.exp);
            }
            let syncIndex = -1;
            if (currentProp.name === "bind" && (syncIndex = currentProp.modifiers.indexOf("sync")) > -1 && checkCompatEnabled(
              "COMPILER_V_BIND_SYNC",
              currentOptions,
              currentProp.loc,
              currentProp.rawName
            )) {
              currentProp.name = "model";
              currentProp.modifiers.splice(syncIndex, 1);
            }
          }
        }
        if (currentProp.type !== 7 || currentProp.name !== "pre") {
          currentOpenTag.props.push(currentProp);
        }
      }
      currentAttrValue = "";
      currentAttrStartIndex = currentAttrEndIndex = -1;
    },
    oncomment(start, end) {
      if (currentOptions.comments) {
        addNode({
          type: 3,
          content: getSlice(start, end),
          loc: getLoc(start - 4, end + 3)
        });
      }
    },
    onend() {
      const end = currentInput.length;
      for (let index = 0; index < stack.length; index++) {
        onCloseTag(stack[index], end - 1);
        emitError(24, stack[index].loc.start.offset);
      }
    },
    oncdata(start, end) {
      if (stack[0].ns !== 0) {
        onText(getSlice(start, end), start, end);
      } else {
        emitError(1, start - 9);
      }
    },
    onprocessinginstruction(start) {
      if ((stack[0] ? stack[0].ns : currentOptions.ns) === 0) {
        emitError(
          21,
          start - 1
        );
      }
    }
  });
  const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
  const stripParensRE = /^\(|\)$/g;
  function parseForExpression(input) {
    const loc = input.loc;
    const exp = input.content;
    const inMatch = exp.match(forAliasRE);
    if (!inMatch) return;
    const [, LHS, RHS] = inMatch;
    const createAliasExpression = (content, offset, asParam = false) => {
      const start = loc.start.offset + offset;
      const end = start + content.length;
      return createExp(
        content,
        false,
        getLoc(start, end),
        0,
        asParam ? 1 : 0
        /* Normal */
      );
    };
    const result = {
      source: createAliasExpression(RHS.trim(), exp.indexOf(RHS, LHS.length)),
      value: void 0,
      key: void 0,
      index: void 0,
      finalized: false
    };
    let valueContent = LHS.trim().replace(stripParensRE, "").trim();
    const trimmedOffset = LHS.indexOf(valueContent);
    const iteratorMatch = valueContent.match(forIteratorRE);
    if (iteratorMatch) {
      valueContent = valueContent.replace(forIteratorRE, "").trim();
      const keyContent = iteratorMatch[1].trim();
      let keyOffset;
      if (keyContent) {
        keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
        result.key = createAliasExpression(keyContent, keyOffset, true);
      }
      if (iteratorMatch[2]) {
        const indexContent = iteratorMatch[2].trim();
        if (indexContent) {
          result.index = createAliasExpression(
            indexContent,
            exp.indexOf(
              indexContent,
              result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length
            ),
            true
          );
        }
      }
    }
    if (valueContent) {
      result.value = createAliasExpression(valueContent, trimmedOffset, true);
    }
    return result;
  }
  function getSlice(start, end) {
    return currentInput.slice(start, end);
  }
  function endOpenTag(end) {
    if (tokenizer.inSFCRoot) {
      currentOpenTag.innerLoc = getLoc(end + 1, end + 1);
    }
    addNode(currentOpenTag);
    const { tag, ns } = currentOpenTag;
    if (ns === 0 && currentOptions.isPreTag(tag)) {
      inPre++;
    }
    if (currentOptions.isVoidTag(tag)) {
      onCloseTag(currentOpenTag, end);
    } else {
      stack.unshift(currentOpenTag);
      if (ns === 1 || ns === 2) {
        tokenizer.inXML = true;
      }
    }
    currentOpenTag = null;
  }
  function onText(content, start, end) {
    {
      const tag = stack[0] && stack[0].tag;
      if (tag !== "script" && tag !== "style" && content.includes("&")) {
        content = currentOptions.decodeEntities(content, false);
      }
    }
    const parent = stack[0] || currentRoot;
    const lastNode = parent.children[parent.children.length - 1];
    if (lastNode && lastNode.type === 2) {
      lastNode.content += content;
      setLocEnd(lastNode.loc, end);
    } else {
      parent.children.push({
        type: 2,
        content,
        loc: getLoc(start, end)
      });
    }
  }
  function onCloseTag(el, end, isImplied = false) {
    if (isImplied) {
      setLocEnd(el.loc, backTrack(end, 60));
    } else {
      setLocEnd(el.loc, lookAhead(end, 62) + 1);
    }
    if (tokenizer.inSFCRoot) {
      if (el.children.length) {
        el.innerLoc.end = extend$1({}, el.children[el.children.length - 1].loc.end);
      } else {
        el.innerLoc.end = extend$1({}, el.innerLoc.start);
      }
      el.innerLoc.source = getSlice(
        el.innerLoc.start.offset,
        el.innerLoc.end.offset
      );
    }
    const { tag, ns } = el;
    if (!inVPre) {
      if (tag === "slot") {
        el.tagType = 2;
      } else if (isFragmentTemplate(el)) {
        el.tagType = 3;
      } else if (isComponent(el)) {
        el.tagType = 1;
      }
    }
    if (!tokenizer.inRCDATA) {
      el.children = condenseWhitespace(el.children, el.tag);
    }
    if (ns === 0 && currentOptions.isPreTag(tag)) {
      inPre--;
    }
    if (currentVPreBoundary === el) {
      inVPre = tokenizer.inVPre = false;
      currentVPreBoundary = null;
    }
    if (tokenizer.inXML && (stack[0] ? stack[0].ns : currentOptions.ns) === 0) {
      tokenizer.inXML = false;
    }
    {
      const props = el.props;
      if (!tokenizer.inSFCRoot && isCompatEnabled(
        "COMPILER_NATIVE_TEMPLATE",
        currentOptions
      ) && el.tag === "template" && !isFragmentTemplate(el)) {
        const parent = stack[0] || currentRoot;
        const index = parent.children.indexOf(el);
        parent.children.splice(index, 1, ...el.children);
      }
      const inlineTemplateProp = props.find(
        (p2) => p2.type === 6 && p2.name === "inline-template"
      );
      if (inlineTemplateProp && checkCompatEnabled(
        "COMPILER_INLINE_TEMPLATE",
        currentOptions,
        inlineTemplateProp.loc
      ) && el.children.length) {
        inlineTemplateProp.value = {
          type: 2,
          content: getSlice(
            el.children[0].loc.start.offset,
            el.children[el.children.length - 1].loc.end.offset
          ),
          loc: inlineTemplateProp.loc
        };
      }
    }
  }
  function lookAhead(index, c2) {
    let i2 = index;
    while (currentInput.charCodeAt(i2) !== c2 && i2 < currentInput.length - 1) i2++;
    return i2;
  }
  function backTrack(index, c2) {
    let i2 = index;
    while (currentInput.charCodeAt(i2) !== c2 && i2 >= 0) i2--;
    return i2;
  }
  const specialTemplateDir = /* @__PURE__ */ new Set(["if", "else", "else-if", "for", "slot"]);
  function isFragmentTemplate({ tag, props }) {
    if (tag === "template") {
      for (let i2 = 0; i2 < props.length; i2++) {
        if (props[i2].type === 7 && specialTemplateDir.has(props[i2].name)) {
          return true;
        }
      }
    }
    return false;
  }
  function isComponent({ tag, props }) {
    if (currentOptions.isCustomElement(tag)) {
      return false;
    }
    if (tag === "component" || isUpperCase(tag.charCodeAt(0)) || isCoreComponent(tag) || currentOptions.isBuiltInComponent && currentOptions.isBuiltInComponent(tag) || currentOptions.isNativeTag && !currentOptions.isNativeTag(tag)) {
      return true;
    }
    for (let i2 = 0; i2 < props.length; i2++) {
      const p2 = props[i2];
      if (p2.type === 6) {
        if (p2.name === "is" && p2.value) {
          if (p2.value.content.startsWith("vue:")) {
            return true;
          } else if (checkCompatEnabled(
            "COMPILER_IS_ON_ELEMENT",
            currentOptions,
            p2.loc
          )) {
            return true;
          }
        }
      } else if (
        // :is on plain element - only treat as component in compat mode
        p2.name === "bind" && isStaticArgOf(p2.arg, "is") && checkCompatEnabled(
          "COMPILER_IS_ON_ELEMENT",
          currentOptions,
          p2.loc
        )
      ) {
        return true;
      }
    }
    return false;
  }
  function isUpperCase(c2) {
    return c2 > 64 && c2 < 91;
  }
  const windowsNewlineRE = /\r\n/g;
  function condenseWhitespace(nodes, tag) {
    const shouldCondense = currentOptions.whitespace !== "preserve";
    let removedWhitespace = false;
    for (let i2 = 0; i2 < nodes.length; i2++) {
      const node = nodes[i2];
      if (node.type === 2) {
        if (!inPre) {
          if (isAllWhitespace(node.content)) {
            const prev = nodes[i2 - 1] && nodes[i2 - 1].type;
            const next = nodes[i2 + 1] && nodes[i2 + 1].type;
            if (!prev || !next || shouldCondense && (prev === 3 && (next === 3 || next === 1) || prev === 1 && (next === 3 || next === 1 && hasNewlineChar(node.content)))) {
              removedWhitespace = true;
              nodes[i2] = null;
            } else {
              node.content = " ";
            }
          } else if (shouldCondense) {
            node.content = condense(node.content);
          }
        } else {
          node.content = node.content.replace(windowsNewlineRE, "\n");
        }
      }
    }
    if (inPre && tag && currentOptions.isPreTag(tag)) {
      const first = nodes[0];
      if (first && first.type === 2) {
        first.content = first.content.replace(/^\r?\n/, "");
      }
    }
    return removedWhitespace ? nodes.filter(Boolean) : nodes;
  }
  function isAllWhitespace(str) {
    for (let i2 = 0; i2 < str.length; i2++) {
      if (!isWhitespace(str.charCodeAt(i2))) {
        return false;
      }
    }
    return true;
  }
  function hasNewlineChar(str) {
    for (let i2 = 0; i2 < str.length; i2++) {
      const c2 = str.charCodeAt(i2);
      if (c2 === 10 || c2 === 13) {
        return true;
      }
    }
    return false;
  }
  function condense(str) {
    let ret = "";
    let prevCharIsWhitespace = false;
    for (let i2 = 0; i2 < str.length; i2++) {
      if (isWhitespace(str.charCodeAt(i2))) {
        if (!prevCharIsWhitespace) {
          ret += " ";
          prevCharIsWhitespace = true;
        }
      } else {
        ret += str[i2];
        prevCharIsWhitespace = false;
      }
    }
    return ret;
  }
  function addNode(node) {
    (stack[0] || currentRoot).children.push(node);
  }
  function getLoc(start, end) {
    return {
      start: tokenizer.getPos(start),
      // @ts-expect-error allow late attachment
      end: end == null ? end : tokenizer.getPos(end),
      // @ts-expect-error allow late attachment
      source: end == null ? end : getSlice(start, end)
    };
  }
  function setLocEnd(loc, end) {
    loc.end = tokenizer.getPos(end);
    loc.source = getSlice(loc.start.offset, end);
  }
  function dirToAttr(dir) {
    const attr = {
      type: 6,
      name: dir.rawName,
      nameLoc: getLoc(
        dir.loc.start.offset,
        dir.loc.start.offset + dir.rawName.length
      ),
      value: void 0,
      loc: dir.loc
    };
    if (dir.exp) {
      const loc = dir.exp.loc;
      if (loc.end.offset < dir.loc.end.offset) {
        loc.start.offset--;
        loc.start.column--;
        loc.end.offset++;
        loc.end.column++;
      }
      attr.value = {
        type: 2,
        content: dir.exp.content,
        loc
      };
    }
    return attr;
  }
  function createExp(content, isStatic = false, loc, constType = 0, parseMode = 0) {
    const exp = createSimpleExpression(content, isStatic, loc, constType);
    return exp;
  }
  function emitError(code, index, message) {
    currentOptions.onError(
      createCompilerError(code, getLoc(index, index))
    );
  }
  function reset() {
    tokenizer.reset();
    currentOpenTag = null;
    currentProp = null;
    currentAttrValue = "";
    currentAttrStartIndex = -1;
    currentAttrEndIndex = -1;
    stack.length = 0;
  }
  function baseParse(input, options) {
    reset();
    currentInput = input;
    currentOptions = extend$1({}, defaultParserOptions);
    if (options) {
      let key;
      for (key in options) {
        if (options[key] != null) {
          currentOptions[key] = options[key];
        }
      }
    }
    tokenizer.mode = currentOptions.parseMode === "html" ? 1 : currentOptions.parseMode === "sfc" ? 2 : 0;
    tokenizer.inXML = currentOptions.ns === 1 || currentOptions.ns === 2;
    const delimiters = options && options.delimiters;
    if (delimiters) {
      tokenizer.delimiterOpen = toCharCodes(delimiters[0]);
      tokenizer.delimiterClose = toCharCodes(delimiters[1]);
    }
    const root = currentRoot = createRoot([], input);
    tokenizer.parse(currentInput);
    root.loc = getLoc(0, input.length);
    root.children = condenseWhitespace(root.children);
    currentRoot = null;
    return root;
  }
  function hoistStatic(root, context) {
    walk(
      root,
      context,
      // Root node is unfortunately non-hoistable due to potential parent
      // fallthrough attributes.
      isSingleElementRoot(root, root.children[0])
    );
  }
  function isSingleElementRoot(root, child) {
    const { children } = root;
    return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
  }
  function walk(node, context, doNotHoistNode = false) {
    const { children } = node;
    const originalCount = children.length;
    let hoistedCount = 0;
    for (let i2 = 0; i2 < children.length; i2++) {
      const child = children[i2];
      if (child.type === 1 && child.tagType === 0) {
        const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
        if (constantType > 0) {
          if (constantType >= 2) {
            child.codegenNode.patchFlag = -1;
            child.codegenNode = context.hoist(child.codegenNode);
            hoistedCount++;
            continue;
          }
        } else {
          const codegenNode = child.codegenNode;
          if (codegenNode.type === 13) {
            const flag = codegenNode.patchFlag;
            if ((flag === void 0 || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
              const props = getNodeProps(child);
              if (props) {
                codegenNode.props = context.hoist(props);
              }
            }
            if (codegenNode.dynamicProps) {
              codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
            }
          }
        }
      }
      if (child.type === 1) {
        const isComponent2 = child.tagType === 1;
        if (isComponent2) {
          context.scopes.vSlot++;
        }
        walk(child, context);
        if (isComponent2) {
          context.scopes.vSlot--;
        }
      } else if (child.type === 11) {
        walk(child, context, child.children.length === 1);
      } else if (child.type === 9) {
        for (let i22 = 0; i22 < child.branches.length; i22++) {
          walk(
            child.branches[i22],
            context,
            child.branches[i22].children.length === 1
          );
        }
      }
    }
    if (hoistedCount && context.transformHoist) {
      context.transformHoist(children, context, node);
    }
    if (hoistedCount && hoistedCount === originalCount && node.type === 1 && node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && isArray$2(node.codegenNode.children)) {
      const hoisted = context.hoist(
        createArrayExpression(node.codegenNode.children)
      );
      if (context.hmr) {
        hoisted.content = `[...${hoisted.content}]`;
      }
      node.codegenNode.children = hoisted;
    }
  }
  function getConstantType(node, context) {
    const { constantCache } = context;
    switch (node.type) {
      case 1:
        if (node.tagType !== 0) {
          return 0;
        }
        const cached = constantCache.get(node);
        if (cached !== void 0) {
          return cached;
        }
        const codegenNode = node.codegenNode;
        if (codegenNode.type !== 13) {
          return 0;
        }
        if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject" && node.tag !== "math") {
          return 0;
        }
        if (codegenNode.patchFlag === void 0) {
          let returnType2 = 3;
          const generatedPropsType = getGeneratedPropsConstantType(node, context);
          if (generatedPropsType === 0) {
            constantCache.set(node, 0);
            return 0;
          }
          if (generatedPropsType < returnType2) {
            returnType2 = generatedPropsType;
          }
          for (let i2 = 0; i2 < node.children.length; i2++) {
            const childType = getConstantType(node.children[i2], context);
            if (childType === 0) {
              constantCache.set(node, 0);
              return 0;
            }
            if (childType < returnType2) {
              returnType2 = childType;
            }
          }
          if (returnType2 > 1) {
            for (let i2 = 0; i2 < node.props.length; i2++) {
              const p2 = node.props[i2];
              if (p2.type === 7 && p2.name === "bind" && p2.exp) {
                const expType = getConstantType(p2.exp, context);
                if (expType === 0) {
                  constantCache.set(node, 0);
                  return 0;
                }
                if (expType < returnType2) {
                  returnType2 = expType;
                }
              }
            }
          }
          if (codegenNode.isBlock) {
            for (let i2 = 0; i2 < node.props.length; i2++) {
              const p2 = node.props[i2];
              if (p2.type === 7) {
                constantCache.set(node, 0);
                return 0;
              }
            }
            context.removeHelper(OPEN_BLOCK);
            context.removeHelper(
              getVNodeBlockHelper(context.inSSR, codegenNode.isComponent)
            );
            codegenNode.isBlock = false;
            context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
          }
          constantCache.set(node, returnType2);
          return returnType2;
        } else {
          constantCache.set(node, 0);
          return 0;
        }
      case 2:
      case 3:
        return 3;
      case 9:
      case 11:
      case 10:
        return 0;
      case 5:
      case 12:
        return getConstantType(node.content, context);
      case 4:
        return node.constType;
      case 8:
        let returnType = 3;
        for (let i2 = 0; i2 < node.children.length; i2++) {
          const child = node.children[i2];
          if (isString$1(child) || isSymbol(child)) {
            continue;
          }
          const childType = getConstantType(child, context);
          if (childType === 0) {
            return 0;
          } else if (childType < returnType) {
            returnType = childType;
          }
        }
        return returnType;
      default:
        return 0;
    }
  }
  const allowHoistedHelperSet = /* @__PURE__ */ new Set([
    NORMALIZE_CLASS,
    NORMALIZE_STYLE,
    NORMALIZE_PROPS,
    GUARD_REACTIVE_PROPS
  ]);
  function getConstantTypeOfHelperCall(value, context) {
    if (value.type === 14 && !isString$1(value.callee) && allowHoistedHelperSet.has(value.callee)) {
      const arg = value.arguments[0];
      if (arg.type === 4) {
        return getConstantType(arg, context);
      } else if (arg.type === 14) {
        return getConstantTypeOfHelperCall(arg, context);
      }
    }
    return 0;
  }
  function getGeneratedPropsConstantType(node, context) {
    let returnType = 3;
    const props = getNodeProps(node);
    if (props && props.type === 15) {
      const { properties } = props;
      for (let i2 = 0; i2 < properties.length; i2++) {
        const { key, value } = properties[i2];
        const keyType = getConstantType(key, context);
        if (keyType === 0) {
          return keyType;
        }
        if (keyType < returnType) {
          returnType = keyType;
        }
        let valueType;
        if (value.type === 4) {
          valueType = getConstantType(value, context);
        } else if (value.type === 14) {
          valueType = getConstantTypeOfHelperCall(value, context);
        } else {
          valueType = 0;
        }
        if (valueType === 0) {
          return valueType;
        }
        if (valueType < returnType) {
          returnType = valueType;
        }
      }
    }
    return returnType;
  }
  function getNodeProps(node) {
    const codegenNode = node.codegenNode;
    if (codegenNode.type === 13) {
      return codegenNode.props;
    }
  }
  function createTransformContext(root, {
    filename = "",
    prefixIdentifiers = false,
    hoistStatic: hoistStatic2 = false,
    hmr = false,
    cacheHandlers = false,
    nodeTransforms = [],
    directiveTransforms = {},
    transformHoist = null,
    isBuiltInComponent = NOOP,
    isCustomElement = NOOP,
    expressionPlugins = [],
    scopeId = null,
    slotted = true,
    ssr = false,
    inSSR = false,
    ssrCssVars = ``,
    bindingMetadata = EMPTY_OBJ,
    inline = false,
    isTS = false,
    onError = defaultOnError,
    onWarn = defaultOnWarn,
    compatConfig
  }) {
    const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
    const context = {
      // options
      filename,
      selfName: nameMatch && capitalize(camelize(nameMatch[1])),
      prefixIdentifiers,
      hoistStatic: hoistStatic2,
      hmr,
      cacheHandlers,
      nodeTransforms,
      directiveTransforms,
      transformHoist,
      isBuiltInComponent,
      isCustomElement,
      expressionPlugins,
      scopeId,
      slotted,
      ssr,
      inSSR,
      ssrCssVars,
      bindingMetadata,
      inline,
      isTS,
      onError,
      onWarn,
      compatConfig,
      // state
      root,
      helpers: /* @__PURE__ */ new Map(),
      components: /* @__PURE__ */ new Set(),
      directives: /* @__PURE__ */ new Set(),
      hoists: [],
      imports: [],
      constantCache: /* @__PURE__ */ new WeakMap(),
      temps: 0,
      cached: 0,
      identifiers: /* @__PURE__ */ Object.create(null),
      scopes: {
        vFor: 0,
        vSlot: 0,
        vPre: 0,
        vOnce: 0
      },
      parent: null,
      grandParent: null,
      currentNode: root,
      childIndex: 0,
      inVOnce: false,
      // methods
      helper(name) {
        const count = context.helpers.get(name) || 0;
        context.helpers.set(name, count + 1);
        return name;
      },
      removeHelper(name) {
        const count = context.helpers.get(name);
        if (count) {
          const currentCount = count - 1;
          if (!currentCount) {
            context.helpers.delete(name);
          } else {
            context.helpers.set(name, currentCount);
          }
        }
      },
      helperString(name) {
        return `_${helperNameMap[context.helper(name)]}`;
      },
      replaceNode(node) {
        context.parent.children[context.childIndex] = context.currentNode = node;
      },
      removeNode(node) {
        const list = context.parent.children;
        const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
        if (!node || node === context.currentNode) {
          context.currentNode = null;
          context.onNodeRemoved();
        } else {
          if (context.childIndex > removalIndex) {
            context.childIndex--;
            context.onNodeRemoved();
          }
        }
        context.parent.children.splice(removalIndex, 1);
      },
      onNodeRemoved: NOOP,
      addIdentifiers(exp) {
      },
      removeIdentifiers(exp) {
      },
      hoist(exp) {
        if (isString$1(exp)) exp = createSimpleExpression(exp);
        context.hoists.push(exp);
        const identifier = createSimpleExpression(
          `_hoisted_${context.hoists.length}`,
          false,
          exp.loc,
          2
        );
        identifier.hoisted = exp;
        return identifier;
      },
      cache(exp, isVNode2 = false) {
        return createCacheExpression(context.cached++, exp, isVNode2);
      }
    };
    {
      context.filters = /* @__PURE__ */ new Set();
    }
    return context;
  }
  function transform(root, options) {
    const context = createTransformContext(root, options);
    traverseNode(root, context);
    if (options.hoistStatic) {
      hoistStatic(root, context);
    }
    if (!options.ssr) {
      createRootCodegen(root, context);
    }
    root.helpers = /* @__PURE__ */ new Set([...context.helpers.keys()]);
    root.components = [...context.components];
    root.directives = [...context.directives];
    root.imports = context.imports;
    root.hoists = context.hoists;
    root.temps = context.temps;
    root.cached = context.cached;
    root.transformed = true;
    {
      root.filters = [...context.filters];
    }
  }
  function createRootCodegen(root, context) {
    const { helper } = context;
    const { children } = root;
    if (children.length === 1) {
      const child = children[0];
      if (isSingleElementRoot(root, child) && child.codegenNode) {
        const codegenNode = child.codegenNode;
        if (codegenNode.type === 13) {
          convertToBlock(codegenNode, context);
        }
        root.codegenNode = codegenNode;
      } else {
        root.codegenNode = child;
      }
    } else if (children.length > 1) {
      let patchFlag = 64;
      root.codegenNode = createVNodeCall(
        context,
        helper(FRAGMENT),
        void 0,
        root.children,
        patchFlag,
        void 0,
        void 0,
        true,
        void 0,
        false
      );
    } else ;
  }
  function traverseChildren(parent, context) {
    let i2 = 0;
    const nodeRemoved = () => {
      i2--;
    };
    for (; i2 < parent.children.length; i2++) {
      const child = parent.children[i2];
      if (isString$1(child)) continue;
      context.grandParent = context.parent;
      context.parent = parent;
      context.childIndex = i2;
      context.onNodeRemoved = nodeRemoved;
      traverseNode(child, context);
    }
  }
  function traverseNode(node, context) {
    context.currentNode = node;
    const { nodeTransforms } = context;
    const exitFns = [];
    for (let i22 = 0; i22 < nodeTransforms.length; i22++) {
      const onExit = nodeTransforms[i22](node, context);
      if (onExit) {
        if (isArray$2(onExit)) {
          exitFns.push(...onExit);
        } else {
          exitFns.push(onExit);
        }
      }
      if (!context.currentNode) {
        return;
      } else {
        node = context.currentNode;
      }
    }
    switch (node.type) {
      case 3:
        if (!context.ssr) {
          context.helper(CREATE_COMMENT);
        }
        break;
      case 5:
        if (!context.ssr) {
          context.helper(TO_DISPLAY_STRING);
        }
        break;
      case 9:
        for (let i22 = 0; i22 < node.branches.length; i22++) {
          traverseNode(node.branches[i22], context);
        }
        break;
      case 10:
      case 11:
      case 1:
      case 0:
        traverseChildren(node, context);
        break;
    }
    context.currentNode = node;
    let i2 = exitFns.length;
    while (i2--) {
      exitFns[i2]();
    }
  }
  function createStructuralDirectiveTransform(name, fn2) {
    const matches2 = isString$1(name) ? (n2) => n2 === name : (n2) => name.test(n2);
    return (node, context) => {
      if (node.type === 1) {
        const { props } = node;
        if (node.tagType === 3 && props.some(isVSlot)) {
          return;
        }
        const exitFns = [];
        for (let i2 = 0; i2 < props.length; i2++) {
          const prop = props[i2];
          if (prop.type === 7 && matches2(prop.name)) {
            props.splice(i2, 1);
            i2--;
            const onExit = fn2(node, prop, context);
            if (onExit) exitFns.push(onExit);
          }
        }
        return exitFns;
      }
    };
  }
  const PURE_ANNOTATION = `/*#__PURE__*/`;
  const aliasHelper = (s2) => `${helperNameMap[s2]}: _${helperNameMap[s2]}`;
  function createCodegenContext(ast, {
    mode = "function",
    prefixIdentifiers = mode === "module",
    sourceMap = false,
    filename = `template.vue.html`,
    scopeId = null,
    optimizeImports = false,
    runtimeGlobalName = `Vue`,
    runtimeModuleName = `vue`,
    ssrRuntimeModuleName = "vue/server-renderer",
    ssr = false,
    isTS = false,
    inSSR = false
  }) {
    const context = {
      mode,
      prefixIdentifiers,
      sourceMap,
      filename,
      scopeId,
      optimizeImports,
      runtimeGlobalName,
      runtimeModuleName,
      ssrRuntimeModuleName,
      ssr,
      isTS,
      inSSR,
      source: ast.source,
      code: ``,
      column: 1,
      line: 1,
      offset: 0,
      indentLevel: 0,
      pure: false,
      map: void 0,
      helper(key) {
        return `_${helperNameMap[key]}`;
      },
      push(code, newlineIndex = -2, node) {
        context.code += code;
      },
      indent() {
        newline(++context.indentLevel);
      },
      deindent(withoutNewLine = false) {
        if (withoutNewLine) {
          --context.indentLevel;
        } else {
          newline(--context.indentLevel);
        }
      },
      newline() {
        newline(context.indentLevel);
      }
    };
    function newline(n2) {
      context.push(
        "\n" + `  `.repeat(n2),
        0
        /* Start */
      );
    }
    return context;
  }
  function generate(ast, options = {}) {
    const context = createCodegenContext(ast, options);
    if (options.onContextCreated) options.onContextCreated(context);
    const {
      mode,
      push,
      prefixIdentifiers,
      indent,
      deindent,
      newline,
      scopeId,
      ssr
    } = context;
    const helpers = Array.from(ast.helpers);
    const hasHelpers = helpers.length > 0;
    const useWithBlock = !prefixIdentifiers && mode !== "module";
    const preambleContext = context;
    {
      genFunctionPreamble(ast, preambleContext);
    }
    const functionName = ssr ? `ssrRender` : `render`;
    const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
    const signature = args.join(", ");
    {
      push(`function ${functionName}(${signature}) {`);
    }
    indent();
    if (useWithBlock) {
      push(`with (_ctx) {`);
      indent();
      if (hasHelpers) {
        push(
          `const { ${helpers.map(aliasHelper).join(", ")} } = _Vue
`,
          -1
          /* End */
        );
        newline();
      }
    }
    if (ast.components.length) {
      genAssets(ast.components, "component", context);
      if (ast.directives.length || ast.temps > 0) {
        newline();
      }
    }
    if (ast.directives.length) {
      genAssets(ast.directives, "directive", context);
      if (ast.temps > 0) {
        newline();
      }
    }
    if (ast.filters && ast.filters.length) {
      newline();
      genAssets(ast.filters, "filter", context);
      newline();
    }
    if (ast.temps > 0) {
      push(`let `);
      for (let i2 = 0; i2 < ast.temps; i2++) {
        push(`${i2 > 0 ? `, ` : ``}_temp${i2}`);
      }
    }
    if (ast.components.length || ast.directives.length || ast.temps) {
      push(
        `
`,
        0
        /* Start */
      );
      newline();
    }
    if (!ssr) {
      push(`return `);
    }
    if (ast.codegenNode) {
      genNode(ast.codegenNode, context);
    } else {
      push(`null`);
    }
    if (useWithBlock) {
      deindent();
      push(`}`);
    }
    deindent();
    push(`}`);
    return {
      ast,
      code: context.code,
      preamble: ``,
      map: context.map ? context.map.toJSON() : void 0
    };
  }
  function genFunctionPreamble(ast, context) {
    const {
      ssr,
      prefixIdentifiers,
      push,
      newline,
      runtimeModuleName,
      runtimeGlobalName,
      ssrRuntimeModuleName
    } = context;
    const VueBinding = runtimeGlobalName;
    const helpers = Array.from(ast.helpers);
    if (helpers.length > 0) {
      {
        push(
          `const _Vue = ${VueBinding}
`,
          -1
          /* End */
        );
        if (ast.hoists.length) {
          const staticHelpers = [
            CREATE_VNODE,
            CREATE_ELEMENT_VNODE,
            CREATE_COMMENT,
            CREATE_TEXT,
            CREATE_STATIC
          ].filter((helper) => helpers.includes(helper)).map(aliasHelper).join(", ");
          push(
            `const { ${staticHelpers} } = _Vue
`,
            -1
            /* End */
          );
        }
      }
    }
    genHoists(ast.hoists, context);
    newline();
    push(`return `);
  }
  function genAssets(assets, type, { helper, push, newline, isTS }) {
    const resolver = helper(
      type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE
    );
    for (let i2 = 0; i2 < assets.length; i2++) {
      let id = assets[i2];
      const maybeSelfReference = id.endsWith("__self");
      if (maybeSelfReference) {
        id = id.slice(0, -6);
      }
      push(
        `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`
      );
      if (i2 < assets.length - 1) {
        newline();
      }
    }
  }
  function genHoists(hoists, context) {
    if (!hoists.length) {
      return;
    }
    context.pure = true;
    const { push, newline, helper, scopeId, mode } = context;
    newline();
    for (let i2 = 0; i2 < hoists.length; i2++) {
      const exp = hoists[i2];
      if (exp) {
        push(
          `const _hoisted_${i2 + 1} = ${``}`
        );
        genNode(exp, context);
        newline();
      }
    }
    context.pure = false;
  }
  function genNodeListAsArray(nodes, context) {
    const multilines = nodes.length > 3 || false;
    context.push(`[`);
    multilines && context.indent();
    genNodeList(nodes, context, multilines);
    multilines && context.deindent();
    context.push(`]`);
  }
  function genNodeList(nodes, context, multilines = false, comma = true) {
    const { push, newline } = context;
    for (let i2 = 0; i2 < nodes.length; i2++) {
      const node = nodes[i2];
      if (isString$1(node)) {
        push(
          node,
          -3
          /* Unknown */
        );
      } else if (isArray$2(node)) {
        genNodeListAsArray(node, context);
      } else {
        genNode(node, context);
      }
      if (i2 < nodes.length - 1) {
        if (multilines) {
          comma && push(",");
          newline();
        } else {
          comma && push(", ");
        }
      }
    }
  }
  function genNode(node, context) {
    if (isString$1(node)) {
      context.push(
        node,
        -3
        /* Unknown */
      );
      return;
    }
    if (isSymbol(node)) {
      context.push(context.helper(node));
      return;
    }
    switch (node.type) {
      case 1:
      case 9:
      case 11:
        genNode(node.codegenNode, context);
        break;
      case 2:
        genText(node, context);
        break;
      case 4:
        genExpression(node, context);
        break;
      case 5:
        genInterpolation(node, context);
        break;
      case 12:
        genNode(node.codegenNode, context);
        break;
      case 8:
        genCompoundExpression(node, context);
        break;
      case 3:
        genComment(node, context);
        break;
      case 13:
        genVNodeCall(node, context);
        break;
      case 14:
        genCallExpression(node, context);
        break;
      case 15:
        genObjectExpression(node, context);
        break;
      case 17:
        genArrayExpression(node, context);
        break;
      case 18:
        genFunctionExpression(node, context);
        break;
      case 19:
        genConditionalExpression(node, context);
        break;
      case 20:
        genCacheExpression(node, context);
        break;
      case 21:
        genNodeList(node.body, context, true, false);
        break;
    }
  }
  function genText(node, context) {
    context.push(JSON.stringify(node.content), -3, node);
  }
  function genExpression(node, context) {
    const { content, isStatic } = node;
    context.push(
      isStatic ? JSON.stringify(content) : content,
      -3,
      node
    );
  }
  function genInterpolation(node, context) {
    const { push, helper, pure } = context;
    if (pure) push(PURE_ANNOTATION);
    push(`${helper(TO_DISPLAY_STRING)}(`);
    genNode(node.content, context);
    push(`)`);
  }
  function genCompoundExpression(node, context) {
    for (let i2 = 0; i2 < node.children.length; i2++) {
      const child = node.children[i2];
      if (isString$1(child)) {
        context.push(
          child,
          -3
          /* Unknown */
        );
      } else {
        genNode(child, context);
      }
    }
  }
  function genExpressionAsPropertyKey(node, context) {
    const { push } = context;
    if (node.type === 8) {
      push(`[`);
      genCompoundExpression(node, context);
      push(`]`);
    } else if (node.isStatic) {
      const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
      push(text, -2, node);
    } else {
      push(`[${node.content}]`, -3, node);
    }
  }
  function genComment(node, context) {
    const { push, helper, pure } = context;
    if (pure) {
      push(PURE_ANNOTATION);
    }
    push(
      `${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`,
      -3,
      node
    );
  }
  function genVNodeCall(node, context) {
    const { push, helper, pure } = context;
    const {
      tag,
      props,
      children,
      patchFlag,
      dynamicProps,
      directives,
      isBlock,
      disableTracking,
      isComponent: isComponent2
    } = node;
    let patchFlagString;
    if (patchFlag) {
      {
        patchFlagString = String(patchFlag);
      }
    }
    if (directives) {
      push(helper(WITH_DIRECTIVES) + `(`);
    }
    if (isBlock) {
      push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
    }
    if (pure) {
      push(PURE_ANNOTATION);
    }
    const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent2) : getVNodeHelper(context.inSSR, isComponent2);
    push(helper(callHelper) + `(`, -2, node);
    genNodeList(
      genNullableArgs([tag, props, children, patchFlagString, dynamicProps]),
      context
    );
    push(`)`);
    if (isBlock) {
      push(`)`);
    }
    if (directives) {
      push(`, `);
      genNode(directives, context);
      push(`)`);
    }
  }
  function genNullableArgs(args) {
    let i2 = args.length;
    while (i2--) {
      if (args[i2] != null) break;
    }
    return args.slice(0, i2 + 1).map((arg) => arg || `null`);
  }
  function genCallExpression(node, context) {
    const { push, helper, pure } = context;
    const callee = isString$1(node.callee) ? node.callee : helper(node.callee);
    if (pure) {
      push(PURE_ANNOTATION);
    }
    push(callee + `(`, -2, node);
    genNodeList(node.arguments, context);
    push(`)`);
  }
  function genObjectExpression(node, context) {
    const { push, indent, deindent, newline } = context;
    const { properties } = node;
    if (!properties.length) {
      push(`{}`, -2, node);
      return;
    }
    const multilines = properties.length > 1 || false;
    push(multilines ? `{` : `{ `);
    multilines && indent();
    for (let i2 = 0; i2 < properties.length; i2++) {
      const { key, value } = properties[i2];
      genExpressionAsPropertyKey(key, context);
      push(`: `);
      genNode(value, context);
      if (i2 < properties.length - 1) {
        push(`,`);
        newline();
      }
    }
    multilines && deindent();
    push(multilines ? `}` : ` }`);
  }
  function genArrayExpression(node, context) {
    genNodeListAsArray(node.elements, context);
  }
  function genFunctionExpression(node, context) {
    const { push, indent, deindent } = context;
    const { params, returns, body, newline, isSlot } = node;
    if (isSlot) {
      push(`_${helperNameMap[WITH_CTX]}(`);
    }
    push(`(`, -2, node);
    if (isArray$2(params)) {
      genNodeList(params, context);
    } else if (params) {
      genNode(params, context);
    }
    push(`) => `);
    if (newline || body) {
      push(`{`);
      indent();
    }
    if (returns) {
      if (newline) {
        push(`return `);
      }
      if (isArray$2(returns)) {
        genNodeListAsArray(returns, context);
      } else {
        genNode(returns, context);
      }
    } else if (body) {
      genNode(body, context);
    }
    if (newline || body) {
      deindent();
      push(`}`);
    }
    if (isSlot) {
      if (node.isNonScopedSlot) {
        push(`, undefined, true`);
      }
      push(`)`);
    }
  }
  function genConditionalExpression(node, context) {
    const { test: test2, consequent, alternate, newline: needNewline } = node;
    const { push, indent, deindent, newline } = context;
    if (test2.type === 4) {
      const needsParens = !isSimpleIdentifier(test2.content);
      needsParens && push(`(`);
      genExpression(test2, context);
      needsParens && push(`)`);
    } else {
      push(`(`);
      genNode(test2, context);
      push(`)`);
    }
    needNewline && indent();
    context.indentLevel++;
    needNewline || push(` `);
    push(`? `);
    genNode(consequent, context);
    context.indentLevel--;
    needNewline && newline();
    needNewline || push(` `);
    push(`: `);
    const isNested = alternate.type === 19;
    if (!isNested) {
      context.indentLevel++;
    }
    genNode(alternate, context);
    if (!isNested) {
      context.indentLevel--;
    }
    needNewline && deindent(
      true
      /* without newline */
    );
  }
  function genCacheExpression(node, context) {
    const { push, helper, indent, deindent, newline } = context;
    push(`_cache[${node.index}] || (`);
    if (node.isVOnce) {
      indent();
      push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
      newline();
      push(`(`);
    }
    push(`_cache[${node.index}] = `);
    genNode(node.value, context);
    if (node.isVOnce) {
      push(`).cacheIndex = ${node.index},`);
      newline();
      push(`${helper(SET_BLOCK_TRACKING)}(1),`);
      newline();
      push(`_cache[${node.index}]`);
      deindent();
    }
    push(`)`);
  }
  new RegExp(
    "\\b" + "arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield".split(",").join("\\b|\\b") + "\\b"
  );
  const transformIf = createStructuralDirectiveTransform(
    /^(if|else|else-if)$/,
    (node, dir, context) => {
      return processIf(node, dir, context, (ifNode, branch, isRoot) => {
        const siblings = context.parent.children;
        let i2 = siblings.indexOf(ifNode);
        let key = 0;
        while (i2-- >= 0) {
          const sibling = siblings[i2];
          if (sibling && sibling.type === 9) {
            key += sibling.branches.length;
          }
        }
        return () => {
          if (isRoot) {
            ifNode.codegenNode = createCodegenNodeForBranch(
              branch,
              key,
              context
            );
          } else {
            const parentCondition = getParentCondition(ifNode.codegenNode);
            parentCondition.alternate = createCodegenNodeForBranch(
              branch,
              key + ifNode.branches.length - 1,
              context
            );
          }
        };
      });
    }
  );
  function processIf(node, dir, context, processCodegen) {
    if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
      const loc = dir.exp ? dir.exp.loc : node.loc;
      context.onError(
        createCompilerError(28, dir.loc)
      );
      dir.exp = createSimpleExpression(`true`, false, loc);
    }
    if (dir.name === "if") {
      const branch = createIfBranch(node, dir);
      const ifNode = {
        type: 9,
        loc: node.loc,
        branches: [branch]
      };
      context.replaceNode(ifNode);
      if (processCodegen) {
        return processCodegen(ifNode, branch, true);
      }
    } else {
      const siblings = context.parent.children;
      let i2 = siblings.indexOf(node);
      while (i2-- >= -1) {
        const sibling = siblings[i2];
        if (sibling && sibling.type === 3) {
          context.removeNode(sibling);
          continue;
        }
        if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
          context.removeNode(sibling);
          continue;
        }
        if (sibling && sibling.type === 9) {
          if (dir.name === "else-if" && sibling.branches[sibling.branches.length - 1].condition === void 0) {
            context.onError(
              createCompilerError(30, node.loc)
            );
          }
          context.removeNode();
          const branch = createIfBranch(node, dir);
          sibling.branches.push(branch);
          const onExit = processCodegen && processCodegen(sibling, branch, false);
          traverseNode(branch, context);
          if (onExit) onExit();
          context.currentNode = null;
        } else {
          context.onError(
            createCompilerError(30, node.loc)
          );
        }
        break;
      }
    }
  }
  function createIfBranch(node, dir) {
    const isTemplateIf = node.tagType === 3;
    return {
      type: 10,
      loc: node.loc,
      condition: dir.name === "else" ? void 0 : dir.exp,
      children: isTemplateIf && !findDir(node, "for") ? node.children : [node],
      userKey: findProp(node, `key`),
      isTemplateIf
    };
  }
  function createCodegenNodeForBranch(branch, keyIndex, context) {
    if (branch.condition) {
      return createConditionalExpression(
        branch.condition,
        createChildrenCodegenNode(branch, keyIndex, context),
        // make sure to pass in asBlock: true so that the comment node call
        // closes the current block.
        createCallExpression(context.helper(CREATE_COMMENT), [
          '""',
          "true"
        ])
      );
    } else {
      return createChildrenCodegenNode(branch, keyIndex, context);
    }
  }
  function createChildrenCodegenNode(branch, keyIndex, context) {
    const { helper } = context;
    const keyProperty = createObjectProperty(
      `key`,
      createSimpleExpression(
        `${keyIndex}`,
        false,
        locStub,
        2
      )
    );
    const { children } = branch;
    const firstChild = children[0];
    const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
    if (needFragmentWrapper) {
      if (children.length === 1 && firstChild.type === 11) {
        const vnodeCall = firstChild.codegenNode;
        injectProp(vnodeCall, keyProperty, context);
        return vnodeCall;
      } else {
        let patchFlag = 64;
        return createVNodeCall(
          context,
          helper(FRAGMENT),
          createObjectExpression([keyProperty]),
          children,
          patchFlag,
          void 0,
          void 0,
          true,
          false,
          false,
          branch.loc
        );
      }
    } else {
      const ret = firstChild.codegenNode;
      const vnodeCall = getMemoedVNodeCall(ret);
      if (vnodeCall.type === 13) {
        convertToBlock(vnodeCall, context);
      }
      injectProp(vnodeCall, keyProperty, context);
      return ret;
    }
  }
  function getParentCondition(node) {
    while (true) {
      if (node.type === 19) {
        if (node.alternate.type === 19) {
          node = node.alternate;
        } else {
          return node;
        }
      } else if (node.type === 20) {
        node = node.value;
      }
    }
  }
  const transformBind = (dir, _node, context) => {
    const { modifiers, loc } = dir;
    const arg = dir.arg;
    let { exp } = dir;
    if (exp && exp.type === 4 && !exp.content.trim()) {
      {
        exp = void 0;
      }
    }
    if (!exp) {
      if (arg.type !== 4 || !arg.isStatic) {
        context.onError(
          createCompilerError(
            52,
            arg.loc
          )
        );
        return {
          props: [
            createObjectProperty(arg, createSimpleExpression("", true, loc))
          ]
        };
      }
      transformBindShorthand(dir);
      exp = dir.exp;
    }
    if (arg.type !== 4) {
      arg.children.unshift(`(`);
      arg.children.push(`) || ""`);
    } else if (!arg.isStatic) {
      arg.content = `${arg.content} || ""`;
    }
    if (modifiers.includes("camel")) {
      if (arg.type === 4) {
        if (arg.isStatic) {
          arg.content = camelize(arg.content);
        } else {
          arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
        }
      } else {
        arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
        arg.children.push(`)`);
      }
    }
    if (!context.inSSR) {
      if (modifiers.includes("prop")) {
        injectPrefix(arg, ".");
      }
      if (modifiers.includes("attr")) {
        injectPrefix(arg, "^");
      }
    }
    return {
      props: [createObjectProperty(arg, exp)]
    };
  };
  const transformBindShorthand = (dir, context) => {
    const arg = dir.arg;
    const propName = camelize(arg.content);
    dir.exp = createSimpleExpression(propName, false, arg.loc);
  };
  const injectPrefix = (arg, prefix) => {
    if (arg.type === 4) {
      if (arg.isStatic) {
        arg.content = prefix + arg.content;
      } else {
        arg.content = `\`${prefix}\${${arg.content}}\``;
      }
    } else {
      arg.children.unshift(`'${prefix}' + (`);
      arg.children.push(`)`);
    }
  };
  const transformFor = createStructuralDirectiveTransform(
    "for",
    (node, dir, context) => {
      const { helper, removeHelper } = context;
      return processFor(node, dir, context, (forNode) => {
        const renderExp = createCallExpression(helper(RENDER_LIST), [
          forNode.source
        ]);
        const isTemplate = isTemplateNode(node);
        const memo = findDir(node, "memo");
        const keyProp = findProp(node, `key`, false, true);
        if (keyProp && keyProp.type === 7 && !keyProp.exp) {
          transformBindShorthand(keyProp);
        }
        const keyExp = keyProp && (keyProp.type === 6 ? keyProp.value ? createSimpleExpression(keyProp.value.content, true) : void 0 : keyProp.exp);
        const keyProperty = keyProp && keyExp ? createObjectProperty(`key`, keyExp) : null;
        const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
        const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
        forNode.codegenNode = createVNodeCall(
          context,
          helper(FRAGMENT),
          void 0,
          renderExp,
          fragmentFlag,
          void 0,
          void 0,
          true,
          !isStableFragment,
          false,
          node.loc
        );
        return () => {
          let childBlock;
          const { children } = forNode;
          const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
          const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
          if (slotOutlet) {
            childBlock = slotOutlet.codegenNode;
            if (isTemplate && keyProperty) {
              injectProp(childBlock, keyProperty, context);
            }
          } else if (needFragmentWrapper) {
            childBlock = createVNodeCall(
              context,
              helper(FRAGMENT),
              keyProperty ? createObjectExpression([keyProperty]) : void 0,
              node.children,
              64,
              void 0,
              void 0,
              true,
              void 0,
              false
            );
          } else {
            childBlock = children[0].codegenNode;
            if (isTemplate && keyProperty) {
              injectProp(childBlock, keyProperty, context);
            }
            if (childBlock.isBlock !== !isStableFragment) {
              if (childBlock.isBlock) {
                removeHelper(OPEN_BLOCK);
                removeHelper(
                  getVNodeBlockHelper(context.inSSR, childBlock.isComponent)
                );
              } else {
                removeHelper(
                  getVNodeHelper(context.inSSR, childBlock.isComponent)
                );
              }
            }
            childBlock.isBlock = !isStableFragment;
            if (childBlock.isBlock) {
              helper(OPEN_BLOCK);
              helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
            } else {
              helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
            }
          }
          if (memo) {
            const loop = createFunctionExpression(
              createForLoopParams(forNode.parseResult, [
                createSimpleExpression(`_cached`)
              ])
            );
            loop.body = createBlockStatement([
              createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
              createCompoundExpression([
                `if (_cached`,
                ...keyExp ? [` && _cached.key === `, keyExp] : [],
                ` && ${context.helperString(
                  IS_MEMO_SAME
                )}(_cached, _memo)) return _cached`
              ]),
              createCompoundExpression([`const _item = `, childBlock]),
              createSimpleExpression(`_item.memo = _memo`),
              createSimpleExpression(`return _item`)
            ]);
            renderExp.arguments.push(
              loop,
              createSimpleExpression(`_cache`),
              createSimpleExpression(String(context.cached++))
            );
          } else {
            renderExp.arguments.push(
              createFunctionExpression(
                createForLoopParams(forNode.parseResult),
                childBlock,
                true
              )
            );
          }
        };
      });
    }
  );
  function processFor(node, dir, context, processCodegen) {
    if (!dir.exp) {
      context.onError(
        createCompilerError(31, dir.loc)
      );
      return;
    }
    const parseResult = dir.forParseResult;
    if (!parseResult) {
      context.onError(
        createCompilerError(32, dir.loc)
      );
      return;
    }
    finalizeForParseResult(parseResult);
    const { addIdentifiers, removeIdentifiers, scopes } = context;
    const { source, value, key, index } = parseResult;
    const forNode = {
      type: 11,
      loc: dir.loc,
      source,
      valueAlias: value,
      keyAlias: key,
      objectIndexAlias: index,
      parseResult,
      children: isTemplateNode(node) ? node.children : [node]
    };
    context.replaceNode(forNode);
    scopes.vFor++;
    const onExit = processCodegen && processCodegen(forNode);
    return () => {
      scopes.vFor--;
      if (onExit) onExit();
    };
  }
  function finalizeForParseResult(result, context) {
    if (result.finalized) return;
    result.finalized = true;
  }
  function createForLoopParams({ value, key, index }, memoArgs = []) {
    return createParamsList([value, key, index, ...memoArgs]);
  }
  function createParamsList(args) {
    let i2 = args.length;
    while (i2--) {
      if (args[i2]) break;
    }
    return args.slice(0, i2 + 1).map((arg, i22) => arg || createSimpleExpression(`_`.repeat(i22 + 1), false));
  }
  const defaultFallback = createSimpleExpression(`undefined`, false);
  const trackSlotScopes = (node, context) => {
    if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
      const vSlot = findDir(node, "slot");
      if (vSlot) {
        vSlot.exp;
        context.scopes.vSlot++;
        return () => {
          context.scopes.vSlot--;
        };
      }
    }
  };
  const buildClientSlotFn = (props, _vForExp, children, loc) => createFunctionExpression(
    props,
    children,
    false,
    true,
    children.length ? children[0].loc : loc
  );
  function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
    context.helper(WITH_CTX);
    const { children, loc } = node;
    const slotsProperties = [];
    const dynamicSlots = [];
    let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
    const onComponentSlot = findDir(node, "slot", true);
    if (onComponentSlot) {
      const { arg, exp } = onComponentSlot;
      if (arg && !isStaticExp(arg)) {
        hasDynamicSlots = true;
      }
      slotsProperties.push(
        createObjectProperty(
          arg || createSimpleExpression("default", true),
          buildSlotFn(exp, void 0, children, loc)
        )
      );
    }
    let hasTemplateSlots = false;
    let hasNamedDefaultSlot = false;
    const implicitDefaultChildren = [];
    const seenSlotNames = /* @__PURE__ */ new Set();
    let conditionalBranchIndex = 0;
    for (let i2 = 0; i2 < children.length; i2++) {
      const slotElement = children[i2];
      let slotDir;
      if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
        if (slotElement.type !== 3) {
          implicitDefaultChildren.push(slotElement);
        }
        continue;
      }
      if (onComponentSlot) {
        context.onError(
          createCompilerError(37, slotDir.loc)
        );
        break;
      }
      hasTemplateSlots = true;
      const { children: slotChildren, loc: slotLoc } = slotElement;
      const {
        arg: slotName = createSimpleExpression(`default`, true),
        exp: slotProps,
        loc: dirLoc
      } = slotDir;
      let staticSlotName;
      if (isStaticExp(slotName)) {
        staticSlotName = slotName ? slotName.content : `default`;
      } else {
        hasDynamicSlots = true;
      }
      const vFor = findDir(slotElement, "for");
      const slotFunction = buildSlotFn(slotProps, vFor, slotChildren, slotLoc);
      let vIf;
      let vElse;
      if (vIf = findDir(slotElement, "if")) {
        hasDynamicSlots = true;
        dynamicSlots.push(
          createConditionalExpression(
            vIf.exp,
            buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++),
            defaultFallback
          )
        );
      } else if (vElse = findDir(
        slotElement,
        /^else(-if)?$/,
        true
        /* allowEmpty */
      )) {
        let j2 = i2;
        let prev;
        while (j2--) {
          prev = children[j2];
          if (prev.type !== 3) {
            break;
          }
        }
        if (prev && isTemplateNode(prev) && findDir(prev, /^(else-)?if$/)) {
          let conditional = dynamicSlots[dynamicSlots.length - 1];
          while (conditional.alternate.type === 19) {
            conditional = conditional.alternate;
          }
          conditional.alternate = vElse.exp ? createConditionalExpression(
            vElse.exp,
            buildDynamicSlot(
              slotName,
              slotFunction,
              conditionalBranchIndex++
            ),
            defaultFallback
          ) : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);
        } else {
          context.onError(
            createCompilerError(30, vElse.loc)
          );
        }
      } else if (vFor) {
        hasDynamicSlots = true;
        const parseResult = vFor.forParseResult;
        if (parseResult) {
          finalizeForParseResult(parseResult);
          dynamicSlots.push(
            createCallExpression(context.helper(RENDER_LIST), [
              parseResult.source,
              createFunctionExpression(
                createForLoopParams(parseResult),
                buildDynamicSlot(slotName, slotFunction),
                true
              )
            ])
          );
        } else {
          context.onError(
            createCompilerError(
              32,
              vFor.loc
            )
          );
        }
      } else {
        if (staticSlotName) {
          if (seenSlotNames.has(staticSlotName)) {
            context.onError(
              createCompilerError(
                38,
                dirLoc
              )
            );
            continue;
          }
          seenSlotNames.add(staticSlotName);
          if (staticSlotName === "default") {
            hasNamedDefaultSlot = true;
          }
        }
        slotsProperties.push(createObjectProperty(slotName, slotFunction));
      }
    }
    if (!onComponentSlot) {
      const buildDefaultSlotProperty = (props, children2) => {
        const fn2 = buildSlotFn(props, void 0, children2, loc);
        if (context.compatConfig) {
          fn2.isNonScopedSlot = true;
        }
        return createObjectProperty(`default`, fn2);
      };
      if (!hasTemplateSlots) {
        slotsProperties.push(buildDefaultSlotProperty(void 0, children));
      } else if (implicitDefaultChildren.length && // #3766
      // with whitespace: 'preserve', whitespaces between slots will end up in
      // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
      implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))) {
        if (hasNamedDefaultSlot) {
          context.onError(
            createCompilerError(
              39,
              implicitDefaultChildren[0].loc
            )
          );
        } else {
          slotsProperties.push(
            buildDefaultSlotProperty(void 0, implicitDefaultChildren)
          );
        }
      }
    }
    const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
    let slots = createObjectExpression(
      slotsProperties.concat(
        createObjectProperty(
          `_`,
          // 2 = compiled but dynamic = can skip normalization, but must run diff
          // 1 = compiled and static = can skip normalization AND diff as optimized
          createSimpleExpression(
            slotFlag + ``,
            false
          )
        )
      ),
      loc
    );
    if (dynamicSlots.length) {
      slots = createCallExpression(context.helper(CREATE_SLOTS), [
        slots,
        createArrayExpression(dynamicSlots)
      ]);
    }
    return {
      slots,
      hasDynamicSlots
    };
  }
  function buildDynamicSlot(name, fn2, index) {
    const props = [
      createObjectProperty(`name`, name),
      createObjectProperty(`fn`, fn2)
    ];
    if (index != null) {
      props.push(
        createObjectProperty(`key`, createSimpleExpression(String(index), true))
      );
    }
    return createObjectExpression(props);
  }
  function hasForwardedSlots(children) {
    for (let i2 = 0; i2 < children.length; i2++) {
      const child = children[i2];
      switch (child.type) {
        case 1:
          if (child.tagType === 2 || hasForwardedSlots(child.children)) {
            return true;
          }
          break;
        case 9:
          if (hasForwardedSlots(child.branches)) return true;
          break;
        case 10:
        case 11:
          if (hasForwardedSlots(child.children)) return true;
          break;
      }
    }
    return false;
  }
  function isNonWhitespaceContent(node) {
    if (node.type !== 2 && node.type !== 12)
      return true;
    return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);
  }
  const directiveImportMap = /* @__PURE__ */ new WeakMap();
  const transformElement = (node, context) => {
    return function postTransformElement() {
      node = context.currentNode;
      if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
        return;
      }
      const { tag, props } = node;
      const isComponent2 = node.tagType === 1;
      let vnodeTag = isComponent2 ? resolveComponentType(node, context) : `"${tag}"`;
      const isDynamicComponent = isObject$1(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
      let vnodeProps;
      let vnodeChildren;
      let patchFlag = 0;
      let vnodeDynamicProps;
      let dynamicPropNames;
      let vnodeDirectives;
      let shouldUseBlock = (
        // dynamic component may resolve to plain elements
        isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent2 && // <svg> and <foreignObject> must be forced into blocks so that block
        // updates inside get proper isSVG flag at runtime. (#639, #643)
        // This is technically web-specific, but splitting the logic out of core
        // leads to too much unnecessary complexity.
        (tag === "svg" || tag === "foreignObject" || tag === "math")
      );
      if (props.length > 0) {
        const propsBuildResult = buildProps(
          node,
          context,
          void 0,
          isComponent2,
          isDynamicComponent
        );
        vnodeProps = propsBuildResult.props;
        patchFlag = propsBuildResult.patchFlag;
        dynamicPropNames = propsBuildResult.dynamicPropNames;
        const directives = propsBuildResult.directives;
        vnodeDirectives = directives && directives.length ? createArrayExpression(
          directives.map((dir) => buildDirectiveArgs(dir, context))
        ) : void 0;
        if (propsBuildResult.shouldUseBlock) {
          shouldUseBlock = true;
        }
      }
      if (node.children.length > 0) {
        if (vnodeTag === KEEP_ALIVE) {
          shouldUseBlock = true;
          patchFlag |= 1024;
        }
        const shouldBuildAsSlots = isComponent2 && // Teleport is not a real component and has dedicated runtime handling
        vnodeTag !== TELEPORT && // explained above.
        vnodeTag !== KEEP_ALIVE;
        if (shouldBuildAsSlots) {
          const { slots, hasDynamicSlots } = buildSlots(node, context);
          vnodeChildren = slots;
          if (hasDynamicSlots) {
            patchFlag |= 1024;
          }
        } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
          const child = node.children[0];
          const type = child.type;
          const hasDynamicTextChild = type === 5 || type === 8;
          if (hasDynamicTextChild && getConstantType(child, context) === 0) {
            patchFlag |= 1;
          }
          if (hasDynamicTextChild || type === 2) {
            vnodeChildren = child;
          } else {
            vnodeChildren = node.children;
          }
        } else {
          vnodeChildren = node.children;
        }
      }
      if (dynamicPropNames && dynamicPropNames.length) {
        vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
      }
      node.codegenNode = createVNodeCall(
        context,
        vnodeTag,
        vnodeProps,
        vnodeChildren,
        patchFlag === 0 ? void 0 : patchFlag,
        vnodeDynamicProps,
        vnodeDirectives,
        !!shouldUseBlock,
        false,
        isComponent2,
        node.loc
      );
    };
  };
  function resolveComponentType(node, context, ssr = false) {
    let { tag } = node;
    const isExplicitDynamic = isComponentTag(tag);
    const isProp = findProp(
      node,
      "is",
      false,
      true
      /* allow empty */
    );
    if (isProp) {
      if (isExplicitDynamic || isCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        context
      )) {
        let exp;
        if (isProp.type === 6) {
          exp = isProp.value && createSimpleExpression(isProp.value.content, true);
        } else {
          exp = isProp.exp;
          if (!exp) {
            exp = createSimpleExpression(`is`, false, isProp.loc);
          }
        }
        if (exp) {
          return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
            exp
          ]);
        }
      } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
        tag = isProp.value.content.slice(4);
      }
    }
    const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
    if (builtIn) {
      if (!ssr) context.helper(builtIn);
      return builtIn;
    }
    context.helper(RESOLVE_COMPONENT);
    context.components.add(tag);
    return toValidAssetId(tag, `component`);
  }
  function buildProps(node, context, props = node.props, isComponent2, isDynamicComponent, ssr = false) {
    const { tag, loc: elementLoc, children } = node;
    let properties = [];
    const mergeArgs = [];
    const runtimeDirectives = [];
    const hasChildren = children.length > 0;
    let shouldUseBlock = false;
    let patchFlag = 0;
    let hasRef = false;
    let hasClassBinding = false;
    let hasStyleBinding = false;
    let hasHydrationEventBinding = false;
    let hasDynamicKeys = false;
    let hasVnodeHook = false;
    const dynamicPropNames = [];
    const pushMergeArg = (arg) => {
      if (properties.length) {
        mergeArgs.push(
          createObjectExpression(dedupeProperties(properties), elementLoc)
        );
        properties = [];
      }
      if (arg) mergeArgs.push(arg);
    };
    const pushRefVForMarker = () => {
      if (context.scopes.vFor > 0) {
        properties.push(
          createObjectProperty(
            createSimpleExpression("ref_for", true),
            createSimpleExpression("true")
          )
        );
      }
    };
    const analyzePatchFlag = ({ key, value }) => {
      if (isStaticExp(key)) {
        const name = key.content;
        const isEventHandler = isOn(name);
        if (isEventHandler && (!isComponent2 || isDynamicComponent) && // omit the flag for click handlers because hydration gives click
        // dedicated fast path.
        name.toLowerCase() !== "onclick" && // omit v-model handlers
        name !== "onUpdate:modelValue" && // omit onVnodeXXX hooks
        !isReservedProp(name)) {
          hasHydrationEventBinding = true;
        }
        if (isEventHandler && isReservedProp(name)) {
          hasVnodeHook = true;
        }
        if (isEventHandler && value.type === 14) {
          value = value.arguments[0];
        }
        if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) {
          return;
        }
        if (name === "ref") {
          hasRef = true;
        } else if (name === "class") {
          hasClassBinding = true;
        } else if (name === "style") {
          hasStyleBinding = true;
        } else if (name !== "key" && !dynamicPropNames.includes(name)) {
          dynamicPropNames.push(name);
        }
        if (isComponent2 && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
          dynamicPropNames.push(name);
        }
      } else {
        hasDynamicKeys = true;
      }
    };
    for (let i2 = 0; i2 < props.length; i2++) {
      const prop = props[i2];
      if (prop.type === 6) {
        const { loc, name, nameLoc, value } = prop;
        let isStatic = true;
        if (name === "ref") {
          hasRef = true;
          pushRefVForMarker();
        }
        if (name === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled(
          "COMPILER_IS_ON_ELEMENT",
          context
        ))) {
          continue;
        }
        properties.push(
          createObjectProperty(
            createSimpleExpression(name, true, nameLoc),
            createSimpleExpression(
              value ? value.content : "",
              isStatic,
              value ? value.loc : loc
            )
          )
        );
      } else {
        const { name, arg, exp, loc, modifiers } = prop;
        const isVBind = name === "bind";
        const isVOn = name === "on";
        if (name === "slot") {
          if (!isComponent2) {
            context.onError(
              createCompilerError(40, loc)
            );
          }
          continue;
        }
        if (name === "once" || name === "memo") {
          continue;
        }
        if (name === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled(
          "COMPILER_IS_ON_ELEMENT",
          context
        ))) {
          continue;
        }
        if (isVOn && ssr) {
          continue;
        }
        if (
          // #938: elements with dynamic keys should be forced into blocks
          isVBind && isStaticArgOf(arg, "key") || // inline before-update hooks need to force block so that it is invoked
          // before children
          isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")
        ) {
          shouldUseBlock = true;
        }
        if (isVBind && isStaticArgOf(arg, "ref")) {
          pushRefVForMarker();
        }
        if (!arg && (isVBind || isVOn)) {
          hasDynamicKeys = true;
          if (exp) {
            if (isVBind) {
              pushRefVForMarker();
              pushMergeArg();
              {
                if (isCompatEnabled(
                  "COMPILER_V_BIND_OBJECT_ORDER",
                  context
                )) {
                  mergeArgs.unshift(exp);
                  continue;
                }
              }
              mergeArgs.push(exp);
            } else {
              pushMergeArg({
                type: 14,
                loc,
                callee: context.helper(TO_HANDLERS),
                arguments: isComponent2 ? [exp] : [exp, `true`]
              });
            }
          } else {
            context.onError(
              createCompilerError(
                isVBind ? 34 : 35,
                loc
              )
            );
          }
          continue;
        }
        if (isVBind && modifiers.includes("prop")) {
          patchFlag |= 32;
        }
        const directiveTransform = context.directiveTransforms[name];
        if (directiveTransform) {
          const { props: props2, needRuntime } = directiveTransform(prop, node, context);
          !ssr && props2.forEach(analyzePatchFlag);
          if (isVOn && arg && !isStaticExp(arg)) {
            pushMergeArg(createObjectExpression(props2, elementLoc));
          } else {
            properties.push(...props2);
          }
          if (needRuntime) {
            runtimeDirectives.push(prop);
            if (isSymbol(needRuntime)) {
              directiveImportMap.set(prop, needRuntime);
            }
          }
        } else if (!isBuiltInDirective(name)) {
          runtimeDirectives.push(prop);
          if (hasChildren) {
            shouldUseBlock = true;
          }
        }
      }
    }
    let propsExpression = void 0;
    if (mergeArgs.length) {
      pushMergeArg();
      if (mergeArgs.length > 1) {
        propsExpression = createCallExpression(
          context.helper(MERGE_PROPS),
          mergeArgs,
          elementLoc
        );
      } else {
        propsExpression = mergeArgs[0];
      }
    } else if (properties.length) {
      propsExpression = createObjectExpression(
        dedupeProperties(properties),
        elementLoc
      );
    }
    if (hasDynamicKeys) {
      patchFlag |= 16;
    } else {
      if (hasClassBinding && !isComponent2) {
        patchFlag |= 2;
      }
      if (hasStyleBinding && !isComponent2) {
        patchFlag |= 4;
      }
      if (dynamicPropNames.length) {
        patchFlag |= 8;
      }
      if (hasHydrationEventBinding) {
        patchFlag |= 32;
      }
    }
    if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
      patchFlag |= 512;
    }
    if (!context.inSSR && propsExpression) {
      switch (propsExpression.type) {
        case 15:
          let classKeyIndex = -1;
          let styleKeyIndex = -1;
          let hasDynamicKey = false;
          for (let i2 = 0; i2 < propsExpression.properties.length; i2++) {
            const key = propsExpression.properties[i2].key;
            if (isStaticExp(key)) {
              if (key.content === "class") {
                classKeyIndex = i2;
              } else if (key.content === "style") {
                styleKeyIndex = i2;
              }
            } else if (!key.isHandlerKey) {
              hasDynamicKey = true;
            }
          }
          const classProp = propsExpression.properties[classKeyIndex];
          const styleProp = propsExpression.properties[styleKeyIndex];
          if (!hasDynamicKey) {
            if (classProp && !isStaticExp(classProp.value)) {
              classProp.value = createCallExpression(
                context.helper(NORMALIZE_CLASS),
                [classProp.value]
              );
            }
            if (styleProp && // the static style is compiled into an object,
            // so use `hasStyleBinding` to ensure that it is a dynamic style binding
            (hasStyleBinding || styleProp.value.type === 4 && styleProp.value.content.trim()[0] === `[` || // v-bind:style and style both exist,
            // v-bind:style with static literal object
            styleProp.value.type === 17)) {
              styleProp.value = createCallExpression(
                context.helper(NORMALIZE_STYLE),
                [styleProp.value]
              );
            }
          } else {
            propsExpression = createCallExpression(
              context.helper(NORMALIZE_PROPS),
              [propsExpression]
            );
          }
          break;
        case 14:
          break;
        default:
          propsExpression = createCallExpression(
            context.helper(NORMALIZE_PROPS),
            [
              createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
                propsExpression
              ])
            ]
          );
          break;
      }
    }
    return {
      props: propsExpression,
      directives: runtimeDirectives,
      patchFlag,
      dynamicPropNames,
      shouldUseBlock
    };
  }
  function dedupeProperties(properties) {
    const knownProps = /* @__PURE__ */ new Map();
    const deduped = [];
    for (let i2 = 0; i2 < properties.length; i2++) {
      const prop = properties[i2];
      if (prop.key.type === 8 || !prop.key.isStatic) {
        deduped.push(prop);
        continue;
      }
      const name = prop.key.content;
      const existing = knownProps.get(name);
      if (existing) {
        if (name === "style" || name === "class" || isOn(name)) {
          mergeAsArray(existing, prop);
        }
      } else {
        knownProps.set(name, prop);
        deduped.push(prop);
      }
    }
    return deduped;
  }
  function mergeAsArray(existing, incoming) {
    if (existing.value.type === 17) {
      existing.value.elements.push(incoming.value);
    } else {
      existing.value = createArrayExpression(
        [existing.value, incoming.value],
        existing.loc
      );
    }
  }
  function buildDirectiveArgs(dir, context) {
    const dirArgs = [];
    const runtime = directiveImportMap.get(dir);
    if (runtime) {
      dirArgs.push(context.helperString(runtime));
    } else {
      {
        context.helper(RESOLVE_DIRECTIVE);
        context.directives.add(dir.name);
        dirArgs.push(toValidAssetId(dir.name, `directive`));
      }
    }
    const { loc } = dir;
    if (dir.exp) dirArgs.push(dir.exp);
    if (dir.arg) {
      if (!dir.exp) {
        dirArgs.push(`void 0`);
      }
      dirArgs.push(dir.arg);
    }
    if (Object.keys(dir.modifiers).length) {
      if (!dir.arg) {
        if (!dir.exp) {
          dirArgs.push(`void 0`);
        }
        dirArgs.push(`void 0`);
      }
      const trueExpression = createSimpleExpression(`true`, false, loc);
      dirArgs.push(
        createObjectExpression(
          dir.modifiers.map(
            (modifier) => createObjectProperty(modifier, trueExpression)
          ),
          loc
        )
      );
    }
    return createArrayExpression(dirArgs, dir.loc);
  }
  function stringifyDynamicPropNames(props) {
    let propsNamesString = `[`;
    for (let i2 = 0, l2 = props.length; i2 < l2; i2++) {
      propsNamesString += JSON.stringify(props[i2]);
      if (i2 < l2 - 1) propsNamesString += ", ";
    }
    return propsNamesString + `]`;
  }
  function isComponentTag(tag) {
    return tag === "component" || tag === "Component";
  }
  const transformSlotOutlet = (node, context) => {
    if (isSlotOutlet(node)) {
      const { children, loc } = node;
      const { slotName, slotProps } = processSlotOutlet(node, context);
      const slotArgs = [
        context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
        slotName,
        "{}",
        "undefined",
        "true"
      ];
      let expectedLen = 2;
      if (slotProps) {
        slotArgs[2] = slotProps;
        expectedLen = 3;
      }
      if (children.length) {
        slotArgs[3] = createFunctionExpression([], children, false, false, loc);
        expectedLen = 4;
      }
      if (context.scopeId && !context.slotted) {
        expectedLen = 5;
      }
      slotArgs.splice(expectedLen);
      node.codegenNode = createCallExpression(
        context.helper(RENDER_SLOT),
        slotArgs,
        loc
      );
    }
  };
  function processSlotOutlet(node, context) {
    let slotName = `"default"`;
    let slotProps = void 0;
    const nonNameProps = [];
    for (let i2 = 0; i2 < node.props.length; i2++) {
      const p2 = node.props[i2];
      if (p2.type === 6) {
        if (p2.value) {
          if (p2.name === "name") {
            slotName = JSON.stringify(p2.value.content);
          } else {
            p2.name = camelize(p2.name);
            nonNameProps.push(p2);
          }
        }
      } else {
        if (p2.name === "bind" && isStaticArgOf(p2.arg, "name")) {
          if (p2.exp) {
            slotName = p2.exp;
          } else if (p2.arg && p2.arg.type === 4) {
            const name = camelize(p2.arg.content);
            slotName = p2.exp = createSimpleExpression(name, false, p2.arg.loc);
          }
        } else {
          if (p2.name === "bind" && p2.arg && isStaticExp(p2.arg)) {
            p2.arg.content = camelize(p2.arg.content);
          }
          nonNameProps.push(p2);
        }
      }
    }
    if (nonNameProps.length > 0) {
      const { props, directives } = buildProps(
        node,
        context,
        nonNameProps,
        false,
        false
      );
      slotProps = props;
      if (directives.length) {
        context.onError(
          createCompilerError(
            36,
            directives[0].loc
          )
        );
      }
    }
    return {
      slotName,
      slotProps
    };
  }
  const fnExpRE = /^\s*(async\s*)?(\([^)]*?\)|[\w$_]+)\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
  const transformOn$1 = (dir, node, context, augmentor) => {
    const { loc, modifiers, arg } = dir;
    if (!dir.exp && !modifiers.length) {
      context.onError(createCompilerError(35, loc));
    }
    let eventName;
    if (arg.type === 4) {
      if (arg.isStatic) {
        let rawName = arg.content;
        if (rawName.startsWith("vue:")) {
          rawName = `vnode-${rawName.slice(4)}`;
        }
        const eventString = node.tagType !== 0 || rawName.startsWith("vnode") || !/[A-Z]/.test(rawName) ? (
          // for non-element and vnode lifecycle event listeners, auto convert
          // it to camelCase. See issue #2249
          toHandlerKey(camelize(rawName))
        ) : (
          // preserve case for plain element listeners that have uppercase
          // letters, as these may be custom elements' custom events
          `on:${rawName}`
        );
        eventName = createSimpleExpression(eventString, true, arg.loc);
      } else {
        eventName = createCompoundExpression([
          `${context.helperString(TO_HANDLER_KEY)}(`,
          arg,
          `)`
        ]);
      }
    } else {
      eventName = arg;
      eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
      eventName.children.push(`)`);
    }
    let exp = dir.exp;
    if (exp && !exp.content.trim()) {
      exp = void 0;
    }
    let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
    if (exp) {
      const isMemberExp = isMemberExpression(exp.content);
      const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
      const hasMultipleStatements = exp.content.includes(`;`);
      if (isInlineStatement || shouldCache && isMemberExp) {
        exp = createCompoundExpression([
          `${isInlineStatement ? `$event` : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
          exp,
          hasMultipleStatements ? `}` : `)`
        ]);
      }
    }
    let ret = {
      props: [
        createObjectProperty(
          eventName,
          exp || createSimpleExpression(`() => {}`, false, loc)
        )
      ]
    };
    if (augmentor) {
      ret = augmentor(ret);
    }
    if (shouldCache) {
      ret.props[0].value = context.cache(ret.props[0].value);
    }
    ret.props.forEach((p2) => p2.key.isHandlerKey = true);
    return ret;
  };
  const transformText = (node, context) => {
    if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
      return () => {
        const children = node.children;
        let currentContainer = void 0;
        let hasText = false;
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          if (isText$1(child)) {
            hasText = true;
            for (let j2 = i2 + 1; j2 < children.length; j2++) {
              const next = children[j2];
              if (isText$1(next)) {
                if (!currentContainer) {
                  currentContainer = children[i2] = createCompoundExpression(
                    [child],
                    child.loc
                  );
                }
                currentContainer.children.push(` + `, next);
                children.splice(j2, 1);
                j2--;
              } else {
                currentContainer = void 0;
                break;
              }
            }
          }
        }
        if (!hasText || // if this is a plain element with a single text child, leave it
        // as-is since the runtime has dedicated fast path for this by directly
        // setting textContent of the element.
        // for component root it's always normalized anyway.
        children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && // #3756
        // custom directives can potentially add DOM elements arbitrarily,
        // we need to avoid setting textContent of the element at runtime
        // to avoid accidentally overwriting the DOM elements added
        // by the user through custom directives.
        !node.props.find(
          (p2) => p2.type === 7 && !context.directiveTransforms[p2.name]
        ) && // in compat mode, <template> tags with no special directives
        // will be rendered as a fragment so its children must be
        // converted into vnodes.
        !(node.tag === "template"))) {
          return;
        }
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          if (isText$1(child) || child.type === 8) {
            const callArgs = [];
            if (child.type !== 2 || child.content !== " ") {
              callArgs.push(child);
            }
            if (!context.ssr && getConstantType(child, context) === 0) {
              callArgs.push(
                `1`
              );
            }
            children[i2] = {
              type: 12,
              content: child,
              loc: child.loc,
              codegenNode: createCallExpression(
                context.helper(CREATE_TEXT),
                callArgs
              )
            };
          }
        }
      };
    }
  };
  const seen$1 = /* @__PURE__ */ new WeakSet();
  const transformOnce = (node, context) => {
    if (node.type === 1 && findDir(node, "once", true)) {
      if (seen$1.has(node) || context.inVOnce || context.inSSR) {
        return;
      }
      seen$1.add(node);
      context.inVOnce = true;
      context.helper(SET_BLOCK_TRACKING);
      return () => {
        context.inVOnce = false;
        const cur = context.currentNode;
        if (cur.codegenNode) {
          cur.codegenNode = context.cache(
            cur.codegenNode,
            true
            /* isVNode */
          );
        }
      };
    }
  };
  const transformModel$1 = (dir, node, context) => {
    const { exp, arg } = dir;
    if (!exp) {
      context.onError(
        createCompilerError(41, dir.loc)
      );
      return createTransformProps();
    }
    const rawExp = exp.loc.source;
    const expString = exp.type === 4 ? exp.content : rawExp;
    const bindingType = context.bindingMetadata[rawExp];
    if (bindingType === "props" || bindingType === "props-aliased") {
      context.onError(createCompilerError(44, exp.loc));
      return createTransformProps();
    }
    const maybeRef = false;
    if (!expString.trim() || !isMemberExpression(expString) && !maybeRef) {
      context.onError(
        createCompilerError(42, exp.loc)
      );
      return createTransformProps();
    }
    const propName = arg ? arg : createSimpleExpression("modelValue", true);
    const eventName = arg ? isStaticExp(arg) ? `onUpdate:${camelize(arg.content)}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
    let assignmentExp;
    const eventArg = context.isTS ? `($event: any)` : `$event`;
    {
      assignmentExp = createCompoundExpression([
        `${eventArg} => ((`,
        exp,
        `) = $event)`
      ]);
    }
    const props = [
      // modelValue: foo
      createObjectProperty(propName, dir.exp),
      // "onUpdate:modelValue": $event => (foo = $event)
      createObjectProperty(eventName, assignmentExp)
    ];
    if (dir.modifiers.length && node.tagType === 1) {
      const modifiers = dir.modifiers.map((m2) => (isSimpleIdentifier(m2) ? m2 : JSON.stringify(m2)) + `: true`).join(`, `);
      const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
      props.push(
        createObjectProperty(
          modifiersKey,
          createSimpleExpression(
            `{ ${modifiers} }`,
            false,
            dir.loc,
            2
          )
        )
      );
    }
    return createTransformProps(props);
  };
  function createTransformProps(props = []) {
    return { props };
  }
  const validDivisionCharRE = /[\w).+\-_$\]]/;
  const transformFilter = (node, context) => {
    if (!isCompatEnabled("COMPILER_FILTERS", context)) {
      return;
    }
    if (node.type === 5) {
      rewriteFilter(node.content, context);
    } else if (node.type === 1) {
      node.props.forEach((prop) => {
        if (prop.type === 7 && prop.name !== "for" && prop.exp) {
          rewriteFilter(prop.exp, context);
        }
      });
    }
  };
  function rewriteFilter(node, context) {
    if (node.type === 4) {
      parseFilter(node, context);
    } else {
      for (let i2 = 0; i2 < node.children.length; i2++) {
        const child = node.children[i2];
        if (typeof child !== "object") continue;
        if (child.type === 4) {
          parseFilter(child, context);
        } else if (child.type === 8) {
          rewriteFilter(node, context);
        } else if (child.type === 5) {
          rewriteFilter(child.content, context);
        }
      }
    }
  }
  function parseFilter(node, context) {
    const exp = node.content;
    let inSingle = false;
    let inDouble = false;
    let inTemplateString = false;
    let inRegex = false;
    let curly = 0;
    let square = 0;
    let paren = 0;
    let lastFilterIndex = 0;
    let c2, prev, i2, expression, filters = [];
    for (i2 = 0; i2 < exp.length; i2++) {
      prev = c2;
      c2 = exp.charCodeAt(i2);
      if (inSingle) {
        if (c2 === 39 && prev !== 92) inSingle = false;
      } else if (inDouble) {
        if (c2 === 34 && prev !== 92) inDouble = false;
      } else if (inTemplateString) {
        if (c2 === 96 && prev !== 92) inTemplateString = false;
      } else if (inRegex) {
        if (c2 === 47 && prev !== 92) inRegex = false;
      } else if (c2 === 124 && // pipe
      exp.charCodeAt(i2 + 1) !== 124 && exp.charCodeAt(i2 - 1) !== 124 && !curly && !square && !paren) {
        if (expression === void 0) {
          lastFilterIndex = i2 + 1;
          expression = exp.slice(0, i2).trim();
        } else {
          pushFilter();
        }
      } else {
        switch (c2) {
          case 34:
            inDouble = true;
            break;
          case 39:
            inSingle = true;
            break;
          case 96:
            inTemplateString = true;
            break;
          case 40:
            paren++;
            break;
          case 41:
            paren--;
            break;
          case 91:
            square++;
            break;
          case 93:
            square--;
            break;
          case 123:
            curly++;
            break;
          case 125:
            curly--;
            break;
        }
        if (c2 === 47) {
          let j2 = i2 - 1;
          let p2;
          for (; j2 >= 0; j2--) {
            p2 = exp.charAt(j2);
            if (p2 !== " ") break;
          }
          if (!p2 || !validDivisionCharRE.test(p2)) {
            inRegex = true;
          }
        }
      }
    }
    if (expression === void 0) {
      expression = exp.slice(0, i2).trim();
    } else if (lastFilterIndex !== 0) {
      pushFilter();
    }
    function pushFilter() {
      filters.push(exp.slice(lastFilterIndex, i2).trim());
      lastFilterIndex = i2 + 1;
    }
    if (filters.length) {
      for (i2 = 0; i2 < filters.length; i2++) {
        expression = wrapFilter(expression, filters[i2], context);
      }
      node.content = expression;
      node.ast = void 0;
    }
  }
  function wrapFilter(exp, filter, context) {
    context.helper(RESOLVE_FILTER);
    const i2 = filter.indexOf("(");
    if (i2 < 0) {
      context.filters.add(filter);
      return `${toValidAssetId(filter, "filter")}(${exp})`;
    } else {
      const name = filter.slice(0, i2);
      const args = filter.slice(i2 + 1);
      context.filters.add(name);
      return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
    }
  }
  const seen = /* @__PURE__ */ new WeakSet();
  const transformMemo = (node, context) => {
    if (node.type === 1) {
      const dir = findDir(node, "memo");
      if (!dir || seen.has(node)) {
        return;
      }
      seen.add(node);
      return () => {
        const codegenNode = node.codegenNode || context.currentNode.codegenNode;
        if (codegenNode && codegenNode.type === 13) {
          if (node.tagType !== 1) {
            convertToBlock(codegenNode, context);
          }
          node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
            dir.exp,
            createFunctionExpression(void 0, codegenNode),
            `_cache`,
            String(context.cached++)
          ]);
        }
      };
    }
  };
  function getBaseTransformPreset(prefixIdentifiers) {
    return [
      [
        transformOnce,
        transformIf,
        transformMemo,
        transformFor,
        ...[transformFilter],
        ...[],
        transformSlotOutlet,
        transformElement,
        trackSlotScopes,
        transformText
      ],
      {
        on: transformOn$1,
        bind: transformBind,
        model: transformModel$1
      }
    ];
  }
  function baseCompile(source, options = {}) {
    const onError = options.onError || defaultOnError;
    const isModuleMode = options.mode === "module";
    {
      if (options.prefixIdentifiers === true) {
        onError(createCompilerError(47));
      } else if (isModuleMode) {
        onError(createCompilerError(48));
      }
    }
    const prefixIdentifiers = false;
    if (options.cacheHandlers) {
      onError(createCompilerError(49));
    }
    if (options.scopeId && !isModuleMode) {
      onError(createCompilerError(50));
    }
    const resolvedOptions = extend$1({}, options, {
      prefixIdentifiers
    });
    const ast = isString$1(source) ? baseParse(source, resolvedOptions) : source;
    const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
    transform(
      ast,
      extend$1({}, resolvedOptions, {
        nodeTransforms: [
          ...nodeTransforms,
          ...options.nodeTransforms || []
          // user transforms
        ],
        directiveTransforms: extend$1(
          {},
          directiveTransforms,
          options.directiveTransforms || {}
          // user transforms
        )
      })
    );
    return generate(ast, resolvedOptions);
  }
  const noopDirectiveTransform = () => ({ props: [] });
  /**
  * @vue/compiler-dom v3.4.32
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  const V_MODEL_RADIO = Symbol(``);
  const V_MODEL_CHECKBOX = Symbol(``);
  const V_MODEL_TEXT = Symbol(``);
  const V_MODEL_SELECT = Symbol(``);
  const V_MODEL_DYNAMIC = Symbol(``);
  const V_ON_WITH_MODIFIERS = Symbol(``);
  const V_ON_WITH_KEYS = Symbol(``);
  const V_SHOW = Symbol(``);
  const TRANSITION = Symbol(``);
  const TRANSITION_GROUP = Symbol(``);
  registerRuntimeHelpers({
    [V_MODEL_RADIO]: `vModelRadio`,
    [V_MODEL_CHECKBOX]: `vModelCheckbox`,
    [V_MODEL_TEXT]: `vModelText`,
    [V_MODEL_SELECT]: `vModelSelect`,
    [V_MODEL_DYNAMIC]: `vModelDynamic`,
    [V_ON_WITH_MODIFIERS]: `withModifiers`,
    [V_ON_WITH_KEYS]: `withKeys`,
    [V_SHOW]: `vShow`,
    [TRANSITION]: `Transition`,
    [TRANSITION_GROUP]: `TransitionGroup`
  });
  let decoder;
  function decodeHtmlBrowser(raw, asAttr = false) {
    if (!decoder) {
      decoder = document.createElement("div");
    }
    if (asAttr) {
      decoder.innerHTML = `<div foo="${raw.replace(/"/g, "&quot;")}">`;
      return decoder.children[0].getAttribute("foo");
    } else {
      decoder.innerHTML = raw;
      return decoder.textContent;
    }
  }
  const parserOptions = {
    parseMode: "html",
    isVoidTag,
    isNativeTag: (tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),
    isPreTag: (tag) => tag === "pre",
    decodeEntities: decodeHtmlBrowser,
    isBuiltInComponent: (tag) => {
      if (tag === "Transition" || tag === "transition") {
        return TRANSITION;
      } else if (tag === "TransitionGroup" || tag === "transition-group") {
        return TRANSITION_GROUP;
      }
    },
    // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
    getNamespace(tag, parent, rootNamespace) {
      let ns = parent ? parent.ns : rootNamespace;
      if (parent && ns === 2) {
        if (parent.tag === "annotation-xml") {
          if (tag === "svg") {
            return 1;
          }
          if (parent.props.some(
            (a2) => a2.type === 6 && a2.name === "encoding" && a2.value != null && (a2.value.content === "text/html" || a2.value.content === "application/xhtml+xml")
          )) {
            ns = 0;
          }
        } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
          ns = 0;
        }
      } else if (parent && ns === 1) {
        if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
          ns = 0;
        }
      }
      if (ns === 0) {
        if (tag === "svg") {
          return 1;
        }
        if (tag === "math") {
          return 2;
        }
      }
      return ns;
    }
  };
  const transformStyle = (node) => {
    if (node.type === 1) {
      node.props.forEach((p2, i2) => {
        if (p2.type === 6 && p2.name === "style" && p2.value) {
          node.props[i2] = {
            type: 7,
            name: `bind`,
            arg: createSimpleExpression(`style`, true, p2.loc),
            exp: parseInlineCSS(p2.value.content, p2.loc),
            modifiers: [],
            loc: p2.loc
          };
        }
      });
    }
  };
  const parseInlineCSS = (cssText, loc) => {
    const normalized = parseStringStyle(cssText);
    return createSimpleExpression(
      JSON.stringify(normalized),
      false,
      loc,
      3
    );
  };
  function createDOMCompilerError(code, loc) {
    return createCompilerError(
      code,
      loc
    );
  }
  const transformVHtml = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
      context.onError(
        createDOMCompilerError(53, loc)
      );
    }
    if (node.children.length) {
      context.onError(
        createDOMCompilerError(54, loc)
      );
      node.children.length = 0;
    }
    return {
      props: [
        createObjectProperty(
          createSimpleExpression(`innerHTML`, true, loc),
          exp || createSimpleExpression("", true)
        )
      ]
    };
  };
  const transformVText = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
      context.onError(
        createDOMCompilerError(55, loc)
      );
    }
    if (node.children.length) {
      context.onError(
        createDOMCompilerError(56, loc)
      );
      node.children.length = 0;
    }
    return {
      props: [
        createObjectProperty(
          createSimpleExpression(`textContent`, true),
          exp ? getConstantType(exp, context) > 0 ? exp : createCallExpression(
            context.helperString(TO_DISPLAY_STRING),
            [exp],
            loc
          ) : createSimpleExpression("", true)
        )
      ]
    };
  };
  const transformModel = (dir, node, context) => {
    const baseResult = transformModel$1(dir, node, context);
    if (!baseResult.props.length || node.tagType === 1) {
      return baseResult;
    }
    if (dir.arg) {
      context.onError(
        createDOMCompilerError(
          58,
          dir.arg.loc
        )
      );
    }
    const { tag } = node;
    const isCustomElement = context.isCustomElement(tag);
    if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
      let directiveToUse = V_MODEL_TEXT;
      let isInvalidType = false;
      if (tag === "input" || isCustomElement) {
        const type = findProp(node, `type`);
        if (type) {
          if (type.type === 7) {
            directiveToUse = V_MODEL_DYNAMIC;
          } else if (type.value) {
            switch (type.value.content) {
              case "radio":
                directiveToUse = V_MODEL_RADIO;
                break;
              case "checkbox":
                directiveToUse = V_MODEL_CHECKBOX;
                break;
              case "file":
                isInvalidType = true;
                context.onError(
                  createDOMCompilerError(
                    59,
                    dir.loc
                  )
                );
                break;
            }
          }
        } else if (hasDynamicKeyVBind(node)) {
          directiveToUse = V_MODEL_DYNAMIC;
        } else ;
      } else if (tag === "select") {
        directiveToUse = V_MODEL_SELECT;
      } else ;
      if (!isInvalidType) {
        baseResult.needRuntime = context.helper(directiveToUse);
      }
    } else {
      context.onError(
        createDOMCompilerError(
          57,
          dir.loc
        )
      );
    }
    baseResult.props = baseResult.props.filter(
      (p2) => !(p2.key.type === 4 && p2.key.content === "modelValue")
    );
    return baseResult;
  };
  const isEventOptionModifier = /* @__PURE__ */ makeMap(`passive,once,capture`);
  const isNonKeyModifier = /* @__PURE__ */ makeMap(
    // event propagation management
    `stop,prevent,self,ctrl,shift,alt,meta,exact,middle`
  );
  const maybeKeyModifier = /* @__PURE__ */ makeMap("left,right");
  const isKeyboardEvent = /* @__PURE__ */ makeMap(
    `onkeyup,onkeydown,onkeypress`,
    true
  );
  const resolveModifiers = (key, modifiers, context, loc) => {
    const keyModifiers = [];
    const nonKeyModifiers = [];
    const eventOptionModifiers = [];
    for (let i2 = 0; i2 < modifiers.length; i2++) {
      const modifier = modifiers[i2];
      if (modifier === "native" && checkCompatEnabled(
        "COMPILER_V_ON_NATIVE",
        context
      )) {
        eventOptionModifiers.push(modifier);
      } else if (isEventOptionModifier(modifier)) {
        eventOptionModifiers.push(modifier);
      } else {
        if (maybeKeyModifier(modifier)) {
          if (isStaticExp(key)) {
            if (isKeyboardEvent(key.content)) {
              keyModifiers.push(modifier);
            } else {
              nonKeyModifiers.push(modifier);
            }
          } else {
            keyModifiers.push(modifier);
            nonKeyModifiers.push(modifier);
          }
        } else {
          if (isNonKeyModifier(modifier)) {
            nonKeyModifiers.push(modifier);
          } else {
            keyModifiers.push(modifier);
          }
        }
      }
    }
    return {
      keyModifiers,
      nonKeyModifiers,
      eventOptionModifiers
    };
  };
  const transformClick = (key, event) => {
    const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === "onclick";
    return isStaticClick ? createSimpleExpression(event, true) : key.type !== 4 ? createCompoundExpression([
      `(`,
      key,
      `) === "onClick" ? "${event}" : (`,
      key,
      `)`
    ]) : key;
  };
  const transformOn = (dir, node, context) => {
    return transformOn$1(dir, node, context, (baseResult) => {
      const { modifiers } = dir;
      if (!modifiers.length) return baseResult;
      let { key, value: handlerExp } = baseResult.props[0];
      const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
      if (nonKeyModifiers.includes("right")) {
        key = transformClick(key, `onContextmenu`);
      }
      if (nonKeyModifiers.includes("middle")) {
        key = transformClick(key, `onMouseup`);
      }
      if (nonKeyModifiers.length) {
        handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
          handlerExp,
          JSON.stringify(nonKeyModifiers)
        ]);
      }
      if (keyModifiers.length && // if event name is dynamic, always wrap with keys guard
      (!isStaticExp(key) || isKeyboardEvent(key.content))) {
        handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
          handlerExp,
          JSON.stringify(keyModifiers)
        ]);
      }
      if (eventOptionModifiers.length) {
        const modifierPostfix = eventOptionModifiers.map(capitalize).join("");
        key = isStaticExp(key) ? createSimpleExpression(`${key.content}${modifierPostfix}`, true) : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
      }
      return {
        props: [createObjectProperty(key, handlerExp)]
      };
    });
  };
  const transformShow = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
      context.onError(
        createDOMCompilerError(61, loc)
      );
    }
    return {
      props: [],
      needRuntime: context.helper(V_SHOW)
    };
  };
  const ignoreSideEffectTags = (node, context) => {
    if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
      context.removeNode();
    }
  };
  const DOMNodeTransforms = [
    transformStyle,
    ...[]
  ];
  const DOMDirectiveTransforms = {
    cloak: noopDirectiveTransform,
    html: transformVHtml,
    text: transformVText,
    model: transformModel,
    // override compiler-core
    on: transformOn,
    // override compiler-core
    show: transformShow
  };
  function compile(src, options = {}) {
    return baseCompile(
      src,
      extend$1({}, parserOptions, options, {
        nodeTransforms: [
          // ignore <script> and <tag>
          // this is not put inside DOMNodeTransforms because that list is used
          // by compiler-ssr to generate vnode fallback branches
          ignoreSideEffectTags,
          ...DOMNodeTransforms,
          ...options.nodeTransforms || []
        ],
        directiveTransforms: extend$1(
          {},
          DOMDirectiveTransforms,
          options.directiveTransforms || {}
        ),
        transformHoist: null
      })
    );
  }
  /**
  * vue v3.4.32
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  const compileCache = /* @__PURE__ */ new WeakMap();
  function getCache(options) {
    let c2 = compileCache.get(options != null ? options : EMPTY_OBJ);
    if (!c2) {
      c2 = /* @__PURE__ */ Object.create(null);
      compileCache.set(options != null ? options : EMPTY_OBJ, c2);
    }
    return c2;
  }
  function compileToFunction(template, options) {
    if (!isString$1(template)) {
      if (template.nodeType) {
        template = template.innerHTML;
      } else {
        return NOOP;
      }
    }
    const key = template;
    const cache2 = getCache(options);
    const cached = cache2[key];
    if (cached) {
      return cached;
    }
    if (template[0] === "#") {
      const el = document.querySelector(template);
      template = el ? el.innerHTML : ``;
    }
    const opts = extend$1(
      {
        hoistStatic: true,
        onError: void 0,
        onWarn: NOOP
      },
      options
    );
    if (!opts.isCustomElement && typeof customElements !== "undefined") {
      opts.isCustomElement = (tag) => !!customElements.get(tag);
    }
    const { code } = compile(template, opts);
    const render2 = new Function("Vue", code)(runtimeDom);
    render2._rc = true;
    return cache2[key] = render2;
  }
  registerRuntimeCompiler(compileToFunction);
  /*!
    * vue-i18n v10.0.3
    * (c) 2024 kazuya kawaguchi
    * Released under the MIT License.
    */
  const VERSION$1 = "10.0.3";
  function initFeatureFlags() {
    if (typeof __VUE_I18N_FULL_INSTALL__ !== "boolean") {
      getGlobalThis$1().__VUE_I18N_FULL_INSTALL__ = true;
    }
    if (typeof __VUE_I18N_LEGACY_API__ !== "boolean") {
      getGlobalThis$1().__VUE_I18N_LEGACY_API__ = true;
    }
    if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
      getGlobalThis$1().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
    }
    if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
      getGlobalThis$1().__INTLIFY_PROD_DEVTOOLS__ = false;
    }
  }
  const I18nErrorCodes = {
    // composer module errors
    UNEXPECTED_RETURN_TYPE: CORE_ERROR_CODES_EXTEND_POINT,
    // 24
    // legacy module errors
    INVALID_ARGUMENT: 25,
    // i18n module errors
    MUST_BE_CALL_SETUP_TOP: 26,
    NOT_INSTALLED: 27,
    // directive module errors
    REQUIRED_VALUE: 28,
    INVALID_VALUE: 29,
    // vue-devtools errors
    CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: 30,
    NOT_INSTALLED_WITH_PROVIDE: 31,
    // unexpected error
    UNEXPECTED_ERROR: 32,
    // not compatible legacy vue-i18n constructor
    NOT_COMPATIBLE_LEGACY_VUE_I18N: 33,
    // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
    NOT_AVAILABLE_COMPOSITION_IN_LEGACY: 34
  };
  function createI18nError(code, ...args) {
    return createCompileError(code, null, void 0);
  }
  const TranslateVNodeSymbol = /* @__PURE__ */ makeSymbol("__translateVNode");
  const DatetimePartsSymbol = /* @__PURE__ */ makeSymbol("__datetimeParts");
  const NumberPartsSymbol = /* @__PURE__ */ makeSymbol("__numberParts");
  const SetPluralRulesSymbol = makeSymbol("__setPluralRules");
  const InejctWithOptionSymbol = /* @__PURE__ */ makeSymbol("__injectWithOption");
  const DisposeSymbol = /* @__PURE__ */ makeSymbol("__dispose");
  function handleFlatJson(obj) {
    if (!isObject$2(obj)) {
      return obj;
    }
    for (const key in obj) {
      if (!hasOwn$1(obj, key)) {
        continue;
      }
      if (!key.includes(".")) {
        if (isObject$2(obj[key])) {
          handleFlatJson(obj[key]);
        }
      } else {
        const subKeys = key.split(".");
        const lastIndex = subKeys.length - 1;
        let currentObj = obj;
        let hasStringValue = false;
        for (let i2 = 0; i2 < lastIndex; i2++) {
          if (!(subKeys[i2] in currentObj)) {
            currentObj[subKeys[i2]] = {};
          }
          if (!isObject$2(currentObj[subKeys[i2]])) {
            hasStringValue = true;
            break;
          }
          currentObj = currentObj[subKeys[i2]];
        }
        if (!hasStringValue) {
          currentObj[subKeys[lastIndex]] = obj[key];
          delete obj[key];
        }
        if (isObject$2(currentObj[subKeys[lastIndex]])) {
          handleFlatJson(currentObj[subKeys[lastIndex]]);
        }
      }
    }
    return obj;
  }
  function getLocaleMessages(locale2, options) {
    const { messages, __i18n, messageResolver, flatJson } = options;
    const ret = isPlainObject$3(messages) ? messages : isArray$3(__i18n) ? {} : { [locale2]: {} };
    if (isArray$3(__i18n)) {
      __i18n.forEach((custom) => {
        if ("locale" in custom && "resource" in custom) {
          const { locale: locale22, resource } = custom;
          if (locale22) {
            ret[locale22] = ret[locale22] || {};
            deepCopy(resource, ret[locale22]);
          } else {
            deepCopy(resource, ret);
          }
        } else {
          isString$2(custom) && deepCopy(JSON.parse(custom), ret);
        }
      });
    }
    if (messageResolver == null && flatJson) {
      for (const key in ret) {
        if (hasOwn$1(ret, key)) {
          handleFlatJson(ret[key]);
        }
      }
    }
    return ret;
  }
  function getComponentOptions(instance) {
    return instance.type;
  }
  function adjustI18nResources(gl, options, componentOptions) {
    let messages = isObject$2(options.messages) ? options.messages : {};
    if ("__i18nGlobal" in componentOptions) {
      messages = getLocaleMessages(gl.locale.value, {
        messages,
        __i18n: componentOptions.__i18nGlobal
      });
    }
    const locales = Object.keys(messages);
    if (locales.length) {
      locales.forEach((locale2) => {
        gl.mergeLocaleMessage(locale2, messages[locale2]);
      });
    }
    {
      if (isObject$2(options.datetimeFormats)) {
        const locales2 = Object.keys(options.datetimeFormats);
        if (locales2.length) {
          locales2.forEach((locale2) => {
            gl.mergeDateTimeFormat(locale2, options.datetimeFormats[locale2]);
          });
        }
      }
      if (isObject$2(options.numberFormats)) {
        const locales2 = Object.keys(options.numberFormats);
        if (locales2.length) {
          locales2.forEach((locale2) => {
            gl.mergeNumberFormat(locale2, options.numberFormats[locale2]);
          });
        }
      }
    }
  }
  function createTextNode(key) {
    return createVNode(Text, null, key, 0);
  }
  const DEVTOOLS_META = "__INTLIFY_META__";
  const NOOP_RETURN_ARRAY = () => [];
  const NOOP_RETURN_FALSE = () => false;
  let composerID = 0;
  function defineCoreMissingHandler(missing) {
    return (ctx, locale2, key, type) => {
      return missing(locale2, key, getCurrentInstance() || void 0, type);
    };
  }
  const getMetaInfo = /* @__NO_SIDE_EFFECTS__ */ () => {
    const instance = getCurrentInstance();
    let meta = null;
    return instance && (meta = getComponentOptions(instance)[DEVTOOLS_META]) ? { [DEVTOOLS_META]: meta } : null;
  };
  function createComposer(options = {}) {
    const { __root, __injectWithOption } = options;
    const _isGlobal = __root === void 0;
    const flatJson = options.flatJson;
    const _ref = inBrowser ? ref : shallowRef;
    let _inheritLocale = isBoolean$1(options.inheritLocale) ? options.inheritLocale : true;
    const _locale = _ref(
      // prettier-ignore
      __root && _inheritLocale ? __root.locale.value : isString$2(options.locale) ? options.locale : DEFAULT_LOCALE
    );
    const _fallbackLocale = _ref(
      // prettier-ignore
      __root && _inheritLocale ? __root.fallbackLocale.value : isString$2(options.fallbackLocale) || isArray$3(options.fallbackLocale) || isPlainObject$3(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value
    );
    const _messages = _ref(getLocaleMessages(_locale.value, options));
    const _datetimeFormats = _ref(isPlainObject$3(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
    const _numberFormats = _ref(isPlainObject$3(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
    let _missingWarn = __root ? __root.missingWarn : isBoolean$1(options.missingWarn) || isRegExp$2(options.missingWarn) ? options.missingWarn : true;
    let _fallbackWarn = __root ? __root.fallbackWarn : isBoolean$1(options.fallbackWarn) || isRegExp$2(options.fallbackWarn) ? options.fallbackWarn : true;
    let _fallbackRoot = __root ? __root.fallbackRoot : isBoolean$1(options.fallbackRoot) ? options.fallbackRoot : true;
    let _fallbackFormat = !!options.fallbackFormat;
    let _missing = isFunction$2(options.missing) ? options.missing : null;
    let _runtimeMissing = isFunction$2(options.missing) ? defineCoreMissingHandler(options.missing) : null;
    let _postTranslation = isFunction$2(options.postTranslation) ? options.postTranslation : null;
    let _warnHtmlMessage = __root ? __root.warnHtmlMessage : isBoolean$1(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
    let _escapeParameter = !!options.escapeParameter;
    const _modifiers = __root ? __root.modifiers : isPlainObject$3(options.modifiers) ? options.modifiers : {};
    let _pluralRules = options.pluralRules || __root && __root.pluralRules;
    let _context;
    const getCoreContext = () => {
      _isGlobal && setFallbackContext(null);
      const ctxOptions = {
        version: VERSION$1,
        locale: _locale.value,
        fallbackLocale: _fallbackLocale.value,
        messages: _messages.value,
        modifiers: _modifiers,
        pluralRules: _pluralRules,
        missing: _runtimeMissing === null ? void 0 : _runtimeMissing,
        missingWarn: _missingWarn,
        fallbackWarn: _fallbackWarn,
        fallbackFormat: _fallbackFormat,
        unresolving: true,
        postTranslation: _postTranslation === null ? void 0 : _postTranslation,
        warnHtmlMessage: _warnHtmlMessage,
        escapeParameter: _escapeParameter,
        messageResolver: options.messageResolver,
        messageCompiler: options.messageCompiler,
        __meta: { framework: "vue" }
      };
      {
        ctxOptions.datetimeFormats = _datetimeFormats.value;
        ctxOptions.numberFormats = _numberFormats.value;
        ctxOptions.__datetimeFormatters = isPlainObject$3(_context) ? _context.__datetimeFormatters : void 0;
        ctxOptions.__numberFormatters = isPlainObject$3(_context) ? _context.__numberFormatters : void 0;
      }
      const ctx = createCoreContext(ctxOptions);
      _isGlobal && setFallbackContext(ctx);
      return ctx;
    };
    _context = getCoreContext();
    updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
    function trackReactivityValues() {
      return [
        _locale.value,
        _fallbackLocale.value,
        _messages.value,
        _datetimeFormats.value,
        _numberFormats.value
      ];
    }
    const locale2 = computed({
      get: () => _locale.value,
      set: (val) => {
        _locale.value = val;
        _context.locale = _locale.value;
      }
    });
    const fallbackLocale = computed({
      get: () => _fallbackLocale.value,
      set: (val) => {
        _fallbackLocale.value = val;
        _context.fallbackLocale = _fallbackLocale.value;
        updateFallbackLocale(_context, _locale.value, val);
      }
    });
    const messages = computed(() => _messages.value);
    const datetimeFormats = /* @__PURE__ */ computed(() => _datetimeFormats.value);
    const numberFormats = /* @__PURE__ */ computed(() => _numberFormats.value);
    function getPostTranslationHandler() {
      return isFunction$2(_postTranslation) ? _postTranslation : null;
    }
    function setPostTranslationHandler(handler) {
      _postTranslation = handler;
      _context.postTranslation = handler;
    }
    function getMissingHandler() {
      return _missing;
    }
    function setMissingHandler(handler) {
      if (handler !== null) {
        _runtimeMissing = defineCoreMissingHandler(handler);
      }
      _missing = handler;
      _context.missing = _runtimeMissing;
    }
    const wrapWithDeps = (fn2, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) => {
      trackReactivityValues();
      let ret;
      try {
        if (__INTLIFY_PROD_DEVTOOLS__) {
          /* @__PURE__ */ setAdditionalMeta(/* @__PURE__ */ getMetaInfo());
        }
        if (!_isGlobal) {
          _context.fallbackContext = __root ? getFallbackContext() : void 0;
        }
        ret = fn2(_context);
      } finally {
        if (__INTLIFY_PROD_DEVTOOLS__) ;
        if (!_isGlobal) {
          _context.fallbackContext = void 0;
        }
      }
      if (warnType !== "translate exists" && // for not `te` (e.g `t`)
      isNumber$1(ret) && ret === NOT_REOSLVED || warnType === "translate exists" && !ret) {
        const [key, arg2] = argumentParser();
        return __root && _fallbackRoot ? fallbackSuccess(__root) : fallbackFail(key);
      } else if (successCondition(ret)) {
        return ret;
      } else {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE);
      }
    };
    function t2(...args) {
      return wrapWithDeps((context) => Reflect.apply(translate, null, [context, ...args]), () => parseTranslateArgs(...args), "translate", (root) => Reflect.apply(root.t, root, [...args]), (key) => key, (val) => isString$2(val));
    }
    function rt2(...args) {
      const [arg1, arg2, arg3] = args;
      if (arg3 && !isObject$2(arg3)) {
        throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
      }
      return t2(...[arg1, arg2, assign$2({ resolvedMessage: true }, arg3 || {})]);
    }
    function d2(...args) {
      return wrapWithDeps((context) => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), "datetime format", (root) => Reflect.apply(root.d, root, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$2(val));
    }
    function n2(...args) {
      return wrapWithDeps((context) => Reflect.apply(number, null, [context, ...args]), () => parseNumberArgs(...args), "number format", (root) => Reflect.apply(root.n, root, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$2(val));
    }
    function normalize(values) {
      return values.map((val) => isString$2(val) || isNumber$1(val) || isBoolean$1(val) ? createTextNode(String(val)) : val);
    }
    const interpolate = (val) => val;
    const processor = {
      normalize,
      interpolate,
      type: "vnode"
    };
    function translateVNode(...args) {
      return wrapWithDeps((context) => {
        let ret;
        const _context2 = context;
        try {
          _context2.processor = processor;
          ret = Reflect.apply(translate, null, [_context2, ...args]);
        } finally {
          _context2.processor = null;
        }
        return ret;
      }, () => parseTranslateArgs(...args), "translate", (root) => root[TranslateVNodeSymbol](...args), (key) => [createTextNode(key)], (val) => isArray$3(val));
    }
    function numberParts(...args) {
      return wrapWithDeps((context) => Reflect.apply(number, null, [context, ...args]), () => parseNumberArgs(...args), "number format", (root) => root[NumberPartsSymbol](...args), NOOP_RETURN_ARRAY, (val) => isString$2(val) || isArray$3(val));
    }
    function datetimeParts(...args) {
      return wrapWithDeps((context) => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), "datetime format", (root) => root[DatetimePartsSymbol](...args), NOOP_RETURN_ARRAY, (val) => isString$2(val) || isArray$3(val));
    }
    function setPluralRules(rules) {
      _pluralRules = rules;
      _context.pluralRules = _pluralRules;
    }
    function te2(key, locale22) {
      return wrapWithDeps(() => {
        if (!key) {
          return false;
        }
        const targetLocale = isString$2(locale22) ? locale22 : _locale.value;
        const message = getLocaleMessage(targetLocale);
        const resolved = _context.messageResolver(message, key);
        return isMessageAST(resolved) || isMessageFunction(resolved) || isString$2(resolved);
      }, () => [key], "translate exists", (root) => {
        return Reflect.apply(root.te, root, [key, locale22]);
      }, NOOP_RETURN_FALSE, (val) => isBoolean$1(val));
    }
    function resolveMessages(key) {
      let messages2 = null;
      const locales = fallbackWithLocaleChain(_context, _fallbackLocale.value, _locale.value);
      for (let i2 = 0; i2 < locales.length; i2++) {
        const targetLocaleMessages = _messages.value[locales[i2]] || {};
        const messageValue = _context.messageResolver(targetLocaleMessages, key);
        if (messageValue != null) {
          messages2 = messageValue;
          break;
        }
      }
      return messages2;
    }
    function tm(key) {
      const messages2 = resolveMessages(key);
      return messages2 != null ? messages2 : __root ? __root.tm(key) || {} : {};
    }
    function getLocaleMessage(locale22) {
      return _messages.value[locale22] || {};
    }
    function setLocaleMessage(locale22, message) {
      if (flatJson) {
        const _message = { [locale22]: message };
        for (const key in _message) {
          if (hasOwn$1(_message, key)) {
            handleFlatJson(_message[key]);
          }
        }
        message = _message[locale22];
      }
      _messages.value[locale22] = message;
      _context.messages = _messages.value;
    }
    function mergeLocaleMessage(locale22, message) {
      _messages.value[locale22] = _messages.value[locale22] || {};
      const _message = { [locale22]: message };
      if (flatJson) {
        for (const key in _message) {
          if (hasOwn$1(_message, key)) {
            handleFlatJson(_message[key]);
          }
        }
      }
      message = _message[locale22];
      deepCopy(message, _messages.value[locale22]);
      _context.messages = _messages.value;
    }
    function getDateTimeFormat(locale22) {
      return _datetimeFormats.value[locale22] || {};
    }
    function setDateTimeFormat(locale22, format2) {
      _datetimeFormats.value[locale22] = format2;
      _context.datetimeFormats = _datetimeFormats.value;
      clearDateTimeFormat(_context, locale22, format2);
    }
    function mergeDateTimeFormat(locale22, format2) {
      _datetimeFormats.value[locale22] = assign$2(_datetimeFormats.value[locale22] || {}, format2);
      _context.datetimeFormats = _datetimeFormats.value;
      clearDateTimeFormat(_context, locale22, format2);
    }
    function getNumberFormat(locale22) {
      return _numberFormats.value[locale22] || {};
    }
    function setNumberFormat(locale22, format2) {
      _numberFormats.value[locale22] = format2;
      _context.numberFormats = _numberFormats.value;
      clearNumberFormat(_context, locale22, format2);
    }
    function mergeNumberFormat(locale22, format2) {
      _numberFormats.value[locale22] = assign$2(_numberFormats.value[locale22] || {}, format2);
      _context.numberFormats = _numberFormats.value;
      clearNumberFormat(_context, locale22, format2);
    }
    composerID++;
    if (__root && inBrowser) {
      watch(__root.locale, (val) => {
        if (_inheritLocale) {
          _locale.value = val;
          _context.locale = val;
          updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
        }
      });
      watch(__root.fallbackLocale, (val) => {
        if (_inheritLocale) {
          _fallbackLocale.value = val;
          _context.fallbackLocale = val;
          updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
        }
      });
    }
    const composer = {
      id: composerID,
      locale: locale2,
      fallbackLocale,
      get inheritLocale() {
        return _inheritLocale;
      },
      set inheritLocale(val) {
        _inheritLocale = val;
        if (val && __root) {
          _locale.value = __root.locale.value;
          _fallbackLocale.value = __root.fallbackLocale.value;
          updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
        }
      },
      get availableLocales() {
        return Object.keys(_messages.value).sort();
      },
      messages,
      get modifiers() {
        return _modifiers;
      },
      get pluralRules() {
        return _pluralRules || {};
      },
      get isGlobal() {
        return _isGlobal;
      },
      get missingWarn() {
        return _missingWarn;
      },
      set missingWarn(val) {
        _missingWarn = val;
        _context.missingWarn = _missingWarn;
      },
      get fallbackWarn() {
        return _fallbackWarn;
      },
      set fallbackWarn(val) {
        _fallbackWarn = val;
        _context.fallbackWarn = _fallbackWarn;
      },
      get fallbackRoot() {
        return _fallbackRoot;
      },
      set fallbackRoot(val) {
        _fallbackRoot = val;
      },
      get fallbackFormat() {
        return _fallbackFormat;
      },
      set fallbackFormat(val) {
        _fallbackFormat = val;
        _context.fallbackFormat = _fallbackFormat;
      },
      get warnHtmlMessage() {
        return _warnHtmlMessage;
      },
      set warnHtmlMessage(val) {
        _warnHtmlMessage = val;
        _context.warnHtmlMessage = val;
      },
      get escapeParameter() {
        return _escapeParameter;
      },
      set escapeParameter(val) {
        _escapeParameter = val;
        _context.escapeParameter = val;
      },
      t: t2,
      getLocaleMessage,
      setLocaleMessage,
      mergeLocaleMessage,
      getPostTranslationHandler,
      setPostTranslationHandler,
      getMissingHandler,
      setMissingHandler,
      [SetPluralRulesSymbol]: setPluralRules
    };
    {
      composer.datetimeFormats = datetimeFormats;
      composer.numberFormats = numberFormats;
      composer.rt = rt2;
      composer.te = te2;
      composer.tm = tm;
      composer.d = d2;
      composer.n = n2;
      composer.getDateTimeFormat = getDateTimeFormat;
      composer.setDateTimeFormat = setDateTimeFormat;
      composer.mergeDateTimeFormat = mergeDateTimeFormat;
      composer.getNumberFormat = getNumberFormat;
      composer.setNumberFormat = setNumberFormat;
      composer.mergeNumberFormat = mergeNumberFormat;
      composer[InejctWithOptionSymbol] = __injectWithOption;
      composer[TranslateVNodeSymbol] = translateVNode;
      composer[DatetimePartsSymbol] = datetimeParts;
      composer[NumberPartsSymbol] = numberParts;
    }
    return composer;
  }
  function convertComposerOptions(options) {
    const locale2 = isString$2(options.locale) ? options.locale : DEFAULT_LOCALE;
    const fallbackLocale = isString$2(options.fallbackLocale) || isArray$3(options.fallbackLocale) || isPlainObject$3(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : locale2;
    const missing = isFunction$2(options.missing) ? options.missing : void 0;
    const missingWarn = isBoolean$1(options.silentTranslationWarn) || isRegExp$2(options.silentTranslationWarn) ? !options.silentTranslationWarn : true;
    const fallbackWarn = isBoolean$1(options.silentFallbackWarn) || isRegExp$2(options.silentFallbackWarn) ? !options.silentFallbackWarn : true;
    const fallbackRoot = isBoolean$1(options.fallbackRoot) ? options.fallbackRoot : true;
    const fallbackFormat = !!options.formatFallbackMessages;
    const modifiers = isPlainObject$3(options.modifiers) ? options.modifiers : {};
    const pluralizationRules = options.pluralizationRules;
    const postTranslation = isFunction$2(options.postTranslation) ? options.postTranslation : void 0;
    const warnHtmlMessage = isString$2(options.warnHtmlInMessage) ? options.warnHtmlInMessage !== "off" : true;
    const escapeParameter = !!options.escapeParameterHtml;
    const inheritLocale = isBoolean$1(options.sync) ? options.sync : true;
    let messages = options.messages;
    if (isPlainObject$3(options.sharedMessages)) {
      const sharedMessages = options.sharedMessages;
      const locales = Object.keys(sharedMessages);
      messages = locales.reduce((messages2, locale22) => {
        const message = messages2[locale22] || (messages2[locale22] = {});
        assign$2(message, sharedMessages[locale22]);
        return messages2;
      }, messages || {});
    }
    const { __i18n, __root, __injectWithOption } = options;
    const datetimeFormats = options.datetimeFormats;
    const numberFormats = options.numberFormats;
    const flatJson = options.flatJson;
    return {
      locale: locale2,
      fallbackLocale,
      messages,
      flatJson,
      datetimeFormats,
      numberFormats,
      missing,
      missingWarn,
      fallbackWarn,
      fallbackRoot,
      fallbackFormat,
      modifiers,
      pluralRules: pluralizationRules,
      postTranslation,
      warnHtmlMessage,
      escapeParameter,
      messageResolver: options.messageResolver,
      inheritLocale,
      __i18n,
      __root,
      __injectWithOption
    };
  }
  function createVueI18n(options = {}) {
    const composer = createComposer(convertComposerOptions(options));
    const { __extender } = options;
    const vueI18n = {
      // id
      id: composer.id,
      // locale
      get locale() {
        return composer.locale.value;
      },
      set locale(val) {
        composer.locale.value = val;
      },
      // fallbackLocale
      get fallbackLocale() {
        return composer.fallbackLocale.value;
      },
      set fallbackLocale(val) {
        composer.fallbackLocale.value = val;
      },
      // messages
      get messages() {
        return composer.messages.value;
      },
      // datetimeFormats
      get datetimeFormats() {
        return composer.datetimeFormats.value;
      },
      // numberFormats
      get numberFormats() {
        return composer.numberFormats.value;
      },
      // availableLocales
      get availableLocales() {
        return composer.availableLocales;
      },
      // missing
      get missing() {
        return composer.getMissingHandler();
      },
      set missing(handler) {
        composer.setMissingHandler(handler);
      },
      // silentTranslationWarn
      get silentTranslationWarn() {
        return isBoolean$1(composer.missingWarn) ? !composer.missingWarn : composer.missingWarn;
      },
      set silentTranslationWarn(val) {
        composer.missingWarn = isBoolean$1(val) ? !val : val;
      },
      // silentFallbackWarn
      get silentFallbackWarn() {
        return isBoolean$1(composer.fallbackWarn) ? !composer.fallbackWarn : composer.fallbackWarn;
      },
      set silentFallbackWarn(val) {
        composer.fallbackWarn = isBoolean$1(val) ? !val : val;
      },
      // modifiers
      get modifiers() {
        return composer.modifiers;
      },
      // formatFallbackMessages
      get formatFallbackMessages() {
        return composer.fallbackFormat;
      },
      set formatFallbackMessages(val) {
        composer.fallbackFormat = val;
      },
      // postTranslation
      get postTranslation() {
        return composer.getPostTranslationHandler();
      },
      set postTranslation(handler) {
        composer.setPostTranslationHandler(handler);
      },
      // sync
      get sync() {
        return composer.inheritLocale;
      },
      set sync(val) {
        composer.inheritLocale = val;
      },
      // warnInHtmlMessage
      get warnHtmlInMessage() {
        return composer.warnHtmlMessage ? "warn" : "off";
      },
      set warnHtmlInMessage(val) {
        composer.warnHtmlMessage = val !== "off";
      },
      // escapeParameterHtml
      get escapeParameterHtml() {
        return composer.escapeParameter;
      },
      set escapeParameterHtml(val) {
        composer.escapeParameter = val;
      },
      // pluralizationRules
      get pluralizationRules() {
        return composer.pluralRules || {};
      },
      // for internal
      __composer: composer,
      // t
      t(...args) {
        return Reflect.apply(composer.t, composer, [...args]);
      },
      // rt
      rt(...args) {
        return Reflect.apply(composer.rt, composer, [...args]);
      },
      // tc
      tc(...args) {
        const [arg1, arg2, arg3] = args;
        const options2 = { plural: 1 };
        let list = null;
        let named = null;
        if (!isString$2(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        const key = arg1;
        if (isString$2(arg2)) {
          options2.locale = arg2;
        } else if (isNumber$1(arg2)) {
          options2.plural = arg2;
        } else if (isArray$3(arg2)) {
          list = arg2;
        } else if (isPlainObject$3(arg2)) {
          named = arg2;
        }
        if (isString$2(arg3)) {
          options2.locale = arg3;
        } else if (isArray$3(arg3)) {
          list = arg3;
        } else if (isPlainObject$3(arg3)) {
          named = arg3;
        }
        return Reflect.apply(composer.t, composer, [
          key,
          list || named || {},
          options2
        ]);
      },
      // te
      te(key, locale2) {
        return composer.te(key, locale2);
      },
      // tm
      tm(key) {
        return composer.tm(key);
      },
      // getLocaleMessage
      getLocaleMessage(locale2) {
        return composer.getLocaleMessage(locale2);
      },
      // setLocaleMessage
      setLocaleMessage(locale2, message) {
        composer.setLocaleMessage(locale2, message);
      },
      // mergeLocaleMessage
      mergeLocaleMessage(locale2, message) {
        composer.mergeLocaleMessage(locale2, message);
      },
      // d
      d(...args) {
        return Reflect.apply(composer.d, composer, [...args]);
      },
      // getDateTimeFormat
      getDateTimeFormat(locale2) {
        return composer.getDateTimeFormat(locale2);
      },
      // setDateTimeFormat
      setDateTimeFormat(locale2, format2) {
        composer.setDateTimeFormat(locale2, format2);
      },
      // mergeDateTimeFormat
      mergeDateTimeFormat(locale2, format2) {
        composer.mergeDateTimeFormat(locale2, format2);
      },
      // n
      n(...args) {
        return Reflect.apply(composer.n, composer, [...args]);
      },
      // getNumberFormat
      getNumberFormat(locale2) {
        return composer.getNumberFormat(locale2);
      },
      // setNumberFormat
      setNumberFormat(locale2, format2) {
        composer.setNumberFormat(locale2, format2);
      },
      // mergeNumberFormat
      mergeNumberFormat(locale2, format2) {
        composer.mergeNumberFormat(locale2, format2);
      }
    };
    vueI18n.__extender = __extender;
    return vueI18n;
  }
  function defineMixin(vuei18n, composer, i18n2) {
    return {
      beforeCreate() {
        const instance = getCurrentInstance();
        if (!instance) {
          throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
        }
        const options = this.$options;
        if (options.i18n) {
          const optionsI18n = options.i18n;
          if (options.__i18n) {
            optionsI18n.__i18n = options.__i18n;
          }
          optionsI18n.__root = composer;
          if (this === this.$root) {
            this.$i18n = mergeToGlobal(vuei18n, optionsI18n);
          } else {
            optionsI18n.__injectWithOption = true;
            optionsI18n.__extender = i18n2.__vueI18nExtend;
            this.$i18n = createVueI18n(optionsI18n);
            const _vueI18n = this.$i18n;
            if (_vueI18n.__extender) {
              _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
            }
          }
        } else if (options.__i18n) {
          if (this === this.$root) {
            this.$i18n = mergeToGlobal(vuei18n, options);
          } else {
            this.$i18n = createVueI18n({
              __i18n: options.__i18n,
              __injectWithOption: true,
              __extender: i18n2.__vueI18nExtend,
              __root: composer
            });
            const _vueI18n = this.$i18n;
            if (_vueI18n.__extender) {
              _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
            }
          }
        } else {
          this.$i18n = vuei18n;
        }
        if (options.__i18nGlobal) {
          adjustI18nResources(composer, options, options);
        }
        this.$t = (...args) => this.$i18n.t(...args);
        this.$rt = (...args) => this.$i18n.rt(...args);
        this.$tc = (...args) => this.$i18n.tc(...args);
        this.$te = (key, locale2) => this.$i18n.te(key, locale2);
        this.$d = (...args) => this.$i18n.d(...args);
        this.$n = (...args) => this.$i18n.n(...args);
        this.$tm = (key) => this.$i18n.tm(key);
        i18n2.__setInstance(instance, this.$i18n);
      },
      mounted() {
      },
      unmounted() {
        const instance = getCurrentInstance();
        if (!instance) {
          throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
        }
        const _vueI18n = this.$i18n;
        delete this.$t;
        delete this.$rt;
        delete this.$tc;
        delete this.$te;
        delete this.$d;
        delete this.$n;
        delete this.$tm;
        if (_vueI18n.__disposer) {
          _vueI18n.__disposer();
          delete _vueI18n.__disposer;
          delete _vueI18n.__extender;
        }
        i18n2.__deleteInstance(instance);
        delete this.$i18n;
      }
    };
  }
  function mergeToGlobal(g2, options) {
    g2.locale = options.locale || g2.locale;
    g2.fallbackLocale = options.fallbackLocale || g2.fallbackLocale;
    g2.missing = options.missing || g2.missing;
    g2.silentTranslationWarn = options.silentTranslationWarn || g2.silentFallbackWarn;
    g2.silentFallbackWarn = options.silentFallbackWarn || g2.silentFallbackWarn;
    g2.formatFallbackMessages = options.formatFallbackMessages || g2.formatFallbackMessages;
    g2.postTranslation = options.postTranslation || g2.postTranslation;
    g2.warnHtmlInMessage = options.warnHtmlInMessage || g2.warnHtmlInMessage;
    g2.escapeParameterHtml = options.escapeParameterHtml || g2.escapeParameterHtml;
    g2.sync = options.sync || g2.sync;
    g2.__composer[SetPluralRulesSymbol](options.pluralizationRules || g2.pluralizationRules);
    const messages = getLocaleMessages(g2.locale, {
      messages: options.messages,
      __i18n: options.__i18n
    });
    Object.keys(messages).forEach((locale2) => g2.mergeLocaleMessage(locale2, messages[locale2]));
    if (options.datetimeFormats) {
      Object.keys(options.datetimeFormats).forEach((locale2) => g2.mergeDateTimeFormat(locale2, options.datetimeFormats[locale2]));
    }
    if (options.numberFormats) {
      Object.keys(options.numberFormats).forEach((locale2) => g2.mergeNumberFormat(locale2, options.numberFormats[locale2]));
    }
    return g2;
  }
  const baseFormatProps = {
    tag: {
      type: [String, Object]
    },
    locale: {
      type: String
    },
    scope: {
      type: String,
      // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
      validator: (val) => val === "parent" || val === "global",
      default: "parent"
      /* ComponentI18nScope */
    },
    i18n: {
      type: Object
    }
  };
  function getInterpolateArg({ slots }, keys) {
    if (keys.length === 1 && keys[0] === "default") {
      const ret = slots.default ? slots.default() : [];
      return ret.reduce((slot, current) => {
        return [
          ...slot,
          // prettier-ignore
          ...current.type === Fragment ? current.children : [current]
        ];
      }, []);
    } else {
      return keys.reduce((arg, key) => {
        const slot = slots[key];
        if (slot) {
          arg[key] = slot();
        }
        return arg;
      }, {});
    }
  }
  function getFragmentableTag() {
    return Fragment;
  }
  const TranslationImpl = /* @__PURE__ */ defineComponent({
    /* eslint-disable */
    name: "i18n-t",
    props: assign$2({
      keypath: {
        type: String,
        required: true
      },
      plural: {
        type: [Number, String],
        validator: (val) => isNumber$1(val) || !isNaN(val)
      }
    }, baseFormatProps),
    /* eslint-enable */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    setup(props, context) {
      const { slots, attrs } = context;
      const i18n2 = props.i18n || useI18n({
        useScope: props.scope,
        __useComponent: true
      });
      return () => {
        const keys = Object.keys(slots).filter((key) => key !== "_");
        const options = {};
        if (props.locale) {
          options.locale = props.locale;
        }
        if (props.plural !== void 0) {
          options.plural = isString$2(props.plural) ? +props.plural : props.plural;
        }
        const arg = getInterpolateArg(context, keys);
        const children = i18n2[TranslateVNodeSymbol](props.keypath, arg, options);
        const assignedAttrs = assign$2({}, attrs);
        const tag = isString$2(props.tag) || isObject$2(props.tag) ? props.tag : getFragmentableTag();
        return h$1(tag, assignedAttrs, children);
      };
    }
  });
  const Translation = TranslationImpl;
  function isVNode(target) {
    return isArray$3(target) && !isString$2(target[0]);
  }
  function renderFormatter(props, context, slotKeys, partFormatter) {
    const { slots, attrs } = context;
    return () => {
      const options = { part: true };
      let overrides = {};
      if (props.locale) {
        options.locale = props.locale;
      }
      if (isString$2(props.format)) {
        options.key = props.format;
      } else if (isObject$2(props.format)) {
        if (isString$2(props.format.key)) {
          options.key = props.format.key;
        }
        overrides = Object.keys(props.format).reduce((options2, prop) => {
          return slotKeys.includes(prop) ? assign$2({}, options2, { [prop]: props.format[prop] }) : options2;
        }, {});
      }
      const parts = partFormatter(...[props.value, options, overrides]);
      let children = [options.key];
      if (isArray$3(parts)) {
        children = parts.map((part, index) => {
          const slot = slots[part.type];
          const node = slot ? slot({ [part.type]: part.value, index, parts }) : [part.value];
          if (isVNode(node)) {
            node[0].key = `${part.type}-${index}`;
          }
          return node;
        });
      } else if (isString$2(parts)) {
        children = [parts];
      }
      const assignedAttrs = assign$2({}, attrs);
      const tag = isString$2(props.tag) || isObject$2(props.tag) ? props.tag : getFragmentableTag();
      return h$1(tag, assignedAttrs, children);
    };
  }
  const NumberFormatImpl = /* @__PURE__ */ defineComponent({
    /* eslint-disable */
    name: "i18n-n",
    props: assign$2({
      value: {
        type: Number,
        required: true
      },
      format: {
        type: [String, Object]
      }
    }, baseFormatProps),
    /* eslint-enable */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    setup(props, context) {
      const i18n2 = props.i18n || useI18n({
        useScope: props.scope,
        __useComponent: true
      });
      return renderFormatter(props, context, NUMBER_FORMAT_OPTIONS_KEYS, (...args) => (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        i18n2[NumberPartsSymbol](...args)
      ));
    }
  });
  const NumberFormat = NumberFormatImpl;
  const DatetimeFormatImpl = /* @__PURE__ */ defineComponent({
    /* eslint-disable */
    name: "i18n-d",
    props: assign$2({
      value: {
        type: [Number, Date],
        required: true
      },
      format: {
        type: [String, Object]
      }
    }, baseFormatProps),
    /* eslint-enable */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    setup(props, context) {
      const i18n2 = props.i18n || useI18n({
        useScope: props.scope,
        __useComponent: true
      });
      return renderFormatter(props, context, DATETIME_FORMAT_OPTIONS_KEYS, (...args) => (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        i18n2[DatetimePartsSymbol](...args)
      ));
    }
  });
  const DatetimeFormat = DatetimeFormatImpl;
  function getComposer$1(i18n2, instance) {
    const i18nInternal = i18n2;
    if (i18n2.mode === "composition") {
      return i18nInternal.__getInstance(instance) || i18n2.global;
    } else {
      const vueI18n = i18nInternal.__getInstance(instance);
      return vueI18n != null ? vueI18n.__composer : i18n2.global.__composer;
    }
  }
  function vTDirective(i18n2) {
    const _process = (binding) => {
      const { instance, value } = binding;
      if (!instance || !instance.$) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const composer = getComposer$1(i18n2, instance.$);
      const parsedValue = parseValue(value);
      return [
        Reflect.apply(composer.t, composer, [...makeParams(parsedValue)]),
        composer
      ];
    };
    const register = (el, binding) => {
      const [textContent, composer] = _process(binding);
      if (inBrowser && i18n2.global === composer) {
        el.__i18nWatcher = watch(composer.locale, () => {
          binding.instance && binding.instance.$forceUpdate();
        });
      }
      el.__composer = composer;
      el.textContent = textContent;
    };
    const unregister = (el) => {
      if (inBrowser && el.__i18nWatcher) {
        el.__i18nWatcher();
        el.__i18nWatcher = void 0;
        delete el.__i18nWatcher;
      }
      if (el.__composer) {
        el.__composer = void 0;
        delete el.__composer;
      }
    };
    const update = (el, { value }) => {
      if (el.__composer) {
        const composer = el.__composer;
        const parsedValue = parseValue(value);
        el.textContent = Reflect.apply(composer.t, composer, [
          ...makeParams(parsedValue)
        ]);
      }
    };
    const getSSRProps = (binding) => {
      const [textContent] = _process(binding);
      return { textContent };
    };
    return {
      created: register,
      unmounted: unregister,
      beforeUpdate: update,
      getSSRProps
    };
  }
  function parseValue(value) {
    if (isString$2(value)) {
      return { path: value };
    } else if (isPlainObject$3(value)) {
      if (!("path" in value)) {
        throw createI18nError(I18nErrorCodes.REQUIRED_VALUE, "path");
      }
      return value;
    } else {
      throw createI18nError(I18nErrorCodes.INVALID_VALUE);
    }
  }
  function makeParams(value) {
    const { path, locale: locale2, args, choice, plural } = value;
    const options = {};
    const named = args || {};
    if (isString$2(locale2)) {
      options.locale = locale2;
    }
    if (isNumber$1(choice)) {
      options.plural = choice;
    }
    if (isNumber$1(plural)) {
      options.plural = plural;
    }
    return [path, named, options];
  }
  function apply(app, i18n2, ...options) {
    const pluginOptions = isPlainObject$3(options[0]) ? options[0] : {};
    const globalInstall = isBoolean$1(pluginOptions.globalInstall) ? pluginOptions.globalInstall : true;
    if (globalInstall) {
      [Translation.name, "I18nT"].forEach((name) => app.component(name, Translation));
      [NumberFormat.name, "I18nN"].forEach((name) => app.component(name, NumberFormat));
      [DatetimeFormat.name, "I18nD"].forEach((name) => app.component(name, DatetimeFormat));
    }
    {
      app.directive("t", vTDirective(i18n2));
    }
  }
  const I18nInjectionKey = /* @__PURE__ */ makeSymbol("global-vue-i18n");
  function createI18n(options = {}, VueI18nLegacy) {
    const __legacyMode = __VUE_I18N_LEGACY_API__ && isBoolean$1(options.legacy) ? options.legacy : __VUE_I18N_LEGACY_API__;
    const __globalInjection = isBoolean$1(options.globalInjection) ? options.globalInjection : true;
    const __instances = /* @__PURE__ */ new Map();
    const [globalScope, __global] = createGlobal(options, __legacyMode);
    const symbol = /* @__PURE__ */ makeSymbol("");
    function __getInstance(component) {
      return __instances.get(component) || null;
    }
    function __setInstance(component, instance) {
      __instances.set(component, instance);
    }
    function __deleteInstance(component) {
      __instances.delete(component);
    }
    const i18n2 = {
      // mode
      get mode() {
        return __VUE_I18N_LEGACY_API__ && __legacyMode ? "legacy" : "composition";
      },
      // install plugin
      async install(app, ...options2) {
        app.__VUE_I18N_SYMBOL__ = symbol;
        app.provide(app.__VUE_I18N_SYMBOL__, i18n2);
        if (isPlainObject$3(options2[0])) {
          const opts = options2[0];
          i18n2.__composerExtend = opts.__composerExtend;
          i18n2.__vueI18nExtend = opts.__vueI18nExtend;
        }
        let globalReleaseHandler = null;
        if (!__legacyMode && __globalInjection) {
          globalReleaseHandler = injectGlobalFields(app, i18n2.global);
        }
        if (__VUE_I18N_FULL_INSTALL__) {
          apply(app, i18n2, ...options2);
        }
        if (__VUE_I18N_LEGACY_API__ && __legacyMode) {
          app.mixin(defineMixin(__global, __global.__composer, i18n2));
        }
        const unmountApp = app.unmount;
        app.unmount = () => {
          globalReleaseHandler && globalReleaseHandler();
          i18n2.dispose();
          unmountApp();
        };
      },
      // global accessor
      get global() {
        return __global;
      },
      dispose() {
        globalScope.stop();
      },
      // @internal
      __instances,
      // @internal
      __getInstance,
      // @internal
      __setInstance,
      // @internal
      __deleteInstance
    };
    return i18n2;
  }
  function useI18n(options = {}) {
    const instance = getCurrentInstance();
    if (instance == null) {
      throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);
    }
    if (!instance.isCE && instance.appContext.app != null && !instance.appContext.app.__VUE_I18N_SYMBOL__) {
      throw createI18nError(I18nErrorCodes.NOT_INSTALLED);
    }
    const i18n2 = getI18nInstance(instance);
    const gl = getGlobalComposer(i18n2);
    const componentOptions = getComponentOptions(instance);
    const scope = getScope(options, componentOptions);
    if (scope === "global") {
      adjustI18nResources(gl, options, componentOptions);
      return gl;
    }
    if (scope === "parent") {
      let composer2 = getComposer(i18n2, instance, options.__useComponent);
      if (composer2 == null) {
        composer2 = gl;
      }
      return composer2;
    }
    const i18nInternal = i18n2;
    let composer = i18nInternal.__getInstance(instance);
    if (composer == null) {
      const composerOptions = assign$2({}, options);
      if ("__i18n" in componentOptions) {
        composerOptions.__i18n = componentOptions.__i18n;
      }
      if (gl) {
        composerOptions.__root = gl;
      }
      composer = createComposer(composerOptions);
      if (i18nInternal.__composerExtend) {
        composer[DisposeSymbol] = i18nInternal.__composerExtend(composer);
      }
      setupLifeCycle(i18nInternal, instance, composer);
      i18nInternal.__setInstance(instance, composer);
    }
    return composer;
  }
  function createGlobal(options, legacyMode, VueI18nLegacy) {
    const scope = effectScope();
    const obj = __VUE_I18N_LEGACY_API__ && legacyMode ? scope.run(() => createVueI18n(options)) : scope.run(() => createComposer(options));
    if (obj == null) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    return [scope, obj];
  }
  function getI18nInstance(instance) {
    const i18n2 = inject(!instance.isCE ? instance.appContext.app.__VUE_I18N_SYMBOL__ : I18nInjectionKey);
    if (!i18n2) {
      throw createI18nError(!instance.isCE ? I18nErrorCodes.UNEXPECTED_ERROR : I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE);
    }
    return i18n2;
  }
  function getScope(options, componentOptions) {
    return isEmptyObject(options) ? "__i18n" in componentOptions ? "local" : "global" : !options.useScope ? "local" : options.useScope;
  }
  function getGlobalComposer(i18n2) {
    return i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
  }
  function getComposer(i18n2, target, useComponent = false) {
    let composer = null;
    const root = target.root;
    let current = getParentComponentInstance(target, useComponent);
    while (current != null) {
      const i18nInternal = i18n2;
      if (i18n2.mode === "composition") {
        composer = i18nInternal.__getInstance(current);
      } else {
        if (__VUE_I18N_LEGACY_API__) {
          const vueI18n = i18nInternal.__getInstance(current);
          if (vueI18n != null) {
            composer = vueI18n.__composer;
            if (useComponent && composer && !composer[InejctWithOptionSymbol]) {
              composer = null;
            }
          }
        }
      }
      if (composer != null) {
        break;
      }
      if (root === current) {
        break;
      }
      current = current.parent;
    }
    return composer;
  }
  function getParentComponentInstance(target, useComponent = false) {
    if (target == null) {
      return null;
    }
    return !useComponent ? target.parent : target.vnode.ctx || target.parent;
  }
  function setupLifeCycle(i18n2, target, composer) {
    onMounted(() => {
    }, target);
    onUnmounted(() => {
      const _composer = composer;
      i18n2.__deleteInstance(target);
      const dispose = _composer[DisposeSymbol];
      if (dispose) {
        dispose();
        delete _composer[DisposeSymbol];
      }
    }, target);
  }
  const globalExportProps = [
    "locale",
    "fallbackLocale",
    "availableLocales"
  ];
  const globalExportMethods = ["t", "rt", "d", "n", "tm", "te"];
  function injectGlobalFields(app, composer) {
    const i18n2 = /* @__PURE__ */ Object.create(null);
    globalExportProps.forEach((prop) => {
      const desc = Object.getOwnPropertyDescriptor(composer, prop);
      if (!desc) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const wrap = isRef(desc.value) ? {
        get() {
          return desc.value.value;
        },
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        set(val) {
          desc.value.value = val;
        }
      } : {
        get() {
          return desc.get && desc.get();
        }
      };
      Object.defineProperty(i18n2, prop, wrap);
    });
    app.config.globalProperties.$i18n = i18n2;
    globalExportMethods.forEach((method) => {
      const desc = Object.getOwnPropertyDescriptor(composer, method);
      if (!desc || !desc.value) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      Object.defineProperty(app.config.globalProperties, `$${method}`, desc);
    });
    const dispose = () => {
      delete app.config.globalProperties.$i18n;
      globalExportMethods.forEach((method) => {
        delete app.config.globalProperties[`$${method}`];
      });
    };
    return dispose;
  }
  {
    initFeatureFlags();
  }
  registerMessageCompiler(compile$2);
  registerMessageResolver(resolveValue);
  registerLocaleFallbacker(fallbackWithLocaleChain);
  if (__INTLIFY_PROD_DEVTOOLS__) {
    const target = getGlobalThis$1();
    target.__INTLIFY__ = true;
    setDevToolsHook(target.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
  }
  const web$o = {
    COMMON: {
      button_generate_secret_short: "Generate Password",
      generate_password_disabled: "Generate Password is disabled when the form is valid",
      email_placeholder: "e.g. tom{'@'}myspace.com",
      password_placeholder: "Enter your password",
      custom_domains_title: "Custom Domains",
      custom_domains_description: "Strengthen connections and build trust with your own branded secret links.",
      get_started_button: "Get Started",
      confirm_password_placeholder: "Confirm your password",
      skill_placeholder: "",
      broadcast: "",
      description: "Keep sensitive information out of your chat logs and email. Share a secret link that is available only one time.",
      keywords: "secret,password generator,share a secret,onetime",
      button_create_secret: "Create a secret link",
      button_generate_secret: "Or generate a random password",
      secret_privacy_options: "Privacy Options",
      secret_passphrase: "Passphrase",
      secret_passphrase_hint: "A word or phrase that's difficult to guess",
      secret_recipient_address: "Recipient Address",
      secret_placeholder: "Secret content goes here...",
      header_create_account: "Create Account",
      header_about: "About",
      header_sign_in: "Sign In",
      header_dashboard: "Account",
      header_logout: "Logout",
      secret: "Secret",
      received: "Received",
      burned: "Burned",
      expires_in: "Expires in",
      burn_this_secret: "Burn this secret",
      burn_this_secret_hint: "Burning a secret will delete it before it has been read (click to confirm)",
      burn_this_secret_confirm_hint: "Burning a secret is permanent and cannot be undone",
      msg_check_email: "Check your email",
      click_to_continue: "Click to reveal →",
      click_to_verify: "Continue to verify your account:",
      error_secret: "You did not provide anything to share",
      error_passphrase: "Double check that passphrase",
      enter_passphrase_here: "Enter the passphrase here",
      view_secret: "View Secret",
      careful_only_see_once: "careful: we will only show it once.",
      warning: "Warning",
      oops: "Oops!",
      error: "Error",
      secret_was_truncated: "The message was truncated b/c it was over",
      signup_for_more: "Signup for more",
      login_to_your_account: "Log in to your account",
      sent_to: "Sent to: ",
      field_email: "Email",
      field_password: "Password",
      field_password2: "Confirm Password",
      button_create_account: "Create Account",
      share_a_secret: "Share a secret",
      title_home: "Home",
      title_recent_secrets: "Recent Secrets",
      word_none: "None",
      word_burned: "burned",
      word_received: "received",
      word_confirm: "Confirm",
      word_cancel: "Cancel",
      feedback_text: "Have a question or comment?",
      button_send_feedback: "Send Feedback",
      verification_sent_to: "A verification was sent to"
    },
    homepage: {
      tagline1: "Paste a password, secret message or private link below.",
      tagline2: "Keep sensitive info out of your email and chat logs.",
      secret_hint: "* A secret link only works once and then disappears forever.",
      secret_form_more_text1: "Sign up for a",
      secret_form_more_text2: "free account",
      secret_form_more_text3: "and be able to send the secret by email.",
      cta_title: "Increase trust & share with confidence",
      cta_subtitle: "Elevate your brand and share with confidence",
      cta_feature1: "Unlimited custom domains",
      cta_feature2: "Unlimited secret sharing",
      cta_feature3: "Increase customer trust and engagement",
      explore_premium_plans: "With Custom Domains",
      need_free_account: "Just getting started? Send emails with a free account.",
      sign_up_free: "Free Sign-up"
    },
    "private": {
      pretext: "Share this link:",
      requires_passphrase: "Requires a passphrase.",
      this_msg_is_encrypted: "This message is encrypted with your passphrase.",
      only_see_once: "you will only see this once"
    },
    shared: {
      requires_passphrase: "This message requires a passphrase:",
      viewed_own_secret: "You have viewed your own secret. It is no longer available for anyone else.",
      you_created_this_secret: "You created this secret. If you view it, the recipient will not be able to see it.",
      your_secret_message: "Your secret message:",
      this_message_for_you: "This message is for you:",
      reply_with_secret: "Reply with another secret"
    },
    dashboard: {
      title_received: "Received",
      title_not_received: "Not Received",
      title_no_recent_secrets: "No recent secrets"
    },
    login: {
      need_an_account: "Need an account?",
      forgot_your_password: "Forgot your password?",
      button_sign_in: "Sign In",
      enter_your_credentials: "Enter your credentials",
      remember_me: "Rembember me"
    },
    incoming: {
      tagline1: "Paste a password, secret message or private link below.",
      tagline2: "Keep sensitive info out of your email and chat logs.",
      secret_hint: "* A secret link only works once and then disappears forever.",
      incoming_button_create: "Send to Support Staff",
      incoming_secret_options: "Support Info",
      incoming_secret_placeholder: "Enter any information your support representative will need (e.g. system password)",
      incoming_ticket_number: "Enter Ticket #",
      incoming_ticket_number_hint: "You can find this in your email (e.g. 123456)",
      incoming_recipient_address: "Support recipient",
      incoming_success_message: "Your email has been sent"
    }
  };
  const email$o = {
    incomingsupport: {
      subject: "[Ticket: %s]",
      body1: "A customer has sent the following info"
    },
    secretlink: {
      subject: "%s sent you a secret",
      body1: "We have a secret for you from",
      body_tagline: "If you don't know the sender or believe it to be spam, send us the details here:"
    },
    welcome: {
      subject: "Verify your Onetime Secret account",
      body1: "Welcome to Onetime Secret. We have a secret for you!",
      please_verify: "Please verify your account:",
      postscript1: "This email was sent to",
      postscript2: "If you did not make this request, you can safely ignore this email."
    }
  };
  const en$1 = {
    web: web$o,
    email: email$o
  };
  const en$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: en$1,
    email: email$o,
    web: web$o
  }, Symbol.toStringTag, { value: "Module" }));
  const supportedLocales$1 = window.supported_locales || [];
  const locale = supportedLocales$1[0] || "en";
  const i18n = createI18n({
    //legacy: false,
    locale,
    fallbackLocale: "en",
    messages: {
      en: en$1
    },
    availableLocales: supportedLocales$1
  });
  async function loadLocaleMessages(locale2) {
    console.log(`Attempting to load locale: ${locale2}`);
    try {
      const messages = await __variableDynamicImportRuntimeHelper(/* @__PURE__ */ Object.assign({ "./locales/ar.json": () => __vitePreload(() => Promise.resolve().then(() => ar$1), false ? __VITE_PRELOAD__ : void 0), "./locales/bg.json": () => __vitePreload(() => Promise.resolve().then(() => bg$1), false ? __VITE_PRELOAD__ : void 0), "./locales/ca_ES.json": () => __vitePreload(() => Promise.resolve().then(() => ca_ES$1), false ? __VITE_PRELOAD__ : void 0), "./locales/cn.json": () => __vitePreload(() => Promise.resolve().then(() => cn$1), false ? __VITE_PRELOAD__ : void 0), "./locales/cs.json": () => __vitePreload(() => Promise.resolve().then(() => cs$1), false ? __VITE_PRELOAD__ : void 0), "./locales/da_DK.json": () => __vitePreload(() => Promise.resolve().then(() => da_DK$1), false ? __VITE_PRELOAD__ : void 0), "./locales/de.json": () => __vitePreload(() => Promise.resolve().then(() => de$1), false ? __VITE_PRELOAD__ : void 0), "./locales/el_GR.json": () => __vitePreload(() => Promise.resolve().then(() => el_GR$1), false ? __VITE_PRELOAD__ : void 0), "./locales/en.json": () => __vitePreload(() => Promise.resolve().then(() => en$2), false ? __VITE_PRELOAD__ : void 0), "./locales/es.json": () => __vitePreload(() => Promise.resolve().then(() => es$1), false ? __VITE_PRELOAD__ : void 0), "./locales/fr.json": () => __vitePreload(() => Promise.resolve().then(() => fr$1), false ? __VITE_PRELOAD__ : void 0), "./locales/fr_FR.json": () => __vitePreload(() => Promise.resolve().then(() => fr_FR$1), false ? __VITE_PRELOAD__ : void 0), "./locales/he.json": () => __vitePreload(() => Promise.resolve().then(() => he$2), false ? __VITE_PRELOAD__ : void 0), "./locales/hu.json": () => __vitePreload(() => Promise.resolve().then(() => hu$1), false ? __VITE_PRELOAD__ : void 0), "./locales/it_IT.json": () => __vitePreload(() => Promise.resolve().then(() => it_IT$1), false ? __VITE_PRELOAD__ : void 0), "./locales/nl.json": () => __vitePreload(() => Promise.resolve().then(() => nl$1), false ? __VITE_PRELOAD__ : void 0), "./locales/pl.json": () => __vitePreload(() => Promise.resolve().then(() => pl$1), false ? __VITE_PRELOAD__ : void 0), "./locales/pt_BR.json": () => __vitePreload(() => Promise.resolve().then(() => pt_BR$1), false ? __VITE_PRELOAD__ : void 0), "./locales/pt_PT.json": () => __vitePreload(() => Promise.resolve().then(() => pt_PT$1), false ? __VITE_PRELOAD__ : void 0), "./locales/ru.json": () => __vitePreload(() => Promise.resolve().then(() => ru$1), false ? __VITE_PRELOAD__ : void 0), "./locales/sl_SI.json": () => __vitePreload(() => Promise.resolve().then(() => sl_SI$1), false ? __VITE_PRELOAD__ : void 0), "./locales/sv_SE.json": () => __vitePreload(() => Promise.resolve().then(() => sv_SE$1), false ? __VITE_PRELOAD__ : void 0), "./locales/tr.json": () => __vitePreload(() => Promise.resolve().then(() => tr$1), false ? __VITE_PRELOAD__ : void 0), "./locales/uk.json": () => __vitePreload(() => Promise.resolve().then(() => uk$1), false ? __VITE_PRELOAD__ : void 0), "./locales/vi.json": () => __vitePreload(() => Promise.resolve().then(() => vi$1), false ? __VITE_PRELOAD__ : void 0) }), `./locales/${locale2}.json`, 3);
      console.log(`Successfully loaded locale: ${locale2}`);
      return messages.default;
    } catch (error) {
      console.error(`Failed to load locale: ${locale2}`, error);
      return null;
    }
  }
  async function setLanguage(lang) {
    if (i18n.global.locale === lang) {
      console.log(`Language is already set to ${lang}. No change needed.`);
      return;
    }
    console.log(`Setting language to: ${lang}`);
    if (lang === "en") {
      i18n.global.locale = "en";
      console.log(`Language set to: ${lang}`);
      return;
    }
    const messages = await loadLocaleMessages(lang);
    if (messages) {
      i18n.global.setLocaleMessage(lang, messages);
      i18n.global.locale = lang;
      console.log(`Language set to: ${lang}`);
    } else {
      console.log(`Failed to set language to: ${lang}. Falling back to default.`);
    }
  }
  var Ft = Object.defineProperty;
  var Dt = (n2, e2, t2) => e2 in n2 ? Ft(n2, e2, { enumerable: true, configurable: true, writable: true, value: t2 }) : n2[e2] = t2;
  var U = (n2, e2, t2) => Dt(n2, typeof e2 != "symbol" ? e2 + "" : e2, t2);
  const ht = "KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2NvbnN0IGY9bmV3IFRleHRFbmNvZGVyO2Z1bmN0aW9uIHAoZSl7cmV0dXJuWy4uLm5ldyBVaW50OEFycmF5KGUpXS5tYXAodD0+dC50b1N0cmluZygxNikucGFkU3RhcnQoMiwiMCIpKS5qb2luKCIiKX1hc3luYyBmdW5jdGlvbiB3KGUsdCxyKXtyZXR1cm4gcChhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdChyLnRvVXBwZXJDYXNlKCksZi5lbmNvZGUoZSt0KSkpfWZ1bmN0aW9uIGIoZSx0LHI9IlNIQS0yNTYiLG49MWU2LHM9MCl7Y29uc3Qgbz1uZXcgQWJvcnRDb250cm9sbGVyLGE9RGF0ZS5ub3coKTtyZXR1cm57cHJvbWlzZTooYXN5bmMoKT0+e2ZvcihsZXQgYz1zO2M8PW47Yys9MSl7aWYoby5zaWduYWwuYWJvcnRlZClyZXR1cm4gbnVsbDtpZihhd2FpdCB3KHQsYyxyKT09PWUpcmV0dXJue251bWJlcjpjLHRvb2s6RGF0ZS5ub3coKS1hfX1yZXR1cm4gbnVsbH0pKCksY29udHJvbGxlcjpvfX1mdW5jdGlvbiBoKGUpe2NvbnN0IHQ9YXRvYihlKSxyPW5ldyBVaW50OEFycmF5KHQubGVuZ3RoKTtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKylyW25dPXQuY2hhckNvZGVBdChuKTtyZXR1cm4gcn1mdW5jdGlvbiBnKGUsdD0xMil7Y29uc3Qgcj1uZXcgVWludDhBcnJheSh0KTtmb3IobGV0IG49MDtuPHQ7bisrKXJbbl09ZSUyNTYsZT1NYXRoLmZsb29yKGUvMjU2KTtyZXR1cm4gcn1hc3luYyBmdW5jdGlvbiBtKGUsdD0iIixyPTFlNixuPTApe2NvbnN0IHM9IkFFUy1HQ00iLG89bmV3IEFib3J0Q29udHJvbGxlcixhPURhdGUubm93KCksbD1hc3luYygpPT57Zm9yKGxldCB1PW47dTw9cjt1Kz0xKXtpZihvLnNpZ25hbC5hYm9ydGVkfHwhY3x8IXkpcmV0dXJuIG51bGw7dHJ5e2NvbnN0IGQ9YXdhaXQgY3J5cHRvLnN1YnRsZS5kZWNyeXB0KHtuYW1lOnMsaXY6Zyh1KX0sYyx5KTtpZihkKXJldHVybntjbGVhclRleHQ6bmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGQpLHRvb2s6RGF0ZS5ub3coKS1hfX1jYXRjaHt9fXJldHVybiBudWxsfTtsZXQgYz1udWxsLHk9bnVsbDt0cnl7eT1oKGUpO2NvbnN0IHU9YXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoIlNIQS0yNTYiLGYuZW5jb2RlKHQpKTtjPWF3YWl0IGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KCJyYXciLHUscywhMSxbImRlY3J5cHQiXSl9Y2F0Y2h7cmV0dXJue3Byb21pc2U6UHJvbWlzZS5yZWplY3QoKSxjb250cm9sbGVyOm99fXJldHVybntwcm9taXNlOmwoKSxjb250cm9sbGVyOm99fWxldCBpO29ubWVzc2FnZT1hc3luYyBlPT57Y29uc3R7dHlwZTp0LHBheWxvYWQ6cixzdGFydDpuLG1heDpzfT1lLmRhdGE7bGV0IG89bnVsbDtpZih0PT09ImFib3J0IilpPT1udWxsfHxpLmFib3J0KCksaT12b2lkIDA7ZWxzZSBpZih0PT09IndvcmsiKXtpZigib2JmdXNjYXRlZCJpbiByKXtjb25zdHtrZXk6YSxvYmZ1c2NhdGVkOmx9PXJ8fHt9O289YXdhaXQgbShsLGEscyxuKX1lbHNle2NvbnN0e2FsZ29yaXRobTphLGNoYWxsZW5nZTpsLHNhbHQ6Y309cnx8e307bz1iKGwsYyxhLHMsbil9aT1vLmNvbnRyb2xsZXIsby5wcm9taXNlLnRoZW4oYT0+e3NlbGYucG9zdE1lc3NhZ2UoYSYmey4uLmEsd29ya2VyOiEwfSl9KX19fSkoKTsK", jt = (n2) => Uint8Array.from(atob(n2), (e2) => e2.charCodeAt(0)), nt = typeof self < "u" && self.Blob && new Blob([jt(ht)], { type: "text/javascript;charset=utf-8" });
  function Pt(n2) {
    let e2;
    try {
      if (e2 = nt && (self.URL || self.webkitURL).createObjectURL(nt), !e2) throw "";
      const t2 = new Worker(e2, {
        name: n2 == null ? void 0 : n2.name
      });
      return t2.addEventListener("error", () => {
        (self.URL || self.webkitURL).revokeObjectURL(e2);
      }), t2;
    } catch {
      return new Worker(
        "data:text/javascript;base64," + ht,
        {
          name: n2 == null ? void 0 : n2.name
        }
      );
    } finally {
      e2 && (self.URL || self.webkitURL).revokeObjectURL(e2);
    }
  }
  function Re() {
  }
  function Wt(n2, e2) {
    for (const t2 in e2) n2[t2] = e2[t2];
    return (
      /** @type {T & S} */
      n2
    );
  }
  function gt(n2) {
    return n2();
  }
  function rt() {
    return /* @__PURE__ */ Object.create(null);
  }
  function we(n2) {
    n2.forEach(gt);
  }
  function mt(n2) {
    return typeof n2 == "function";
  }
  function Ut(n2, e2) {
    return n2 != n2 ? e2 == e2 : n2 !== e2 || n2 && typeof n2 == "object" || typeof n2 == "function";
  }
  function Kt(n2) {
    return Object.keys(n2).length === 0;
  }
  function Mt(n2, e2, t2, i2) {
    if (n2) {
      const o2 = bt(n2, e2, t2, i2);
      return n2[0](o2);
    }
  }
  function bt(n2, e2, t2, i2) {
    return n2[1] && i2 ? Wt(t2.ctx.slice(), n2[1](i2(e2))) : t2.ctx;
  }
  function Bt(n2, e2, t2, i2) {
    if (n2[2] && i2) {
      const o2 = n2[2](i2(t2));
      if (e2.dirty === void 0)
        return o2;
      if (typeof o2 == "object") {
        const l2 = [], s2 = Math.max(e2.dirty.length, o2.length);
        for (let d2 = 0; d2 < s2; d2 += 1)
          l2[d2] = e2.dirty[d2] | o2[d2];
        return l2;
      }
      return e2.dirty | o2;
    }
    return e2.dirty;
  }
  function Ot(n2, e2, t2, i2, o2, l2) {
    if (o2) {
      const s2 = bt(e2, t2, i2, l2);
      n2.p(s2, o2);
    }
  }
  function Jt(n2) {
    if (n2.ctx.length > 32) {
      const e2 = [], t2 = n2.ctx.length / 32;
      for (let i2 = 0; i2 < t2; i2++)
        e2[i2] = -1;
      return e2;
    }
    return -1;
  }
  function L(n2, e2) {
    n2.appendChild(e2);
  }
  function Qt(n2, e2, t2) {
    const i2 = $t(n2);
    if (!i2.getElementById(e2)) {
      const o2 = Z$1("style");
      o2.id = e2, o2.textContent = t2, qt(i2, o2);
    }
  }
  function $t(n2) {
    if (!n2) return document;
    const e2 = n2.getRootNode ? n2.getRootNode() : n2.ownerDocument;
    return e2 && /** @type {ShadowRoot} */
    e2.host ? (
      /** @type {ShadowRoot} */
      e2
    ) : n2.ownerDocument;
  }
  function qt(n2, e2) {
    return L(
      /** @type {Document} */
      n2.head || n2,
      e2
    ), e2.sheet;
  }
  function X(n2, e2, t2) {
    n2.insertBefore(e2, t2 || null);
  }
  function Y(n2) {
    n2.parentNode && n2.parentNode.removeChild(n2);
  }
  function Z$1(n2) {
    return document.createElement(n2);
  }
  function $(n2) {
    return document.createElementNS("http://www.w3.org/2000/svg", n2);
  }
  function en(n2) {
    return document.createTextNode(n2);
  }
  function Q() {
    return en(" ");
  }
  function Le(n2, e2, t2, i2) {
    return n2.addEventListener(e2, t2, i2), () => n2.removeEventListener(e2, t2, i2);
  }
  function a$2(n2, e2, t2) {
    t2 == null ? n2.removeAttribute(e2) : n2.getAttribute(e2) !== t2 && n2.setAttribute(e2, t2);
  }
  function tn(n2) {
    return Array.from(n2.childNodes);
  }
  function it(n2, e2, t2) {
    n2.classList.toggle(e2, !!t2);
  }
  function nn(n2, e2, { bubbles: t2 = false, cancelable: i2 = false } = {}) {
    return new CustomEvent(n2, { detail: e2, bubbles: t2, cancelable: i2 });
  }
  function rn(n2) {
    const e2 = {};
    return n2.childNodes.forEach(
      /** @param {Element} node */
      (t2) => {
        e2[t2.slot || "default"] = true;
      }
    ), e2;
  }
  let pe;
  function ve(n2) {
    pe = n2;
  }
  function Ae() {
    if (!pe) throw new Error("Function called outside component initialization");
    return pe;
  }
  function on(n2) {
    Ae().$$.on_mount.push(n2);
  }
  function ln(n2) {
    Ae().$$.on_destroy.push(n2);
  }
  function sn() {
    const n2 = Ae();
    return (e2, t2, { cancelable: i2 = false } = {}) => {
      const o2 = n2.$$.callbacks[e2];
      if (o2) {
        const l2 = nn(
          /** @type {string} */
          e2,
          t2,
          { cancelable: i2 }
        );
        return o2.slice().forEach((s2) => {
          s2.call(n2, l2);
        }), !l2.defaultPrevented;
      }
      return true;
    };
  }
  const ae = [], Ce = [];
  let fe = [];
  const ot = [], yt = /* @__PURE__ */ Promise.resolve();
  let ze = false;
  function vt() {
    ze || (ze = true, yt.then(w$3));
  }
  function cn$2() {
    return vt(), yt;
  }
  function Se$1(n2) {
    fe.push(n2);
  }
  const Ne = /* @__PURE__ */ new Set();
  let ce = 0;
  function w$3() {
    if (ce !== 0)
      return;
    const n2 = pe;
    do {
      try {
        for (; ce < ae.length; ) {
          const e2 = ae[ce];
          ce++, ve(e2), an(e2.$$);
        }
      } catch (e2) {
        throw ae.length = 0, ce = 0, e2;
      }
      for (ve(null), ae.length = 0, ce = 0; Ce.length; ) Ce.pop()();
      for (let e2 = 0; e2 < fe.length; e2 += 1) {
        const t2 = fe[e2];
        Ne.has(t2) || (Ne.add(t2), t2());
      }
      fe.length = 0;
    } while (ae.length);
    for (; ot.length; )
      ot.pop()();
    ze = false, Ne.clear(), ve(n2);
  }
  function an(n2) {
    if (n2.fragment !== null) {
      n2.update(), we(n2.before_update);
      const e2 = n2.dirty;
      n2.dirty = [-1], n2.fragment && n2.fragment.p(n2.ctx, e2), n2.after_update.forEach(Se$1);
    }
  }
  function fn(n2) {
    const e2 = [], t2 = [];
    fe.forEach((i2) => n2.indexOf(i2) === -1 ? e2.push(i2) : t2.push(i2)), t2.forEach((i2) => i2()), fe = e2;
  }
  const xe = /* @__PURE__ */ new Set();
  let un;
  function pt(n2, e2) {
    n2 && n2.i && (xe.delete(n2), n2.i(e2));
  }
  function dn(n2, e2, t2, i2) {
    if (n2 && n2.o) {
      if (xe.has(n2)) return;
      xe.add(n2), un.c.push(() => {
        xe.delete(n2);
      }), n2.o(e2);
    }
  }
  function hn(n2, e2, t2) {
    const { fragment: i2, after_update: o2 } = n2.$$;
    i2 && i2.m(e2, t2), Se$1(() => {
      const l2 = n2.$$.on_mount.map(gt).filter(mt);
      n2.$$.on_destroy ? n2.$$.on_destroy.push(...l2) : we(l2), n2.$$.on_mount = [];
    }), o2.forEach(Se$1);
  }
  function gn(n2, e2) {
    const t2 = n2.$$;
    t2.fragment !== null && (fn(t2.after_update), we(t2.on_destroy), t2.fragment && t2.fragment.d(e2), t2.on_destroy = t2.fragment = null, t2.ctx = []);
  }
  function mn(n2, e2) {
    n2.$$.dirty[0] === -1 && (ae.push(n2), vt(), n2.$$.dirty.fill(0)), n2.$$.dirty[e2 / 31 | 0] |= 1 << e2 % 31;
  }
  function bn(n2, e2, t2, i2, o2, l2, s2 = null, d2 = [-1]) {
    const h2 = pe;
    ve(n2);
    const f2 = n2.$$ = {
      fragment: null,
      ctx: [],
      // state
      props: l2,
      update: Re,
      not_equal: o2,
      bound: rt(),
      // lifecycle
      on_mount: [],
      on_destroy: [],
      on_disconnect: [],
      before_update: [],
      after_update: [],
      context: new Map(e2.context || (h2 ? h2.$$.context : [])),
      // everything else
      callbacks: rt(),
      dirty: d2,
      skip_bound: false,
      root: e2.target || h2.$$.root
    };
    s2 && s2(f2.root);
    let C = false;
    if (f2.ctx = t2 ? t2(n2, e2.props || {}, (b2, M, ...D) => {
      const j2 = D.length ? D[0] : M;
      return f2.ctx && o2(f2.ctx[b2], f2.ctx[b2] = j2) && (!f2.skip_bound && f2.bound[b2] && f2.bound[b2](j2), C && mn(n2, b2)), M;
    }) : [], f2.update(), C = true, we(f2.before_update), f2.fragment = i2 ? i2(f2.ctx) : false, e2.target) {
      if (e2.hydrate) {
        const b2 = tn(e2.target);
        f2.fragment && f2.fragment.l(b2), b2.forEach(Y);
      } else
        f2.fragment && f2.fragment.c();
      e2.intro && pt(n2.$$.fragment), hn(n2, e2.target, e2.anchor), w$3();
    }
    ve(h2);
  }
  let wt;
  typeof HTMLElement == "function" && (wt = class extends HTMLElement {
    constructor(e2, t2, i2) {
      super();
      U(this, "$$ctor");
      U(this, "$$s");
      U(this, "$$c");
      U(this, "$$cn", false);
      U(this, "$$d", {});
      U(this, "$$r", false);
      U(this, "$$p_d", {});
      U(this, "$$l", {});
      U(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = e2, this.$$s = t2, i2 && this.attachShadow({ mode: "open" });
    }
    addEventListener(e2, t2, i2) {
      if (this.$$l[e2] = this.$$l[e2] || [], this.$$l[e2].push(t2), this.$$c) {
        const o2 = this.$$c.$on(e2, t2);
        this.$$l_u.set(t2, o2);
      }
      super.addEventListener(e2, t2, i2);
    }
    removeEventListener(e2, t2, i2) {
      if (super.removeEventListener(e2, t2, i2), this.$$c) {
        const o2 = this.$$l_u.get(t2);
        o2 && (o2(), this.$$l_u.delete(t2));
      }
    }
    async connectedCallback() {
      if (this.$$cn = true, !this.$$c) {
        let e2 = function(l2) {
          return () => {
            let s2;
            return {
              c: function() {
                s2 = Z$1("slot"), l2 !== "default" && a$2(s2, "name", l2);
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function(f2, C) {
                X(f2, s2, C);
              },
              d: function(f2) {
                f2 && Y(s2);
              }
            };
          };
        };
        if (await Promise.resolve(), !this.$$cn || this.$$c)
          return;
        const t2 = {}, i2 = rn(this);
        for (const l2 of this.$$s)
          l2 in i2 && (t2[l2] = [e2(l2)]);
        for (const l2 of this.attributes) {
          const s2 = this.$$g_p(l2.name);
          s2 in this.$$d || (this.$$d[s2] = Ee(s2, l2.value, this.$$p_d, "toProp"));
        }
        for (const l2 in this.$$p_d)
          !(l2 in this.$$d) && this[l2] !== void 0 && (this.$$d[l2] = this[l2], delete this[l2]);
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots: t2,
            $$scope: {
              ctx: []
            }
          }
        });
        const o2 = () => {
          this.$$r = true;
          for (const l2 in this.$$p_d)
            if (this.$$d[l2] = this.$$c.$$.ctx[this.$$c.$$.props[l2]], this.$$p_d[l2].reflect) {
              const s2 = Ee(
                l2,
                this.$$d[l2],
                this.$$p_d,
                "toAttribute"
              );
              s2 == null ? this.removeAttribute(this.$$p_d[l2].attribute || l2) : this.setAttribute(this.$$p_d[l2].attribute || l2, s2);
            }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(o2), o2();
        for (const l2 in this.$$l)
          for (const s2 of this.$$l[l2]) {
            const d2 = this.$$c.$on(l2, s2);
            this.$$l_u.set(s2, d2);
          }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(e2, t2, i2) {
      var o2;
      this.$$r || (e2 = this.$$g_p(e2), this.$$d[e2] = Ee(e2, i2, this.$$p_d, "toProp"), (o2 = this.$$c) == null || o2.$set({ [e2]: this.$$d[e2] }));
    }
    disconnectedCallback() {
      this.$$cn = false, Promise.resolve().then(() => {
        !this.$$cn && this.$$c && (this.$$c.$destroy(), this.$$c = void 0);
      });
    }
    $$g_p(e2) {
      return Object.keys(this.$$p_d).find(
        (t2) => this.$$p_d[t2].attribute === e2 || !this.$$p_d[t2].attribute && t2.toLowerCase() === e2
      ) || e2;
    }
  });
  function Ee(n2, e2, t2, i2) {
    var l2;
    const o2 = (l2 = t2[n2]) == null ? void 0 : l2.type;
    if (e2 = o2 === "Boolean" && typeof e2 != "boolean" ? e2 != null : e2, !i2 || !t2[n2])
      return e2;
    if (i2 === "toAttribute")
      switch (o2) {
        case "Object":
        case "Array":
          return e2 == null ? null : JSON.stringify(e2);
        case "Boolean":
          return e2 ? "" : null;
        case "Number":
          return e2 ?? null;
        default:
          return e2;
      }
    else
      switch (o2) {
        case "Object":
        case "Array":
          return e2 && JSON.parse(e2);
        case "Boolean":
          return e2;
        case "Number":
          return e2 != null ? +e2 : e2;
        default:
          return e2;
      }
  }
  function yn(n2, e2, t2, i2, o2, l2) {
    let s2 = class extends wt {
      constructor() {
        super(n2, t2, o2), this.$$p_d = e2;
      }
      static get observedAttributes() {
        return Object.keys(e2).map(
          (d2) => (e2[d2].attribute || d2).toLowerCase()
        );
      }
    };
    return Object.keys(e2).forEach((d2) => {
      Object.defineProperty(s2.prototype, d2, {
        get() {
          return this.$$c && d2 in this.$$c ? this.$$c[d2] : this.$$d[d2];
        },
        set(h2) {
          var f2;
          h2 = Ee(d2, h2, e2), this.$$d[d2] = h2, (f2 = this.$$c) == null || f2.$set({ [d2]: h2 });
        }
      });
    }), i2.forEach((d2) => {
      Object.defineProperty(s2.prototype, d2, {
        get() {
          var h2;
          return (h2 = this.$$c) == null ? void 0 : h2[d2];
        }
      });
    }), n2.element = /** @type {any} */
    s2, s2;
  }
  class vn {
    constructor() {
      U(this, "$$");
      U(this, "$$set");
    }
    /** @returns {void} */
    $destroy() {
      gn(this, 1), this.$destroy = Re;
    }
    /**
     * @template {Extract<keyof Events, string>} K
     * @param {K} type
     * @param {((e: Events[K]) => void) | null | undefined} callback
     * @returns {() => void}
     */
    $on(e2, t2) {
      if (!mt(t2))
        return Re;
      const i2 = this.$$.callbacks[e2] || (this.$$.callbacks[e2] = []);
      return i2.push(t2), () => {
        const o2 = i2.indexOf(t2);
        o2 !== -1 && i2.splice(o2, 1);
      };
    }
    /**
     * @param {Partial<Props>} props
     * @returns {void}
     */
    $set(e2) {
      this.$$set && !Kt(e2) && (this.$$.skip_bound = true, this.$$set(e2), this.$$.skip_bound = false);
    }
  }
  const pn = "4";
  typeof window < "u" && (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(pn);
  const _t = new TextEncoder();
  function wn(n2) {
    return [...new Uint8Array(n2)].map((e2) => e2.toString(16).padStart(2, "0")).join("");
  }
  async function _n(n2, e2 = "SHA-256", t2 = 1e5) {
    const i2 = Date.now().toString(16);
    n2 || (n2 = Math.round(Math.random() * t2));
    const o2 = await kt(i2, n2, e2);
    return {
      algorithm: e2,
      challenge: o2,
      salt: i2,
      signature: ""
    };
  }
  async function kt(n2, e2, t2) {
    return wn(
      await crypto.subtle.digest(
        t2.toUpperCase(),
        _t.encode(n2 + e2)
      )
    );
  }
  function kn(n2, e2, t2 = "SHA-256", i2 = 1e6, o2 = 0) {
    const l2 = new AbortController(), s2 = Date.now();
    return {
      promise: (async () => {
        for (let h2 = o2; h2 <= i2; h2 += 1) {
          if (l2.signal.aborted)
            return null;
          if (await kt(e2, h2, t2) === n2)
            return {
              number: h2,
              took: Date.now() - s2
            };
        }
        return null;
      })(),
      controller: l2
    };
  }
  function xn() {
    try {
      return Intl.DateTimeFormat().resolvedOptions().timeZone;
    } catch {
    }
  }
  function En(n2) {
    const e2 = atob(n2), t2 = new Uint8Array(e2.length);
    for (let i2 = 0; i2 < e2.length; i2++)
      t2[i2] = e2.charCodeAt(i2);
    return t2;
  }
  function Rn(n2, e2 = 12) {
    const t2 = new Uint8Array(e2);
    for (let i2 = 0; i2 < e2; i2++)
      t2[i2] = n2 % 256, n2 = Math.floor(n2 / 256);
    return t2;
  }
  async function Cn(n2, e2 = "", t2 = 1e6, i2 = 0) {
    const o2 = "AES-GCM", l2 = new AbortController(), s2 = Date.now(), d2 = async () => {
      for (let C = i2; C <= t2; C += 1) {
        if (l2.signal.aborted || !h2 || !f2)
          return null;
        try {
          const b2 = await crypto.subtle.decrypt(
            {
              name: o2,
              iv: Rn(C)
            },
            h2,
            f2
          );
          if (b2)
            return {
              clearText: new TextDecoder().decode(b2),
              took: Date.now() - s2
            };
        } catch {
        }
      }
      return null;
    };
    let h2 = null, f2 = null;
    try {
      f2 = En(n2);
      const C = await crypto.subtle.digest(
        "SHA-256",
        _t.encode(e2)
      );
      h2 = await crypto.subtle.importKey(
        "raw",
        C,
        o2,
        false,
        ["decrypt"]
      );
    } catch {
      return {
        promise: Promise.reject(),
        controller: l2
      };
    }
    return {
      promise: d2(),
      controller: l2
    };
  }
  var m = /* @__PURE__ */ ((n2) => (n2.ERROR = "error", n2.VERIFIED = "verified", n2.VERIFYING = "verifying", n2.UNVERIFIED = "unverified", n2.EXPIRED = "expired", n2))(m || {});
  function In(n2) {
    Qt(n2, "svelte-ddsc3z", '.altcha.svelte-ddsc3z.svelte-ddsc3z{background:var(--altcha-color-base, transparent);border:var(--altcha-border-width, 1px) solid var(--altcha-color-border, #a0a0a0);border-radius:var(--altcha-border-radius, 3px);color:var(--altcha-color-text, currentColor);display:flex;flex-direction:column;max-width:var(--altcha-max-width, 260px);position:relative;text-align:left}.altcha.svelte-ddsc3z.svelte-ddsc3z:focus-within{border-color:var(--altcha-color-border-focus, currentColor)}.altcha[data-floating].svelte-ddsc3z.svelte-ddsc3z{background:var(--altcha-color-base, white);display:none;filter:drop-shadow(3px 3px 6px rgba(0, 0, 0, 0.2));left:-100%;position:fixed;top:-100%;width:var(--altcha-max-width, 260px);z-index:999999}.altcha[data-floating=top].svelte-ddsc3z .altcha-anchor-arrow.svelte-ddsc3z{border-bottom-color:transparent;border-top-color:var(--altcha-color-border, #a0a0a0);bottom:-12px;top:auto}.altcha[data-floating=bottom].svelte-ddsc3z.svelte-ddsc3z:focus-within::after{border-bottom-color:var(--altcha-color-border-focus, currentColor)}.altcha[data-floating=top].svelte-ddsc3z.svelte-ddsc3z:focus-within::after{border-top-color:var(--altcha-color-border-focus, currentColor)}.altcha[data-floating].svelte-ddsc3z.svelte-ddsc3z:not([data-state=unverified]){display:block}.altcha-anchor-arrow.svelte-ddsc3z.svelte-ddsc3z{border:6px solid transparent;border-bottom-color:var(--altcha-color-border, #a0a0a0);content:"";height:0;left:12px;position:absolute;top:-12px;width:0}.altcha-main.svelte-ddsc3z.svelte-ddsc3z{align-items:center;display:flex;gap:0.4rem;padding:0.7rem}.altcha-label.svelte-ddsc3z.svelte-ddsc3z{flex-grow:1}.altcha-label.svelte-ddsc3z label.svelte-ddsc3z{cursor:pointer}.altcha-logo.svelte-ddsc3z.svelte-ddsc3z{color:currentColor;opacity:0.3}.altcha-logo.svelte-ddsc3z.svelte-ddsc3z:hover{opacity:1}.altcha-error.svelte-ddsc3z.svelte-ddsc3z{color:var(--altcha-color-error-text, #f23939);display:flex;font-size:0.85rem;gap:0.3rem;padding:0 0.7rem 0.7rem}.altcha-footer.svelte-ddsc3z.svelte-ddsc3z{align-items:center;background-color:var(--altcha-color-footer-bg, transparent);display:flex;font-size:0.75rem;opacity:0.4;padding:0.2rem 0.7rem;text-align:right}.altcha-footer.svelte-ddsc3z.svelte-ddsc3z:hover{opacity:1}.altcha-footer.svelte-ddsc3z>.svelte-ddsc3z:first-child{flex-grow:1}.altcha-footer.svelte-ddsc3z a{color:currentColor}.altcha-checkbox.svelte-ddsc3z.svelte-ddsc3z{display:flex;align-items:center;height:24px;width:24px}.altcha-checkbox.svelte-ddsc3z input.svelte-ddsc3z{width:18px;height:18px;margin:0}.altcha-hidden.svelte-ddsc3z.svelte-ddsc3z{display:none}.altcha-spinner.svelte-ddsc3z.svelte-ddsc3z{animation:svelte-ddsc3z-altcha-spinner 0.75s infinite linear;transform-origin:center}@keyframes svelte-ddsc3z-altcha-spinner{100%{transform:rotate(360deg)}}');
  }
  function lt(n2) {
    let e2, t2, i2;
    return {
      c() {
        e2 = $("svg"), t2 = $("path"), i2 = $("path"), a$2(t2, "d", "M12,1A11,11,0,1,0,23,12,11,11,0,0,0,12,1Zm0,19a8,8,0,1,1,8-8A8,8,0,0,1,12,20Z"), a$2(t2, "fill", "currentColor"), a$2(t2, "opacity", ".25"), a$2(i2, "d", "M12,4a8,8,0,0,1,7.89,6.7A1.53,1.53,0,0,0,21.38,12h0a1.5,1.5,0,0,0,1.48-1.75,11,11,0,0,0-21.72,0A1.5,1.5,0,0,0,2.62,12h0a1.53,1.53,0,0,0,1.49-1.3A8,8,0,0,1,12,4Z"), a$2(i2, "fill", "currentColor"), a$2(i2, "class", "altcha-spinner svelte-ddsc3z"), a$2(e2, "width", "24"), a$2(e2, "height", "24"), a$2(e2, "viewBox", "0 0 24 24"), a$2(e2, "xmlns", "http://www.w3.org/2000/svg");
      },
      m(o2, l2) {
        X(o2, e2, l2), L(e2, t2), L(e2, i2);
      },
      d(o2) {
        o2 && Y(e2);
      }
    };
  }
  function Ln(n2) {
    let e2, t2 = (
      /*_strings*/
      n2[11].label + ""
    ), i2;
    return {
      c() {
        e2 = Z$1("label"), a$2(e2, "for", i2 = /*name*/
        n2[4] + "_checkbox"), a$2(e2, "class", "svelte-ddsc3z");
      },
      m(o2, l2) {
        X(o2, e2, l2), e2.innerHTML = t2;
      },
      p(o2, l2) {
        l2[0] & /*_strings*/
        2048 && t2 !== (t2 = /*_strings*/
        o2[11].label + "") && (e2.innerHTML = t2), l2[0] & /*name*/
        16 && i2 !== (i2 = /*name*/
        o2[4] + "_checkbox") && a$2(e2, "for", i2);
      },
      d(o2) {
        o2 && Y(e2);
      }
    };
  }
  function Nn(n2) {
    let e2, t2 = (
      /*_strings*/
      n2[11].verifying + ""
    );
    return {
      c() {
        e2 = Z$1("span");
      },
      m(i2, o2) {
        X(i2, e2, o2), e2.innerHTML = t2;
      },
      p(i2, o2) {
        o2[0] & /*_strings*/
        2048 && t2 !== (t2 = /*_strings*/
        i2[11].verifying + "") && (e2.innerHTML = t2);
      },
      d(i2) {
        i2 && Y(e2);
      }
    };
  }
  function zn(n2) {
    let e2, t2 = (
      /*_strings*/
      n2[11].verified + ""
    ), i2, o2;
    return {
      c() {
        e2 = Z$1("span"), i2 = Q(), o2 = Z$1("input"), a$2(o2, "type", "hidden"), a$2(
          o2,
          "name",
          /*name*/
          n2[4]
        ), o2.value = /*payload*/
        n2[6];
      },
      m(l2, s2) {
        X(l2, e2, s2), e2.innerHTML = t2, X(l2, i2, s2), X(l2, o2, s2);
      },
      p(l2, s2) {
        s2[0] & /*_strings*/
        2048 && t2 !== (t2 = /*_strings*/
        l2[11].verified + "") && (e2.innerHTML = t2), s2[0] & /*name*/
        16 && a$2(
          o2,
          "name",
          /*name*/
          l2[4]
        ), s2[0] & /*payload*/
        64 && (o2.value = /*payload*/
        l2[6]);
      },
      d(l2) {
        l2 && (Y(e2), Y(i2), Y(o2));
      }
    };
  }
  function st(n2) {
    let e2, t2, i2, o2, l2, s2, d2;
    return {
      c() {
        e2 = Z$1("div"), t2 = Z$1("a"), i2 = $("svg"), o2 = $("path"), l2 = $("path"), s2 = $("path"), a$2(o2, "d", "M2.33955 16.4279C5.88954 20.6586 12.1971 21.2105 16.4279 17.6604C18.4699 15.947 19.6548 13.5911 19.9352 11.1365L17.9886 10.4279C17.8738 12.5624 16.909 14.6459 15.1423 16.1284C11.7577 18.9684 6.71167 18.5269 3.87164 15.1423C1.03163 11.7577 1.4731 6.71166 4.8577 3.87164C8.24231 1.03162 13.2883 1.4731 16.1284 4.8577C16.9767 5.86872 17.5322 7.02798 17.804 8.2324L19.9522 9.01429C19.7622 7.07737 19.0059 5.17558 17.6604 3.57212C14.1104 -0.658624 7.80283 -1.21043 3.57212 2.33956C-0.658625 5.88958 -1.21046 12.1971 2.33955 16.4279Z"), a$2(o2, "fill", "currentColor"), a$2(l2, "d", "M3.57212 2.33956C1.65755 3.94607 0.496389 6.11731 0.12782 8.40523L2.04639 9.13961C2.26047 7.15832 3.21057 5.25375 4.8577 3.87164C8.24231 1.03162 13.2883 1.4731 16.1284 4.8577L13.8302 6.78606L19.9633 9.13364C19.7929 7.15555 19.0335 5.20847 17.6604 3.57212C14.1104 -0.658624 7.80283 -1.21043 3.57212 2.33956Z"), a$2(l2, "fill", "currentColor"), a$2(s2, "d", "M7 10H5C5 12.7614 7.23858 15 10 15C12.7614 15 15 12.7614 15 10H13C13 11.6569 11.6569 13 10 13C8.3431 13 7 11.6569 7 10Z"), a$2(s2, "fill", "currentColor"), a$2(i2, "width", "22"), a$2(i2, "height", "22"), a$2(i2, "viewBox", "0 0 20 20"), a$2(i2, "fill", "none"), a$2(i2, "xmlns", "http://www.w3.org/2000/svg"), a$2(t2, "href", xt), a$2(t2, "target", "_blank"), a$2(t2, "class", "altcha-logo svelte-ddsc3z"), a$2(t2, "aria-label", d2 = /*_strings*/
        n2[11].ariaLinkLabel);
      },
      m(h2, f2) {
        X(h2, e2, f2), L(e2, t2), L(t2, i2), L(i2, o2), L(i2, l2), L(i2, s2);
      },
      p(h2, f2) {
        f2[0] & /*_strings*/
        2048 && d2 !== (d2 = /*_strings*/
        h2[11].ariaLinkLabel) && a$2(t2, "aria-label", d2);
      },
      d(h2) {
        h2 && Y(e2);
      }
    };
  }
  function ct(n2) {
    let e2, t2, i2, o2;
    function l2(h2, f2) {
      return (
        /*state*/
        h2[7] === m.EXPIRED ? An : Sn
      );
    }
    let s2 = l2(n2), d2 = s2(n2);
    return {
      c() {
        e2 = Z$1("div"), t2 = $("svg"), i2 = $("path"), o2 = Q(), d2.c(), a$2(i2, "stroke-linecap", "round"), a$2(i2, "stroke-linejoin", "round"), a$2(i2, "d", "M6 18L18 6M6 6l12 12"), a$2(t2, "width", "14"), a$2(t2, "height", "14"), a$2(t2, "xmlns", "http://www.w3.org/2000/svg"), a$2(t2, "fill", "none"), a$2(t2, "viewBox", "0 0 24 24"), a$2(t2, "stroke-width", "1.5"), a$2(t2, "stroke", "currentColor"), a$2(e2, "class", "altcha-error svelte-ddsc3z");
      },
      m(h2, f2) {
        X(h2, e2, f2), L(e2, t2), L(t2, i2), L(e2, o2), d2.m(e2, null);
      },
      p(h2, f2) {
        s2 === (s2 = l2(h2)) && d2 ? d2.p(h2, f2) : (d2.d(1), d2 = s2(h2), d2 && (d2.c(), d2.m(e2, null)));
      },
      d(h2) {
        h2 && Y(e2), d2.d();
      }
    };
  }
  function Sn(n2) {
    let e2, t2 = (
      /*_strings*/
      n2[11].error + ""
    );
    return {
      c() {
        e2 = Z$1("div"), a$2(
          e2,
          "title",
          /*error*/
          n2[5]
        );
      },
      m(i2, o2) {
        X(i2, e2, o2), e2.innerHTML = t2;
      },
      p(i2, o2) {
        o2[0] & /*_strings*/
        2048 && t2 !== (t2 = /*_strings*/
        i2[11].error + "") && (e2.innerHTML = t2), o2[0] & /*error*/
        32 && a$2(
          e2,
          "title",
          /*error*/
          i2[5]
        );
      },
      d(i2) {
        i2 && Y(e2);
      }
    };
  }
  function An(n2) {
    let e2, t2 = (
      /*_strings*/
      n2[11].expired + ""
    );
    return {
      c() {
        e2 = Z$1("div"), a$2(
          e2,
          "title",
          /*error*/
          n2[5]
        );
      },
      m(i2, o2) {
        X(i2, e2, o2), e2.innerHTML = t2;
      },
      p(i2, o2) {
        o2[0] & /*_strings*/
        2048 && t2 !== (t2 = /*_strings*/
        i2[11].expired + "") && (e2.innerHTML = t2), o2[0] & /*error*/
        32 && a$2(
          e2,
          "title",
          /*error*/
          i2[5]
        );
      },
      d(i2) {
        i2 && Y(e2);
      }
    };
  }
  function at(n2) {
    let e2, t2, i2 = (
      /*_strings*/
      n2[11].footer + ""
    );
    return {
      c() {
        e2 = Z$1("div"), t2 = Z$1("div"), a$2(t2, "class", "svelte-ddsc3z"), a$2(e2, "class", "altcha-footer svelte-ddsc3z");
      },
      m(o2, l2) {
        X(o2, e2, l2), L(e2, t2), t2.innerHTML = i2;
      },
      p(o2, l2) {
        l2[0] & /*_strings*/
        2048 && i2 !== (i2 = /*_strings*/
        o2[11].footer + "") && (t2.innerHTML = i2);
      },
      d(o2) {
        o2 && Y(e2);
      }
    };
  }
  function ft(n2) {
    let e2;
    return {
      c() {
        e2 = Z$1("div"), a$2(e2, "class", "altcha-anchor-arrow svelte-ddsc3z");
      },
      m(t2, i2) {
        X(t2, e2, i2), n2[48](e2);
      },
      p: Re,
      d(t2) {
        t2 && Y(e2), n2[48](null);
      }
    };
  }
  function Tn(n2) {
    let e2, t2, i2, o2, l2, s2, d2, h2, f2, C, b2, M, D, j2, S2, N2, O2;
    const J = (
      /*#slots*/
      n2[46].default
    ), G = Mt(
      J,
      n2,
      /*$$scope*/
      n2[45],
      null
    );
    let A2 = (
      /*state*/
      n2[7] === m.VERIFYING && lt()
    );
    function q(u2, y2) {
      return (
        /*state*/
        u2[7] === m.VERIFIED ? zn : (
          /*state*/
          u2[7] === m.VERIFYING ? Nn : Ln
        )
      );
    }
    let K = q(n2), H2 = K(n2), x = (
      /*hidelogo*/
      (n2[3] !== true || /*isFreeSaaS*/
      n2[12]) && st(n2)
    ), T2 = (
      /*error*/
      (n2[5] || /*state*/
      n2[7] === m.EXPIRED) && ct(n2)
    ), z = (
      /*_strings*/
      n2[11].footer && /*hidefooter*/
      (n2[2] !== true || /*isFreeSaaS*/
      n2[12]) && at(n2)
    ), _2 = (
      /*floating*/
      n2[1] && ft(n2)
    );
    return {
      c() {
        G && G.c(), e2 = Q(), t2 = Z$1("div"), i2 = Z$1("div"), A2 && A2.c(), o2 = Q(), l2 = Z$1("div"), s2 = Z$1("input"), f2 = Q(), C = Z$1("div"), H2.c(), b2 = Q(), x && x.c(), M = Q(), T2 && T2.c(), D = Q(), z && z.c(), j2 = Q(), _2 && _2.c(), a$2(s2, "type", "checkbox"), a$2(s2, "id", d2 = /*name*/
        n2[4] + "_checkbox"), s2.required = h2 = /*auto*/
        n2[0] !== "onsubmit" && (!/*floating*/
        n2[1] || /*auto*/
        n2[0] !== "off"), a$2(s2, "class", "svelte-ddsc3z"), a$2(l2, "class", "altcha-checkbox svelte-ddsc3z"), it(
          l2,
          "altcha-hidden",
          /*state*/
          n2[7] === m.VERIFYING
        ), a$2(C, "class", "altcha-label svelte-ddsc3z"), a$2(i2, "class", "altcha-main svelte-ddsc3z"), a$2(t2, "class", "altcha svelte-ddsc3z"), a$2(
          t2,
          "data-state",
          /*state*/
          n2[7]
        ), a$2(
          t2,
          "data-floating",
          /*floating*/
          n2[1]
        );
      },
      m(u2, y2) {
        G && G.m(u2, y2), X(u2, e2, y2), X(u2, t2, y2), L(t2, i2), A2 && A2.m(i2, null), L(i2, o2), L(i2, l2), L(l2, s2), s2.checked = /*checked*/
        n2[8], L(i2, f2), L(i2, C), H2.m(C, null), L(i2, b2), x && x.m(i2, null), L(t2, M), T2 && T2.m(t2, null), L(t2, D), z && z.m(t2, null), L(t2, j2), _2 && _2.m(t2, null), n2[49](t2), S2 = true, N2 || (O2 = [
          Le(
            s2,
            "change",
            /*input_change_handler*/
            n2[47]
          ),
          Le(
            s2,
            "change",
            /*onCheckedChange*/
            n2[13]
          ),
          Le(
            s2,
            "invalid",
            /*onInvalid*/
            n2[14]
          )
        ], N2 = true);
      },
      p(u2, y2) {
        G && G.p && (!S2 || y2[1] & /*$$scope*/
        16384) && Ot(
          G,
          J,
          u2,
          /*$$scope*/
          u2[45],
          S2 ? Bt(
            J,
            /*$$scope*/
            u2[45],
            y2,
            null
          ) : Jt(
            /*$$scope*/
            u2[45]
          ),
          null
        ), /*state*/
        u2[7] === m.VERIFYING ? A2 || (A2 = lt(), A2.c(), A2.m(i2, o2)) : A2 && (A2.d(1), A2 = null), (!S2 || y2[0] & /*name*/
        16 && d2 !== (d2 = /*name*/
        u2[4] + "_checkbox")) && a$2(s2, "id", d2), (!S2 || y2[0] & /*auto, floating*/
        3 && h2 !== (h2 = /*auto*/
        u2[0] !== "onsubmit" && (!/*floating*/
        u2[1] || /*auto*/
        u2[0] !== "off"))) && (s2.required = h2), y2[0] & /*checked*/
        256 && (s2.checked = /*checked*/
        u2[8]), (!S2 || y2[0] & /*state*/
        128) && it(
          l2,
          "altcha-hidden",
          /*state*/
          u2[7] === m.VERIFYING
        ), K === (K = q(u2)) && H2 ? H2.p(u2, y2) : (H2.d(1), H2 = K(u2), H2 && (H2.c(), H2.m(C, null))), /*hidelogo*/
        u2[3] !== true || /*isFreeSaaS*/
        u2[12] ? x ? x.p(u2, y2) : (x = st(u2), x.c(), x.m(i2, null)) : x && (x.d(1), x = null), /*error*/
        u2[5] || /*state*/
        u2[7] === m.EXPIRED ? T2 ? T2.p(u2, y2) : (T2 = ct(u2), T2.c(), T2.m(t2, D)) : T2 && (T2.d(1), T2 = null), /*_strings*/
        u2[11].footer && /*hidefooter*/
        (u2[2] !== true || /*isFreeSaaS*/
        u2[12]) ? z ? z.p(u2, y2) : (z = at(u2), z.c(), z.m(t2, j2)) : z && (z.d(1), z = null), /*floating*/
        u2[1] ? _2 ? _2.p(u2, y2) : (_2 = ft(u2), _2.c(), _2.m(t2, null)) : _2 && (_2.d(1), _2 = null), (!S2 || y2[0] & /*state*/
        128) && a$2(
          t2,
          "data-state",
          /*state*/
          u2[7]
        ), (!S2 || y2[0] & /*floating*/
        2) && a$2(
          t2,
          "data-floating",
          /*floating*/
          u2[1]
        );
      },
      i(u2) {
        S2 || (pt(G, u2), S2 = true);
      },
      o(u2) {
        dn(G, u2), S2 = false;
      },
      d(u2) {
        u2 && (Y(e2), Y(t2)), G && G.d(u2), A2 && A2.d(), H2.d(), x && x.d(), T2 && T2.d(), z && z.d(), _2 && _2.d(), n2[49](null), N2 = false, we(O2);
      }
    };
  }
  const ut = "Visit Altcha.org", xt = "https://altcha.org/";
  function dt(n2) {
    return JSON.parse(n2);
  }
  function Zn(n2, e2, t2) {
    var qe, et;
    let i2, o2, l2, s2, { $$slots: d2 = {}, $$scope: h2 } = e2, { auto: f2 = void 0 } = e2, { blockspam: C = void 0 } = e2, { challengeurl: b2 = void 0 } = e2, { challengejson: M = void 0 } = e2, { debug: D = false } = e2, { delay: j2 = 0 } = e2, { expire: S2 = void 0 } = e2, { floating: N2 = void 0 } = e2, { floatinganchor: O2 = void 0 } = e2, { floatingoffset: J = void 0 } = e2, { hidefooter: G = false } = e2, { hidelogo: A2 = false } = e2, { name: q = "altcha" } = e2, { maxnumber: K = 1e6 } = e2, { mockerror: H2 = false } = e2, { obfuscated: x = void 0 } = e2, { plugins: T2 = void 0 } = e2, { refetchonexpire: z = true } = e2, { spamfilter: _2 = false } = e2, { strings: u2 = void 0 } = e2, { test: y2 = false } = e2, { verifyurl: ee2 = void 0 } = e2, { workers: le2 = Math.min(16, navigator.hardwareConcurrency || 8) } = e2, { workerurl: ue = void 0 } = e2;
    const de2 = sn(), Te = ["SHA-256", "SHA-384", "SHA-512"], Ze = (et = (qe = document.documentElement.lang) == null ? void 0 : qe.split("-")) == null ? void 0 : et[0];
    let re = false, E2, ie2 = null, se = null, v2 = null, he2 = null, B = null, oe = null, te2 = [], R = m.UNVERIFIED;
    ln(() => {
      Et(), v2 && (v2.removeEventListener("submit", Fe), v2.removeEventListener("reset", De), v2.removeEventListener("focusin", Xe), v2 = null), B && (clearTimeout(B), B = null), document.removeEventListener("click", He), document.removeEventListener("scroll", Ye), window.removeEventListener("resize", Pe);
    }), on(() => {
      k2("mounted", "1.0.0"), k2("workers", le2), Nt(), k2("plugins", te2.length ? te2.map((r2) => r2.constructor.pluginName).join(", ") : "none"), y2 && k2("using test mode"), S2 && ke(S2), f2 !== void 0 && k2("auto", f2), N2 !== void 0 && We(N2), v2 = E2.closest("form"), v2 && (v2.addEventListener("submit", Fe, { capture: true }), v2.addEventListener("reset", De), f2 === "onfocus" && v2.addEventListener("focusin", Xe)), f2 === "onload" && (x ? ge2() : ne()), i2 && (G || A2) && k2("Attributes hidefooter and hidelogo ignored because usage with free API Keys requires attribution."), requestAnimationFrame(() => {
        de2("load");
      });
    });
    function Ve(r2, c2) {
      return btoa(JSON.stringify({
        algorithm: r2.algorithm,
        challenge: r2.challenge,
        number: c2.number,
        salt: r2.salt,
        signature: r2.signature,
        test: y2 ? true : void 0,
        took: c2.took
      }));
    }
    function Et() {
      for (const r2 of te2)
        r2.destroy();
    }
    function Ge() {
      b2 && z && R === m.VERIFIED ? ne() : me(m.EXPIRED, s2.expired);
    }
    async function Rt() {
      var r2;
      if (H2)
        throw k2("mocking error"), new Error("Mocked error.");
      if (o2)
        return k2("using provided json data"), o2;
      if (y2)
        return k2("generating test challenge", { test: y2 }), _n(typeof y2 != "boolean" ? +y2 : void 0);
      {
        if (!b2 && v2) {
          const p2 = v2.getAttribute("action");
          p2 != null && p2.includes("/form/") && t2(15, b2 = p2 + "/altcha");
        }
        if (!b2)
          throw new Error("Attribute challengeurl not set.");
        k2("fetching challenge from", b2);
        const c2 = await fetch(b2, {
          headers: _2 ? { "x-altcha-spam-filter": "1" } : {}
        });
        if (c2.status !== 200)
          throw new Error(`Server responded with ${c2.status}.`);
        const g2 = c2.headers.get("Expires"), I2 = c2.headers.get("X-Altcha-Config"), P2 = await c2.json(), F2 = new URLSearchParams((r2 = P2.salt.split("?")) == null ? void 0 : r2[1]), V = F2.get("expires") || F2.get("expire");
        if (V) {
          const p2 = new Date(+V * 1e3), W = isNaN(p2.getTime()) ? 0 : p2.getTime() - Date.now();
          W > 0 && ke(W);
        }
        if (I2)
          try {
            const p2 = JSON.parse(I2);
            p2 && typeof p2 == "object" && (p2.verifyurl && (p2.verifyurl = new URL(p2.verifyurl, new URL(b2)).toString()), Me2(p2));
          } catch (p2) {
            k2("unable to configure from X-Altcha-Config", p2);
          }
        if (!S2 && (g2 != null && g2.length)) {
          const p2 = Date.parse(g2);
          if (p2) {
            const W = p2 - Date.now();
            W > 0 && ke(W);
          }
        }
        return P2;
      }
    }
    function Ct(r2) {
      var g2;
      const c2 = v2 == null ? void 0 : v2.querySelector(typeof r2 == "string" ? `input[name="${r2}"]` : 'input[type="email"]:not([data-no-spamfilter])');
      return ((g2 = c2 == null ? void 0 : c2.value) == null ? void 0 : g2.slice(c2.value.indexOf("@"))) || void 0;
    }
    function It() {
      return _2 === "ipAddress" ? {
        blockedCountries: void 0,
        classifier: void 0,
        disableRules: void 0,
        email: false,
        expectedCountries: void 0,
        expectedLanguages: void 0,
        fields: false,
        ipAddress: void 0,
        text: void 0,
        timeZone: void 0
      } : typeof _2 == "object" ? _2 : {
        blockedCountries: void 0,
        classifier: void 0,
        disableRules: void 0,
        email: void 0,
        expectedCountries: void 0,
        expectedLanguages: void 0,
        fields: void 0,
        ipAddress: void 0,
        text: void 0,
        timeZone: void 0
      };
    }
    function Lt(r2) {
      return [
        ...(v2 == null ? void 0 : v2.querySelectorAll(r2 != null && r2.length ? r2.map((g2) => `input[name="${g2}"]`).join(", ") : 'input[type="text"]:not([data-no-spamfilter]), textarea:not([data-no-spamfilter])')) || []
      ].reduce(
        (g2, I2) => {
          const P2 = I2.name, F2 = I2.value;
          return P2 && F2 && (g2[P2] = /\n/.test(F2) ? F2.replace(new RegExp("(?<!\\r)\\n", "g"), `\r
`) : F2), g2;
        },
        {}
      );
    }
    function Nt() {
      const r2 = T2 !== void 0 ? T2.split(",") : void 0;
      for (const c2 of globalThis.altchaPlugins)
        (!r2 || r2.includes(c2.pluginName)) && te2.push(new c2({
          el: E2,
          clarify: ge2,
          dispatch: de2,
          getConfiguration: Be,
          getFloatingAnchor: Oe2,
          getState: Je,
          log: k2,
          reset: me,
          solve: Ke,
          setState: $e,
          setFloatingAnchor: Qe,
          verify: ne
        }));
    }
    function k2(...r2) {
      (D || r2.some((c2) => c2 instanceof Error)) && console[r2[0] instanceof Error ? "error" : "log"]("ALTCHA", `[name=${q}]`, ...r2);
    }
    function zt() {
      [m.UNVERIFIED, m.ERROR, m.EXPIRED].includes(R) ? _2 && (v2 == null ? void 0 : v2.reportValidity()) === false ? t2(8, re = false) : x ? ge2() : ne() : t2(8, re = true);
    }
    function He(r2) {
      const c2 = r2.target;
      N2 && c2 && !E2.contains(c2) && (R === m.VERIFIED || f2 === "off" && R === m.UNVERIFIED) && t2(9, E2.style.display = "none", E2);
    }
    function Ye() {
      N2 && R !== m.UNVERIFIED && _e();
    }
    function St(r2) {
      for (const c2 of te2)
        typeof c2.onErrorChange == "function" && c2.onErrorChange(he2);
    }
    function Xe(r2) {
      R === m.UNVERIFIED && ne();
    }
    function Fe(r2) {
      v2 && f2 === "onsubmit" ? R === m.UNVERIFIED ? (r2.preventDefault(), r2.stopPropagation(), ne().then(() => {
        v2 == null || v2.requestSubmit();
      })) : R !== m.VERIFIED && (r2.preventDefault(), r2.stopPropagation(), R === m.VERIFYING && je()) : v2 && N2 && f2 === "off" && R === m.UNVERIFIED && (r2.preventDefault(), r2.stopPropagation(), t2(9, E2.style.display = "block", E2), _e());
    }
    function De() {
      me();
    }
    function je() {
      R === m.VERIFYING && s2.waitAlert && alert(s2.waitAlert);
    }
    function At(r2) {
      for (const c2 of te2)
        typeof c2.onStateChange == "function" && c2.onStateChange(R);
      N2 && R !== m.UNVERIFIED && requestAnimationFrame(() => {
        _e();
      }), t2(8, re = R === m.VERIFIED);
    }
    function Pe() {
      N2 && _e();
    }
    function _e(r2 = 20) {
      if (E2)
        if (se || (se = (O2 ? document.querySelector(O2) : v2 == null ? void 0 : v2.querySelector('input[type="submit"], button[type="submit"], button:not([type="button"]):not([type="reset"])')) || v2), se) {
          const c2 = parseInt(J, 10) || 12, g2 = se.getBoundingClientRect(), I2 = E2.getBoundingClientRect(), P2 = document.documentElement.clientHeight, F2 = document.documentElement.clientWidth, V = N2 === "auto" ? g2.bottom + I2.height + c2 + r2 > P2 : N2 === "top", p2 = Math.max(r2, Math.min(F2 - r2 - I2.width, g2.left + g2.width / 2 - I2.width / 2));
          if (V ? t2(9, E2.style.top = `${g2.top - (I2.height + c2)}px`, E2) : t2(9, E2.style.top = `${g2.bottom + c2}px`, E2), t2(9, E2.style.left = `${p2}px`, E2), E2.setAttribute("data-floating", V ? "top" : "bottom"), ie2) {
            const W = ie2.getBoundingClientRect();
            t2(10, ie2.style.left = g2.left - p2 + g2.width / 2 - W.width / 2 + "px", ie2);
          }
        } else
          k2("unable to find floating anchor element");
    }
    async function Tt(r2) {
      if (!ee2)
        throw new Error("Attribute verifyurl not set.");
      k2("requesting server verification from", ee2);
      const c2 = { payload: r2 };
      if (_2) {
        const { blockedCountries: P2, classifier: F2, disableRules: V, email: p2, expectedLanguages: W, expectedCountries: Ie, fields: be2, ipAddress: ye, text: Xt, timeZone: tt } = It();
        c2.blockedCountries = P2, c2.classifier = F2, c2.disableRules = V, c2.email = p2 === false ? void 0 : Ct(p2), c2.expectedCountries = Ie, c2.expectedLanguages = W || (Ze ? [Ze] : void 0), c2.fields = be2 === false ? void 0 : Lt(be2), c2.ipAddress = ye === false ? void 0 : ye || "auto", c2.text = Xt, c2.timeZone = tt === false ? void 0 : tt || xn();
      }
      const g2 = await fetch(ee2, {
        body: JSON.stringify(c2),
        headers: { "content-type": "application/json" },
        method: "POST"
      });
      if (g2.status !== 200)
        throw new Error(`Server responded with ${g2.status}.`);
      const I2 = await g2.json();
      if (I2 != null && I2.payload && t2(6, oe = I2.payload), de2("serververification", I2), C && I2.classification === "BAD")
        throw new Error("SpamFilter returned negative classification.");
    }
    function ke(r2) {
      k2("expire", r2), B && (clearTimeout(B), B = null), r2 < 1 ? Ge() : B = setTimeout(Ge, r2);
    }
    function We(r2) {
      k2("floating", r2), N2 !== r2 && (t2(9, E2.style.left = "", E2), t2(9, E2.style.top = "", E2)), t2(1, N2 = r2 === true || r2 === "" ? "auto" : r2 === false || r2 === "false" ? void 0 : N2), N2 ? (f2 || t2(0, f2 = "onsubmit"), document.addEventListener("scroll", Ye), document.addEventListener("click", He), window.addEventListener("resize", Pe)) : f2 === "onsubmit" && t2(0, f2 = void 0);
    }
    function Ue(r2) {
      if (!r2.algorithm)
        throw new Error("Invalid challenge. Property algorithm is missing.");
      if (r2.signature === void 0)
        throw new Error("Invalid challenge. Property signature is missing.");
      if (!Te.includes(r2.algorithm.toUpperCase()))
        throw new Error(`Unknown algorithm value. Allowed values: ${Te.join(", ")}`);
      if (!r2.challenge || r2.challenge.length < 40)
        throw new Error("Challenge is too short. Min. 40 chars.");
      if (!r2.salt || r2.salt.length < 10)
        throw new Error("Salt is too short. Min. 10 chars.");
    }
    async function Ke(r2) {
      let c2 = null;
      if ("Worker" in window) {
        try {
          c2 = await Zt(r2, r2.maxnumber);
        } catch (g2) {
          k2(g2);
        }
        if ((c2 == null ? void 0 : c2.number) !== void 0 || "obfuscated" in r2)
          return { data: r2, solution: c2 };
      }
      if ("obfuscated" in r2) {
        const g2 = await Cn(r2.obfuscated, r2.key, r2.maxnumber);
        return { data: r2, solution: await g2.promise };
      }
      return {
        data: r2,
        solution: await kn(r2.challenge, r2.salt, r2.algorithm, r2.maxnumber || K).promise
      };
    }
    async function Zt(r2, c2 = typeof y2 == "number" ? y2 : K, g2 = Math.ceil(le2)) {
      const I2 = [];
      g2 = Math.min(16, Math.max(1, g2));
      for (let V = 0; V < g2; V++)
        I2.push(altchaCreateWorker(ue));
      const P2 = Math.ceil(c2 / g2), F2 = await Promise.all(I2.map((V, p2) => {
        const W = p2 * P2;
        return new Promise((Ie) => {
          V.addEventListener("message", (be2) => {
            if (be2.data)
              for (const ye of I2)
                ye !== V && ye.postMessage({ type: "abort" });
            Ie(be2.data);
          }), V.postMessage({
            payload: r2,
            max: W + P2,
            start: W,
            type: "work"
          });
        });
      }));
      for (const V of I2)
        V.terminate();
      return F2.find((V) => !!V) || null;
    }
    async function ge2() {
      if (!x) {
        t2(7, R = m.ERROR);
        return;
      }
      const r2 = te2.find((c2) => c2.constructor.pluginName === "obfuscation");
      if (!r2 || !("clarify" in r2)) {
        t2(7, R = m.ERROR), k2("Plugin `obfuscation` not found. Import `altcha/plugins/obfuscation` to load it.");
        return;
      }
      if ("clarify" in r2 && typeof r2.clarify == "function")
        return r2.clarify();
    }
    function Me2(r2) {
      r2.obfuscated !== void 0 && t2(24, x = r2.obfuscated), r2.auto !== void 0 && (t2(0, f2 = r2.auto), f2 === "onload" && (x ? ge2() : ne())), r2.blockspam !== void 0 && t2(16, C = !!r2.blockspam), r2.floatinganchor !== void 0 && t2(20, O2 = r2.floatinganchor), r2.delay !== void 0 && t2(18, j2 = r2.delay), r2.floatingoffset !== void 0 && t2(21, J = r2.floatingoffset), r2.floating !== void 0 && We(r2.floating), r2.expire !== void 0 && (ke(r2.expire), t2(19, S2 = r2.expire)), r2.challenge && (Ue(r2.challenge), o2 = r2.challenge), r2.challengeurl !== void 0 && t2(15, b2 = r2.challengeurl), r2.debug !== void 0 && t2(17, D = !!r2.debug), r2.hidefooter !== void 0 && t2(2, G = !!r2.hidefooter), r2.hidelogo !== void 0 && t2(3, A2 = !!r2.hidelogo), r2.maxnumber !== void 0 && t2(22, K = +r2.maxnumber), r2.mockerror !== void 0 && t2(23, H2 = !!r2.mockerror), r2.name !== void 0 && t2(4, q = r2.name), r2.refetchonexpire !== void 0 && t2(25, z = !!r2.refetchonexpire), r2.spamfilter !== void 0 && t2(26, _2 = typeof r2.spamfilter == "object" ? r2.spamfilter : !!r2.spamfilter), r2.strings && t2(44, l2 = r2.strings), r2.test !== void 0 && t2(27, y2 = typeof r2.test == "number" ? r2.test : !!r2.test), r2.verifyurl !== void 0 && t2(28, ee2 = r2.verifyurl), r2.workers !== void 0 && t2(29, le2 = +r2.workers), r2.workerurl !== void 0 && t2(30, ue = r2.workerurl);
    }
    function Be() {
      return {
        auto: f2,
        blockspam: C,
        challengeurl: b2,
        debug: D,
        delay: j2,
        expire: S2,
        floating: N2,
        floatinganchor: O2,
        floatingoffset: J,
        hidefooter: G,
        hidelogo: A2,
        name: q,
        maxnumber: K,
        mockerror: H2,
        obfuscated: x,
        refetchonexpire: z,
        spamfilter: _2,
        strings: s2,
        test: y2,
        verifyurl: ee2,
        workers: le2,
        workerurl: ue
      };
    }
    function Oe2() {
      return se;
    }
    function Vt(r2) {
      return te2.find((c2) => c2.constructor.pluginName === r2);
    }
    function Je() {
      return R;
    }
    function me(r2 = m.UNVERIFIED, c2 = null) {
      B && (clearTimeout(B), B = null), t2(8, re = false), t2(5, he2 = c2), t2(6, oe = null), t2(7, R = r2);
    }
    function Qe(r2) {
      se = r2;
    }
    function $e(r2, c2 = null) {
      t2(7, R = r2), t2(5, he2 = c2);
    }
    async function ne() {
      return me(m.VERIFYING), await new Promise((r2) => setTimeout(r2, j2 || 0)), Rt().then((r2) => (Ue(r2), k2("challenge", r2), Ke(r2))).then(({ data: r2, solution: c2 }) => {
        if (k2("solution", c2), "challenge" in r2 && c2 && !("clearText" in c2))
          if ((c2 == null ? void 0 : c2.number) !== void 0) {
            if (ee2)
              return Tt(Ve(r2, c2));
            t2(6, oe = Ve(r2, c2)), k2("payload", oe);
          } else
            throw k2("Unable to find a solution. Ensure that the 'maxnumber' attribute is greater than the randomly generated number."), new Error("Unexpected result returned.");
      }).then(() => {
        cn$2().then(() => {
          t2(7, R = m.VERIFIED), k2("verified"), de2("verified", { payload: oe });
        });
      }).catch((r2) => {
        k2(r2), t2(7, R = m.ERROR), t2(5, he2 = r2.message);
      });
    }
    function Gt() {
      re = this.checked, t2(8, re);
    }
    function Ht(r2) {
      Ce[r2 ? "unshift" : "push"](() => {
        ie2 = r2, t2(10, ie2);
      });
    }
    function Yt(r2) {
      Ce[r2 ? "unshift" : "push"](() => {
        E2 = r2, t2(9, E2);
      });
    }
    return n2.$$set = (r2) => {
      "auto" in r2 && t2(0, f2 = r2.auto), "blockspam" in r2 && t2(16, C = r2.blockspam), "challengeurl" in r2 && t2(15, b2 = r2.challengeurl), "challengejson" in r2 && t2(31, M = r2.challengejson), "debug" in r2 && t2(17, D = r2.debug), "delay" in r2 && t2(18, j2 = r2.delay), "expire" in r2 && t2(19, S2 = r2.expire), "floating" in r2 && t2(1, N2 = r2.floating), "floatinganchor" in r2 && t2(20, O2 = r2.floatinganchor), "floatingoffset" in r2 && t2(21, J = r2.floatingoffset), "hidefooter" in r2 && t2(2, G = r2.hidefooter), "hidelogo" in r2 && t2(3, A2 = r2.hidelogo), "name" in r2 && t2(4, q = r2.name), "maxnumber" in r2 && t2(22, K = r2.maxnumber), "mockerror" in r2 && t2(23, H2 = r2.mockerror), "obfuscated" in r2 && t2(24, x = r2.obfuscated), "plugins" in r2 && t2(32, T2 = r2.plugins), "refetchonexpire" in r2 && t2(25, z = r2.refetchonexpire), "spamfilter" in r2 && t2(26, _2 = r2.spamfilter), "strings" in r2 && t2(33, u2 = r2.strings), "test" in r2 && t2(27, y2 = r2.test), "verifyurl" in r2 && t2(28, ee2 = r2.verifyurl), "workers" in r2 && t2(29, le2 = r2.workers), "workerurl" in r2 && t2(30, ue = r2.workerurl), "$$scope" in r2 && t2(45, h2 = r2.$$scope);
    }, n2.$$.update = () => {
      n2.$$.dirty[0] & /*challengeurl*/
      32768 && t2(12, i2 = !!(b2 != null && b2.includes(".altcha.org")) && !!(b2 != null && b2.includes("apiKey=ckey_"))), n2.$$.dirty[1] & /*challengejson*/
      1 && (o2 = M ? dt(M) : void 0), n2.$$.dirty[1] & /*strings*/
      4 && t2(44, l2 = u2 ? dt(u2) : {}), n2.$$.dirty[1] & /*parsedStrings*/
      8192 && t2(11, s2 = {
        ariaLinkLabel: ut,
        error: "Verification failed. Try again later.",
        expired: "Verification expired. Try again.",
        footer: `Protected by <a href="${xt}" target="_blank" aria-label="${l2.ariaLinkLabel || ut}">ALTCHA</a>`,
        label: "I'm not a robot",
        verified: "Verified",
        verifying: "Verifying...",
        waitAlert: "Verifying... please wait.",
        ...l2
      }), n2.$$.dirty[0] & /*payload, state*/
      192 && de2("statechange", { payload: oe, state: R }), n2.$$.dirty[0] & /*error*/
      32 && St(), n2.$$.dirty[0] & /*state*/
      128 && At();
    }, [
      f2,
      N2,
      G,
      A2,
      q,
      he2,
      oe,
      R,
      re,
      E2,
      ie2,
      s2,
      i2,
      zt,
      je,
      b2,
      C,
      D,
      j2,
      S2,
      O2,
      J,
      K,
      H2,
      x,
      z,
      _2,
      y2,
      ee2,
      le2,
      ue,
      M,
      T2,
      u2,
      ge2,
      Me2,
      Be,
      Oe2,
      Vt,
      Je,
      me,
      Qe,
      $e,
      ne,
      l2,
      h2,
      d2,
      Gt,
      Ht,
      Yt
    ];
  }
  class Vn extends vn {
    constructor(e2) {
      super(), bn(
        this,
        e2,
        Zn,
        Tn,
        Ut,
        {
          auto: 0,
          blockspam: 16,
          challengeurl: 15,
          challengejson: 31,
          debug: 17,
          delay: 18,
          expire: 19,
          floating: 1,
          floatinganchor: 20,
          floatingoffset: 21,
          hidefooter: 2,
          hidelogo: 3,
          name: 4,
          maxnumber: 22,
          mockerror: 23,
          obfuscated: 24,
          plugins: 32,
          refetchonexpire: 25,
          spamfilter: 26,
          strings: 33,
          test: 27,
          verifyurl: 28,
          workers: 29,
          workerurl: 30,
          clarify: 34,
          configure: 35,
          getConfiguration: 36,
          getFloatingAnchor: 37,
          getPlugin: 38,
          getState: 39,
          reset: 40,
          setFloatingAnchor: 41,
          setState: 42,
          verify: 43
        },
        In,
        [-1, -1, -1]
      );
    }
    get auto() {
      return this.$$.ctx[0];
    }
    set auto(e2) {
      this.$$set({ auto: e2 }), w$3();
    }
    get blockspam() {
      return this.$$.ctx[16];
    }
    set blockspam(e2) {
      this.$$set({ blockspam: e2 }), w$3();
    }
    get challengeurl() {
      return this.$$.ctx[15];
    }
    set challengeurl(e2) {
      this.$$set({ challengeurl: e2 }), w$3();
    }
    get challengejson() {
      return this.$$.ctx[31];
    }
    set challengejson(e2) {
      this.$$set({ challengejson: e2 }), w$3();
    }
    get debug() {
      return this.$$.ctx[17];
    }
    set debug(e2) {
      this.$$set({ debug: e2 }), w$3();
    }
    get delay() {
      return this.$$.ctx[18];
    }
    set delay(e2) {
      this.$$set({ delay: e2 }), w$3();
    }
    get expire() {
      return this.$$.ctx[19];
    }
    set expire(e2) {
      this.$$set({ expire: e2 }), w$3();
    }
    get floating() {
      return this.$$.ctx[1];
    }
    set floating(e2) {
      this.$$set({ floating: e2 }), w$3();
    }
    get floatinganchor() {
      return this.$$.ctx[20];
    }
    set floatinganchor(e2) {
      this.$$set({ floatinganchor: e2 }), w$3();
    }
    get floatingoffset() {
      return this.$$.ctx[21];
    }
    set floatingoffset(e2) {
      this.$$set({ floatingoffset: e2 }), w$3();
    }
    get hidefooter() {
      return this.$$.ctx[2];
    }
    set hidefooter(e2) {
      this.$$set({ hidefooter: e2 }), w$3();
    }
    get hidelogo() {
      return this.$$.ctx[3];
    }
    set hidelogo(e2) {
      this.$$set({ hidelogo: e2 }), w$3();
    }
    get name() {
      return this.$$.ctx[4];
    }
    set name(e2) {
      this.$$set({ name: e2 }), w$3();
    }
    get maxnumber() {
      return this.$$.ctx[22];
    }
    set maxnumber(e2) {
      this.$$set({ maxnumber: e2 }), w$3();
    }
    get mockerror() {
      return this.$$.ctx[23];
    }
    set mockerror(e2) {
      this.$$set({ mockerror: e2 }), w$3();
    }
    get obfuscated() {
      return this.$$.ctx[24];
    }
    set obfuscated(e2) {
      this.$$set({ obfuscated: e2 }), w$3();
    }
    get plugins() {
      return this.$$.ctx[32];
    }
    set plugins(e2) {
      this.$$set({ plugins: e2 }), w$3();
    }
    get refetchonexpire() {
      return this.$$.ctx[25];
    }
    set refetchonexpire(e2) {
      this.$$set({ refetchonexpire: e2 }), w$3();
    }
    get spamfilter() {
      return this.$$.ctx[26];
    }
    set spamfilter(e2) {
      this.$$set({ spamfilter: e2 }), w$3();
    }
    get strings() {
      return this.$$.ctx[33];
    }
    set strings(e2) {
      this.$$set({ strings: e2 }), w$3();
    }
    get test() {
      return this.$$.ctx[27];
    }
    set test(e2) {
      this.$$set({ test: e2 }), w$3();
    }
    get verifyurl() {
      return this.$$.ctx[28];
    }
    set verifyurl(e2) {
      this.$$set({ verifyurl: e2 }), w$3();
    }
    get workers() {
      return this.$$.ctx[29];
    }
    set workers(e2) {
      this.$$set({ workers: e2 }), w$3();
    }
    get workerurl() {
      return this.$$.ctx[30];
    }
    set workerurl(e2) {
      this.$$set({ workerurl: e2 }), w$3();
    }
    get clarify() {
      return this.$$.ctx[34];
    }
    get configure() {
      return this.$$.ctx[35];
    }
    get getConfiguration() {
      return this.$$.ctx[36];
    }
    get getFloatingAnchor() {
      return this.$$.ctx[37];
    }
    get getPlugin() {
      return this.$$.ctx[38];
    }
    get getState() {
      return this.$$.ctx[39];
    }
    get reset() {
      return this.$$.ctx[40];
    }
    get setFloatingAnchor() {
      return this.$$.ctx[41];
    }
    get setState() {
      return this.$$.ctx[42];
    }
    get verify() {
      return this.$$.ctx[43];
    }
  }
  customElements.define("altcha-widget", yn(
    Vn,
    { auto: {}, blockspam: {}, challengeurl: {}, challengejson: {}, debug: { type: "Boolean" }, delay: {}, expire: {}, floating: {}, floatinganchor: {}, floatingoffset: {}, hidefooter: { type: "Boolean" }, hidelogo: { type: "Boolean" }, name: {}, maxnumber: {}, mockerror: { type: "Boolean" }, obfuscated: {}, plugins: {}, refetchonexpire: { type: "Boolean" }, spamfilter: { type: "Boolean" }, strings: {}, test: { type: "Boolean" }, verifyurl: {}, workers: {}, workerurl: {} },
    ["default"],
    [
      "clarify",
      "configure",
      "getConfiguration",
      "getFloatingAnchor",
      "getPlugin",
      "getState",
      "reset",
      "setFloatingAnchor",
      "setState",
      "verify"
    ],
    false
  ));
  globalThis.altchaCreateWorker = (n2) => n2 ? new Worker(new URL(n2)) : new Pt();
  globalThis.altchaPlugins = globalThis.altchaPlugins || [];
  const _hoisted_1$1b = { class: "flex" };
  const _hoisted_2$_ = ["floating"];
  const _sfc_main$1e = /* @__PURE__ */ defineComponent({
    __name: "AltchaChallenge",
    props: {
      payload: {},
      isFloating: { type: Boolean, default: true }
    },
    emits: ["update:payload"],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emit2 = __emit;
      const altchaWidget = ref(null);
      const internalValue = ref(props.payload);
      watch(internalValue, (v2) => {
        emit2("update:payload", v2 || "");
      });
      const onStateChange = (ev) => {
        if ("detail" in ev) {
          const { payload, state } = ev.detail;
          if (state === "verified" && payload) {
            internalValue.value = payload;
          } else {
            internalValue.value = "";
          }
        }
      };
      onMounted(() => {
        if (altchaWidget.value) {
          altchaWidget.value.addEventListener("statechange", onStateChange);
        }
      });
      onUnmounted(() => {
        if (altchaWidget.value) {
          altchaWidget.value.removeEventListener("statechange", onStateChange);
        }
      });
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$1b, [
          createBaseVNode("altcha-widget", {
            ref_key: "altchaWidget",
            ref: altchaWidget,
            challengeurl: "/api/v2/altcha/challenge",
            name: "authenticity_payload",
            floating: _ctx.isFloating,
            floatinganchor: "bottom-right",
            hidelogo: "",
            hidefooter: "",
            class: ""
          }, null, 8, _hoisted_2$_)
        ]);
      };
    }
  });
  const _export_sfc = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
      target[key] = val;
    }
    return target;
  };
  const AltchaChallenge = /* @__PURE__ */ _export_sfc(_sfc_main$1e, [["__scopeId", "data-v-700a382d"]]);
  var isVue2 = false;
  /*!
   * pinia v2.2.2
   * (c) 2024 Eduardo San Martin Morote
   * @license MIT
   */
  let activePinia;
  const setActivePinia = (pinia) => activePinia = pinia;
  const piniaSymbol = (
    /* istanbul ignore next */
    Symbol()
  );
  function isPlainObject$1(o2) {
    return o2 && typeof o2 === "object" && Object.prototype.toString.call(o2) === "[object Object]" && typeof o2.toJSON !== "function";
  }
  var MutationType;
  (function(MutationType2) {
    MutationType2["direct"] = "direct";
    MutationType2["patchObject"] = "patch object";
    MutationType2["patchFunction"] = "patch function";
  })(MutationType || (MutationType = {}));
  function createPinia() {
    const scope = effectScope(true);
    const state = scope.run(() => ref({}));
    let _p = [];
    let toBeInstalled = [];
    const pinia = markRaw({
      install(app) {
        setActivePinia(pinia);
        {
          pinia._a = app;
          app.provide(piniaSymbol, pinia);
          app.config.globalProperties.$pinia = pinia;
          toBeInstalled.forEach((plugin) => _p.push(plugin));
          toBeInstalled = [];
        }
      },
      use(plugin) {
        if (!this._a && !isVue2) {
          toBeInstalled.push(plugin);
        } else {
          _p.push(plugin);
        }
        return this;
      },
      _p,
      // it's actually undefined here
      // @ts-expect-error
      _a: null,
      _e: scope,
      _s: /* @__PURE__ */ new Map(),
      state
    });
    return pinia;
  }
  const noop$2 = () => {
  };
  function addSubscription(subscriptions, callback, detached, onCleanup = noop$2) {
    subscriptions.push(callback);
    const removeSubscription = () => {
      const idx = subscriptions.indexOf(callback);
      if (idx > -1) {
        subscriptions.splice(idx, 1);
        onCleanup();
      }
    };
    if (!detached && getCurrentScope()) {
      onScopeDispose(removeSubscription);
    }
    return removeSubscription;
  }
  function triggerSubscriptions(subscriptions, ...args) {
    subscriptions.slice().forEach((callback) => {
      callback(...args);
    });
  }
  const fallbackRunWithContext = (fn2) => fn2();
  const ACTION_MARKER = Symbol();
  const ACTION_NAME = Symbol();
  function mergeReactiveObjects(target, patchToApply) {
    if (target instanceof Map && patchToApply instanceof Map) {
      patchToApply.forEach((value, key) => target.set(key, value));
    } else if (target instanceof Set && patchToApply instanceof Set) {
      patchToApply.forEach(target.add, target);
    }
    for (const key in patchToApply) {
      if (!patchToApply.hasOwnProperty(key))
        continue;
      const subPatch = patchToApply[key];
      const targetValue = target[key];
      if (isPlainObject$1(targetValue) && isPlainObject$1(subPatch) && target.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
        target[key] = mergeReactiveObjects(targetValue, subPatch);
      } else {
        target[key] = subPatch;
      }
    }
    return target;
  }
  const skipHydrateSymbol = (
    /* istanbul ignore next */
    Symbol()
  );
  function shouldHydrate(obj) {
    return !isPlainObject$1(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
  }
  const { assign: assign$1 } = Object;
  function isComputed(o2) {
    return !!(isRef(o2) && o2.effect);
  }
  function createOptionsStore(id, options, pinia, hot) {
    const { state, actions, getters } = options;
    const initialState = pinia.state.value[id];
    let store;
    function setup() {
      if (!initialState && true) {
        {
          pinia.state.value[id] = state ? state() : {};
        }
      }
      const localState = toRefs(pinia.state.value[id]);
      return assign$1(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
        computedGetters[name] = markRaw(computed(() => {
          setActivePinia(pinia);
          const store2 = pinia._s.get(id);
          return getters[name].call(store2, store2);
        }));
        return computedGetters;
      }, {}));
    }
    store = createSetupStore(id, setup, options, pinia, hot, true);
    return store;
  }
  function createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {
    let scope;
    const optionsForPlugin = assign$1({ actions: {} }, options);
    const $subscribeOptions = { deep: true };
    let isListening;
    let isSyncListening;
    let subscriptions = [];
    let actionSubscriptions = [];
    let debuggerEvents;
    const initialState = pinia.state.value[$id];
    if (!isOptionsStore && !initialState && true) {
      {
        pinia.state.value[$id] = {};
      }
    }
    ref({});
    let activeListener;
    function $patch(partialStateOrMutator) {
      let subscriptionMutation;
      isListening = isSyncListening = false;
      if (typeof partialStateOrMutator === "function") {
        partialStateOrMutator(pinia.state.value[$id]);
        subscriptionMutation = {
          type: MutationType.patchFunction,
          storeId: $id,
          events: debuggerEvents
        };
      } else {
        mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);
        subscriptionMutation = {
          type: MutationType.patchObject,
          payload: partialStateOrMutator,
          storeId: $id,
          events: debuggerEvents
        };
      }
      const myListenerId = activeListener = Symbol();
      nextTick().then(() => {
        if (activeListener === myListenerId) {
          isListening = true;
        }
      });
      isSyncListening = true;
      triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);
    }
    const $reset = isOptionsStore ? function $reset2() {
      const { state } = options;
      const newState = state ? state() : {};
      this.$patch(($state) => {
        assign$1($state, newState);
      });
    } : (
      /* istanbul ignore next */
      noop$2
    );
    function $dispose() {
      scope.stop();
      subscriptions = [];
      actionSubscriptions = [];
      pinia._s.delete($id);
    }
    const action = (fn2, name = "") => {
      if (ACTION_MARKER in fn2) {
        fn2[ACTION_NAME] = name;
        return fn2;
      }
      const wrappedAction = function() {
        setActivePinia(pinia);
        const args = Array.from(arguments);
        const afterCallbackList = [];
        const onErrorCallbackList = [];
        function after(callback) {
          afterCallbackList.push(callback);
        }
        function onError(callback) {
          onErrorCallbackList.push(callback);
        }
        triggerSubscriptions(actionSubscriptions, {
          args,
          name: wrappedAction[ACTION_NAME],
          store,
          after,
          onError
        });
        let ret;
        try {
          ret = fn2.apply(this && this.$id === $id ? this : store, args);
        } catch (error) {
          triggerSubscriptions(onErrorCallbackList, error);
          throw error;
        }
        if (ret instanceof Promise) {
          return ret.then((value) => {
            triggerSubscriptions(afterCallbackList, value);
            return value;
          }).catch((error) => {
            triggerSubscriptions(onErrorCallbackList, error);
            return Promise.reject(error);
          });
        }
        triggerSubscriptions(afterCallbackList, ret);
        return ret;
      };
      wrappedAction[ACTION_MARKER] = true;
      wrappedAction[ACTION_NAME] = name;
      return wrappedAction;
    };
    const partialStore = {
      _p: pinia,
      // _s: scope,
      $id,
      $onAction: addSubscription.bind(null, actionSubscriptions),
      $patch,
      $reset,
      $subscribe(callback, options2 = {}) {
        const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
        const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state) => {
          if (options2.flush === "sync" ? isSyncListening : isListening) {
            callback({
              storeId: $id,
              type: MutationType.direct,
              events: debuggerEvents
            }, state);
          }
        }, assign$1({}, $subscribeOptions, options2)));
        return removeSubscription;
      },
      $dispose
    };
    const store = reactive(partialStore);
    pinia._s.set($id, store);
    const runWithContext = pinia._a && pinia._a.runWithContext || fallbackRunWithContext;
    const setupStore = runWithContext(() => pinia._e.run(() => (scope = effectScope()).run(() => setup({ action }))));
    for (const key in setupStore) {
      const prop = setupStore[key];
      if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {
        if (!isOptionsStore) {
          if (initialState && shouldHydrate(prop)) {
            if (isRef(prop)) {
              prop.value = initialState[key];
            } else {
              mergeReactiveObjects(prop, initialState[key]);
            }
          }
          {
            pinia.state.value[$id][key] = prop;
          }
        }
      } else if (typeof prop === "function") {
        const actionValue = action(prop, key);
        {
          setupStore[key] = actionValue;
        }
        optionsForPlugin.actions[key] = prop;
      } else ;
    }
    {
      assign$1(store, setupStore);
      assign$1(toRaw(store), setupStore);
    }
    Object.defineProperty(store, "$state", {
      get: () => pinia.state.value[$id],
      set: (state) => {
        $patch(($state) => {
          assign$1($state, state);
        });
      }
    });
    pinia._p.forEach((extender) => {
      {
        assign$1(store, scope.run(() => extender({
          store,
          app: pinia._a,
          pinia,
          options: optionsForPlugin
        })));
      }
    });
    if (initialState && isOptionsStore && options.hydrate) {
      options.hydrate(store.$state, initialState);
    }
    isListening = true;
    isSyncListening = true;
    return store;
  }
  // @__NO_SIDE_EFFECTS__
  function defineStore(idOrOptions, setup, setupOptions) {
    let id;
    let options;
    const isSetupStore = typeof setup === "function";
    if (typeof idOrOptions === "string") {
      id = idOrOptions;
      options = isSetupStore ? setupOptions : setup;
    } else {
      options = idOrOptions;
      id = idOrOptions.id;
    }
    function useStore(pinia, hot) {
      const hasContext = hasInjectionContext();
      pinia = // in test mode, ignore the argument provided as we can always retrieve a
      // pinia instance with getActivePinia()
      pinia || (hasContext ? inject(piniaSymbol, null) : null);
      if (pinia)
        setActivePinia(pinia);
      pinia = activePinia;
      if (!pinia._s.has(id)) {
        if (isSetupStore) {
          createSetupStore(id, setup, options, pinia);
        } else {
          createOptionsStore(id, options, pinia);
        }
      }
      const store = pinia._s.get(id);
      return store;
    }
    useStore.$id = id;
    return useStore;
  }
  const useCsrfStore = /* @__PURE__ */ defineStore("csrf", {
    state: () => ({
      /** The current CSRF token */
      shrimp: window.shrimp || "",
      /** Whether the current token is valid */
      isValid: false,
      /** ID of the interval timer for periodic checks */
      checkInterval: null
    }),
    actions: {
      /**
       * Updates the CSRF token (shrimp).
       * @param {string} newShrimp - The new CSRF token.
       */
      updateShrimp(newShrimp) {
        this.shrimp = newShrimp;
        window.shrimp = newShrimp;
        this.isValid = true;
      },
      /**
       * Checks the validity of the current CSRF token with the server.
       *
       * Expected server API:
       * - Endpoint: '/api/v2/check-shrimp'
       * - Method: POST
       * - Headers:
       *   - 'Content-Type': 'application/json'
       *   - 'O-Shrimp': The current token
       * - Response: JSON object with `isValid` boolean property
       *
       * @example
       * // Server-side pseudocode (Python with Flask)
       * @app.route('/api/v2/check-shrimp', methods=['POST'])
       * def check_csrf_token():
       *     token = request.headers.get('O-Shrimp')
       *     is_valid = validate_csrf_token(token)  # Your validation logic
       *     return jsonify({'isValid': is_valid})
       */
      async checkShrimpValidity() {
        try {
          const response = await fetch("/api/v2/validate-shrimp", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "O-Shrimp": this.shrimp
            }
          });
          if (response.ok) {
            const data = await response.json();
            this.isValid = data.isValid;
            if (data == null ? void 0 : data.shrimp) {
              this.updateShrimp(data.shrimp);
            }
          } else {
            this.isValid = false;
          }
        } catch (error) {
          console.error("Failed to check CSRF token validity:", error);
          this.isValid = false;
        }
      },
      /**
       * Starts periodic checks of the CSRF token validity.
       * @param {number} intervalMs - The interval in milliseconds between checks. Defaults to 60000 (1 minute).
       */
      startPeriodicCheck(intervalMs = 6e4) {
        this.stopPeriodicCheck();
        this.checkInterval = window.setInterval(() => {
          this.checkShrimpValidity();
        }, intervalMs);
      },
      /**
       * Stops the periodic checks of the CSRF token validity.
       */
      stopPeriodicCheck() {
        if (this.checkInterval !== null) {
          clearInterval(this.checkInterval);
          this.checkInterval = null;
        }
      }
    }
  });
  const _hoisted_1$1a = { class: "container" };
  const _hoisted_2$Z = {
    class: "form form-inline",
    action: "/feedback",
    method: "post"
  };
  const _hoisted_3$T = /* @__PURE__ */ createBaseVNode("input", {
    type: "hidden",
    name: "utf8",
    value: "✓"
  }, null, -1);
  const _hoisted_4$L = ["value"];
  const _hoisted_5$J = { class: "flex mb-4" };
  const _hoisted_6$E = { class: "flex flex-grow" };
  const _hoisted_7$z = ["placeholder"];
  const _sfc_main$1d = /* @__PURE__ */ defineComponent({
    __name: "FeedbackForm",
    props: {
      enabled: { type: Boolean, default: true },
      showRedButton: { type: [Boolean, null], default: false }
    },
    setup(__props) {
      const csrfStore = useCsrfStore();
      const cust = window.cust;
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$1a, [
          createBaseVNode("form", _hoisted_2$Z, [
            _hoisted_3$T,
            createBaseVNode("input", {
              type: "hidden",
              name: "shrimp",
              value: unref(csrfStore).shrimp
            }, null, 8, _hoisted_4$L),
            createBaseVNode("div", _hoisted_5$J, [
              !unref(cust) ? (openBlock(), createBlock(AltchaChallenge, { key: 0 })) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_6$E, [
                createBaseVNode("input", {
                  type: "text",
                  name: "msg",
                  class: "flex-grow px-4 py-2 border border-gray-300 rounded-l-md focus:border-brandcomp-500 focus:ring-2 focus:ring-brandcomp-500 focus:outline-none dark:bg-gray-700 dark:border-gray-600 dark:text-gray-200",
                  autocomplete: "off",
                  placeholder: _ctx.$t("web.COMMON.feedback_text")
                }, null, 8, _hoisted_7$z),
                createBaseVNode("button", {
                  class: normalizeClass([
                    "px-4 py-2 font-medium text-white transition duration-150 ease-in-out rounded-r-md",
                    _ctx.showRedButton ? "bg-brand-500 hover:bg-brand-600" : "bg-gray-400 hover:bg-gray-500 dark:bg-gray-500 dark:hover:bg-gray-600"
                  ]),
                  type: "submit"
                }, toDisplayString(_ctx.$t("web.COMMON.button_send_feedback")), 3)
              ])
            ])
          ])
        ]);
      };
    }
  });
  function bind(fn2, thisArg) {
    return function wrap() {
      return fn2.apply(thisArg, arguments);
    };
  }
  const { toString } = Object.prototype;
  const { getPrototypeOf } = Object;
  const kindOf = /* @__PURE__ */ ((cache2) => (thing) => {
    const str = toString.call(thing);
    return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
  })(/* @__PURE__ */ Object.create(null));
  const kindOfTest = (type) => {
    type = type.toLowerCase();
    return (thing) => kindOf(thing) === type;
  };
  const typeOfTest = (type) => (thing) => typeof thing === type;
  const { isArray: isArray$1 } = Array;
  const isUndefined = typeOfTest("undefined");
  function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
  }
  const isArrayBuffer = kindOfTest("ArrayBuffer");
  function isArrayBufferView(val) {
    let result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
  }
  const isString = typeOfTest("string");
  const isFunction = typeOfTest("function");
  const isNumber = typeOfTest("number");
  const isObject = (thing) => thing !== null && typeof thing === "object";
  const isBoolean = (thing) => thing === true || thing === false;
  const isPlainObject = (val) => {
    if (kindOf(val) !== "object") {
      return false;
    }
    const prototype2 = getPrototypeOf(val);
    return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
  };
  const isDate = kindOfTest("Date");
  const isFile = kindOfTest("File");
  const isBlob = kindOfTest("Blob");
  const isFileList = kindOfTest("FileList");
  const isStream = (val) => isObject(val) && isFunction(val.pipe);
  const isFormData = (thing) => {
    let kind;
    return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
    kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
  };
  const isURLSearchParams = kindOfTest("URLSearchParams");
  const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
  const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  function forEach(obj, fn2, { allOwnKeys = false } = {}) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    let i2;
    let l2;
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray$1(obj)) {
      for (i2 = 0, l2 = obj.length; i2 < l2; i2++) {
        fn2.call(null, obj[i2], i2, obj);
      }
    } else {
      const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
      const len = keys.length;
      let key;
      for (i2 = 0; i2 < len; i2++) {
        key = keys[i2];
        fn2.call(null, obj[key], key, obj);
      }
    }
  }
  function findKey(obj, key) {
    key = key.toLowerCase();
    const keys = Object.keys(obj);
    let i2 = keys.length;
    let _key;
    while (i2-- > 0) {
      _key = keys[i2];
      if (key === _key.toLowerCase()) {
        return _key;
      }
    }
    return null;
  }
  const _global = (() => {
    if (typeof globalThis !== "undefined") return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
  })();
  const isContextDefined = (context) => !isUndefined(context) && context !== _global;
  function merge() {
    const { caseless } = isContextDefined(this) && this || {};
    const result = {};
    const assignValue = (val, key) => {
      const targetKey = caseless && findKey(result, key) || key;
      if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
        result[targetKey] = merge(result[targetKey], val);
      } else if (isPlainObject(val)) {
        result[targetKey] = merge({}, val);
      } else if (isArray$1(val)) {
        result[targetKey] = val.slice();
      } else {
        result[targetKey] = val;
      }
    };
    for (let i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
      arguments[i2] && forEach(arguments[i2], assignValue);
    }
    return result;
  }
  const extend = (a2, b2, thisArg, { allOwnKeys } = {}) => {
    forEach(b2, (val, key) => {
      if (thisArg && isFunction(val)) {
        a2[key] = bind(val, thisArg);
      } else {
        a2[key] = val;
      }
    }, { allOwnKeys });
    return a2;
  };
  const stripBOM = (content) => {
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  };
  const inherits = (constructor, superConstructor, props, descriptors2) => {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, "super", {
      value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
  };
  const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
    let props;
    let i2;
    let prop;
    const merged = {};
    destObj = destObj || {};
    if (sourceObj == null) return destObj;
    do {
      props = Object.getOwnPropertyNames(sourceObj);
      i2 = props.length;
      while (i2-- > 0) {
        prop = props[i2];
        if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
          destObj[prop] = sourceObj[prop];
          merged[prop] = true;
        }
      }
      sourceObj = filter !== false && getPrototypeOf(sourceObj);
    } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
  };
  const endsWith = (str, searchString, position) => {
    str = String(str);
    if (position === void 0 || position > str.length) {
      position = str.length;
    }
    position -= searchString.length;
    const lastIndex = str.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
  };
  const toArray = (thing) => {
    if (!thing) return null;
    if (isArray$1(thing)) return thing;
    let i2 = thing.length;
    if (!isNumber(i2)) return null;
    const arr = new Array(i2);
    while (i2-- > 0) {
      arr[i2] = thing[i2];
    }
    return arr;
  };
  const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
    return (thing) => {
      return TypedArray && thing instanceof TypedArray;
    };
  })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
  const forEachEntry = (obj, fn2) => {
    const generator = obj && obj[Symbol.iterator];
    const iterator = generator.call(obj);
    let result;
    while ((result = iterator.next()) && !result.done) {
      const pair = result.value;
      fn2.call(obj, pair[0], pair[1]);
    }
  };
  const matchAll = (regExp, str) => {
    let matches2;
    const arr = [];
    while ((matches2 = regExp.exec(str)) !== null) {
      arr.push(matches2);
    }
    return arr;
  };
  const isHTMLForm = kindOfTest("HTMLFormElement");
  const toCamelCase = (str) => {
    return str.toLowerCase().replace(
      /[-_\s]([a-z\d])(\w*)/g,
      function replacer2(m2, p1, p2) {
        return p1.toUpperCase() + p2;
      }
    );
  };
  const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
  const isRegExp = kindOfTest("RegExp");
  const reduceDescriptors = (obj, reducer) => {
    const descriptors2 = Object.getOwnPropertyDescriptors(obj);
    const reducedDescriptors = {};
    forEach(descriptors2, (descriptor, name) => {
      let ret;
      if ((ret = reducer(descriptor, name, obj)) !== false) {
        reducedDescriptors[name] = ret || descriptor;
      }
    });
    Object.defineProperties(obj, reducedDescriptors);
  };
  const freezeMethods = (obj) => {
    reduceDescriptors(obj, (descriptor, name) => {
      if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
        return false;
      }
      const value = obj[name];
      if (!isFunction(value)) return;
      descriptor.enumerable = false;
      if ("writable" in descriptor) {
        descriptor.writable = false;
        return;
      }
      if (!descriptor.set) {
        descriptor.set = () => {
          throw Error("Can not rewrite read-only method '" + name + "'");
        };
      }
    });
  };
  const toObjectSet = (arrayOrString, delimiter) => {
    const obj = {};
    const define2 = (arr) => {
      arr.forEach((value) => {
        obj[value] = true;
      });
    };
    isArray$1(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
    return obj;
  };
  const noop$1 = () => {
  };
  const toFiniteNumber = (value, defaultValue) => {
    return value != null && Number.isFinite(value = +value) ? value : defaultValue;
  };
  const ALPHA = "abcdefghijklmnopqrstuvwxyz";
  const DIGIT = "0123456789";
  const ALPHABET = {
    DIGIT,
    ALPHA,
    ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
  };
  const generateString = (size2 = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
    let str = "";
    const { length } = alphabet;
    while (size2--) {
      str += alphabet[Math.random() * length | 0];
    }
    return str;
  };
  function isSpecCompliantForm(thing) {
    return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
  }
  const toJSONObject = (obj) => {
    const stack2 = new Array(10);
    const visit = (source, i2) => {
      if (isObject(source)) {
        if (stack2.indexOf(source) >= 0) {
          return;
        }
        if (!("toJSON" in source)) {
          stack2[i2] = source;
          const target = isArray$1(source) ? [] : {};
          forEach(source, (value, key) => {
            const reducedValue = visit(value, i2 + 1);
            !isUndefined(reducedValue) && (target[key] = reducedValue);
          });
          stack2[i2] = void 0;
          return target;
        }
      }
      return source;
    };
    return visit(obj, 0);
  };
  const isAsyncFn = kindOfTest("AsyncFunction");
  const isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
  const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
    if (setImmediateSupported) {
      return setImmediate;
    }
    return postMessageSupported ? ((token, callbacks) => {
      _global.addEventListener("message", ({ source, data }) => {
        if (source === _global && data === token) {
          callbacks.length && callbacks.shift()();
        }
      }, false);
      return (cb) => {
        callbacks.push(cb);
        _global.postMessage(token, "*");
      };
    })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
  })(
    typeof setImmediate === "function",
    isFunction(_global.postMessage)
  );
  const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
  const utils$1 = {
    isArray: isArray$1,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isBoolean,
    isObject,
    isPlainObject,
    isReadableStream,
    isRequest,
    isResponse,
    isHeaders,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isRegExp,
    isFunction,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge,
    extend,
    trim,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty,
    hasOwnProp: hasOwnProperty,
    // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop: noop$1,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    ALPHABET,
    generateString,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable,
    setImmediate: _setImmediate,
    asap
  };
  function AxiosError(message, code, config, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack;
    }
    this.message = message;
    this.name = "AxiosError";
    code && (this.code = code);
    config && (this.config = config);
    request && (this.request = request);
    if (response) {
      this.response = response;
      this.status = response.status ? response.status : null;
    }
  }
  utils$1.inherits(AxiosError, Error, {
    toJSON: function toJSON() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: utils$1.toJSONObject(this.config),
        code: this.code,
        status: this.status
      };
    }
  });
  const prototype$1 = AxiosError.prototype;
  const descriptors = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
    // eslint-disable-next-line func-names
  ].forEach((code) => {
    descriptors[code] = { value: code };
  });
  Object.defineProperties(AxiosError, descriptors);
  Object.defineProperty(prototype$1, "isAxiosError", { value: true });
  AxiosError.from = (error, code, config, request, response, customProps) => {
    const axiosError = Object.create(prototype$1);
    utils$1.toFlatObject(error, axiosError, function filter(obj) {
      return obj !== Error.prototype;
    }, (prop) => {
      return prop !== "isAxiosError";
    });
    AxiosError.call(axiosError, error.message, code, config, request, response);
    axiosError.cause = error;
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
  };
  const httpAdapter = null;
  function isVisitable(thing) {
    return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
  }
  function removeBrackets(key) {
    return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
  }
  function renderKey(path, key, dots) {
    if (!path) return key;
    return path.concat(key).map(function each(token, i2) {
      token = removeBrackets(token);
      return !dots && i2 ? "[" + token + "]" : token;
    }).join(dots ? "." : "");
  }
  function isFlatArray(arr) {
    return utils$1.isArray(arr) && !arr.some(isVisitable);
  }
  const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
    return /^is[A-Z]/.test(prop);
  });
  function toFormData(obj, formData, options) {
    if (!utils$1.isObject(obj)) {
      throw new TypeError("target must be an object");
    }
    formData = formData || new FormData();
    options = utils$1.toFlatObject(options, {
      metaTokens: true,
      dots: false,
      indexes: false
    }, false, function defined(option, source) {
      return !utils$1.isUndefined(source[option]);
    });
    const metaTokens = options.metaTokens;
    const visitor = options.visitor || defaultVisitor;
    const dots = options.dots;
    const indexes = options.indexes;
    const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
    const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
    if (!utils$1.isFunction(visitor)) {
      throw new TypeError("visitor must be a function");
    }
    function convertValue(value) {
      if (value === null) return "";
      if (utils$1.isDate(value)) {
        return value.toISOString();
      }
      if (!useBlob && utils$1.isBlob(value)) {
        throw new AxiosError("Blob is not supported. Use a Buffer instead.");
      }
      if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
        return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
      }
      return value;
    }
    function defaultVisitor(value, key, path) {
      let arr = value;
      if (value && !path && typeof value === "object") {
        if (utils$1.endsWith(key, "{}")) {
          key = metaTokens ? key : key.slice(0, -2);
          value = JSON.stringify(value);
        } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
          key = removeBrackets(key);
          arr.forEach(function each(el, index) {
            !(utils$1.isUndefined(el) || el === null) && formData.append(
              // eslint-disable-next-line no-nested-ternary
              indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
              convertValue(el)
            );
          });
          return false;
        }
      }
      if (isVisitable(value)) {
        return true;
      }
      formData.append(renderKey(path, key, dots), convertValue(value));
      return false;
    }
    const stack2 = [];
    const exposedHelpers = Object.assign(predicates, {
      defaultVisitor,
      convertValue,
      isVisitable
    });
    function build(value, path) {
      if (utils$1.isUndefined(value)) return;
      if (stack2.indexOf(value) !== -1) {
        throw Error("Circular reference detected in " + path.join("."));
      }
      stack2.push(value);
      utils$1.forEach(value, function each(el, key) {
        const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
          formData,
          el,
          utils$1.isString(key) ? key.trim() : key,
          path,
          exposedHelpers
        );
        if (result === true) {
          build(el, path ? path.concat(key) : [key]);
        }
      });
      stack2.pop();
    }
    if (!utils$1.isObject(obj)) {
      throw new TypeError("data must be an object");
    }
    build(obj);
    return formData;
  }
  function encode$1(str) {
    const charMap = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0"
    };
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer2(match) {
      return charMap[match];
    });
  }
  function AxiosURLSearchParams(params, options) {
    this._pairs = [];
    params && toFormData(params, this, options);
  }
  const prototype = AxiosURLSearchParams.prototype;
  prototype.append = function append(name, value) {
    this._pairs.push([name, value]);
  };
  prototype.toString = function toString2(encoder) {
    const _encode = encoder ? function(value) {
      return encoder.call(this, value, encode$1);
    } : encode$1;
    return this._pairs.map(function each(pair) {
      return _encode(pair[0]) + "=" + _encode(pair[1]);
    }, "").join("&");
  };
  function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  function buildURL(url, params, options) {
    if (!params) {
      return url;
    }
    const _encode = options && options.encode || encode;
    const serializeFn = options && options.serialize;
    let serializedParams;
    if (serializeFn) {
      serializedParams = serializeFn(params, options);
    } else {
      serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
    }
    if (serializedParams) {
      const hashmarkIndex = url.indexOf("#");
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
  }
  class InterceptorManager {
    constructor() {
      this.handlers = [];
    }
    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    }
    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     *
     * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
     */
    eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    }
    /**
     * Clear all interceptors from the stack
     *
     * @returns {void}
     */
    clear() {
      if (this.handlers) {
        this.handlers = [];
      }
    }
    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     *
     * @returns {void}
     */
    forEach(fn2) {
      utils$1.forEach(this.handlers, function forEachHandler(h2) {
        if (h2 !== null) {
          fn2(h2);
        }
      });
    }
  }
  const transitionalDefaults = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  };
  const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
  const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
  const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
  const platform$1 = {
    isBrowser: true,
    classes: {
      URLSearchParams: URLSearchParams$1,
      FormData: FormData$1,
      Blob: Blob$1
    },
    protocols: ["http", "https", "file", "blob", "url", "data"]
  };
  const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
  const _navigator = typeof navigator === "object" && navigator || void 0;
  const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
  const hasStandardBrowserWebWorkerEnv = (() => {
    return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
  })();
  const origin = hasBrowserEnv && window.location.href || "http://localhost";
  const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    hasBrowserEnv,
    hasStandardBrowserEnv,
    hasStandardBrowserWebWorkerEnv,
    navigator: _navigator,
    origin
  }, Symbol.toStringTag, { value: "Module" }));
  const platform = {
    ...utils,
    ...platform$1
  };
  function toURLEncodedForm(data, options) {
    return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
      visitor: function(value, key, path, helpers) {
        if (platform.isNode && utils$1.isBuffer(value)) {
          this.append(key, value.toString("base64"));
          return false;
        }
        return helpers.defaultVisitor.apply(this, arguments);
      }
    }, options));
  }
  function parsePropPath(name) {
    return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
      return match[0] === "[]" ? "" : match[1] || match[0];
    });
  }
  function arrayToObject(arr) {
    const obj = {};
    const keys = Object.keys(arr);
    let i2;
    const len = keys.length;
    let key;
    for (i2 = 0; i2 < len; i2++) {
      key = keys[i2];
      obj[key] = arr[key];
    }
    return obj;
  }
  function formDataToJSON(formData) {
    function buildPath(path, value, target, index) {
      let name = path[index++];
      if (name === "__proto__") return true;
      const isNumericKey = Number.isFinite(+name);
      const isLast = index >= path.length;
      name = !name && utils$1.isArray(target) ? target.length : name;
      if (isLast) {
        if (utils$1.hasOwnProp(target, name)) {
          target[name] = [target[name], value];
        } else {
          target[name] = value;
        }
        return !isNumericKey;
      }
      if (!target[name] || !utils$1.isObject(target[name])) {
        target[name] = [];
      }
      const result = buildPath(path, value, target[name], index);
      if (result && utils$1.isArray(target[name])) {
        target[name] = arrayToObject(target[name]);
      }
      return !isNumericKey;
    }
    if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
      const obj = {};
      utils$1.forEachEntry(formData, (name, value) => {
        buildPath(parsePropPath(name), value, obj, 0);
      });
      return obj;
    }
    return null;
  }
  function stringifySafely(rawValue, parser, encoder) {
    if (utils$1.isString(rawValue)) {
      try {
        (parser || JSON.parse)(rawValue);
        return utils$1.trim(rawValue);
      } catch (e2) {
        if (e2.name !== "SyntaxError") {
          throw e2;
        }
      }
    }
    return (encoder || JSON.stringify)(rawValue);
  }
  const defaults = {
    transitional: transitionalDefaults,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function transformRequest(data, headers) {
      const contentType = headers.getContentType() || "";
      const hasJSONContentType = contentType.indexOf("application/json") > -1;
      const isObjectPayload = utils$1.isObject(data);
      if (isObjectPayload && utils$1.isHTMLForm(data)) {
        data = new FormData(data);
      }
      const isFormData2 = utils$1.isFormData(data);
      if (isFormData2) {
        return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
      }
      if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
        return data;
      }
      if (utils$1.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils$1.isURLSearchParams(data)) {
        headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
        return data.toString();
      }
      let isFileList2;
      if (isObjectPayload) {
        if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
          return toURLEncodedForm(data, this.formSerializer).toString();
        }
        if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
          const _FormData = this.env && this.env.FormData;
          return toFormData(
            isFileList2 ? { "files[]": data } : data,
            _FormData && new _FormData(),
            this.formSerializer
          );
        }
      }
      if (isObjectPayload || hasJSONContentType) {
        headers.setContentType("application/json", false);
        return stringifySafely(data);
      }
      return data;
    }],
    transformResponse: [function transformResponse(data) {
      const transitional = this.transitional || defaults.transitional;
      const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
      const JSONRequested = this.responseType === "json";
      if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
        return data;
      }
      if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
        const silentJSONParsing = transitional && transitional.silentJSONParsing;
        const strictJSONParsing = !silentJSONParsing && JSONRequested;
        try {
          return JSON.parse(data);
        } catch (e2) {
          if (strictJSONParsing) {
            if (e2.name === "SyntaxError") {
              throw AxiosError.from(e2, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
            }
            throw e2;
          }
        }
      }
      return data;
    }],
    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: platform.classes.FormData,
      Blob: platform.classes.Blob
    },
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },
    headers: {
      common: {
        "Accept": "application/json, text/plain, */*",
        "Content-Type": void 0
      }
    }
  };
  utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
    defaults.headers[method] = {};
  });
  const ignoreDuplicateOf = utils$1.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ]);
  const parseHeaders = (rawHeaders) => {
    const parsed = {};
    let key;
    let val;
    let i2;
    rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
      i2 = line.indexOf(":");
      key = line.substring(0, i2).trim().toLowerCase();
      val = line.substring(i2 + 1).trim();
      if (!key || parsed[key] && ignoreDuplicateOf[key]) {
        return;
      }
      if (key === "set-cookie") {
        if (parsed[key]) {
          parsed[key].push(val);
        } else {
          parsed[key] = [val];
        }
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
      }
    });
    return parsed;
  };
  const $internals = Symbol("internals");
  function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
  }
  function normalizeValue(value) {
    if (value === false || value == null) {
      return value;
    }
    return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
  }
  function parseTokens(str) {
    const tokens = /* @__PURE__ */ Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match;
    while (match = tokensRE.exec(str)) {
      tokens[match[1]] = match[2];
    }
    return tokens;
  }
  const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
  function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
    if (utils$1.isFunction(filter)) {
      return filter.call(this, value, header);
    }
    if (isHeaderNameFilter) {
      value = header;
    }
    if (!utils$1.isString(value)) return;
    if (utils$1.isString(filter)) {
      return value.indexOf(filter) !== -1;
    }
    if (utils$1.isRegExp(filter)) {
      return filter.test(value);
    }
  }
  function formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str) => {
      return char.toUpperCase() + str;
    });
  }
  function buildAccessors(obj, header) {
    const accessorName = utils$1.toCamelCase(" " + header);
    ["get", "set", "has"].forEach((methodName) => {
      Object.defineProperty(obj, methodName + accessorName, {
        value: function(arg1, arg2, arg3) {
          return this[methodName].call(this, header, arg1, arg2, arg3);
        },
        configurable: true
      });
    });
  }
  class AxiosHeaders {
    constructor(headers) {
      headers && this.set(headers);
    }
    set(header, valueOrRewrite, rewrite) {
      const self2 = this;
      function setHeader(_value, _header, _rewrite) {
        const lHeader = normalizeHeader(_header);
        if (!lHeader) {
          throw new Error("header name must be a non-empty string");
        }
        const key = utils$1.findKey(self2, lHeader);
        if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
          self2[key || _header] = normalizeValue(_value);
        }
      }
      const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
      if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
        setHeaders(header, valueOrRewrite);
      } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
        setHeaders(parseHeaders(header), valueOrRewrite);
      } else if (utils$1.isHeaders(header)) {
        for (const [key, value] of header.entries()) {
          setHeader(value, key, rewrite);
        }
      } else {
        header != null && setHeader(valueOrRewrite, header, rewrite);
      }
      return this;
    }
    get(header, parser) {
      header = normalizeHeader(header);
      if (header) {
        const key = utils$1.findKey(this, header);
        if (key) {
          const value = this[key];
          if (!parser) {
            return value;
          }
          if (parser === true) {
            return parseTokens(value);
          }
          if (utils$1.isFunction(parser)) {
            return parser.call(this, value, key);
          }
          if (utils$1.isRegExp(parser)) {
            return parser.exec(value);
          }
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(header, matcher) {
      header = normalizeHeader(header);
      if (header) {
        const key = utils$1.findKey(this, header);
        return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
      }
      return false;
    }
    delete(header, matcher) {
      const self2 = this;
      let deleted = false;
      function deleteHeader(_header) {
        _header = normalizeHeader(_header);
        if (_header) {
          const key = utils$1.findKey(self2, _header);
          if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
            delete self2[key];
            deleted = true;
          }
        }
      }
      if (utils$1.isArray(header)) {
        header.forEach(deleteHeader);
      } else {
        deleteHeader(header);
      }
      return deleted;
    }
    clear(matcher) {
      const keys = Object.keys(this);
      let i2 = keys.length;
      let deleted = false;
      while (i2--) {
        const key = keys[i2];
        if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
          delete this[key];
          deleted = true;
        }
      }
      return deleted;
    }
    normalize(format2) {
      const self2 = this;
      const headers = {};
      utils$1.forEach(this, (value, header) => {
        const key = utils$1.findKey(headers, header);
        if (key) {
          self2[key] = normalizeValue(value);
          delete self2[header];
          return;
        }
        const normalized = format2 ? formatHeader(header) : String(header).trim();
        if (normalized !== header) {
          delete self2[header];
        }
        self2[normalized] = normalizeValue(value);
        headers[normalized] = true;
      });
      return this;
    }
    concat(...targets) {
      return this.constructor.concat(this, ...targets);
    }
    toJSON(asStrings) {
      const obj = /* @__PURE__ */ Object.create(null);
      utils$1.forEach(this, (value, header) => {
        value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
      });
      return obj;
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(thing) {
      return thing instanceof this ? thing : new this(thing);
    }
    static concat(first, ...targets) {
      const computed2 = new this(first);
      targets.forEach((target) => computed2.set(target));
      return computed2;
    }
    static accessor(header) {
      const internals = this[$internals] = this[$internals] = {
        accessors: {}
      };
      const accessors = internals.accessors;
      const prototype2 = this.prototype;
      function defineAccessor(_header) {
        const lHeader = normalizeHeader(_header);
        if (!accessors[lHeader]) {
          buildAccessors(prototype2, _header);
          accessors[lHeader] = true;
        }
      }
      utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
      return this;
    }
  }
  AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
  utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
    let mapped = key[0].toUpperCase() + key.slice(1);
    return {
      get: () => value,
      set(headerValue) {
        this[mapped] = headerValue;
      }
    };
  });
  utils$1.freezeMethods(AxiosHeaders);
  function transformData(fns, response) {
    const config = this || defaults;
    const context = response || config;
    const headers = AxiosHeaders.from(context.headers);
    let data = context.data;
    utils$1.forEach(fns, function transform2(fn2) {
      data = fn2.call(config, data, headers.normalize(), response ? response.status : void 0);
    });
    headers.normalize();
    return data;
  }
  function isCancel(value) {
    return !!(value && value.__CANCEL__);
  }
  function CanceledError(message, config, request) {
    AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
    this.name = "CanceledError";
  }
  utils$1.inherits(CanceledError, AxiosError, {
    __CANCEL__: true
  });
  function settle(resolve2, reject, response) {
    const validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve2(response);
    } else {
      reject(new AxiosError(
        "Request failed with status code " + response.status,
        [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  }
  function parseProtocol(url) {
    const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || "";
  }
  function speedometer(samplesCount, min) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;
    min = min !== void 0 ? min : 1e3;
    return function push(chunkLength) {
      const now = Date.now();
      const startedAt = timestamps[tail];
      if (!firstSampleTS) {
        firstSampleTS = now;
      }
      bytes[head] = chunkLength;
      timestamps[head] = now;
      let i2 = tail;
      let bytesCount = 0;
      while (i2 !== head) {
        bytesCount += bytes[i2++];
        i2 = i2 % samplesCount;
      }
      head = (head + 1) % samplesCount;
      if (head === tail) {
        tail = (tail + 1) % samplesCount;
      }
      if (now - firstSampleTS < min) {
        return;
      }
      const passed = startedAt && now - startedAt;
      return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
    };
  }
  function throttle(fn2, freq) {
    let timestamp = 0;
    let threshold = 1e3 / freq;
    let lastArgs;
    let timer;
    const invoke = (args, now = Date.now()) => {
      timestamp = now;
      lastArgs = null;
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      fn2.apply(null, args);
    };
    const throttled = (...args) => {
      const now = Date.now();
      const passed = now - timestamp;
      if (passed >= threshold) {
        invoke(args, now);
      } else {
        lastArgs = args;
        if (!timer) {
          timer = setTimeout(() => {
            timer = null;
            invoke(lastArgs);
          }, threshold - passed);
        }
      }
    };
    const flush = () => lastArgs && invoke(lastArgs);
    return [throttled, flush];
  }
  const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
    let bytesNotified = 0;
    const _speedometer = speedometer(50, 250);
    return throttle((e2) => {
      const loaded = e2.loaded;
      const total = e2.lengthComputable ? e2.total : void 0;
      const progressBytes = loaded - bytesNotified;
      const rate = _speedometer(progressBytes);
      const inRange = loaded <= total;
      bytesNotified = loaded;
      const data = {
        loaded,
        total,
        progress: total ? loaded / total : void 0,
        bytes: progressBytes,
        rate: rate ? rate : void 0,
        estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
        event: e2,
        lengthComputable: total != null,
        [isDownloadStream ? "download" : "upload"]: true
      };
      listener(data);
    }, freq);
  };
  const progressEventDecorator = (total, throttled) => {
    const lengthComputable = total != null;
    return [(loaded) => throttled[0]({
      lengthComputable,
      total,
      loaded
    }), throttled[1]];
  };
  const asyncDecorator = (fn2) => (...args) => utils$1.asap(() => fn2(...args));
  const isURLSameOrigin = platform.hasStandardBrowserEnv ? (
    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
    function standardBrowserEnv() {
      const msie = platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent);
      const urlParsingNode = document.createElement("a");
      let originURL;
      function resolveURL(url) {
        let href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin2(requestURL) {
        const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }()
  ) : (
    // Non standard browser envs (web workers, react-native) lack needed support.
    /* @__PURE__ */ function nonStandardBrowserEnv() {
      return function isURLSameOrigin2() {
        return true;
      };
    }()
  );
  const cookies = platform.hasStandardBrowserEnv ? (
    // Standard browser envs support document.cookie
    {
      write(name, value, expires, path, domain, secure) {
        const cookie = [name + "=" + encodeURIComponent(value)];
        utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
        utils$1.isString(path) && cookie.push("path=" + path);
        utils$1.isString(domain) && cookie.push("domain=" + domain);
        secure === true && cookie.push("secure");
        document.cookie = cookie.join("; ");
      },
      read(name) {
        const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove(name) {
        this.write(name, "", Date.now() - 864e5);
      }
    }
  ) : (
    // Non-standard browser env (web workers, react-native) lack needed support.
    {
      write() {
      },
      read() {
        return null;
      },
      remove() {
      }
    }
  );
  function isAbsoluteURL(url) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
  }
  function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  }
  function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL(requestedURL)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  }
  const headersToObject = (thing) => thing instanceof AxiosHeaders ? { ...thing } : thing;
  function mergeConfig(config1, config2) {
    config2 = config2 || {};
    const config = {};
    function getMergedValue(target, source, caseless) {
      if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
        return utils$1.merge.call({ caseless }, target, source);
      } else if (utils$1.isPlainObject(source)) {
        return utils$1.merge({}, source);
      } else if (utils$1.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(a2, b2, caseless) {
      if (!utils$1.isUndefined(b2)) {
        return getMergedValue(a2, b2, caseless);
      } else if (!utils$1.isUndefined(a2)) {
        return getMergedValue(void 0, a2, caseless);
      }
    }
    function valueFromConfig2(a2, b2) {
      if (!utils$1.isUndefined(b2)) {
        return getMergedValue(void 0, b2);
      }
    }
    function defaultToConfig2(a2, b2) {
      if (!utils$1.isUndefined(b2)) {
        return getMergedValue(void 0, b2);
      } else if (!utils$1.isUndefined(a2)) {
        return getMergedValue(void 0, a2);
      }
    }
    function mergeDirectKeys(a2, b2, prop) {
      if (prop in config2) {
        return getMergedValue(a2, b2);
      } else if (prop in config1) {
        return getMergedValue(void 0, a2);
      }
    }
    const mergeMap = {
      url: valueFromConfig2,
      method: valueFromConfig2,
      data: valueFromConfig2,
      baseURL: defaultToConfig2,
      transformRequest: defaultToConfig2,
      transformResponse: defaultToConfig2,
      paramsSerializer: defaultToConfig2,
      timeout: defaultToConfig2,
      timeoutMessage: defaultToConfig2,
      withCredentials: defaultToConfig2,
      withXSRFToken: defaultToConfig2,
      adapter: defaultToConfig2,
      responseType: defaultToConfig2,
      xsrfCookieName: defaultToConfig2,
      xsrfHeaderName: defaultToConfig2,
      onUploadProgress: defaultToConfig2,
      onDownloadProgress: defaultToConfig2,
      decompress: defaultToConfig2,
      maxContentLength: defaultToConfig2,
      maxBodyLength: defaultToConfig2,
      beforeRedirect: defaultToConfig2,
      transport: defaultToConfig2,
      httpAgent: defaultToConfig2,
      httpsAgent: defaultToConfig2,
      cancelToken: defaultToConfig2,
      socketPath: defaultToConfig2,
      responseEncoding: defaultToConfig2,
      validateStatus: mergeDirectKeys,
      headers: (a2, b2) => mergeDeepProperties(headersToObject(a2), headersToObject(b2), true)
    };
    utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
      const merge2 = mergeMap[prop] || mergeDeepProperties;
      const configValue = merge2(config1[prop], config2[prop], prop);
      utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
  }
  const resolveConfig = (config) => {
    const newConfig = mergeConfig({}, config);
    let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
    newConfig.headers = headers = AxiosHeaders.from(headers);
    newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config.params, config.paramsSerializer);
    if (auth) {
      headers.set(
        "Authorization",
        "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
      );
    }
    let contentType;
    if (utils$1.isFormData(data)) {
      if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
        headers.setContentType(void 0);
      } else if ((contentType = headers.getContentType()) !== false) {
        const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
        headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
      }
    }
    if (platform.hasStandardBrowserEnv) {
      withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
      if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
        const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
        if (xsrfValue) {
          headers.set(xsrfHeaderName, xsrfValue);
        }
      }
    }
    return newConfig;
  };
  const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
  const xhrAdapter = isXHRAdapterSupported && function(config) {
    return new Promise(function dispatchXhrRequest(resolve2, reject) {
      const _config = resolveConfig(config);
      let requestData = _config.data;
      const requestHeaders = AxiosHeaders.from(_config.headers).normalize();
      let { responseType, onUploadProgress, onDownloadProgress } = _config;
      let onCanceled;
      let uploadThrottled, downloadThrottled;
      let flushUpload, flushDownload;
      function done() {
        flushUpload && flushUpload();
        flushDownload && flushDownload();
        _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
        _config.signal && _config.signal.removeEventListener("abort", onCanceled);
      }
      let request = new XMLHttpRequest();
      request.open(_config.method.toUpperCase(), _config.url, true);
      request.timeout = _config.timeout;
      function onloadend() {
        if (!request) {
          return;
        }
        const responseHeaders = AxiosHeaders.from(
          "getAllResponseHeaders" in request && request.getAllResponseHeaders()
        );
        const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
        const response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config,
          request
        };
        settle(function _resolve(value) {
          resolve2(value);
          done();
        }, function _reject(err) {
          reject(err);
          done();
        }, response);
        request = null;
      }
      if ("onloadend" in request) {
        request.onloadend = onloadend;
      } else {
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }
        reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
        request = null;
      };
      request.onerror = function handleError2() {
        reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
        request = null;
      };
      request.ontimeout = function handleTimeout() {
        let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
        const transitional = _config.transitional || transitionalDefaults;
        if (_config.timeoutErrorMessage) {
          timeoutErrorMessage = _config.timeoutErrorMessage;
        }
        reject(new AxiosError(
          timeoutErrorMessage,
          transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
          config,
          request
        ));
        request = null;
      };
      requestData === void 0 && requestHeaders.setContentType(null);
      if ("setRequestHeader" in request) {
        utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
          request.setRequestHeader(key, val);
        });
      }
      if (!utils$1.isUndefined(_config.withCredentials)) {
        request.withCredentials = !!_config.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request.responseType = _config.responseType;
      }
      if (onDownloadProgress) {
        [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
        request.addEventListener("progress", downloadThrottled);
      }
      if (onUploadProgress && request.upload) {
        [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
        request.upload.addEventListener("progress", uploadThrottled);
        request.upload.addEventListener("loadend", flushUpload);
      }
      if (_config.cancelToken || _config.signal) {
        onCanceled = (cancel) => {
          if (!request) {
            return;
          }
          reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
          request.abort();
          request = null;
        };
        _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
        if (_config.signal) {
          _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
        }
      }
      const protocol = parseProtocol(_config.url);
      if (protocol && platform.protocols.indexOf(protocol) === -1) {
        reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
        return;
      }
      request.send(requestData || null);
    });
  };
  const composeSignals = (signals, timeout) => {
    const { length } = signals = signals ? signals.filter(Boolean) : [];
    if (timeout || length) {
      let controller = new AbortController();
      let aborted;
      const onabort = function(reason) {
        if (!aborted) {
          aborted = true;
          unsubscribe();
          const err = reason instanceof Error ? reason : this.reason;
          controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
        }
      };
      let timer = timeout && setTimeout(() => {
        timer = null;
        onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
      }, timeout);
      const unsubscribe = () => {
        if (signals) {
          timer && clearTimeout(timer);
          timer = null;
          signals.forEach((signal2) => {
            signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
          });
          signals = null;
        }
      };
      signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
      const { signal } = controller;
      signal.unsubscribe = () => utils$1.asap(unsubscribe);
      return signal;
    }
  };
  const streamChunk = function* (chunk, chunkSize) {
    let len = chunk.byteLength;
    if (!chunkSize || len < chunkSize) {
      yield chunk;
      return;
    }
    let pos = 0;
    let end;
    while (pos < len) {
      end = pos + chunkSize;
      yield chunk.slice(pos, end);
      pos = end;
    }
  };
  const readBytes = async function* (iterable, chunkSize) {
    for await (const chunk of readStream(iterable)) {
      yield* streamChunk(chunk, chunkSize);
    }
  };
  const readStream = async function* (stream) {
    if (stream[Symbol.asyncIterator]) {
      yield* stream;
      return;
    }
    const reader = stream.getReader();
    try {
      for (; ; ) {
        const { done, value } = await reader.read();
        if (done) {
          break;
        }
        yield value;
      }
    } finally {
      await reader.cancel();
    }
  };
  const trackStream = (stream, chunkSize, onProgress, onFinish) => {
    const iterator = readBytes(stream, chunkSize);
    let bytes = 0;
    let done;
    let _onFinish = (e2) => {
      if (!done) {
        done = true;
        onFinish && onFinish(e2);
      }
    };
    return new ReadableStream({
      async pull(controller) {
        try {
          const { done: done2, value } = await iterator.next();
          if (done2) {
            _onFinish();
            controller.close();
            return;
          }
          let len = value.byteLength;
          if (onProgress) {
            let loadedBytes = bytes += len;
            onProgress(loadedBytes);
          }
          controller.enqueue(new Uint8Array(value));
        } catch (err) {
          _onFinish(err);
          throw err;
        }
      },
      cancel(reason) {
        _onFinish(reason);
        return iterator.return();
      }
    }, {
      highWaterMark: 2
    });
  };
  const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
  const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
  const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
  const test = (fn2, ...args) => {
    try {
      return !!fn2(...args);
    } catch (e2) {
      return false;
    }
  };
  const supportsRequestStream = isReadableStreamSupported && test(() => {
    let duplexAccessed = false;
    const hasContentType = new Request(platform.origin, {
      body: new ReadableStream(),
      method: "POST",
      get duplex() {
        duplexAccessed = true;
        return "half";
      }
    }).headers.has("Content-Type");
    return duplexAccessed && !hasContentType;
  });
  const DEFAULT_CHUNK_SIZE = 64 * 1024;
  const supportsResponseStream = isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
  const resolvers = {
    stream: supportsResponseStream && ((res) => res.body)
  };
  isFetchSupported && ((res) => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
      !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res2) => res2[type]() : (_2, config) => {
        throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
      });
    });
  })(new Response());
  const getBodyLength = async (body) => {
    if (body == null) {
      return 0;
    }
    if (utils$1.isBlob(body)) {
      return body.size;
    }
    if (utils$1.isSpecCompliantForm(body)) {
      const _request = new Request(platform.origin, {
        method: "POST",
        body
      });
      return (await _request.arrayBuffer()).byteLength;
    }
    if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
      return body.byteLength;
    }
    if (utils$1.isURLSearchParams(body)) {
      body = body + "";
    }
    if (utils$1.isString(body)) {
      return (await encodeText(body)).byteLength;
    }
  };
  const resolveBodyLength = async (headers, body) => {
    const length = utils$1.toFiniteNumber(headers.getContentLength());
    return length == null ? getBodyLength(body) : length;
  };
  const fetchAdapter = isFetchSupported && (async (config) => {
    let {
      url,
      method,
      data,
      signal,
      cancelToken,
      timeout,
      onDownloadProgress,
      onUploadProgress,
      responseType,
      headers,
      withCredentials = "same-origin",
      fetchOptions
    } = resolveConfig(config);
    responseType = responseType ? (responseType + "").toLowerCase() : "text";
    let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
    let request;
    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
    });
    let requestContentLength;
    try {
      if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
        let _request = new Request(url, {
          method: "POST",
          body: data,
          duplex: "half"
        });
        let contentTypeHeader;
        if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
          headers.setContentType(contentTypeHeader);
        }
        if (_request.body) {
          const [onProgress, flush] = progressEventDecorator(
            requestContentLength,
            progressEventReducer(asyncDecorator(onUploadProgress))
          );
          data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
        }
      }
      if (!utils$1.isString(withCredentials)) {
        withCredentials = withCredentials ? "include" : "omit";
      }
      const isCredentialsSupported = "credentials" in Request.prototype;
      request = new Request(url, {
        ...fetchOptions,
        signal: composedSignal,
        method: method.toUpperCase(),
        headers: headers.normalize().toJSON(),
        body: data,
        duplex: "half",
        credentials: isCredentialsSupported ? withCredentials : void 0
      });
      let response = await fetch(request);
      const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
      if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
        const options = {};
        ["status", "statusText", "headers"].forEach((prop) => {
          options[prop] = response[prop];
        });
        const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
          responseContentLength,
          progressEventReducer(asyncDecorator(onDownloadProgress), true)
        ) || [];
        response = new Response(
          trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
            flush && flush();
            unsubscribe && unsubscribe();
          }),
          options
        );
      }
      responseType = responseType || "text";
      let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config);
      !isStreamResponse && unsubscribe && unsubscribe();
      return await new Promise((resolve2, reject) => {
        settle(resolve2, reject, {
          data: responseData,
          headers: AxiosHeaders.from(response.headers),
          status: response.status,
          statusText: response.statusText,
          config,
          request
        });
      });
    } catch (err) {
      unsubscribe && unsubscribe();
      if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
        throw Object.assign(
          new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request),
          {
            cause: err.cause || err
          }
        );
      }
      throw AxiosError.from(err, err && err.code, config, request);
    }
  });
  const knownAdapters = {
    http: httpAdapter,
    xhr: xhrAdapter,
    fetch: fetchAdapter
  };
  utils$1.forEach(knownAdapters, (fn2, value) => {
    if (fn2) {
      try {
        Object.defineProperty(fn2, "name", { value });
      } catch (e2) {
      }
      Object.defineProperty(fn2, "adapterName", { value });
    }
  });
  const renderReason = (reason) => `- ${reason}`;
  const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
  const adapters = {
    getAdapter: (adapters2) => {
      adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
      const { length } = adapters2;
      let nameOrAdapter;
      let adapter;
      const rejectedReasons = {};
      for (let i2 = 0; i2 < length; i2++) {
        nameOrAdapter = adapters2[i2];
        let id;
        adapter = nameOrAdapter;
        if (!isResolvedHandle(nameOrAdapter)) {
          adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
          if (adapter === void 0) {
            throw new AxiosError(`Unknown adapter '${id}'`);
          }
        }
        if (adapter) {
          break;
        }
        rejectedReasons[id || "#" + i2] = adapter;
      }
      if (!adapter) {
        const reasons = Object.entries(rejectedReasons).map(
          ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
        );
        let s2 = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
        throw new AxiosError(
          `There is no suitable adapter to dispatch the request ` + s2,
          "ERR_NOT_SUPPORT"
        );
      }
      return adapter;
    },
    adapters: knownAdapters
  };
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
    if (config.signal && config.signal.aborted) {
      throw new CanceledError(null, config);
    }
  }
  function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = AxiosHeaders.from(config.headers);
    config.data = transformData.call(
      config,
      config.transformRequest
    );
    if (["post", "put", "patch"].indexOf(config.method) !== -1) {
      config.headers.setContentType("application/x-www-form-urlencoded", false);
    }
    const adapter = adapters.getAdapter(config.adapter || defaults.adapter);
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);
      response.data = transformData.call(
        config,
        config.transformResponse,
        response
      );
      response.headers = AxiosHeaders.from(response.headers);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config);
        if (reason && reason.response) {
          reason.response.data = transformData.call(
            config,
            config.transformResponse,
            reason.response
          );
          reason.response.headers = AxiosHeaders.from(reason.response.headers);
        }
      }
      return Promise.reject(reason);
    });
  }
  const VERSION = "1.7.7";
  const validators$1 = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i2) => {
    validators$1[type] = function validator2(thing) {
      return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
    };
  });
  const deprecatedWarnings = {};
  validators$1.transitional = function transitional(validator2, version2, message) {
    function formatMessage(opt, desc) {
      return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    return (value, opt, opts) => {
      if (validator2 === false) {
        throw new AxiosError(
          formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
          AxiosError.ERR_DEPRECATED
        );
      }
      if (version2 && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        console.warn(
          formatMessage(
            opt,
            " has been deprecated since v" + version2 + " and will be removed in the near future"
          )
        );
      }
      return validator2 ? validator2(value, opt, opts) : true;
    };
  };
  function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== "object") {
      throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
    }
    const keys = Object.keys(options);
    let i2 = keys.length;
    while (i2-- > 0) {
      const opt = keys[i2];
      const validator2 = schema[opt];
      if (validator2) {
        const value = options[opt];
        const result = value === void 0 || validator2(value, opt, options);
        if (result !== true) {
          throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
      }
    }
  }
  const validator = {
    assertOptions,
    validators: validators$1
  };
  const validators = validator.validators;
  class Axios {
    constructor(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    /**
     * Dispatch a request
     *
     * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
     * @param {?Object} config
     *
     * @returns {Promise} The Promise to be fulfilled
     */
    async request(configOrUrl, config) {
      try {
        return await this._request(configOrUrl, config);
      } catch (err) {
        if (err instanceof Error) {
          let dummy;
          Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
          const stack2 = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
          try {
            if (!err.stack) {
              err.stack = stack2;
            } else if (stack2 && !String(err.stack).endsWith(stack2.replace(/^.+\n.+\n/, ""))) {
              err.stack += "\n" + stack2;
            }
          } catch (e2) {
          }
        }
        throw err;
      }
    }
    _request(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      config = mergeConfig(this.defaults, config);
      const { transitional, paramsSerializer, headers } = config;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      if (paramsSerializer != null) {
        if (utils$1.isFunction(paramsSerializer)) {
          config.paramsSerializer = {
            serialize: paramsSerializer
          };
        } else {
          validator.assertOptions(paramsSerializer, {
            encode: validators.function,
            serialize: validators.function
          }, true);
        }
      }
      config.method = (config.method || this.defaults.method || "get").toLowerCase();
      let contextHeaders = headers && utils$1.merge(
        headers.common,
        headers[config.method]
      );
      headers && utils$1.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        (method) => {
          delete headers[method];
        }
      );
      config.headers = AxiosHeaders.concat(contextHeaders, headers);
      const requestInterceptorChain = [];
      let synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      const responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      let promise;
      let i2 = 0;
      let len;
      if (!synchronousRequestInterceptors) {
        const chain = [dispatchRequest.bind(this), void 0];
        chain.unshift.apply(chain, requestInterceptorChain);
        chain.push.apply(chain, responseInterceptorChain);
        len = chain.length;
        promise = Promise.resolve(config);
        while (i2 < len) {
          promise = promise.then(chain[i2++], chain[i2++]);
        }
        return promise;
      }
      len = requestInterceptorChain.length;
      let newConfig = config;
      i2 = 0;
      while (i2 < len) {
        const onFulfilled = requestInterceptorChain[i2++];
        const onRejected = requestInterceptorChain[i2++];
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected.call(this, error);
          break;
        }
      }
      try {
        promise = dispatchRequest.call(this, newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      i2 = 0;
      len = responseInterceptorChain.length;
      while (i2 < len) {
        promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
      }
      return promise;
    }
    getUri(config) {
      config = mergeConfig(this.defaults, config);
      const fullPath = buildFullPath(config.baseURL, config.url);
      return buildURL(fullPath, config.params, config.paramsSerializer);
    }
  }
  utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
    Axios.prototype[method] = function(url, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        url,
        data: (config || {}).data
      }));
    };
  });
  utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    function generateHTTPMethod(isForm) {
      return function httpMethod(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          headers: isForm ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url,
          data
        }));
      };
    }
    Axios.prototype[method] = generateHTTPMethod();
    Axios.prototype[method + "Form"] = generateHTTPMethod(true);
  });
  class CancelToken {
    constructor(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      let resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve2) {
        resolvePromise = resolve2;
      });
      const token = this;
      this.promise.then((cancel) => {
        if (!token._listeners) return;
        let i2 = token._listeners.length;
        while (i2-- > 0) {
          token._listeners[i2](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = (onfulfilled) => {
        let _resolve;
        const promise = new Promise((resolve2) => {
          token.subscribe(resolve2);
          _resolve = resolve2;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message, config, request) {
        if (token.reason) {
          return;
        }
        token.reason = new CanceledError(message, config, request);
        resolvePromise(token.reason);
      });
    }
    /**
     * Throws a `CanceledError` if cancellation has been requested.
     */
    throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    }
    /**
     * Subscribe to the cancel signal
     */
    subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    }
    /**
     * Unsubscribe from the cancel signal
     */
    unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      const index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    }
    toAbortSignal() {
      const controller = new AbortController();
      const abort = (err) => {
        controller.abort(err);
      };
      this.subscribe(abort);
      controller.signal.unsubscribe = () => this.unsubscribe(abort);
      return controller.signal;
    }
    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    static source() {
      let cancel;
      const token = new CancelToken(function executor(c2) {
        cancel = c2;
      });
      return {
        token,
        cancel
      };
    }
  }
  function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  }
  function isAxiosError(payload) {
    return utils$1.isObject(payload) && payload.isAxiosError === true;
  }
  const HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
  };
  Object.entries(HttpStatusCode).forEach(([key, value]) => {
    HttpStatusCode[value] = key;
  });
  function createInstance(defaultConfig2) {
    const context = new Axios(defaultConfig2);
    const instance = bind(Axios.prototype.request, context);
    utils$1.extend(instance, Axios.prototype, context, { allOwnKeys: true });
    utils$1.extend(instance, context, null, { allOwnKeys: true });
    instance.create = function create(instanceConfig) {
      return createInstance(mergeConfig(defaultConfig2, instanceConfig));
    };
    return instance;
  }
  const axios = createInstance(defaults);
  axios.Axios = Axios;
  axios.CanceledError = CanceledError;
  axios.CancelToken = CancelToken;
  axios.isCancel = isCancel;
  axios.VERSION = VERSION;
  axios.toFormData = toFormData;
  axios.AxiosError = AxiosError;
  axios.Cancel = axios.CanceledError;
  axios.all = function all(promises) {
    return Promise.all(promises);
  };
  axios.spread = spread;
  axios.isAxiosError = isAxiosError;
  axios.mergeConfig = mergeConfig;
  axios.AxiosHeaders = AxiosHeaders;
  axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
  axios.getAdapter = adapters.getAdapter;
  axios.HttpStatusCode = HttpStatusCode;
  axios.default = axios;
  const api = axios.create();
  api.interceptors.request.use((config) => {
    const csrfStore = useCsrfStore();
    config.data = config.data || {};
    config.data.shrimp = csrfStore.shrimp;
    return config;
  });
  api.interceptors.response.use((response) => {
    const csrfStore = useCsrfStore();
    if (response.data && response.data.shrimp) {
      csrfStore.updateShrimp(response.data.shrimp);
    }
    return response;
  });
  const supportedLocales = window.supported_locales;
  const defaultLocale = "en";
  const LOCAL_STORAGE_KEY = "selected.locale";
  const useLanguageStore = /* @__PURE__ */ defineStore("language", {
    state: () => ({
      storedLocale: localStorage.getItem(LOCAL_STORAGE_KEY),
      currentLocale: null,
      supportedLocales,
      defaultLocale,
      isLoading: false,
      error: null
    }),
    getters: {
      getCurrentLocale: (state) => state.currentLocale,
      getSupportedLocales: (state) => state.supportedLocales
    },
    actions: {
      // When we start up, we may have the device locale but we won't have
      // the user's preferred locale yet. This method sets a definite initial
      // locale to get things going with the information we have.
      //
      // Priority: 1. Stored locale, 2. Browser language, 3. Default locale
      initializeCurrentLocale(deviceLocale) {
        deviceLocale = deviceLocale.split("-")[0];
        this.currentLocale = this.storedLocale || deviceLocale || this.defaultLocale;
        return this.currentLocale;
      },
      /**
       * Determines the appropriate locale (if supported) based on the following priority:
       * 1. Preferred locale
       * 2. Primary language code of preferred locale
       * 3. Current locale (the intialized locale or modified during this run)
       * 4. Stored locale preference (if set)
       * 5. Default locale (fallback)
       *
       * @param {string} [preferredLocale] - The preferred locale string (e.g., 'en', 'fr-FR')
       * @returns {string} The determined locale that is supported by the application
       */
      determineLocale(preferredLocale) {
        const locales = [
          preferredLocale,
          preferredLocale == null ? void 0 : preferredLocale.split("-")[0],
          this.currentLocale,
          this.storedLocale
        ];
        return locales.find(
          (locale2) => locale2 && this.supportedLocales.includes(locale2)
        ) ?? this.defaultLocale;
      },
      async updateLanguage(newLocale) {
        this.isLoading = true;
        this.error = null;
        this.setCurrentLocale(newLocale);
        try {
          await api.post("/api/v2/account/update-locale", {
            locale: newLocale
          });
          this.isLoading = false;
        } catch (error) {
          this.isLoading = false;
          if (axios.isAxiosError(error)) {
            if (error.response && error.response.status >= 400 && error.response.status < 500) {
              this.error = `Failed to update language: ${error.response.data.message || "Unknown error"}`;
            } else {
              this.error = "An unexpected error occurred while updating the language";
            }
          } else {
            this.error = "An unexpected error occurred";
          }
          console.error("Error updating language:", error);
        }
      },
      setCurrentLocale(locale2) {
        if (this.supportedLocales.includes(locale2)) {
          this.currentLocale = locale2;
          localStorage.setItem(LOCAL_STORAGE_KEY, locale2);
        } else {
          console.warn(`Unsupported locale: ${locale2}`);
        }
      }
    }
  });
  const cache = {};
  const useWindowProps = (props) => {
    const result = {};
    props.forEach((prop) => {
      if (!cache[prop]) {
        cache[prop] = ref(window[prop]);
      }
      result[prop] = readonly(cache[prop]);
    });
    return result;
  };
  const useWindowProp = (prop) => {
    if (!cache[prop]) {
      cache[prop] = ref(window[prop]);
    }
    return readonly(cache[prop]);
  };
  const _hoisted_1$19 = ["aria-expanded", "onKeydown"];
  const _hoisted_2$Y = /* @__PURE__ */ createBaseVNode("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    class: "h-5 w-5 mr-2",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor"
  }, [
    /* @__PURE__ */ createBaseVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M3 5h12M9 3v2m1.048 9.5A18.022 18.022 0 016.412 9m6.088 9h7M11 21l5-10 5 10M12.751 5C11.783 10.77 8.07 15.61 3 18.129"
    })
  ], -1);
  const _hoisted_3$S = /* @__PURE__ */ createBaseVNode("svg", {
    class: "ml-2 -mr-1 h-5 w-5",
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    /* @__PURE__ */ createBaseVNode("path", {
      "fill-rule": "evenodd",
      d: "M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z",
      "clip-rule": "evenodd"
    })
  ], -1);
  const _hoisted_4$K = ["onKeydown"];
  const _hoisted_5$I = {
    class: "py-1 max-h-60 overflow-y-auto",
    role: "none"
  };
  const _hoisted_6$D = ["onClick"];
  const _sfc_main$1c = /* @__PURE__ */ defineComponent({
    __name: "LanguageToggle",
    emits: ["localeChanged"],
    setup(__props, { emit: __emit }) {
      var _a;
      const emit2 = __emit;
      const languageStore = useLanguageStore();
      const supportedLocales2 = languageStore.getSupportedLocales;
      const cust = useWindowProp("cust");
      const selectedLocale = ref(languageStore.determineLocale((_a = cust == null ? void 0 : cust.value) == null ? void 0 : _a.locale));
      const currentLocale = computed(() => selectedLocale.value);
      const isMenuOpen = ref(false);
      const menuItems = ref([]);
      const toggleMenu = () => {
        isMenuOpen.value = !isMenuOpen.value;
      };
      const openMenu = () => {
        isMenuOpen.value = true;
      };
      const closeMenu = () => {
        isMenuOpen.value = false;
      };
      const focusNextItem = () => {
        const currentIndex = menuItems.value.indexOf(document.activeElement);
        const nextIndex = (currentIndex + 1) % menuItems.value.length;
        menuItems.value[nextIndex].focus();
      };
      const focusPreviousItem = () => {
        const currentIndex = menuItems.value.indexOf(document.activeElement);
        const previousIndex = (currentIndex - 1 + menuItems.value.length) % menuItems.value.length;
        menuItems.value[previousIndex].focus();
      };
      const changeLocale = async (newLocale) => {
        if (languageStore.getSupportedLocales.includes(newLocale)) {
          try {
            if (cust.value) {
              cust.value.locale = newLocale;
            }
            await languageStore.updateLanguage(newLocale);
            await setLanguage(newLocale);
            selectedLocale.value = newLocale;
            emit2("localeChanged", newLocale);
          } catch (err) {
            console.error("Failed to update language:", err);
          } finally {
            closeMenu();
          }
        }
      };
      onMounted(async () => {
        menuItems.value = Array.from(document.querySelectorAll('[role="menuitem"]'));
        await setLanguage(selectedLocale.value);
      });
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock(Fragment, null, [
          createBaseVNode("button", {
            type: "button",
            class: "inline-flex items-center justify-center w-full rounded-md border border-gray-300 shadow-sm px-4 py-2 bg-white text-sm font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-100 focus:ring-indigo-500",
            "aria-expanded": isMenuOpen.value,
            "aria-haspopup": "true",
            onClick: toggleMenu,
            onKeydown: [
              withKeys(withModifiers(openMenu, ["prevent"]), ["down"]),
              withKeys(withModifiers(openMenu, ["prevent"]), ["enter"]),
              withKeys(withModifiers(openMenu, ["prevent"]), ["space"])
            ]
          }, [
            _hoisted_2$Y,
            createTextVNode(" " + toDisplayString(currentLocale.value) + " ", 1),
            _hoisted_3$S
          ], 40, _hoisted_1$19),
          isMenuOpen.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "origin-bottom-right absolute right-0 bottom-full mb-2 w-56 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none",
            role: "menu",
            "aria-orientation": "vertical",
            onKeydown: [
              withKeys(closeMenu, ["esc"]),
              withKeys(withModifiers(focusPreviousItem, ["prevent"]), ["up"]),
              withKeys(withModifiers(focusNextItem, ["prevent"]), ["down"])
            ]
          }, [
            createBaseVNode("div", _hoisted_5$I, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(supportedLocales2), (locale2) => {
                return openBlock(), createElementBlock("a", {
                  key: locale2,
                  href: "#",
                  onClick: withModifiers(($event) => changeLocale(locale2), ["prevent"]),
                  class: normalizeClass([
                    "block px-4 py-2 text-base hover:bg-gray-100 hover:text-gray-900",
                    locale2 === currentLocale.value ? "text-brandcomp-700 font-bold bg-gray-200" : "text-gray-700"
                  ]),
                  role: "menuitem"
                }, toDisplayString(locale2), 11, _hoisted_6$D);
              }), 128))
            ])
          ], 40, _hoisted_4$K)) : createCommentVNode("", true)
        ], 64);
      };
    }
  });
  const _hoisted_1$18 = ["aria-pressed"];
  const _hoisted_2$X = {
    key: 0,
    "aria-hidden": "true",
    class: "w-6 h-6",
    fill: "none",
    stroke: "currentColor",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  };
  const _hoisted_3$R = /* @__PURE__ */ createBaseVNode("path", {
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "2",
    d: "M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"
  }, null, -1);
  const _hoisted_4$J = [
    _hoisted_3$R
  ];
  const _hoisted_5$H = {
    key: 1,
    "aria-hidden": "true",
    class: "w-6 h-6",
    fill: "none",
    stroke: "currentColor",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  };
  const _hoisted_6$C = /* @__PURE__ */ createBaseVNode("path", {
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "2",
    d: "M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"
  }, null, -1);
  const _hoisted_7$y = [
    _hoisted_6$C
  ];
  const _sfc_main$1b = /* @__PURE__ */ defineComponent({
    __name: "ThemeToggle",
    setup(__props) {
      const isDarkMode = ref(false);
      const toggleDarkMode = () => {
        isDarkMode.value = !isDarkMode.value;
        localStorage.setItem("darkMode", isDarkMode.value.toString());
        updateDarkMode();
      };
      const updateDarkMode = () => {
        if (isDarkMode.value) {
          document.documentElement.classList.add("dark");
        } else {
          document.documentElement.classList.remove("dark");
        }
      };
      const detectSystemPreference = () => {
        return window.matchMedia("(prefers-color-scheme: dark)").matches;
      };
      onMounted(() => {
        const storedPreference = localStorage.getItem("darkMode");
        if (storedPreference !== null) {
          isDarkMode.value = storedPreference === "true";
        } else {
          isDarkMode.value = detectSystemPreference();
        }
        updateDarkMode();
      });
      watch(isDarkMode, updateDarkMode);
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("button", {
          onClick: toggleDarkMode,
          "aria-label": "Toggle dark mode",
          "aria-pressed": isDarkMode.value,
          class: "p-2 rounded-md hover:bg-gray-200 dark:hover:bg-gray-700"
        }, [
          isDarkMode.value ? (openBlock(), createElementBlock("svg", _hoisted_2$X, _hoisted_4$J)) : (openBlock(), createElementBlock("svg", _hoisted_5$H, _hoisted_7$y))
        ], 8, _hoisted_1$18);
      };
    }
  });
  const _hoisted_1$17 = { class: "min-w-[320px] text-sm text-center space-y-2" };
  const _hoisted_2$W = { class: "container mx-auto p-4 max-w-2xl" };
  const _hoisted_3$Q = { key: 0 };
  const _hoisted_4$I = {
    key: 1,
    class: "prose dark:prose-invert text-base pt-4 font-brand"
  };
  const _hoisted_5$G = ["href"];
  const _hoisted_6$B = /* @__PURE__ */ createBaseVNode("a", {
    href: "https://github.com/onetimesecret/onetimesecret",
    "aria-label": "View source code on GitHub",
    class: "text-gray-700 dark:text-gray-300 hover:text-gray-900 dark:hover:text-gray-100",
    rel: "noopener noreferrer"
  }, "GitHub", -1);
  const _hoisted_7$x = ["href"];
  const _hoisted_8$u = ["href"];
  const _hoisted_9$v = {
    key: 2,
    class: "prose dark:prose-invert text-base font-brand"
  };
  const _hoisted_10$s = /* @__PURE__ */ createBaseVNode("a", {
    href: "https://status.onetimesecret.com/",
    "aria-label": "Check service status",
    class: "text-gray-700 dark:text-gray-300 hover:text-gray-900 dark:hover:text-gray-100",
    rel: "noopener noreferrer"
  }, "Status", -1);
  const _hoisted_11$r = ["href"];
  const _hoisted_12$o = { class: "fixed bottom-4 left-4 z-50" };
  const _hoisted_13$m = { class: "mt-2 text-slate-300" };
  const _hoisted_14$h = {
    class: "fixed text-left bottom-4 right-4 z-50 opacity-60 hover:opacity-100",
    "aria-label": "Change language"
  };
  const _hoisted_15$h = { class: "relative" };
  const _hoisted_16$f = {
    key: 3,
    class: "text-gray-400 dark:text-gray-500 mt-4 pt-4"
  };
  const _sfc_main$1a = /* @__PURE__ */ defineComponent({
    __name: "DefaultFooter",
    props: {
      displayFeedback: { type: Boolean },
      displayLinks: { type: Boolean },
      displayMasthead: { type: Boolean },
      displayNavigation: { type: Boolean },
      displayVersion: { type: Boolean },
      authentication: {},
      cust: {},
      onetimeVersion: {},
      supportHost: {},
      colonel: { type: Boolean },
      authenticated: { type: Boolean },
      plansEnabled: { type: Boolean }
    },
    setup(__props) {
      return (_ctx, _cache) => {
        const _component_router_link = resolveComponent("router-link");
        return openBlock(), createElementBlock("footer", _hoisted_1$17, [
          createBaseVNode("div", _hoisted_2$W, [
            _ctx.displayFeedback ? (openBlock(), createElementBlock("div", _hoisted_3$Q, [
              createVNode(_sfc_main$1d, { showRedButton: false })
            ])) : createCommentVNode("", true),
            _ctx.displayLinks ? (openBlock(), createElementBlock("div", _hoisted_4$I, [
              _ctx.supportHost ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createBaseVNode("a", {
                  href: `${_ctx.supportHost}/blog`,
                  "aria-label": "Our blogging website",
                  class: "text-gray-700 dark:text-gray-300 hover:text-gray-900 dark:hover:text-gray-100",
                  rel: "noopener noreferrer"
                }, "Blog", 8, _hoisted_5$G),
                createTextVNode(" | ")
              ], 64)) : createCommentVNode("", true),
              _ctx.plansEnabled ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createVNode(_component_router_link, {
                  to: "/pricing",
                  "aria-label": "Onetime Secret Subscription Pricing",
                  class: "text-gray-700 dark:text-gray-300 hover:text-gray-900 dark:hover:text-gray-100"
                }, {
                  default: withCtx(() => [
                    createTextVNode(" Pricing ")
                  ]),
                  _: 1
                }),
                createTextVNode(" | ")
              ], 64)) : createCommentVNode("", true),
              _hoisted_6$B,
              createTextVNode(" | "),
              _ctx.supportHost ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                createBaseVNode("a", {
                  href: `${_ctx.supportHost}/docs/rest-api`,
                  "aria-label": "Our documentation site (in beta)",
                  class: "text-gray-700 dark:text-gray-300 hover:text-gray-900 dark:hover:text-gray-100",
                  rel: "noopener noreferrer"
                }, "API", 8, _hoisted_7$x),
                createTextVNode(" | "),
                createBaseVNode("a", {
                  href: `${_ctx.supportHost}/docs`,
                  "aria-label": "Our documentation site (in beta)",
                  class: "text-gray-700 dark:text-gray-300 hover:text-gray-900 dark:hover:text-gray-100",
                  rel: "noopener noreferrer"
                }, "Docs", 8, _hoisted_8$u)
              ], 64)) : createCommentVNode("", true)
            ])) : createCommentVNode("", true),
            _ctx.displayLinks ? (openBlock(), createElementBlock("div", _hoisted_9$v, [
              createVNode(_component_router_link, {
                to: "/info/privacy",
                "aria-label": "Read our Privacy Policy",
                class: "text-gray-700 dark:text-gray-300 hover:text-gray-900 dark:hover:text-gray-100"
              }, {
                default: withCtx(() => [
                  createTextVNode(" Privacy ")
                ]),
                _: 1
              }),
              createTextVNode(" | "),
              createVNode(_component_router_link, {
                to: "/info/terms",
                "aria-label": "Read our Terms and Conditions",
                class: "text-gray-700 dark:text-gray-300 hover:text-gray-900 dark:hover:text-gray-100"
              }, {
                default: withCtx(() => [
                  createTextVNode(" Terms ")
                ]),
                _: 1
              }),
              createTextVNode(" | "),
              createVNode(_component_router_link, {
                to: "/info/security",
                "aria-label": "View security information",
                class: "text-gray-700 dark:text-gray-300 hover:text-gray-900 dark:hover:text-gray-100"
              }, {
                default: withCtx(() => [
                  createTextVNode(" Security ")
                ]),
                _: 1
              }),
              createTextVNode(" | "),
              _hoisted_10$s,
              createTextVNode(" | "),
              createBaseVNode("a", {
                href: `${_ctx.supportHost}/about`,
                "aria-label": "About Onetime Secret",
                class: "text-gray-700 dark:text-gray-300 hover:text-gray-900 dark:hover:text-gray-100"
              }, "About", 8, _hoisted_11$r)
            ])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_12$o, [
              createBaseVNode("div", _hoisted_13$m, [
                createVNode(_sfc_main$1b)
              ])
            ]),
            createBaseVNode("div", _hoisted_14$h, [
              createBaseVNode("div", _hoisted_15$h, [
                createVNode(_sfc_main$1c)
              ])
            ]),
            _ctx.displayVersion ? (openBlock(), createElementBlock("div", _hoisted_16$f, " v" + toDisplayString(_ctx.onetimeVersion), 1)) : createCommentVNode("", true)
          ])
        ]);
      };
    }
  });
  const _imports_0$1 = "/dist/assets/onetime-logo-v3-xl.svg";
  const matchIconName = /^[a-z0-9]+(-[a-z0-9]+)*$/;
  const stringToIcon = (value, validate, allowSimpleName, provider = "") => {
    const colonSeparated = value.split(":");
    if (value.slice(0, 1) === "@") {
      if (colonSeparated.length < 2 || colonSeparated.length > 3) {
        return null;
      }
      provider = colonSeparated.shift().slice(1);
    }
    if (colonSeparated.length > 3 || !colonSeparated.length) {
      return null;
    }
    if (colonSeparated.length > 1) {
      const name2 = colonSeparated.pop();
      const prefix = colonSeparated.pop();
      const result = {
        // Allow provider without '@': "provider:prefix:name"
        provider: colonSeparated.length > 0 ? colonSeparated[0] : provider,
        prefix,
        name: name2
      };
      return validate && !validateIconName(result) ? null : result;
    }
    const name = colonSeparated[0];
    const dashSeparated = name.split("-");
    if (dashSeparated.length > 1) {
      const result = {
        provider,
        prefix: dashSeparated.shift(),
        name: dashSeparated.join("-")
      };
      return validate && !validateIconName(result) ? null : result;
    }
    if (allowSimpleName && provider === "") {
      const result = {
        provider,
        prefix: "",
        name
      };
      return validate && !validateIconName(result, allowSimpleName) ? null : result;
    }
    return null;
  };
  const validateIconName = (icon, allowSimpleName) => {
    if (!icon) {
      return false;
    }
    return !!((icon.provider === "" || icon.provider.match(matchIconName)) && (allowSimpleName && icon.prefix === "" || icon.prefix.match(matchIconName)) && icon.name.match(matchIconName));
  };
  const defaultIconDimensions = Object.freeze(
    {
      left: 0,
      top: 0,
      width: 16,
      height: 16
    }
  );
  const defaultIconTransformations = Object.freeze({
    rotate: 0,
    vFlip: false,
    hFlip: false
  });
  const defaultIconProps = Object.freeze({
    ...defaultIconDimensions,
    ...defaultIconTransformations
  });
  const defaultExtendedIconProps = Object.freeze({
    ...defaultIconProps,
    body: "",
    hidden: false
  });
  function mergeIconTransformations(obj1, obj2) {
    const result = {};
    if (!obj1.hFlip !== !obj2.hFlip) {
      result.hFlip = true;
    }
    if (!obj1.vFlip !== !obj2.vFlip) {
      result.vFlip = true;
    }
    const rotate = ((obj1.rotate || 0) + (obj2.rotate || 0)) % 4;
    if (rotate) {
      result.rotate = rotate;
    }
    return result;
  }
  function mergeIconData(parent, child) {
    const result = mergeIconTransformations(parent, child);
    for (const key in defaultExtendedIconProps) {
      if (key in defaultIconTransformations) {
        if (key in parent && !(key in result)) {
          result[key] = defaultIconTransformations[key];
        }
      } else if (key in child) {
        result[key] = child[key];
      } else if (key in parent) {
        result[key] = parent[key];
      }
    }
    return result;
  }
  function getIconsTree(data, names) {
    const icons = data.icons;
    const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
    const resolved = /* @__PURE__ */ Object.create(null);
    function resolve2(name) {
      if (icons[name]) {
        return resolved[name] = [];
      }
      if (!(name in resolved)) {
        resolved[name] = null;
        const parent = aliases[name] && aliases[name].parent;
        const value = parent && resolve2(parent);
        if (value) {
          resolved[name] = [parent].concat(value);
        }
      }
      return resolved[name];
    }
    Object.keys(icons).concat(Object.keys(aliases)).forEach(resolve2);
    return resolved;
  }
  function internalGetIconData(data, name, tree) {
    const icons = data.icons;
    const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
    let currentProps = {};
    function parse2(name2) {
      currentProps = mergeIconData(
        icons[name2] || aliases[name2],
        currentProps
      );
    }
    parse2(name);
    tree.forEach(parse2);
    return mergeIconData(data, currentProps);
  }
  function parseIconSet(data, callback) {
    const names = [];
    if (typeof data !== "object" || typeof data.icons !== "object") {
      return names;
    }
    if (data.not_found instanceof Array) {
      data.not_found.forEach((name) => {
        callback(name, null);
        names.push(name);
      });
    }
    const tree = getIconsTree(data);
    for (const name in tree) {
      const item = tree[name];
      if (item) {
        callback(name, internalGetIconData(data, name, item));
        names.push(name);
      }
    }
    return names;
  }
  const optionalPropertyDefaults = {
    provider: "",
    aliases: {},
    not_found: {},
    ...defaultIconDimensions
  };
  function checkOptionalProps(item, defaults2) {
    for (const prop in defaults2) {
      if (prop in item && typeof item[prop] !== typeof defaults2[prop]) {
        return false;
      }
    }
    return true;
  }
  function quicklyValidateIconSet(obj) {
    if (typeof obj !== "object" || obj === null) {
      return null;
    }
    const data = obj;
    if (typeof data.prefix !== "string" || !obj.icons || typeof obj.icons !== "object") {
      return null;
    }
    if (!checkOptionalProps(obj, optionalPropertyDefaults)) {
      return null;
    }
    const icons = data.icons;
    for (const name in icons) {
      const icon = icons[name];
      if (!name.match(matchIconName) || typeof icon.body !== "string" || !checkOptionalProps(
        icon,
        defaultExtendedIconProps
      )) {
        return null;
      }
    }
    const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
    for (const name in aliases) {
      const icon = aliases[name];
      const parent = icon.parent;
      if (!name.match(matchIconName) || typeof parent !== "string" || !icons[parent] && !aliases[parent] || !checkOptionalProps(
        icon,
        defaultExtendedIconProps
      )) {
        return null;
      }
    }
    return data;
  }
  const dataStorage = /* @__PURE__ */ Object.create(null);
  function newStorage(provider, prefix) {
    return {
      provider,
      prefix,
      icons: /* @__PURE__ */ Object.create(null),
      missing: /* @__PURE__ */ new Set()
    };
  }
  function getStorage(provider, prefix) {
    const providerStorage = dataStorage[provider] || (dataStorage[provider] = /* @__PURE__ */ Object.create(null));
    return providerStorage[prefix] || (providerStorage[prefix] = newStorage(provider, prefix));
  }
  function addIconSet(storage2, data) {
    if (!quicklyValidateIconSet(data)) {
      return [];
    }
    return parseIconSet(data, (name, icon) => {
      if (icon) {
        storage2.icons[name] = icon;
      } else {
        storage2.missing.add(name);
      }
    });
  }
  function addIconToStorage(storage2, name, icon) {
    try {
      if (typeof icon.body === "string") {
        storage2.icons[name] = { ...icon };
        return true;
      }
    } catch (err) {
    }
    return false;
  }
  let simpleNames = false;
  function allowSimpleNames(allow) {
    if (typeof allow === "boolean") {
      simpleNames = allow;
    }
    return simpleNames;
  }
  function getIconData(name) {
    const icon = typeof name === "string" ? stringToIcon(name, true, simpleNames) : name;
    if (icon) {
      const storage2 = getStorage(icon.provider, icon.prefix);
      const iconName = icon.name;
      return storage2.icons[iconName] || (storage2.missing.has(iconName) ? null : void 0);
    }
  }
  function addIcon(name, data) {
    const icon = stringToIcon(name, true, simpleNames);
    if (!icon) {
      return false;
    }
    const storage2 = getStorage(icon.provider, icon.prefix);
    return addIconToStorage(storage2, icon.name, data);
  }
  function addCollection(data, provider) {
    if (typeof data !== "object") {
      return false;
    }
    if (typeof provider !== "string") {
      provider = data.provider || "";
    }
    if (simpleNames && !provider && !data.prefix) {
      let added = false;
      if (quicklyValidateIconSet(data)) {
        data.prefix = "";
        parseIconSet(data, (name, icon) => {
          if (icon && addIcon(name, icon)) {
            added = true;
          }
        });
      }
      return added;
    }
    const prefix = data.prefix;
    if (!validateIconName({
      provider,
      prefix,
      name: "a"
    })) {
      return false;
    }
    const storage2 = getStorage(provider, prefix);
    return !!addIconSet(storage2, data);
  }
  const defaultIconSizeCustomisations = Object.freeze({
    width: null,
    height: null
  });
  const defaultIconCustomisations = Object.freeze({
    // Dimensions
    ...defaultIconSizeCustomisations,
    // Transformations
    ...defaultIconTransformations
  });
  const unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
  const unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
  function calculateSize(size2, ratio, precision) {
    if (ratio === 1) {
      return size2;
    }
    precision = precision || 100;
    if (typeof size2 === "number") {
      return Math.ceil(size2 * ratio * precision) / precision;
    }
    if (typeof size2 !== "string") {
      return size2;
    }
    const oldParts = size2.split(unitsSplit);
    if (oldParts === null || !oldParts.length) {
      return size2;
    }
    const newParts = [];
    let code = oldParts.shift();
    let isNumber2 = unitsTest.test(code);
    while (true) {
      if (isNumber2) {
        const num = parseFloat(code);
        if (isNaN(num)) {
          newParts.push(code);
        } else {
          newParts.push(Math.ceil(num * ratio * precision) / precision);
        }
      } else {
        newParts.push(code);
      }
      code = oldParts.shift();
      if (code === void 0) {
        return newParts.join("");
      }
      isNumber2 = !isNumber2;
    }
  }
  function splitSVGDefs(content, tag = "defs") {
    let defs = "";
    const index = content.indexOf("<" + tag);
    while (index >= 0) {
      const start = content.indexOf(">", index);
      const end = content.indexOf("</" + tag);
      if (start === -1 || end === -1) {
        break;
      }
      const endEnd = content.indexOf(">", end);
      if (endEnd === -1) {
        break;
      }
      defs += content.slice(start + 1, end).trim();
      content = content.slice(0, index).trim() + content.slice(endEnd + 1);
    }
    return {
      defs,
      content
    };
  }
  function mergeDefsAndContent(defs, content) {
    return defs ? "<defs>" + defs + "</defs>" + content : content;
  }
  function wrapSVGContent(body, start, end) {
    const split = splitSVGDefs(body);
    return mergeDefsAndContent(split.defs, start + split.content + end);
  }
  const isUnsetKeyword = (value) => value === "unset" || value === "undefined" || value === "none";
  function iconToSVG(icon, customisations) {
    const fullIcon = {
      ...defaultIconProps,
      ...icon
    };
    const fullCustomisations = {
      ...defaultIconCustomisations,
      ...customisations
    };
    const box = {
      left: fullIcon.left,
      top: fullIcon.top,
      width: fullIcon.width,
      height: fullIcon.height
    };
    let body = fullIcon.body;
    [fullIcon, fullCustomisations].forEach((props) => {
      const transformations = [];
      const hFlip = props.hFlip;
      const vFlip = props.vFlip;
      let rotation = props.rotate;
      if (hFlip) {
        if (vFlip) {
          rotation += 2;
        } else {
          transformations.push(
            "translate(" + (box.width + box.left).toString() + " " + (0 - box.top).toString() + ")"
          );
          transformations.push("scale(-1 1)");
          box.top = box.left = 0;
        }
      } else if (vFlip) {
        transformations.push(
          "translate(" + (0 - box.left).toString() + " " + (box.height + box.top).toString() + ")"
        );
        transformations.push("scale(1 -1)");
        box.top = box.left = 0;
      }
      let tempValue;
      if (rotation < 0) {
        rotation -= Math.floor(rotation / 4) * 4;
      }
      rotation = rotation % 4;
      switch (rotation) {
        case 1:
          tempValue = box.height / 2 + box.top;
          transformations.unshift(
            "rotate(90 " + tempValue.toString() + " " + tempValue.toString() + ")"
          );
          break;
        case 2:
          transformations.unshift(
            "rotate(180 " + (box.width / 2 + box.left).toString() + " " + (box.height / 2 + box.top).toString() + ")"
          );
          break;
        case 3:
          tempValue = box.width / 2 + box.left;
          transformations.unshift(
            "rotate(-90 " + tempValue.toString() + " " + tempValue.toString() + ")"
          );
          break;
      }
      if (rotation % 2 === 1) {
        if (box.left !== box.top) {
          tempValue = box.left;
          box.left = box.top;
          box.top = tempValue;
        }
        if (box.width !== box.height) {
          tempValue = box.width;
          box.width = box.height;
          box.height = tempValue;
        }
      }
      if (transformations.length) {
        body = wrapSVGContent(
          body,
          '<g transform="' + transformations.join(" ") + '">',
          "</g>"
        );
      }
    });
    const customisationsWidth = fullCustomisations.width;
    const customisationsHeight = fullCustomisations.height;
    const boxWidth = box.width;
    const boxHeight = box.height;
    let width;
    let height;
    if (customisationsWidth === null) {
      height = customisationsHeight === null ? "1em" : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
      width = calculateSize(height, boxWidth / boxHeight);
    } else {
      width = customisationsWidth === "auto" ? boxWidth : customisationsWidth;
      height = customisationsHeight === null ? calculateSize(width, boxHeight / boxWidth) : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
    }
    const attributes = {};
    const setAttr = (prop, value) => {
      if (!isUnsetKeyword(value)) {
        attributes[prop] = value.toString();
      }
    };
    setAttr("width", width);
    setAttr("height", height);
    const viewBox = [box.left, box.top, boxWidth, boxHeight];
    attributes.viewBox = viewBox.join(" ");
    return {
      attributes,
      viewBox,
      body
    };
  }
  const regex = /\sid="(\S+)"/g;
  const randomPrefix = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
  let counter = 0;
  function replaceIDs(body, prefix = randomPrefix) {
    const ids = [];
    let match;
    while (match = regex.exec(body)) {
      ids.push(match[1]);
    }
    if (!ids.length) {
      return body;
    }
    const suffix = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
    ids.forEach((id) => {
      const newID = typeof prefix === "function" ? prefix(id) : prefix + (counter++).toString();
      const escapedID = id.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      body = body.replace(
        // Allowed characters before id: [#;"]
        // Allowed characters after id: [)"], .[a-z]
        new RegExp('([#;"])(' + escapedID + ')([")]|\\.[a-z])', "g"),
        "$1" + newID + suffix + "$3"
      );
    });
    body = body.replace(new RegExp(suffix, "g"), "");
    return body;
  }
  const storage = /* @__PURE__ */ Object.create(null);
  function setAPIModule(provider, item) {
    storage[provider] = item;
  }
  function getAPIModule(provider) {
    return storage[provider] || storage[""];
  }
  function createAPIConfig(source) {
    let resources;
    if (typeof source.resources === "string") {
      resources = [source.resources];
    } else {
      resources = source.resources;
      if (!(resources instanceof Array) || !resources.length) {
        return null;
      }
    }
    const result = {
      // API hosts
      resources,
      // Root path
      path: source.path || "/",
      // URL length limit
      maxURL: source.maxURL || 500,
      // Timeout before next host is used.
      rotate: source.rotate || 750,
      // Timeout before failing query.
      timeout: source.timeout || 5e3,
      // Randomise default API end point.
      random: source.random === true,
      // Start index
      index: source.index || 0,
      // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
      dataAfterTimeout: source.dataAfterTimeout !== false
    };
    return result;
  }
  const configStorage = /* @__PURE__ */ Object.create(null);
  const fallBackAPISources = [
    "https://api.simplesvg.com",
    "https://api.unisvg.com"
  ];
  const fallBackAPI = [];
  while (fallBackAPISources.length > 0) {
    if (fallBackAPISources.length === 1) {
      fallBackAPI.push(fallBackAPISources.shift());
    } else {
      if (Math.random() > 0.5) {
        fallBackAPI.push(fallBackAPISources.shift());
      } else {
        fallBackAPI.push(fallBackAPISources.pop());
      }
    }
  }
  configStorage[""] = createAPIConfig({
    resources: ["https://api.iconify.design"].concat(fallBackAPI)
  });
  function addAPIProvider(provider, customConfig) {
    const config = createAPIConfig(customConfig);
    if (config === null) {
      return false;
    }
    configStorage[provider] = config;
    return true;
  }
  function getAPIConfig(provider) {
    return configStorage[provider];
  }
  const detectFetch = () => {
    let callback;
    try {
      callback = fetch;
      if (typeof callback === "function") {
        return callback;
      }
    } catch (err) {
    }
  };
  let fetchModule = detectFetch();
  function calculateMaxLength(provider, prefix) {
    const config = getAPIConfig(provider);
    if (!config) {
      return 0;
    }
    let result;
    if (!config.maxURL) {
      result = 0;
    } else {
      let maxHostLength = 0;
      config.resources.forEach((item) => {
        const host = item;
        maxHostLength = Math.max(maxHostLength, host.length);
      });
      const url = prefix + ".json?icons=";
      result = config.maxURL - maxHostLength - config.path.length - url.length;
    }
    return result;
  }
  function shouldAbort(status) {
    return status === 404;
  }
  const prepare = (provider, prefix, icons) => {
    const results = [];
    const maxLength = calculateMaxLength(provider, prefix);
    const type = "icons";
    let item = {
      type,
      provider,
      prefix,
      icons: []
    };
    let length = 0;
    icons.forEach((name, index) => {
      length += name.length + 1;
      if (length >= maxLength && index > 0) {
        results.push(item);
        item = {
          type,
          provider,
          prefix,
          icons: []
        };
        length = name.length;
      }
      item.icons.push(name);
    });
    results.push(item);
    return results;
  };
  function getPath(provider) {
    if (typeof provider === "string") {
      const config = getAPIConfig(provider);
      if (config) {
        return config.path;
      }
    }
    return "/";
  }
  const send = (host, params, callback) => {
    if (!fetchModule) {
      callback("abort", 424);
      return;
    }
    let path = getPath(params.provider);
    switch (params.type) {
      case "icons": {
        const prefix = params.prefix;
        const icons = params.icons;
        const iconsList = icons.join(",");
        const urlParams = new URLSearchParams({
          icons: iconsList
        });
        path += prefix + ".json?" + urlParams.toString();
        break;
      }
      case "custom": {
        const uri = params.uri;
        path += uri.slice(0, 1) === "/" ? uri.slice(1) : uri;
        break;
      }
      default:
        callback("abort", 400);
        return;
    }
    let defaultError = 503;
    fetchModule(host + path).then((response) => {
      const status = response.status;
      if (status !== 200) {
        setTimeout(() => {
          callback(shouldAbort(status) ? "abort" : "next", status);
        });
        return;
      }
      defaultError = 501;
      return response.json();
    }).then((data) => {
      if (typeof data !== "object" || data === null) {
        setTimeout(() => {
          if (data === 404) {
            callback("abort", data);
          } else {
            callback("next", defaultError);
          }
        });
        return;
      }
      setTimeout(() => {
        callback("success", data);
      });
    }).catch(() => {
      callback("next", defaultError);
    });
  };
  const fetchAPIModule = {
    prepare,
    send
  };
  function sortIcons(icons) {
    const result = {
      loaded: [],
      missing: [],
      pending: []
    };
    const storage2 = /* @__PURE__ */ Object.create(null);
    icons.sort((a2, b2) => {
      if (a2.provider !== b2.provider) {
        return a2.provider.localeCompare(b2.provider);
      }
      if (a2.prefix !== b2.prefix) {
        return a2.prefix.localeCompare(b2.prefix);
      }
      return a2.name.localeCompare(b2.name);
    });
    let lastIcon = {
      provider: "",
      prefix: "",
      name: ""
    };
    icons.forEach((icon) => {
      if (lastIcon.name === icon.name && lastIcon.prefix === icon.prefix && lastIcon.provider === icon.provider) {
        return;
      }
      lastIcon = icon;
      const provider = icon.provider;
      const prefix = icon.prefix;
      const name = icon.name;
      const providerStorage = storage2[provider] || (storage2[provider] = /* @__PURE__ */ Object.create(null));
      const localStorage2 = providerStorage[prefix] || (providerStorage[prefix] = getStorage(provider, prefix));
      let list;
      if (name in localStorage2.icons) {
        list = result.loaded;
      } else if (prefix === "" || localStorage2.missing.has(name)) {
        list = result.missing;
      } else {
        list = result.pending;
      }
      const item = {
        provider,
        prefix,
        name
      };
      list.push(item);
    });
    return result;
  }
  function removeCallback(storages, id) {
    storages.forEach((storage2) => {
      const items = storage2.loaderCallbacks;
      if (items) {
        storage2.loaderCallbacks = items.filter((row) => row.id !== id);
      }
    });
  }
  function updateCallbacks(storage2) {
    if (!storage2.pendingCallbacksFlag) {
      storage2.pendingCallbacksFlag = true;
      setTimeout(() => {
        storage2.pendingCallbacksFlag = false;
        const items = storage2.loaderCallbacks ? storage2.loaderCallbacks.slice(0) : [];
        if (!items.length) {
          return;
        }
        let hasPending = false;
        const provider = storage2.provider;
        const prefix = storage2.prefix;
        items.forEach((item) => {
          const icons = item.icons;
          const oldLength = icons.pending.length;
          icons.pending = icons.pending.filter((icon) => {
            if (icon.prefix !== prefix) {
              return true;
            }
            const name = icon.name;
            if (storage2.icons[name]) {
              icons.loaded.push({
                provider,
                prefix,
                name
              });
            } else if (storage2.missing.has(name)) {
              icons.missing.push({
                provider,
                prefix,
                name
              });
            } else {
              hasPending = true;
              return true;
            }
            return false;
          });
          if (icons.pending.length !== oldLength) {
            if (!hasPending) {
              removeCallback([storage2], item.id);
            }
            item.callback(
              icons.loaded.slice(0),
              icons.missing.slice(0),
              icons.pending.slice(0),
              item.abort
            );
          }
        });
      });
    }
  }
  let idCounter = 0;
  function storeCallback(callback, icons, pendingSources) {
    const id = idCounter++;
    const abort = removeCallback.bind(null, pendingSources, id);
    if (!icons.pending.length) {
      return abort;
    }
    const item = {
      id,
      icons,
      callback,
      abort
    };
    pendingSources.forEach((storage2) => {
      (storage2.loaderCallbacks || (storage2.loaderCallbacks = [])).push(item);
    });
    return abort;
  }
  function listToIcons(list, validate = true, simpleNames2 = false) {
    const result = [];
    list.forEach((item) => {
      const icon = typeof item === "string" ? stringToIcon(item, validate, simpleNames2) : item;
      if (icon) {
        result.push(icon);
      }
    });
    return result;
  }
  var defaultConfig = {
    resources: [],
    index: 0,
    timeout: 2e3,
    rotate: 750,
    random: false,
    dataAfterTimeout: false
  };
  function sendQuery(config, payload, query, done) {
    const resourcesCount = config.resources.length;
    const startIndex = config.random ? Math.floor(Math.random() * resourcesCount) : config.index;
    let resources;
    if (config.random) {
      let list = config.resources.slice(0);
      resources = [];
      while (list.length > 1) {
        const nextIndex = Math.floor(Math.random() * list.length);
        resources.push(list[nextIndex]);
        list = list.slice(0, nextIndex).concat(list.slice(nextIndex + 1));
      }
      resources = resources.concat(list);
    } else {
      resources = config.resources.slice(startIndex).concat(config.resources.slice(0, startIndex));
    }
    const startTime = Date.now();
    let status = "pending";
    let queriesSent = 0;
    let lastError;
    let timer = null;
    let queue2 = [];
    let doneCallbacks = [];
    if (typeof done === "function") {
      doneCallbacks.push(done);
    }
    function resetTimer() {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
    }
    function abort() {
      if (status === "pending") {
        status = "aborted";
      }
      resetTimer();
      queue2.forEach((item) => {
        if (item.status === "pending") {
          item.status = "aborted";
        }
      });
      queue2 = [];
    }
    function subscribe(callback, overwrite) {
      if (overwrite) {
        doneCallbacks = [];
      }
      if (typeof callback === "function") {
        doneCallbacks.push(callback);
      }
    }
    function getQueryStatus() {
      return {
        startTime,
        payload,
        status,
        queriesSent,
        queriesPending: queue2.length,
        subscribe,
        abort
      };
    }
    function failQuery() {
      status = "failed";
      doneCallbacks.forEach((callback) => {
        callback(void 0, lastError);
      });
    }
    function clearQueue() {
      queue2.forEach((item) => {
        if (item.status === "pending") {
          item.status = "aborted";
        }
      });
      queue2 = [];
    }
    function moduleResponse(item, response, data) {
      const isError = response !== "success";
      queue2 = queue2.filter((queued) => queued !== item);
      switch (status) {
        case "pending":
          break;
        case "failed":
          if (isError || !config.dataAfterTimeout) {
            return;
          }
          break;
        default:
          return;
      }
      if (response === "abort") {
        lastError = data;
        failQuery();
        return;
      }
      if (isError) {
        lastError = data;
        if (!queue2.length) {
          if (!resources.length) {
            failQuery();
          } else {
            execNext();
          }
        }
        return;
      }
      resetTimer();
      clearQueue();
      if (!config.random) {
        const index = config.resources.indexOf(item.resource);
        if (index !== -1 && index !== config.index) {
          config.index = index;
        }
      }
      status = "completed";
      doneCallbacks.forEach((callback) => {
        callback(data);
      });
    }
    function execNext() {
      if (status !== "pending") {
        return;
      }
      resetTimer();
      const resource = resources.shift();
      if (resource === void 0) {
        if (queue2.length) {
          timer = setTimeout(() => {
            resetTimer();
            if (status === "pending") {
              clearQueue();
              failQuery();
            }
          }, config.timeout);
          return;
        }
        failQuery();
        return;
      }
      const item = {
        status: "pending",
        resource,
        callback: (status2, data) => {
          moduleResponse(item, status2, data);
        }
      };
      queue2.push(item);
      queriesSent++;
      timer = setTimeout(execNext, config.rotate);
      query(resource, payload, item.callback);
    }
    setTimeout(execNext);
    return getQueryStatus;
  }
  function initRedundancy(cfg) {
    const config = {
      ...defaultConfig,
      ...cfg
    };
    let queries = [];
    function cleanup() {
      queries = queries.filter((item) => item().status === "pending");
    }
    function query(payload, queryCallback, doneCallback) {
      const query2 = sendQuery(
        config,
        payload,
        queryCallback,
        (data, error) => {
          cleanup();
          if (doneCallback) {
            doneCallback(data, error);
          }
        }
      );
      queries.push(query2);
      return query2;
    }
    function find(callback) {
      return queries.find((value) => {
        return callback(value);
      }) || null;
    }
    const instance = {
      query,
      find,
      setIndex: (index) => {
        config.index = index;
      },
      getIndex: () => config.index,
      cleanup
    };
    return instance;
  }
  function emptyCallback$1() {
  }
  const redundancyCache = /* @__PURE__ */ Object.create(null);
  function getRedundancyCache(provider) {
    if (!redundancyCache[provider]) {
      const config = getAPIConfig(provider);
      if (!config) {
        return;
      }
      const redundancy = initRedundancy(config);
      const cachedReundancy = {
        config,
        redundancy
      };
      redundancyCache[provider] = cachedReundancy;
    }
    return redundancyCache[provider];
  }
  function sendAPIQuery(target, query, callback) {
    let redundancy;
    let send2;
    if (typeof target === "string") {
      const api2 = getAPIModule(target);
      if (!api2) {
        callback(void 0, 424);
        return emptyCallback$1;
      }
      send2 = api2.send;
      const cached = getRedundancyCache(target);
      if (cached) {
        redundancy = cached.redundancy;
      }
    } else {
      const config = createAPIConfig(target);
      if (config) {
        redundancy = initRedundancy(config);
        const moduleKey = target.resources ? target.resources[0] : "";
        const api2 = getAPIModule(moduleKey);
        if (api2) {
          send2 = api2.send;
        }
      }
    }
    if (!redundancy || !send2) {
      callback(void 0, 424);
      return emptyCallback$1;
    }
    return redundancy.query(query, send2, callback)().abort;
  }
  const browserCacheVersion = "iconify2";
  const browserCachePrefix = "iconify";
  const browserCacheCountKey = browserCachePrefix + "-count";
  const browserCacheVersionKey = browserCachePrefix + "-version";
  const browserStorageHour = 36e5;
  const browserStorageCacheExpiration = 168;
  const browserStorageLimit = 50;
  function getStoredItem(func, key) {
    try {
      return func.getItem(key);
    } catch (err) {
    }
  }
  function setStoredItem(func, key, value) {
    try {
      func.setItem(key, value);
      return true;
    } catch (err) {
    }
  }
  function removeStoredItem(func, key) {
    try {
      func.removeItem(key);
    } catch (err) {
    }
  }
  function setBrowserStorageItemsCount(storage2, value) {
    return setStoredItem(storage2, browserCacheCountKey, value.toString());
  }
  function getBrowserStorageItemsCount(storage2) {
    return parseInt(getStoredItem(storage2, browserCacheCountKey)) || 0;
  }
  const browserStorageConfig = {
    local: true,
    session: true
  };
  const browserStorageEmptyItems = {
    local: /* @__PURE__ */ new Set(),
    session: /* @__PURE__ */ new Set()
  };
  let browserStorageStatus = false;
  function setBrowserStorageStatus(status) {
    browserStorageStatus = status;
  }
  let _window = typeof window === "undefined" ? {} : window;
  function getBrowserStorage(key) {
    const attr = key + "Storage";
    try {
      if (_window && _window[attr] && typeof _window[attr].length === "number") {
        return _window[attr];
      }
    } catch (err) {
    }
    browserStorageConfig[key] = false;
  }
  function iterateBrowserStorage(key, callback) {
    const func = getBrowserStorage(key);
    if (!func) {
      return;
    }
    const version2 = getStoredItem(func, browserCacheVersionKey);
    if (version2 !== browserCacheVersion) {
      if (version2) {
        const total2 = getBrowserStorageItemsCount(func);
        for (let i2 = 0; i2 < total2; i2++) {
          removeStoredItem(func, browserCachePrefix + i2.toString());
        }
      }
      setStoredItem(func, browserCacheVersionKey, browserCacheVersion);
      setBrowserStorageItemsCount(func, 0);
      return;
    }
    const minTime = Math.floor(Date.now() / browserStorageHour) - browserStorageCacheExpiration;
    const parseItem = (index) => {
      const name = browserCachePrefix + index.toString();
      const item = getStoredItem(func, name);
      if (typeof item !== "string") {
        return;
      }
      try {
        const data = JSON.parse(item);
        if (typeof data === "object" && typeof data.cached === "number" && data.cached > minTime && typeof data.provider === "string" && typeof data.data === "object" && typeof data.data.prefix === "string" && // Valid item: run callback
        callback(data, index)) {
          return true;
        }
      } catch (err) {
      }
      removeStoredItem(func, name);
    };
    let total = getBrowserStorageItemsCount(func);
    for (let i2 = total - 1; i2 >= 0; i2--) {
      if (!parseItem(i2)) {
        if (i2 === total - 1) {
          total--;
          setBrowserStorageItemsCount(func, total);
        } else {
          browserStorageEmptyItems[key].add(i2);
        }
      }
    }
  }
  function initBrowserStorage() {
    if (browserStorageStatus) {
      return;
    }
    setBrowserStorageStatus(true);
    for (const key in browserStorageConfig) {
      iterateBrowserStorage(key, (item) => {
        const iconSet = item.data;
        const provider = item.provider;
        const prefix = iconSet.prefix;
        const storage2 = getStorage(
          provider,
          prefix
        );
        if (!addIconSet(storage2, iconSet).length) {
          return false;
        }
        const lastModified = iconSet.lastModified || -1;
        storage2.lastModifiedCached = storage2.lastModifiedCached ? Math.min(storage2.lastModifiedCached, lastModified) : lastModified;
        return true;
      });
    }
  }
  function updateLastModified(storage2, lastModified) {
    const lastValue = storage2.lastModifiedCached;
    if (
      // Matches or newer
      lastValue && lastValue >= lastModified
    ) {
      return lastValue === lastModified;
    }
    storage2.lastModifiedCached = lastModified;
    if (lastValue) {
      for (const key in browserStorageConfig) {
        iterateBrowserStorage(key, (item) => {
          const iconSet = item.data;
          return item.provider !== storage2.provider || iconSet.prefix !== storage2.prefix || iconSet.lastModified === lastModified;
        });
      }
    }
    return true;
  }
  function storeInBrowserStorage(storage2, data) {
    if (!browserStorageStatus) {
      initBrowserStorage();
    }
    function store(key) {
      let func;
      if (!browserStorageConfig[key] || !(func = getBrowserStorage(key))) {
        return;
      }
      const set2 = browserStorageEmptyItems[key];
      let index;
      if (set2.size) {
        set2.delete(index = Array.from(set2).shift());
      } else {
        index = getBrowserStorageItemsCount(func);
        if (index >= browserStorageLimit || !setBrowserStorageItemsCount(func, index + 1)) {
          return;
        }
      }
      const item = {
        cached: Math.floor(Date.now() / browserStorageHour),
        provider: storage2.provider,
        data
      };
      return setStoredItem(
        func,
        browserCachePrefix + index.toString(),
        JSON.stringify(item)
      );
    }
    if (data.lastModified && !updateLastModified(storage2, data.lastModified)) {
      return;
    }
    if (!Object.keys(data.icons).length) {
      return;
    }
    if (data.not_found) {
      data = Object.assign({}, data);
      delete data.not_found;
    }
    if (!store("local")) {
      store("session");
    }
  }
  function emptyCallback() {
  }
  function loadedNewIcons(storage2) {
    if (!storage2.iconsLoaderFlag) {
      storage2.iconsLoaderFlag = true;
      setTimeout(() => {
        storage2.iconsLoaderFlag = false;
        updateCallbacks(storage2);
      });
    }
  }
  function loadNewIcons(storage2, icons) {
    if (!storage2.iconsToLoad) {
      storage2.iconsToLoad = icons;
    } else {
      storage2.iconsToLoad = storage2.iconsToLoad.concat(icons).sort();
    }
    if (!storage2.iconsQueueFlag) {
      storage2.iconsQueueFlag = true;
      setTimeout(() => {
        storage2.iconsQueueFlag = false;
        const { provider, prefix } = storage2;
        const icons2 = storage2.iconsToLoad;
        delete storage2.iconsToLoad;
        let api2;
        if (!icons2 || !(api2 = getAPIModule(provider))) {
          return;
        }
        const params = api2.prepare(provider, prefix, icons2);
        params.forEach((item) => {
          sendAPIQuery(provider, item, (data) => {
            if (typeof data !== "object") {
              item.icons.forEach((name) => {
                storage2.missing.add(name);
              });
            } else {
              try {
                const parsed = addIconSet(
                  storage2,
                  data
                );
                if (!parsed.length) {
                  return;
                }
                const pending = storage2.pendingIcons;
                if (pending) {
                  parsed.forEach((name) => {
                    pending.delete(name);
                  });
                }
                storeInBrowserStorage(storage2, data);
              } catch (err) {
                console.error(err);
              }
            }
            loadedNewIcons(storage2);
          });
        });
      });
    }
  }
  const loadIcons = (icons, callback) => {
    const cleanedIcons = listToIcons(icons, true, allowSimpleNames());
    const sortedIcons = sortIcons(cleanedIcons);
    if (!sortedIcons.pending.length) {
      let callCallback = true;
      if (callback) {
        setTimeout(() => {
          if (callCallback) {
            callback(
              sortedIcons.loaded,
              sortedIcons.missing,
              sortedIcons.pending,
              emptyCallback
            );
          }
        });
      }
      return () => {
        callCallback = false;
      };
    }
    const newIcons = /* @__PURE__ */ Object.create(null);
    const sources = [];
    let lastProvider, lastPrefix;
    sortedIcons.pending.forEach((icon) => {
      const { provider, prefix } = icon;
      if (prefix === lastPrefix && provider === lastProvider) {
        return;
      }
      lastProvider = provider;
      lastPrefix = prefix;
      sources.push(getStorage(provider, prefix));
      const providerNewIcons = newIcons[provider] || (newIcons[provider] = /* @__PURE__ */ Object.create(null));
      if (!providerNewIcons[prefix]) {
        providerNewIcons[prefix] = [];
      }
    });
    sortedIcons.pending.forEach((icon) => {
      const { provider, prefix, name } = icon;
      const storage2 = getStorage(provider, prefix);
      const pendingQueue = storage2.pendingIcons || (storage2.pendingIcons = /* @__PURE__ */ new Set());
      if (!pendingQueue.has(name)) {
        pendingQueue.add(name);
        newIcons[provider][prefix].push(name);
      }
    });
    sources.forEach((storage2) => {
      const { provider, prefix } = storage2;
      if (newIcons[provider][prefix].length) {
        loadNewIcons(storage2, newIcons[provider][prefix]);
      }
    });
    return callback ? storeCallback(callback, sortedIcons, sources) : emptyCallback;
  };
  function mergeCustomisations(defaults2, item) {
    const result = {
      ...defaults2
    };
    for (const key in item) {
      const value = item[key];
      const valueType = typeof value;
      if (key in defaultIconSizeCustomisations) {
        if (value === null || value && (valueType === "string" || valueType === "number")) {
          result[key] = value;
        }
      } else if (valueType === typeof result[key]) {
        result[key] = key === "rotate" ? value % 4 : value;
      }
    }
    return result;
  }
  const separator = /[\s,]+/;
  function flipFromString(custom, flip) {
    flip.split(separator).forEach((str) => {
      const value = str.trim();
      switch (value) {
        case "horizontal":
          custom.hFlip = true;
          break;
        case "vertical":
          custom.vFlip = true;
          break;
      }
    });
  }
  function rotateFromString(value, defaultValue = 0) {
    const units = value.replace(/^-?[0-9.]*/, "");
    function cleanup(value2) {
      while (value2 < 0) {
        value2 += 4;
      }
      return value2 % 4;
    }
    if (units === "") {
      const num = parseInt(value);
      return isNaN(num) ? 0 : cleanup(num);
    } else if (units !== value) {
      let split = 0;
      switch (units) {
        case "%":
          split = 25;
          break;
        case "deg":
          split = 90;
      }
      if (split) {
        let num = parseFloat(value.slice(0, value.length - units.length));
        if (isNaN(num)) {
          return 0;
        }
        num = num / split;
        return num % 1 === 0 ? cleanup(num) : 0;
      }
    }
    return defaultValue;
  }
  function iconToHTML(body, attributes) {
    let renderAttribsHTML = body.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
    for (const attr in attributes) {
      renderAttribsHTML += " " + attr + '="' + attributes[attr] + '"';
    }
    return '<svg xmlns="http://www.w3.org/2000/svg"' + renderAttribsHTML + ">" + body + "</svg>";
  }
  function encodeSVGforURL(svg) {
    return svg.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
  }
  function svgToData(svg) {
    return "data:image/svg+xml," + encodeSVGforURL(svg);
  }
  function svgToURL(svg) {
    return 'url("' + svgToData(svg) + '")';
  }
  const defaultExtendedIconCustomisations = {
    ...defaultIconCustomisations,
    inline: false
  };
  const svgDefaults = {
    "xmlns": "http://www.w3.org/2000/svg",
    "xmlns:xlink": "http://www.w3.org/1999/xlink",
    "aria-hidden": true,
    "role": "img"
  };
  const commonProps = {
    display: "inline-block"
  };
  const monotoneProps = {
    backgroundColor: "currentColor"
  };
  const coloredProps = {
    backgroundColor: "transparent"
  };
  const propsToAdd = {
    Image: "var(--svg)",
    Repeat: "no-repeat",
    Size: "100% 100%"
  };
  const propsToAddTo = {
    webkitMask: monotoneProps,
    mask: monotoneProps,
    background: coloredProps
  };
  for (const prefix in propsToAddTo) {
    const list = propsToAddTo[prefix];
    for (const prop in propsToAdd) {
      list[prefix + prop] = propsToAdd[prop];
    }
  }
  const customisationAliases = {};
  ["horizontal", "vertical"].forEach((prefix) => {
    const attr = prefix.slice(0, 1) + "Flip";
    customisationAliases[prefix + "-flip"] = attr;
    customisationAliases[prefix.slice(0, 1) + "-flip"] = attr;
    customisationAliases[prefix + "Flip"] = attr;
  });
  function fixSize(value) {
    return value + (value.match(/^[-0-9.]+$/) ? "px" : "");
  }
  const render = (icon, props) => {
    const customisations = mergeCustomisations(defaultExtendedIconCustomisations, props);
    const componentProps = { ...svgDefaults };
    const mode = props.mode || "svg";
    const style = {};
    const propsStyle = props.style;
    const customStyle = typeof propsStyle === "object" && !(propsStyle instanceof Array) ? propsStyle : {};
    for (let key in props) {
      const value = props[key];
      if (value === void 0) {
        continue;
      }
      switch (key) {
        case "icon":
        case "style":
        case "onLoad":
        case "mode":
          break;
        case "inline":
        case "hFlip":
        case "vFlip":
          customisations[key] = value === true || value === "true" || value === 1;
          break;
        case "flip":
          if (typeof value === "string") {
            flipFromString(customisations, value);
          }
          break;
        case "color":
          style.color = value;
          break;
        case "rotate":
          if (typeof value === "string") {
            customisations[key] = rotateFromString(value);
          } else if (typeof value === "number") {
            customisations[key] = value;
          }
          break;
        case "ariaHidden":
        case "aria-hidden":
          if (value !== true && value !== "true") {
            delete componentProps["aria-hidden"];
          }
          break;
        default: {
          const alias = customisationAliases[key];
          if (alias) {
            if (value === true || value === "true" || value === 1) {
              customisations[alias] = true;
            }
          } else if (defaultExtendedIconCustomisations[key] === void 0) {
            componentProps[key] = value;
          }
        }
      }
    }
    const item = iconToSVG(icon, customisations);
    const renderAttribs = item.attributes;
    if (customisations.inline) {
      style.verticalAlign = "-0.125em";
    }
    if (mode === "svg") {
      componentProps.style = {
        ...style,
        ...customStyle
      };
      Object.assign(componentProps, renderAttribs);
      let localCounter = 0;
      let id = props.id;
      if (typeof id === "string") {
        id = id.replace(/-/g, "_");
      }
      componentProps["innerHTML"] = replaceIDs(item.body, id ? () => id + "ID" + localCounter++ : "iconifyVue");
      return h$1("svg", componentProps);
    }
    const { body, width, height } = icon;
    const useMask = mode === "mask" || (mode === "bg" ? false : body.indexOf("currentColor") !== -1);
    const html = iconToHTML(body, {
      ...renderAttribs,
      width: width + "",
      height: height + ""
    });
    componentProps.style = {
      ...style,
      "--svg": svgToURL(html),
      "width": fixSize(renderAttribs.width),
      "height": fixSize(renderAttribs.height),
      ...commonProps,
      ...useMask ? monotoneProps : coloredProps,
      ...customStyle
    };
    return h$1("span", componentProps);
  };
  allowSimpleNames(true);
  setAPIModule("", fetchAPIModule);
  if (typeof document !== "undefined" && typeof window !== "undefined") {
    initBrowserStorage();
    const _window2 = window;
    if (_window2.IconifyPreload !== void 0) {
      const preload = _window2.IconifyPreload;
      const err = "Invalid IconifyPreload syntax.";
      if (typeof preload === "object" && preload !== null) {
        (preload instanceof Array ? preload : [preload]).forEach((item) => {
          try {
            if (
              // Check if item is an object and not null/array
              typeof item !== "object" || item === null || item instanceof Array || // Check for 'icons' and 'prefix'
              typeof item.icons !== "object" || typeof item.prefix !== "string" || // Add icon set
              !addCollection(item)
            ) {
              console.error(err);
            }
          } catch (e2) {
            console.error(err);
          }
        });
      }
    }
    if (_window2.IconifyProviders !== void 0) {
      const providers = _window2.IconifyProviders;
      if (typeof providers === "object" && providers !== null) {
        for (let key in providers) {
          const err = "IconifyProviders[" + key + "] is invalid.";
          try {
            const value = providers[key];
            if (typeof value !== "object" || !value || value.resources === void 0) {
              continue;
            }
            if (!addAPIProvider(key, value)) {
              console.error(err);
            }
          } catch (e2) {
            console.error(err);
          }
        }
      }
    }
  }
  const emptyIcon = {
    ...defaultIconProps,
    body: ""
  };
  const Icon = /* @__PURE__ */ defineComponent({
    // Do not inherit other attributes: it is handled by render()
    inheritAttrs: false,
    // Set initial data
    data() {
      return {
        // Current icon name
        _name: "",
        // Loading
        _loadingIcon: null,
        // Mounted status
        iconMounted: false,
        // Callback counter to trigger re-render
        counter: 0
      };
    },
    mounted() {
      this.iconMounted = true;
    },
    unmounted() {
      this.abortLoading();
    },
    methods: {
      abortLoading() {
        if (this._loadingIcon) {
          this._loadingIcon.abort();
          this._loadingIcon = null;
        }
      },
      // Get data for icon to render or null
      getIcon(icon, onload) {
        if (typeof icon === "object" && icon !== null && typeof icon.body === "string") {
          this._name = "";
          this.abortLoading();
          return {
            data: icon
          };
        }
        let iconName;
        if (typeof icon !== "string" || (iconName = stringToIcon(icon, false, true)) === null) {
          this.abortLoading();
          return null;
        }
        const data = getIconData(iconName);
        if (!data) {
          if (!this._loadingIcon || this._loadingIcon.name !== icon) {
            this.abortLoading();
            this._name = "";
            if (data !== null) {
              this._loadingIcon = {
                name: icon,
                abort: loadIcons([iconName], () => {
                  this.counter++;
                })
              };
            }
          }
          return null;
        }
        this.abortLoading();
        if (this._name !== icon) {
          this._name = icon;
          if (onload) {
            onload(icon);
          }
        }
        const classes = ["iconify"];
        if (iconName.prefix !== "") {
          classes.push("iconify--" + iconName.prefix);
        }
        if (iconName.provider !== "") {
          classes.push("iconify--" + iconName.provider);
        }
        return { data, classes };
      }
    },
    // Render icon
    render() {
      this.counter;
      const props = this.$attrs;
      const icon = this.iconMounted || props.ssr ? this.getIcon(props.icon, props.onLoad) : null;
      if (!icon) {
        return render(emptyIcon, props);
      }
      let newProps = props;
      if (icon.classes) {
        newProps = {
          ...props,
          class: (typeof props["class"] === "string" ? props["class"] + " " : "") + icon.classes.join(" ")
        };
      }
      return render({
        ...defaultIconProps,
        ...icon.data
      }, newProps);
    }
  });
  const _hoisted_1$16 = { class: "container mx-auto mt-1 p-2 max-w-2xl" };
  const _hoisted_2$V = {
    key: 0,
    class: "min-w-[320px]"
  };
  const _hoisted_3$P = { class: "flex flex-col sm:flex-row justify-between items-center" };
  const _hoisted_4$H = { class: "mb-6 sm:mb-0" };
  const _hoisted_5$F = /* @__PURE__ */ createBaseVNode("img", {
    id: "logo",
    src: _imports_0$1,
    class: "",
    width: "64",
    height: "64",
    alt: "Logo"
  }, null, -1);
  const _hoisted_6$A = {
    key: 0,
    class: "flex flex-wrap justify-center sm:justify-end items-center gap-2 text-base font-brand"
  };
  const _hoisted_7$w = { class: "hidden sm:flex items-center" };
  const _hoisted_8$t = { id: "userEmail" };
  const _hoisted_9$u = /* @__PURE__ */ createBaseVNode("span", { class: "mx-2 text-gray-400" }, "|", -1);
  const _hoisted_10$r = /* @__PURE__ */ createBaseVNode("span", { class: "mx-0 text-gray-400" }, "|", -1);
  const _hoisted_11$q = /* @__PURE__ */ createBaseVNode("span", { class: "mx-0" }, "|", -1);
  const _hoisted_12$n = /* @__PURE__ */ createBaseVNode("span", { class: "mx-0" }, "|", -1);
  const _sfc_main$19 = /* @__PURE__ */ defineComponent({
    __name: "DefaultHeader",
    props: {
      displayFeedback: { type: Boolean },
      displayLinks: { type: Boolean },
      displayMasthead: { type: Boolean },
      displayNavigation: { type: Boolean },
      displayVersion: { type: Boolean },
      authentication: {},
      cust: {},
      onetimeVersion: {},
      supportHost: {},
      colonel: { type: Boolean },
      authenticated: { type: Boolean },
      plansEnabled: { type: Boolean }
    },
    setup(__props) {
      return (_ctx, _cache) => {
        const _component_router_link = resolveComponent("router-link");
        return openBlock(), createElementBlock("header", null, [
          createBaseVNode("div", _hoisted_1$16, [
            _ctx.displayMasthead ? (openBlock(), createElementBlock("div", _hoisted_2$V, [
              createBaseVNode("div", _hoisted_3$P, [
                createBaseVNode("div", _hoisted_4$H, [
                  createVNode(_component_router_link, { to: "/" }, {
                    default: withCtx(() => [
                      _hoisted_5$F
                    ]),
                    _: 1
                  })
                ]),
                _ctx.displayNavigation ? (openBlock(), createElementBlock("nav", _hoisted_6$A, [
                  _ctx.authenticated && _ctx.cust ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    createBaseVNode("div", _hoisted_7$w, [
                      createVNode(_component_router_link, {
                        to: "/",
                        class: "text-gray-400 hover:text-gray-300 transition"
                      }, {
                        default: withCtx(() => [
                          createBaseVNode("span", _hoisted_8$t, toDisplayString(_ctx.cust.custid), 1)
                        ]),
                        _: 1
                      }),
                      _ctx.colonel ? (openBlock(), createBlock(_component_router_link, {
                        key: 0,
                        to: "/colonel/",
                        title: "",
                        class: "ml-2 text-gray-400 hover:text-gray-300 transition"
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(Icon), {
                            icon: "mdi:star",
                            class: "w-4 h-4"
                          })
                        ]),
                        _: 1
                      })) : createCommentVNode("", true),
                      _hoisted_9$u
                    ]),
                    createVNode(_component_router_link, {
                      to: "/account",
                      class: "underline",
                      title: "Your Account"
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.$t("web.COMMON.header_dashboard")), 1)
                      ]),
                      _: 1
                    }),
                    createTextVNode(),
                    _hoisted_10$r,
                    createVNode(_component_router_link, {
                      to: "/logout",
                      class: "underline",
                      title: "Log out of Onetime Secret"
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.$t("web.COMMON.header_logout")), 1)
                      ]),
                      _: 1
                    })
                  ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    _ctx.authentication.enabled ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      _ctx.authentication.signup ? (openBlock(), createBlock(_component_router_link, {
                        key: 0,
                        to: "/signup",
                        title: "Signup - Individual and Business plans",
                        class: "underline font-bold mx-0 px-0"
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(_ctx.$t("web.COMMON.header_create_account")), 1)
                        ]),
                        _: 1
                      })) : createCommentVNode("", true),
                      _hoisted_11$q,
                      createVNode(_component_router_link, {
                        to: "/about",
                        title: "About Onetime Secret",
                        class: "underline"
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(_ctx.$t("web.COMMON.header_about")), 1)
                        ]),
                        _: 1
                      }),
                      _hoisted_12$n,
                      _ctx.authentication.signin ? (openBlock(), createBlock(_component_router_link, {
                        key: 1,
                        to: "/signin",
                        title: "Log in to Onetime Secret",
                        class: "underline"
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(_ctx.$t("web.COMMON.header_sign_in")), 1)
                        ]),
                        _: 1
                      })) : createCommentVNode("", true)
                    ], 64)) : (openBlock(), createBlock(_component_router_link, {
                      key: 1,
                      to: "/about",
                      title: "About Onetime Secret",
                      class: "underline"
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.$t("web.COMMON.header_about")), 1)
                      ]),
                      _: 1
                    }))
                  ], 64))
                ])) : createCommentVNode("", true)
              ])
            ])) : createCommentVNode("", true)
          ])
        ]);
      };
    }
  });
  const _hoisted_1$15 = {
    class: "absolute inset-x-0 -top-3 -z-10 transform-gpu overflow-hidden px-36 blur-3xl",
    "aria-hidden": "true"
  };
  const _sfc_main$18 = /* @__PURE__ */ defineComponent({
    __name: "MovingGlobules",
    props: {
      fromColour: { default: "#655b5f" },
      toColour: { default: "#23b5dd" },
      speed: { default: "6s" },
      interval: { default: 2e3 },
      scale: { default: 1 }
    },
    setup(__props) {
      const clipPath = ref("polygon(74.1% 44.1%, 100% 61.6%, 97.5% 26.9%, 85.5% 0.1%, 80.7% 2%, 72.5% 32.5%, 60.2% 62.4%, 52.4% 68.1%, 47.5% 58.3%, 45.2% 34.5%, 27.5% 76.7%, 0.1% 64.9%, 17.9% 100%, 27.6% 76.8%, 76.1% 97.7%, 74.1% 44.1%)");
      function updateClipPath() {
        const points = [];
        for (let i2 = 0; i2 < 10; i2++) {
          const x = Math.random() * 100;
          const y2 = Math.random() * 100;
          points.push(`${x.toFixed(1)}% ${y2.toFixed(1)}%`);
        }
        clipPath.value = `polygon(${points.join(", ")})`;
      }
      onMounted(() => {
        setTimeout(() => {
          updateClipPath();
          setInterval(updateClipPath, props.interval);
        }, 0);
      });
      const props = __props;
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$15, [
          createBaseVNode("div", {
            class: normalizeClass(["mx-auto aspect-[1155/678] w-[72.1875rem] opacity-30"]),
            style: normalizeStyle({
              clipPath: clipPath.value,
              transition: `clip-path ${props.speed} ease`,
              background: `linear-gradient(to top right, ${props.fromColour}, ${props.toColour})`,
              transform: `scale(${props.scale})`
            })
          }, null, 4)
        ]);
      };
    }
  });
  const _hoisted_1$14 = {
    key: 0,
    class: "relative isolate flex items-center gap-x-6 overflow-hidden bg-gray-50 dark:bg-gray-900 px-6 py-2.5 sm:px-3.5 sm:before:flex-1"
  };
  const _hoisted_2$U = /* @__PURE__ */ createBaseVNode("div", {
    class: "absolute left-[max(-7rem,calc(50%-52rem))] top-1/2 -z-10 -translate-y-1/2 transform-gpu blur-2xl",
    "aria-hidden": "true"
  }, [
    /* @__PURE__ */ createBaseVNode("div", {
      class: "aspect-[577/310] w-[36.0625rem] bg-gradient-to-r from-[#dc4a22] to-[#fcf4e8] opacity-30",
      style: { "clip-path": "polygon(74.8% 41.9%, 97.2% 73.2%, 100% 34.9%, 92.5% 0.4%, 87.5% 0%, 75% 28.6%, 58.5% 54.6%, 50.1% 56.8%, 46.9% 44%, 48.3% 17.4%, 24.7% 53.9%, 0% 27.9%, 11.9% 74.2%, 24.9% 54.1%, 68.6% 100%, 74.8% 41.9%)" }
    })
  ], -1);
  const _hoisted_3$O = /* @__PURE__ */ createBaseVNode("div", {
    class: "absolute left-[max(45rem,calc(50%+8rem))] top-1/2 -z-10 -translate-y-1/2 transform-gpu blur-2xl",
    "aria-hidden": "true"
  }, [
    /* @__PURE__ */ createBaseVNode("div", {
      class: "aspect-[577/310] w-[36.0625rem] bg-gradient-to-r from-[#dc4a22] to-[#fcf4e8] opacity-30",
      style: { "clip-path": "polygon(74.8% 41.9%, 97.2% 73.2%, 100% 34.9%, 92.5% 0.4%, 87.5% 0%, 75% 28.6%, 58.5% 54.6%, 50.1% 56.8%, 46.9% 44%, 48.3% 17.4%, 24.7% 53.9%, 0% 27.9%, 11.9% 74.2%, 24.9% 54.1%, 68.6% 100%, 74.8% 41.9%)" }
    })
  ], -1);
  const _hoisted_4$G = { class: "text-sm leading-6 text-gray-900 dark:text-gray-100" };
  const _hoisted_5$E = { href: "#" };
  const _hoisted_6$z = /* @__PURE__ */ createBaseVNode("strong", { class: "font-semibold" }, null, -1);
  const _hoisted_7$v = { class: "text-base font-brand leading-6 text-gray-900 dark:text-gray-100" };
  const _hoisted_8$s = { class: "relative flex items-center space-x-3" };
  const _hoisted_9$t = /* @__PURE__ */ createBaseVNode("svg", {
    class: "h-6 w-6 opacity-60",
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor"
  }, [
    /* @__PURE__ */ createBaseVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M11 5.882V19.24a1.76 1.76 0 01-3.417.592l-2.147-6.15M18 13a3 3 0 100-6M5.436 13.683A4.001 4.001 0 017 6h1.832c4.1 0 7.625-1.234 9.168-3v14c-1.543-1.766-5.067-3-9.168-3H7a3.988 3.988 0 01-1.564-.317z"
    })
  ], -1);
  const _hoisted_10$q = { href: "#" };
  const _hoisted_11$p = { class: "flex flex-1 justify-end" };
  const _hoisted_12$m = {
    type: "button",
    class: "-m-3 p-3 focus-visible:outline-offset-[-4px]"
  };
  const _hoisted_13$l = /* @__PURE__ */ createBaseVNode("span", { class: "sr-only" }, "Dismiss", -1);
  const _sfc_main$17 = /* @__PURE__ */ defineComponent({
    __name: "GlobalBroadcast",
    props: {
      content: { default: "Welcome to the Global Broadcast!" },
      show: { type: Boolean, default: false }
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return _ctx.show ? (openBlock(), createElementBlock("div", _hoisted_1$14, [
          _hoisted_2$U,
          createVNode(_sfc_main$18, {
            "from-colour": "#23b5dd",
            "to-colour": "#dc4a22",
            speed: "10s",
            interval: 1e3,
            scale: 2
          }),
          _hoisted_3$O,
          createBaseVNode("p", _hoisted_4$G, [
            createBaseVNode("a", _hoisted_5$E, [
              _hoisted_6$z,
              createBaseVNode("div", _hoisted_7$v, [
                createBaseVNode("div", _hoisted_8$s, [
                  _hoisted_9$t,
                  createBaseVNode("a", _hoisted_10$q, toDisplayString(_ctx.content), 1)
                ])
              ])
            ])
          ]),
          createBaseVNode("div", _hoisted_11$p, [
            createBaseVNode("button", _hoisted_12$m, [
              _hoisted_13$l,
              createVNode(unref(Icon), {
                icon: "heroicons-solid:xmarkicon",
                class: "h-5 w-5 text-gray-900 dark:text-gray-100",
                "aria-hidden": "true"
              })
            ])
          ])
        ])) : createCommentVNode("", true);
      };
    }
  });
  const _hoisted_1$13 = /* @__PURE__ */ createBaseVNode("div", { class: "w-full h-1 bg-brand-500 fixed top-0 left-0 z-50" }, null, -1);
  const _sfc_main$16 = /* @__PURE__ */ defineComponent({
    __name: "BaseLayout",
    props: {
      authentication: {},
      cust: {},
      onetimeVersion: {},
      supportHost: {},
      colonel: { type: Boolean, default: false },
      authenticated: { type: Boolean, default: false },
      plansEnabled: { type: Boolean, default: false }
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", null, [
          _hoisted_1$13,
          createVNode(_sfc_main$17, {
            show: false,
            content: ""
          }),
          renderSlot(_ctx.$slots, "header"),
          renderSlot(_ctx.$slots, "main"),
          renderSlot(_ctx.$slots, "footer")
        ]);
      };
    }
  });
  const _hoisted_1$12 = {
    class: "container mx-auto p-4 max-w-2xl",
    name: "DefaultLayout"
  };
  const _sfc_main$15 = /* @__PURE__ */ defineComponent({
    __name: "DefaultLayout",
    props: {
      displayFeedback: { type: Boolean, default: true },
      displayLinks: { type: Boolean, default: true },
      displayMasthead: { type: Boolean, default: true },
      displayNavigation: { type: Boolean, default: true },
      displayVersion: { type: Boolean, default: true },
      authentication: {},
      cust: {},
      onetimeVersion: {},
      supportHost: {},
      colonel: { type: Boolean },
      authenticated: { type: Boolean },
      plansEnabled: { type: Boolean }
    },
    setup(__props) {
      const props = __props;
      return (_ctx, _cache) => {
        return openBlock(), createBlock(_sfc_main$16, normalizeProps(guardReactiveProps(props)), {
          header: withCtx(() => [
            createVNode(_sfc_main$19, normalizeProps(guardReactiveProps(props)), null, 16)
          ]),
          main: withCtx(() => [
            createBaseVNode("main", _hoisted_1$12, [
              renderSlot(_ctx.$slots, "default")
            ])
          ]),
          footer: withCtx(() => [
            createVNode(_sfc_main$1a, normalizeProps(guardReactiveProps(props)), null, 16)
          ]),
          _: 3
        }, 16);
      };
    }
  });
  const _hoisted_1$11 = {
    class: "container mx-auto p-4 max-w-2xl",
    name: "QuietLayout"
  };
  const _sfc_main$14 = /* @__PURE__ */ defineComponent({
    __name: "QuietLayout",
    props: {
      displayFeedback: { type: Boolean, default: false },
      displayLinks: { type: Boolean, default: false },
      displayVersion: { type: Boolean, default: false },
      authentication: {},
      cust: {},
      onetimeVersion: {},
      supportHost: {},
      colonel: { type: Boolean },
      authenticated: { type: Boolean },
      plansEnabled: { type: Boolean }
    },
    setup(__props) {
      const props = __props;
      return (_ctx, _cache) => {
        return openBlock(), createBlock(_sfc_main$16, normalizeProps(guardReactiveProps(props)), {
          main: withCtx(() => [
            createBaseVNode("main", _hoisted_1$11, [
              renderSlot(_ctx.$slots, "default")
            ])
          ]),
          footer: withCtx(() => [
            createVNode(_sfc_main$1a, normalizeProps(guardReactiveProps(props)), null, 16)
          ]),
          _: 3
        }, 16);
      };
    }
  });
  const _hoisted_1$10 = {
    class: "container mx-auto p-4",
    name: "WideLayout"
  };
  const _sfc_main$13 = /* @__PURE__ */ defineComponent({
    __name: "WideLayout",
    props: {
      displayFeedback: { type: Boolean, default: true },
      displayLinks: { type: Boolean, default: true },
      displayMasthead: { type: Boolean, default: true },
      displayNavigation: { type: Boolean, default: true },
      displayVersion: { type: Boolean, default: true },
      authentication: {},
      cust: {},
      onetimeVersion: {},
      supportHost: {},
      colonel: { type: Boolean },
      authenticated: { type: Boolean },
      plansEnabled: { type: Boolean }
    },
    setup(__props) {
      const props = __props;
      return (_ctx, _cache) => {
        return openBlock(), createBlock(_sfc_main$16, normalizeProps(guardReactiveProps(props)), {
          header: withCtx(() => [
            createVNode(_sfc_main$19, normalizeProps(guardReactiveProps(props)), null, 16)
          ]),
          main: withCtx(() => [
            createBaseVNode("main", _hoisted_1$10, [
              renderSlot(_ctx.$slots, "default")
            ])
          ]),
          footer: withCtx(() => [
            createVNode(_sfc_main$1a, normalizeProps(guardReactiveProps(props)), null, 16)
          ]),
          _: 3
        }, 16);
      };
    }
  });
  const _hoisted_1$$ = { class: "text-base font-brand font-medium text-gray-700 dark:text-gray-300" };
  const _sfc_main$12 = /* @__PURE__ */ defineComponent({
    __name: "SecretFormDrawer",
    props: {
      title: {
        type: String,
        required: true
      },
      border: {
        type: String,
        default: "default",
        validator: (value) => ["none", "default", "dashed"].includes(value)
      },
      expandedBg: {
        type: String,
        default: "bg-white dark:bg-gray-800"
      },
      collapsedBg: {
        type: String,
        default: "bg-gray-50 dark:bg-gray-700"
      }
    },
    setup(__props) {
      const props = __props;
      const isExpanded = ref(false);
      const toggleExpanded = () => {
        isExpanded.value = !isExpanded.value;
        localStorage.setItem(`${props.title}Expanded`, isExpanded.value.toString());
      };
      isExpanded.value = localStorage.getItem(`${props.title}Expanded`) === "true";
      watch(isExpanded, (newValue) => {
        localStorage.setItem(`${props.title}Expanded`, newValue.toString());
      });
      const borderClass = computed(() => {
        switch (props.border) {
          case "none":
            return "";
          case "dashed":
            return "border-2 border-dashed border-gray-300 dark:border-gray-600";
          default:
            return "border border-gray-300 dark:border-gray-600";
        }
      });
      const expandedBgClass = computed(() => props.expandedBg);
      const collapsedBgClass = computed(() => props.collapsedBg);
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", {
          class: normalizeClass([
            "transition-all duration-200 ease-in-out rounded-lg",
            borderClass.value,
            isExpanded.value ? `mb-3 p-3 ${expandedBgClass.value}` : `mb-2 p-2 ${collapsedBgClass.value}`
          ])
        }, [
          createBaseVNode("div", {
            onClick: toggleExpanded,
            class: "flex justify-between items-center cursor-pointer"
          }, [
            createBaseVNode("p", _hoisted_1$$, toDisplayString(__props.title), 1),
            createVNode(unref(Icon), {
              icon: isExpanded.value ? "mdi:chevron-up" : "mdi:chevron-down",
              class: "w-5 h-5 text-gray-500 dark:text-gray-400"
            }, null, 8, ["icon"])
          ]),
          isExpanded.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "mt-2",
            onClick: _cache[0] || (_cache[0] = withModifiers(() => {
            }, ["stop"]))
          }, [
            renderSlot(_ctx.$slots, "default", {}, void 0, true)
          ])) : createCommentVNode("", true)
        ], 2);
      };
    }
  });
  const SecretFormDrawer = /* @__PURE__ */ _export_sfc(_sfc_main$12, [["__scopeId", "data-v-b85fc969"]]);
  const _hoisted_1$_ = { class: "mt-2 flex items-center space-x-2 overflow-hidden font-mono" };
  const _hoisted_2$T = { class: "flex items-center space-x-1 overflow-hidden" };
  const _hoisted_3$N = /* @__PURE__ */ createBaseVNode("span", { class: "text-sm text-gray-800 dark:text-gray-500 font-medium transition-colors duration-200" }, "https://", -1);
  const _hoisted_4$F = { class: "text-sm text-slate-600 dark:text-slate-400 font-bold transition-colors duration-200" };
  const _hoisted_5$D = /* @__PURE__ */ createBaseVNode("span", { class: "text-sm text-gray-600 dark:text-gray-400 truncate transition-colors duration-200" }, [
    /* @__PURE__ */ createTextVNode(" /secret/"),
    /* @__PURE__ */ createBaseVNode("span", { class: "blur-sm" }, "00000000000000000000000000")
  ], -1);
  const _sfc_main$11 = /* @__PURE__ */ defineComponent({
    __name: "CustomDomainPreview",
    props: {
      default_domain: {
        type: String,
        required: false,
        default: window.site_host
      }
    },
    setup(__props) {
      const props = __props;
      return (_ctx, _cache) => {
        return openBlock(), createBlock(SecretFormDrawer, {
          title: "Link Preview",
          border: "dashed",
          expandedBg: "bg-gray-50 dark:bg-gray-700"
        }, {
          default: withCtx(() => [
            createBaseVNode("div", _hoisted_1$_, [
              createVNode(unref(Icon), {
                icon: "mdi:link-variant",
                class: "text-gray-400 dark:text-gray-500 flex-shrink-0 transition-colors duration-200"
              }),
              createBaseVNode("div", _hoisted_2$T, [
                _hoisted_3$N,
                createBaseVNode("span", _hoisted_4$F, toDisplayString(props.default_domain), 1),
                _hoisted_5$D
              ])
            ])
          ]),
          _: 1
        });
      };
    }
  });
  const _hoisted_1$Z = ["maxlength"];
  const _hoisted_2$S = {
    key: 0,
    class: "hidden bg-white dark:bg-gray-800 rounded-full px-3 py-1 text-sm text-gray-400 dark:text-gray-500 shadow-sm select-none pointer-events-none transition-colors duration-200"
  };
  const _hoisted_3$M = {
    key: 1,
    class: "absolute bottom-4 right-4"
  };
  const _hoisted_4$E = { class: "truncate max-w-[150px]" };
  const _hoisted_5$C = {
    key: 0,
    class: "origin-top-right absolute right-0 mt-2 w-56 rounded-md shadow-lg bg-white dark:bg-gray-800 ring-1 ring-black ring-opacity-5 dark:ring-gray-700 focus:outline-none z-50 max-h-60 overflow-y-auto"
  };
  const _hoisted_6$y = {
    class: "py-1",
    role: "menu",
    "aria-orientation": "vertical",
    "aria-labelledby": "options-menu"
  };
  const _hoisted_7$u = ["onClick"];
  const maxHeight = 400;
  const _sfc_main$10 = /* @__PURE__ */ defineComponent({
    __name: "SecretContentInputArea",
    props: {
      availableDomains: {},
      initialDomain: { default: "" },
      withDomainDropdown: { type: Boolean, default: false },
      maxLength: {},
      initialContent: {}
    },
    emits: ["update:selectedDomain", "update:content"],
    setup(__props, { emit: __emit }) {
      const availablePlans = window.available_plans;
      const cust = window.cust;
      const planOptions = (cust == null ? void 0 : cust.plan.options) || (availablePlans == null ? void 0 : availablePlans.anonymous.options);
      const maxSize = (planOptions == null ? void 0 : planOptions.size) || 1e4;
      const isHovering = ref(false);
      const showCounter = computed(() => {
        return isHovering.value || charCount.value > localMaxLength.value / 2;
      });
      const handleMouseEnter = () => {
        isHovering.value = true;
      };
      const handleMouseLeave = () => {
        isHovering.value = false;
      };
      const formatNumber = (num) => {
        return new Intl.NumberFormat().format(num);
      };
      const formattedCharCount = computed(() => formatNumber(charCount.value));
      const formattedMaxLength = computed(() => formatNumber(localMaxLength.value));
      const props = __props;
      const emit2 = __emit;
      const content = ref(props.initialContent || "");
      const charCount = ref(0);
      const isOpen = ref(false);
      const selectedDomain = ref(props.initialDomain);
      const dropdownRef = ref(null);
      const textareaRef = ref(null);
      const localMaxLength = ref(props.maxLength || maxSize);
      let watchStop = null;
      const toggleDropdown = (event) => {
        event.stopPropagation();
        isOpen.value = !isOpen.value;
      };
      const selectDomain = (domain) => {
        selectedDomain.value = domain;
        emit2("update:selectedDomain", domain);
        isOpen.value = false;
      };
      const closeDropdown = () => {
        isOpen.value = false;
      };
      const handleClickOutside = (event) => {
        if (dropdownRef.value && !dropdownRef.value.contains(event.target)) {
          closeDropdown();
        }
      };
      const handleEscapeKey = (event) => {
        if (event.key === "Escape") {
          closeDropdown();
        }
      };
      const adjustTextareaHeight = () => {
        if (textareaRef.value) {
          textareaRef.value.style.height = "auto";
          const newHeight = Math.min(textareaRef.value.scrollHeight, maxHeight);
          textareaRef.value.style.height = newHeight + "px";
          if (newHeight >= maxHeight && watchStop) {
            watchStop();
            watchStop = null;
          }
        }
      };
      const checkContentLength = (event) => {
        const target = event.target;
        if (target.value.length <= localMaxLength.value) {
          content.value = target.value;
          charCount.value = target.value.length;
        } else {
          content.value = target.value.slice(0, props.maxLength);
          charCount.value = localMaxLength.value;
          target.value = content.value;
        }
        adjustTextareaHeight();
        emit2("update:content", content.value);
      };
      watchStop = watch(content, (newContent) => {
        emit2("update:content", newContent);
        adjustTextareaHeight();
      });
      onMounted(() => {
        document.addEventListener("click", handleClickOutside);
        document.addEventListener("keydown", handleEscapeKey);
        adjustTextareaHeight();
      });
      onUnmounted(() => {
        document.removeEventListener("click", handleClickOutside);
        document.removeEventListener("keydown", handleEscapeKey);
      });
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", {
          class: "relative",
          onMouseenter: handleMouseEnter,
          onMouseleave: handleMouseLeave
        }, [
          withDirectives(createBaseVNode("textarea", {
            ref_key: "textareaRef",
            ref: textareaRef,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => content.value = $event),
            onInput: checkContentLength,
            maxlength: _ctx.maxLength,
            class: "w-full min-h-[6rem] max-h-[400px] p-4 font-mono text-base leading-[1.2] tracking-wide border-gray-300 rounded-md shadow-sm focus:ring-brandcomp-500 focus:border-brandcomp-500 bg-white dark:bg-gray-800 dark:border-gray-600 dark:text-white placeholder-gray-400 dark:placeholder-gray-500 resize-none overflow-y-auto transition-colors duration-200",
            name: "secret",
            autofocus: "",
            autocomplete: "off",
            placeholder: "Secret content goes here...",
            "aria-label": "Enter the secret content to share here"
          }, "\n    ", 40, _hoisted_1$Z), [
            [vModelText, content.value]
          ]),
          showCounter.value ? (openBlock(), createElementBlock("div", _hoisted_2$S, toDisplayString(formattedCharCount.value) + " / " + toDisplayString(formattedMaxLength.value) + " chars ", 1)) : createCommentVNode("", true),
          _ctx.withDomainDropdown ? (openBlock(), createElementBlock("div", _hoisted_3$M, [
            createBaseVNode("div", {
              class: "relative inline-block text-left",
              ref_key: "dropdownRef",
              ref: dropdownRef
            }, [
              createBaseVNode("button", {
                type: "button",
                onClick: toggleDropdown,
                class: "inline-flex justify-between items-center w-full rounded-md px-4 py-2 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 text-sm font-medium text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-brandcomp-500 dark:focus:ring-offset-gray-800 transition-colors duration-200"
              }, [
                createBaseVNode("span", _hoisted_4$E, toDisplayString(selectedDomain.value || "Select Domain"), 1),
                createVNode(unref(Icon), {
                  icon: "heroicons-solid:chevron-down",
                  class: "ml-2 flex-shrink-0 h-5 w-5 text-gray-400 dark:text-gray-500",
                  "aria-hidden": "true"
                })
              ]),
              isOpen.value ? (openBlock(), createElementBlock("div", _hoisted_5$C, [
                createBaseVNode("div", _hoisted_6$y, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.availableDomains, (domain) => {
                    return openBlock(), createElementBlock("a", {
                      key: domain,
                      href: "#",
                      onClick: withModifiers(($event) => selectDomain(domain), ["prevent"]),
                      class: "block px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 hover:text-gray-900 dark:hover:text-white transition-colors duration-200",
                      role: "menuitem"
                    }, toDisplayString(domain), 9, _hoisted_7$u);
                  }), 128))
                ])
              ])) : createCommentVNode("", true)
            ], 512)
          ])) : createCommentVNode("", true)
        ], 32);
      };
    }
  });
  const SecretContentInputArea = /* @__PURE__ */ _export_sfc(_sfc_main$10, [["__scopeId", "data-v-93c94bbe"]]);
  const _hoisted_1$Y = { class: "space-y-6 mt-4" };
  const _hoisted_2$R = { class: "flex flex-col md:flex-row md:space-x-4 space-y-6 md:space-y-0" };
  const _hoisted_3$L = {
    key: 0,
    class: "flex-1"
  };
  const _hoisted_4$D = /* @__PURE__ */ createBaseVNode("label", {
    for: "currentPassphrase",
    class: "sr-only"
  }, "Passphrase:", -1);
  const _hoisted_5$B = { class: "relative" };
  const _hoisted_6$x = ["type"];
  const _hoisted_7$t = {
    key: 1,
    class: "flex-1"
  };
  const _hoisted_8$r = /* @__PURE__ */ createBaseVNode("label", {
    for: "lifetime",
    class: "sr-only"
  }, "Lifetime:", -1);
  const _hoisted_9$s = /* @__PURE__ */ createBaseVNode("option", {
    value: "",
    disabled: ""
  }, "Select duration", -1);
  const _hoisted_10$p = ["value"];
  const _hoisted_11$o = /* @__PURE__ */ createBaseVNode("span", { class: "text-gray-500" }, "Expires in", -1);
  const _hoisted_12$l = {
    key: 0,
    class: "flex flex-col"
  };
  const _hoisted_13$k = /* @__PURE__ */ createBaseVNode("label", {
    for: "recipient",
    class: "block font-brand text-sm font-medium text-gray-500 dark:text-gray-300 mb-2 transition-colors duration-200"
  }, " Recipient Address ", -1);
  const _hoisted_14$g = /* @__PURE__ */ createBaseVNode("input", {
    type: "email",
    tabindex: "5",
    id: "recipient",
    name: "recipient[]",
    placeholder: "tom@myspace.com",
    class: "w-full px-4 py-2 border border-gray-300 rounded-md focus:ring-brandcomp-500 focus:border-brandcomp-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white transition-colors duration-200"
  }, null, -1);
  const _hoisted_15$g = [
    _hoisted_13$k,
    _hoisted_14$g
  ];
  const _sfc_main$$ = /* @__PURE__ */ defineComponent({
    __name: "SecretFormPrivacyOptions",
    props: {
      enabled: { type: Boolean, default: true },
      withRecipient: { type: Boolean, default: false },
      withPassphrase: { type: Boolean, default: true },
      withExpiry: { type: Boolean, default: true }
    },
    setup(__props) {
      const plan = useWindowProp("plan");
      const props = __props;
      const showPassphrase = ref(false);
      const currentPassphrase = ref("");
      const selectedLifetime = ref("604800.0");
      const lifetimeOptions = [
        { value: "1209600.0", label: "14 days" },
        { value: "604800.0", label: "7 days" },
        { value: "259200.0", label: "3 days" },
        { value: "86400.0", label: "1 day" },
        { value: "43200.0", label: "12 hours" },
        { value: "14400.0", label: "4 hours" },
        { value: "3600.0", label: "1 hour" },
        { value: "1800.0", label: "30 minutes" },
        { value: "300.0", label: "5 minutes" }
      ];
      const filteredLifetimeOptions = computed(() => {
        var _a, _b;
        const planTtl = ((_b = (_a = plan.value) == null ? void 0 : _a.options) == null ? void 0 : _b.ttl) || 0;
        return lifetimeOptions.filter((option) => parseFloat(option.value) <= planTtl);
      });
      const togglePassphrase = () => {
        showPassphrase.value = !showPassphrase.value;
      };
      return (_ctx, _cache) => {
        return openBlock(), createBlock(SecretFormDrawer, { title: "Privacy Options" }, {
          default: withCtx(() => [
            createBaseVNode("div", _hoisted_1$Y, [
              createBaseVNode("div", _hoisted_2$R, [
                props.withPassphrase ? (openBlock(), createElementBlock("div", _hoisted_3$L, [
                  _hoisted_4$D,
                  createBaseVNode("div", _hoisted_5$B, [
                    withDirectives(createBaseVNode("input", {
                      type: showPassphrase.value ? "text" : "password",
                      tabindex: "3",
                      id: "currentPassphrase",
                      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => currentPassphrase.value = $event),
                      name: "passphrase",
                      autocomplete: "unique-passphrase",
                      placeholder: "Enter a passphrase",
                      "aria-label": "Passphrase",
                      class: "w-full px-4 py-2 border rounded-md border-gray-300 focus:ring-brandcomp-500 focus:border-brandcomp-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white transition-colors duration-200"
                    }, null, 8, _hoisted_6$x), [
                      [vModelDynamic, currentPassphrase.value]
                    ]),
                    createBaseVNode("button", {
                      type: "button",
                      onClick: _cache[1] || (_cache[1] = ($event) => togglePassphrase()),
                      class: "absolute inset-y-0 right-0 flex items-center px-3 text-gray-500 dark:text-gray-300 transition-colors duration-200"
                    }, [
                      createVNode(unref(Icon), {
                        icon: showPassphrase.value ? "mdi:eye" : "mdi:eye-off",
                        class: "w-5 h-5"
                      }, null, 8, ["icon"])
                    ])
                  ])
                ])) : createCommentVNode("", true),
                props.withExpiry ? (openBlock(), createElementBlock("div", _hoisted_7$t, [
                  _hoisted_8$r,
                  withDirectives(createBaseVNode("select", {
                    id: "lifetime",
                    tabindex: "4",
                    name: "ttl",
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => selectedLifetime.value = $event),
                    class: "w-full px-4 py-2 border rounded-md border-gray-300 focus:ring-brandcomp-500 focus:border-brandcomp-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white transition-colors duration-200"
                  }, [
                    _hoisted_9$s,
                    (openBlock(true), createElementBlock(Fragment, null, renderList(filteredLifetimeOptions.value, (option) => {
                      return openBlock(), createElementBlock("option", {
                        key: option.value,
                        value: option.value
                      }, [
                        _hoisted_11$o,
                        createTextVNode(" " + toDisplayString(option.label), 1)
                      ], 8, _hoisted_10$p);
                    }), 128))
                  ], 512), [
                    [vModelSelect, selectedLifetime.value]
                  ])
                ])) : createCommentVNode("", true)
              ]),
              props.withRecipient ? (openBlock(), createElementBlock("div", _hoisted_12$l, _hoisted_15$g)) : createCommentVNode("", true)
            ])
          ]),
          _: 1
        });
      };
    }
  });
  const _hoisted_1$X = ["disabled", "aria-label", "title"];
  const _hoisted_2$Q = /* @__PURE__ */ createBaseVNode("span", {
    class: "inline-block transition-margin duration-200 ease-in-out mr-0 group-hover:mr-2 opacity-80",
    "aria-hidden": "true"
  }, "🔑", -1);
  const _hoisted_3$K = { class: "opacity-0 transition-opacity duration-200 ease-in-out group-hover:opacity-100" };
  const _sfc_main$_ = /* @__PURE__ */ defineComponent({
    __name: "GenerateButton",
    props: {
      disabled: { type: Boolean }
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("button", {
          type: "submit",
          class: "generate-btn text-base py-2 px-4 pr-6 rounded bg-brand-100 dark:bg-gray-700 hover:bg-gray-600 dark:hover:bg-gray-600 text-white font-medium transition-all duration-200 ease-in-out transform w-12 hover:w-56 overflow-hidden whitespace-nowrap group disabled:opacity-50 disabled:cursor-not-allowed disabled:bg-gray-400 dark:disabled:bg-gray-700 disabled:hover:bg-gray-400 dark:disabled:hover:bg-gray-700 disabled:hover:scale-100 disabled:hover:w-12",
          disabled: _ctx.disabled,
          "aria-label": _ctx.$t("web.COMMON.button_generate_secret_short"),
          title: _ctx.disabled ? _ctx.$t("web.COMMON.generate_password_disabled") : "",
          name: "kind",
          value: "generate"
        }, [
          _hoisted_2$Q,
          createBaseVNode("span", _hoisted_3$K, toDisplayString(_ctx.$t("web.COMMON.button_generate_secret_short")), 1)
        ], 8, _hoisted_1$X);
      };
    }
  });
  const _hoisted_1$W = ["disabled", "aria-label"];
  const _hoisted_2$P = { key: 0 };
  const _sfc_main$Z = /* @__PURE__ */ defineComponent({
    __name: "ConcealButton",
    props: {
      disabled: { type: Boolean },
      withAsterisk: { type: Boolean }
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("button", {
          type: "submit",
          class: "text-xl flex-grow py-2 px-4 rounded bg-orange-600 hover:bg-orange-700 text-white font-bold disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200 ease-in-out transform hover:scale-105 disabled:hover:scale-100",
          disabled: _ctx.disabled,
          "aria-label": _ctx.$t("web.COMMON.button_create_secret"),
          name: "kind",
          value: "share"
        }, [
          createTextVNode(toDisplayString(_ctx.$t("web.COMMON.button_create_secret")), 1),
          _ctx.withAsterisk ? (openBlock(), createElementBlock("span", _hoisted_2$P, "*")) : createCommentVNode("", true)
        ], 8, _hoisted_1$W);
      };
    }
  });
  function useFormSubmission(options) {
    const isSubmitting = ref(false);
    const error = ref("");
    const success = ref("");
    const submitForm = async (event) => {
      var _a;
      isSubmitting.value = true;
      error.value = "";
      success.value = "";
      try {
        let formData;
        let submissionUrl;
        const url = options.url;
        if (options.getFormData) {
          formData = options.getFormData();
          if (!options.url) {
            throw new Error("URL is required when using getFormData");
          }
          submissionUrl = options.url;
        } else if (event) {
          const form = event.target;
          formData = new FormData(form);
          if (!url) {
            submissionUrl = form.action;
          } else {
            submissionUrl = url;
          }
          if (!submissionUrl) {
            throw new Error("No URL provided in options or form action");
          }
        } else {
          throw new Error("No form data provided");
        }
        const urlSearchParams = formData instanceof URLSearchParams ? formData : new URLSearchParams(formData);
        const csrfStore = useCsrfStore();
        urlSearchParams.append("shrimp", csrfStore.shrimp);
        const response = await fetch(submissionUrl, {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          },
          body: urlSearchParams.toString()
        });
        let jsonData;
        try {
          jsonData = await response.json();
        } catch (error2) {
          const message = `Server returned an incomplete response (${url})`;
          console.error(message, error2);
          throw new Error(message);
        }
        if (jsonData == null ? void 0 : jsonData.shrimp) {
          csrfStore.updateShrimp(jsonData.shrimp);
        }
        if (!response.ok) {
          if (options.onError) {
            await options.onError(jsonData);
          }
          if ((_a = response.headers.get("content-type")) == null ? void 0 : _a.includes("application/json")) {
            throw new Error(jsonData.message || "Request was not successful. Please try again later.");
          } else {
            throw new Error("Please refresh the page and try again.");
          }
        }
        success.value = options.successMessage;
        if (options.onSuccess) {
          await options.onSuccess(jsonData);
        }
        if (options.redirectUrl) {
          setTimeout(() => {
            window.location.href = options.redirectUrl;
          }, options.redirectDelay || 3e3);
        }
      } catch (err) {
        if (err instanceof Error) {
          error.value = err.message;
        } else {
          const msg = "An unexpected error occurred";
          console.error(msg, err);
          error.value = msg;
        }
      } finally {
        isSubmitting.value = false;
      }
    };
    return {
      isSubmitting,
      error,
      success,
      submitForm
    };
  }
  /*!
    * vue-router v4.4.0
    * (c) 2024 Eduardo San Martin Morote
    * @license MIT
    */
  const isBrowser = typeof document !== "undefined";
  function isESModule(obj) {
    return obj.__esModule || obj[Symbol.toStringTag] === "Module";
  }
  const assign = Object.assign;
  function applyToParams(fn2, params) {
    const newParams = {};
    for (const key in params) {
      const value = params[key];
      newParams[key] = isArray(value) ? value.map(fn2) : fn2(value);
    }
    return newParams;
  }
  const noop = () => {
  };
  const isArray = Array.isArray;
  const HASH_RE = /#/g;
  const AMPERSAND_RE = /&/g;
  const SLASH_RE = /\//g;
  const EQUAL_RE = /=/g;
  const IM_RE = /\?/g;
  const PLUS_RE = /\+/g;
  const ENC_BRACKET_OPEN_RE = /%5B/g;
  const ENC_BRACKET_CLOSE_RE = /%5D/g;
  const ENC_CARET_RE = /%5E/g;
  const ENC_BACKTICK_RE = /%60/g;
  const ENC_CURLY_OPEN_RE = /%7B/g;
  const ENC_PIPE_RE = /%7C/g;
  const ENC_CURLY_CLOSE_RE = /%7D/g;
  const ENC_SPACE_RE = /%20/g;
  function commonEncode(text) {
    return encodeURI("" + text).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
  }
  function encodeHash(text) {
    return commonEncode(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
  }
  function encodeQueryValue(text) {
    return commonEncode(text).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
  }
  function encodeQueryKey(text) {
    return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
  }
  function encodePath(text) {
    return commonEncode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
  }
  function encodeParam(text) {
    return text == null ? "" : encodePath(text).replace(SLASH_RE, "%2F");
  }
  function decode(text) {
    try {
      return decodeURIComponent("" + text);
    } catch (err) {
    }
    return "" + text;
  }
  const TRAILING_SLASH_RE = /\/$/;
  const removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, "");
  function parseURL(parseQuery2, location2, currentLocation = "/") {
    let path, query = {}, searchString = "", hash = "";
    const hashPos = location2.indexOf("#");
    let searchPos = location2.indexOf("?");
    if (hashPos < searchPos && hashPos >= 0) {
      searchPos = -1;
    }
    if (searchPos > -1) {
      path = location2.slice(0, searchPos);
      searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);
      query = parseQuery2(searchString);
    }
    if (hashPos > -1) {
      path = path || location2.slice(0, hashPos);
      hash = location2.slice(hashPos, location2.length);
    }
    path = resolveRelativePath(path != null ? path : location2, currentLocation);
    return {
      fullPath: path + (searchString && "?") + searchString + hash,
      path,
      query,
      hash: decode(hash)
    };
  }
  function stringifyURL(stringifyQuery2, location2) {
    const query = location2.query ? stringifyQuery2(location2.query) : "";
    return location2.path + (query && "?") + query + (location2.hash || "");
  }
  function stripBase(pathname, base) {
    if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))
      return pathname;
    return pathname.slice(base.length) || "/";
  }
  function isSameRouteLocation(stringifyQuery2, a2, b2) {
    const aLastIndex = a2.matched.length - 1;
    const bLastIndex = b2.matched.length - 1;
    return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a2.matched[aLastIndex], b2.matched[bLastIndex]) && isSameRouteLocationParams(a2.params, b2.params) && stringifyQuery2(a2.query) === stringifyQuery2(b2.query) && a2.hash === b2.hash;
  }
  function isSameRouteRecord(a2, b2) {
    return (a2.aliasOf || a2) === (b2.aliasOf || b2);
  }
  function isSameRouteLocationParams(a2, b2) {
    if (Object.keys(a2).length !== Object.keys(b2).length)
      return false;
    for (const key in a2) {
      if (!isSameRouteLocationParamsValue(a2[key], b2[key]))
        return false;
    }
    return true;
  }
  function isSameRouteLocationParamsValue(a2, b2) {
    return isArray(a2) ? isEquivalentArray(a2, b2) : isArray(b2) ? isEquivalentArray(b2, a2) : a2 === b2;
  }
  function isEquivalentArray(a2, b2) {
    return isArray(b2) ? a2.length === b2.length && a2.every((value, i2) => value === b2[i2]) : a2.length === 1 && a2[0] === b2;
  }
  function resolveRelativePath(to, from) {
    if (to.startsWith("/"))
      return to;
    if (!to)
      return from;
    const fromSegments = from.split("/");
    const toSegments = to.split("/");
    const lastToSegment = toSegments[toSegments.length - 1];
    if (lastToSegment === ".." || lastToSegment === ".") {
      toSegments.push("");
    }
    let position = fromSegments.length - 1;
    let toPosition;
    let segment;
    for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
      segment = toSegments[toPosition];
      if (segment === ".")
        continue;
      if (segment === "..") {
        if (position > 1)
          position--;
      } else
        break;
    }
    return fromSegments.slice(0, position).join("/") + "/" + toSegments.slice(toPosition).join("/");
  }
  const START_LOCATION_NORMALIZED = {
    path: "/",
    // TODO: could we use a symbol in the future?
    name: void 0,
    params: {},
    query: {},
    hash: "",
    fullPath: "/",
    matched: [],
    meta: {},
    redirectedFrom: void 0
  };
  var NavigationType;
  (function(NavigationType2) {
    NavigationType2["pop"] = "pop";
    NavigationType2["push"] = "push";
  })(NavigationType || (NavigationType = {}));
  var NavigationDirection;
  (function(NavigationDirection2) {
    NavigationDirection2["back"] = "back";
    NavigationDirection2["forward"] = "forward";
    NavigationDirection2["unknown"] = "";
  })(NavigationDirection || (NavigationDirection = {}));
  function normalizeBase(base) {
    if (!base) {
      if (isBrowser) {
        const baseEl = document.querySelector("base");
        base = baseEl && baseEl.getAttribute("href") || "/";
        base = base.replace(/^\w+:\/\/[^\/]+/, "");
      } else {
        base = "/";
      }
    }
    if (base[0] !== "/" && base[0] !== "#")
      base = "/" + base;
    return removeTrailingSlash(base);
  }
  const BEFORE_HASH_RE = /^[^#]+#/;
  function createHref(base, location2) {
    return base.replace(BEFORE_HASH_RE, "#") + location2;
  }
  function getElementPosition(el, offset) {
    const docRect = document.documentElement.getBoundingClientRect();
    const elRect = el.getBoundingClientRect();
    return {
      behavior: offset.behavior,
      left: elRect.left - docRect.left - (offset.left || 0),
      top: elRect.top - docRect.top - (offset.top || 0)
    };
  }
  const computeScrollPosition = () => ({
    left: window.scrollX,
    top: window.scrollY
  });
  function scrollToPosition(position) {
    let scrollToOptions;
    if ("el" in position) {
      const positionEl = position.el;
      const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
      const el = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
      if (!el) {
        return;
      }
      scrollToOptions = getElementPosition(el, position);
    } else {
      scrollToOptions = position;
    }
    if ("scrollBehavior" in document.documentElement.style)
      window.scrollTo(scrollToOptions);
    else {
      window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.scrollX, scrollToOptions.top != null ? scrollToOptions.top : window.scrollY);
    }
  }
  function getScrollKey(path, delta) {
    const position = history.state ? history.state.position - delta : -1;
    return position + path;
  }
  const scrollPositions = /* @__PURE__ */ new Map();
  function saveScrollPosition(key, scrollPosition) {
    scrollPositions.set(key, scrollPosition);
  }
  function getSavedScrollPosition(key) {
    const scroll = scrollPositions.get(key);
    scrollPositions.delete(key);
    return scroll;
  }
  let createBaseLocation = () => location.protocol + "//" + location.host;
  function createCurrentLocation(base, location2) {
    const { pathname, search, hash } = location2;
    const hashPos = base.indexOf("#");
    if (hashPos > -1) {
      let slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;
      let pathFromHash = hash.slice(slicePos);
      if (pathFromHash[0] !== "/")
        pathFromHash = "/" + pathFromHash;
      return stripBase(pathFromHash, "");
    }
    const path = stripBase(pathname, base);
    return path + search + hash;
  }
  function useHistoryListeners(base, historyState, currentLocation, replace) {
    let listeners = [];
    let teardowns = [];
    let pauseState = null;
    const popStateHandler = ({ state }) => {
      const to = createCurrentLocation(base, location);
      const from = currentLocation.value;
      const fromState = historyState.value;
      let delta = 0;
      if (state) {
        currentLocation.value = to;
        historyState.value = state;
        if (pauseState && pauseState === from) {
          pauseState = null;
          return;
        }
        delta = fromState ? state.position - fromState.position : 0;
      } else {
        replace(to);
      }
      listeners.forEach((listener) => {
        listener(currentLocation.value, from, {
          delta,
          type: NavigationType.pop,
          direction: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
        });
      });
    };
    function pauseListeners() {
      pauseState = currentLocation.value;
    }
    function listen(callback) {
      listeners.push(callback);
      const teardown = () => {
        const index = listeners.indexOf(callback);
        if (index > -1)
          listeners.splice(index, 1);
      };
      teardowns.push(teardown);
      return teardown;
    }
    function beforeUnloadListener() {
      const { history: history2 } = window;
      if (!history2.state)
        return;
      history2.replaceState(assign({}, history2.state, { scroll: computeScrollPosition() }), "");
    }
    function destroy() {
      for (const teardown of teardowns)
        teardown();
      teardowns = [];
      window.removeEventListener("popstate", popStateHandler);
      window.removeEventListener("beforeunload", beforeUnloadListener);
    }
    window.addEventListener("popstate", popStateHandler);
    window.addEventListener("beforeunload", beforeUnloadListener, {
      passive: true
    });
    return {
      pauseListeners,
      listen,
      destroy
    };
  }
  function buildState(back, current, forward, replaced = false, computeScroll = false) {
    return {
      back,
      current,
      forward,
      replaced,
      position: window.history.length,
      scroll: computeScroll ? computeScrollPosition() : null
    };
  }
  function useHistoryStateNavigation(base) {
    const { history: history2, location: location2 } = window;
    const currentLocation = {
      value: createCurrentLocation(base, location2)
    };
    const historyState = { value: history2.state };
    if (!historyState.value) {
      changeLocation(currentLocation.value, {
        back: null,
        current: currentLocation.value,
        forward: null,
        // the length is off by one, we need to decrease it
        position: history2.length - 1,
        replaced: true,
        // don't add a scroll as the user may have an anchor, and we want
        // scrollBehavior to be triggered without a saved position
        scroll: null
      }, true);
    }
    function changeLocation(to, state, replace2) {
      const hashIndex = base.indexOf("#");
      const url = hashIndex > -1 ? (location2.host && document.querySelector("base") ? base : base.slice(hashIndex)) + to : createBaseLocation() + base + to;
      try {
        history2[replace2 ? "replaceState" : "pushState"](state, "", url);
        historyState.value = state;
      } catch (err) {
        {
          console.error(err);
        }
        location2[replace2 ? "replace" : "assign"](url);
      }
    }
    function replace(to, data) {
      const state = assign({}, history2.state, buildState(
        historyState.value.back,
        // keep back and forward entries but override current position
        to,
        historyState.value.forward,
        true
      ), data, { position: historyState.value.position });
      changeLocation(to, state, true);
      currentLocation.value = to;
    }
    function push(to, data) {
      const currentState = assign(
        {},
        // use current history state to gracefully handle a wrong call to
        // history.replaceState
        // https://github.com/vuejs/router/issues/366
        historyState.value,
        history2.state,
        {
          forward: to,
          scroll: computeScrollPosition()
        }
      );
      changeLocation(currentState.current, currentState, true);
      const state = assign({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);
      changeLocation(to, state, false);
      currentLocation.value = to;
    }
    return {
      location: currentLocation,
      state: historyState,
      push,
      replace
    };
  }
  function createWebHistory(base) {
    base = normalizeBase(base);
    const historyNavigation = useHistoryStateNavigation(base);
    const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
    function go(delta, triggerListeners = true) {
      if (!triggerListeners)
        historyListeners.pauseListeners();
      history.go(delta);
    }
    const routerHistory = assign({
      // it's overridden right after
      location: "",
      base,
      go,
      createHref: createHref.bind(null, base)
    }, historyNavigation, historyListeners);
    Object.defineProperty(routerHistory, "location", {
      enumerable: true,
      get: () => historyNavigation.location.value
    });
    Object.defineProperty(routerHistory, "state", {
      enumerable: true,
      get: () => historyNavigation.state.value
    });
    return routerHistory;
  }
  function isRouteLocation(route) {
    return typeof route === "string" || route && typeof route === "object";
  }
  function isRouteName(name) {
    return typeof name === "string" || typeof name === "symbol";
  }
  const NavigationFailureSymbol = Symbol("");
  var NavigationFailureType;
  (function(NavigationFailureType2) {
    NavigationFailureType2[NavigationFailureType2["aborted"] = 4] = "aborted";
    NavigationFailureType2[NavigationFailureType2["cancelled"] = 8] = "cancelled";
    NavigationFailureType2[NavigationFailureType2["duplicated"] = 16] = "duplicated";
  })(NavigationFailureType || (NavigationFailureType = {}));
  function createRouterError(type, params) {
    {
      return assign(new Error(), {
        type,
        [NavigationFailureSymbol]: true
      }, params);
    }
  }
  function isNavigationFailure(error, type) {
    return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));
  }
  const BASE_PARAM_PATTERN = "[^/]+?";
  const BASE_PATH_PARSER_OPTIONS = {
    sensitive: false,
    strict: false,
    start: true,
    end: true
  };
  const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
  function tokensToParser(segments, extraOptions) {
    const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
    const score = [];
    let pattern = options.start ? "^" : "";
    const keys = [];
    for (const segment of segments) {
      const segmentScores = segment.length ? [] : [
        90
        /* PathScore.Root */
      ];
      if (options.strict && !segment.length)
        pattern += "/";
      for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
        const token = segment[tokenIndex];
        let subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);
        if (token.type === 0) {
          if (!tokenIndex)
            pattern += "/";
          pattern += token.value.replace(REGEX_CHARS_RE, "\\$&");
          subSegmentScore += 40;
        } else if (token.type === 1) {
          const { value, repeatable, optional, regexp } = token;
          keys.push({
            name: value,
            repeatable,
            optional
          });
          const re2 = regexp ? regexp : BASE_PARAM_PATTERN;
          if (re2 !== BASE_PARAM_PATTERN) {
            subSegmentScore += 10;
            try {
              new RegExp(`(${re2})`);
            } catch (err) {
              throw new Error(`Invalid custom RegExp for param "${value}" (${re2}): ` + err.message);
            }
          }
          let subPattern = repeatable ? `((?:${re2})(?:/(?:${re2}))*)` : `(${re2})`;
          if (!tokenIndex)
            subPattern = // avoid an optional / if there are more segments e.g. /:p?-static
            // or /:p?-:p2
            optional && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
          if (optional)
            subPattern += "?";
          pattern += subPattern;
          subSegmentScore += 20;
          if (optional)
            subSegmentScore += -8;
          if (repeatable)
            subSegmentScore += -20;
          if (re2 === ".*")
            subSegmentScore += -50;
        }
        segmentScores.push(subSegmentScore);
      }
      score.push(segmentScores);
    }
    if (options.strict && options.end) {
      const i2 = score.length - 1;
      score[i2][score[i2].length - 1] += 0.7000000000000001;
    }
    if (!options.strict)
      pattern += "/?";
    if (options.end)
      pattern += "$";
    else if (options.strict)
      pattern += "(?:/|$)";
    const re = new RegExp(pattern, options.sensitive ? "" : "i");
    function parse2(path) {
      const match = path.match(re);
      const params = {};
      if (!match)
        return null;
      for (let i2 = 1; i2 < match.length; i2++) {
        const value = match[i2] || "";
        const key = keys[i2 - 1];
        params[key.name] = value && key.repeatable ? value.split("/") : value;
      }
      return params;
    }
    function stringify(params) {
      let path = "";
      let avoidDuplicatedSlash = false;
      for (const segment of segments) {
        if (!avoidDuplicatedSlash || !path.endsWith("/"))
          path += "/";
        avoidDuplicatedSlash = false;
        for (const token of segment) {
          if (token.type === 0) {
            path += token.value;
          } else if (token.type === 1) {
            const { value, repeatable, optional } = token;
            const param = value in params ? params[value] : "";
            if (isArray(param) && !repeatable) {
              throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
            }
            const text = isArray(param) ? param.join("/") : param;
            if (!text) {
              if (optional) {
                if (segment.length < 2) {
                  if (path.endsWith("/"))
                    path = path.slice(0, -1);
                  else
                    avoidDuplicatedSlash = true;
                }
              } else
                throw new Error(`Missing required param "${value}"`);
            }
            path += text;
          }
        }
      }
      return path || "/";
    }
    return {
      re,
      score,
      keys,
      parse: parse2,
      stringify
    };
  }
  function compareScoreArray(a2, b2) {
    let i2 = 0;
    while (i2 < a2.length && i2 < b2.length) {
      const diff = b2[i2] - a2[i2];
      if (diff)
        return diff;
      i2++;
    }
    if (a2.length < b2.length) {
      return a2.length === 1 && a2[0] === 40 + 40 ? -1 : 1;
    } else if (a2.length > b2.length) {
      return b2.length === 1 && b2[0] === 40 + 40 ? 1 : -1;
    }
    return 0;
  }
  function comparePathParserScore(a2, b2) {
    let i2 = 0;
    const aScore = a2.score;
    const bScore = b2.score;
    while (i2 < aScore.length && i2 < bScore.length) {
      const comp = compareScoreArray(aScore[i2], bScore[i2]);
      if (comp)
        return comp;
      i2++;
    }
    if (Math.abs(bScore.length - aScore.length) === 1) {
      if (isLastScoreNegative(aScore))
        return 1;
      if (isLastScoreNegative(bScore))
        return -1;
    }
    return bScore.length - aScore.length;
  }
  function isLastScoreNegative(score) {
    const last = score[score.length - 1];
    return score.length > 0 && last[last.length - 1] < 0;
  }
  const ROOT_TOKEN = {
    type: 0,
    value: ""
  };
  const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
  function tokenizePath(path) {
    if (!path)
      return [[]];
    if (path === "/")
      return [[ROOT_TOKEN]];
    if (!path.startsWith("/")) {
      throw new Error(`Invalid path "${path}"`);
    }
    function crash(message) {
      throw new Error(`ERR (${state})/"${buffer2}": ${message}`);
    }
    let state = 0;
    let previousState = state;
    const tokens = [];
    let segment;
    function finalizeSegment() {
      if (segment)
        tokens.push(segment);
      segment = [];
    }
    let i2 = 0;
    let char;
    let buffer2 = "";
    let customRe = "";
    function consumeBuffer() {
      if (!buffer2)
        return;
      if (state === 0) {
        segment.push({
          type: 0,
          value: buffer2
        });
      } else if (state === 1 || state === 2 || state === 3) {
        if (segment.length > 1 && (char === "*" || char === "+"))
          crash(`A repeatable param (${buffer2}) must be alone in its segment. eg: '/:ids+.`);
        segment.push({
          type: 1,
          value: buffer2,
          regexp: customRe,
          repeatable: char === "*" || char === "+",
          optional: char === "*" || char === "?"
        });
      } else {
        crash("Invalid state to consume buffer");
      }
      buffer2 = "";
    }
    function addCharToBuffer() {
      buffer2 += char;
    }
    while (i2 < path.length) {
      char = path[i2++];
      if (char === "\\" && state !== 2) {
        previousState = state;
        state = 4;
        continue;
      }
      switch (state) {
        case 0:
          if (char === "/") {
            if (buffer2) {
              consumeBuffer();
            }
            finalizeSegment();
          } else if (char === ":") {
            consumeBuffer();
            state = 1;
          } else {
            addCharToBuffer();
          }
          break;
        case 4:
          addCharToBuffer();
          state = previousState;
          break;
        case 1:
          if (char === "(") {
            state = 2;
          } else if (VALID_PARAM_RE.test(char)) {
            addCharToBuffer();
          } else {
            consumeBuffer();
            state = 0;
            if (char !== "*" && char !== "?" && char !== "+")
              i2--;
          }
          break;
        case 2:
          if (char === ")") {
            if (customRe[customRe.length - 1] == "\\")
              customRe = customRe.slice(0, -1) + char;
            else
              state = 3;
          } else {
            customRe += char;
          }
          break;
        case 3:
          consumeBuffer();
          state = 0;
          if (char !== "*" && char !== "?" && char !== "+")
            i2--;
          customRe = "";
          break;
        default:
          crash("Unknown state");
          break;
      }
    }
    if (state === 2)
      crash(`Unfinished custom RegExp for param "${buffer2}"`);
    consumeBuffer();
    finalizeSegment();
    return tokens;
  }
  function createRouteRecordMatcher(record, parent, options) {
    const parser = tokensToParser(tokenizePath(record.path), options);
    const matcher = assign(parser, {
      record,
      parent,
      // these needs to be populated by the parent
      children: [],
      alias: []
    });
    if (parent) {
      if (!matcher.record.aliasOf === !parent.record.aliasOf)
        parent.children.push(matcher);
    }
    return matcher;
  }
  function createRouterMatcher(routes2, globalOptions) {
    const matchers = [];
    const matcherMap = /* @__PURE__ */ new Map();
    globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
    function getRecordMatcher(name) {
      return matcherMap.get(name);
    }
    function addRoute(record, parent, originalRecord) {
      const isRootAdd = !originalRecord;
      const mainNormalizedRecord = normalizeRouteRecord(record);
      mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
      const options = mergeOptions(globalOptions, record);
      const normalizedRecords = [
        mainNormalizedRecord
      ];
      if ("alias" in record) {
        const aliases = typeof record.alias === "string" ? [record.alias] : record.alias;
        for (const alias of aliases) {
          normalizedRecords.push(assign({}, mainNormalizedRecord, {
            // this allows us to hold a copy of the `components` option
            // so that async components cache is hold on the original record
            components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
            path: alias,
            // we might be the child of an alias
            aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
            // the aliases are always of the same kind as the original since they
            // are defined on the same record
          }));
        }
      }
      let matcher;
      let originalMatcher;
      for (const normalizedRecord of normalizedRecords) {
        const { path } = normalizedRecord;
        if (parent && path[0] !== "/") {
          const parentPath = parent.record.path;
          const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
          normalizedRecord.path = parent.record.path + (path && connectingSlash + path);
        }
        matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
        if (originalRecord) {
          originalRecord.alias.push(matcher);
        } else {
          originalMatcher = originalMatcher || matcher;
          if (originalMatcher !== matcher)
            originalMatcher.alias.push(matcher);
          if (isRootAdd && record.name && !isAliasRecord(matcher))
            removeRoute(record.name);
        }
        if (isMatchable(matcher)) {
          insertMatcher(matcher);
        }
        if (mainNormalizedRecord.children) {
          const children = mainNormalizedRecord.children;
          for (let i2 = 0; i2 < children.length; i2++) {
            addRoute(children[i2], matcher, originalRecord && originalRecord.children[i2]);
          }
        }
        originalRecord = originalRecord || matcher;
      }
      return originalMatcher ? () => {
        removeRoute(originalMatcher);
      } : noop;
    }
    function removeRoute(matcherRef) {
      if (isRouteName(matcherRef)) {
        const matcher = matcherMap.get(matcherRef);
        if (matcher) {
          matcherMap.delete(matcherRef);
          matchers.splice(matchers.indexOf(matcher), 1);
          matcher.children.forEach(removeRoute);
          matcher.alias.forEach(removeRoute);
        }
      } else {
        const index = matchers.indexOf(matcherRef);
        if (index > -1) {
          matchers.splice(index, 1);
          if (matcherRef.record.name)
            matcherMap.delete(matcherRef.record.name);
          matcherRef.children.forEach(removeRoute);
          matcherRef.alias.forEach(removeRoute);
        }
      }
    }
    function getRoutes() {
      return matchers;
    }
    function insertMatcher(matcher) {
      const index = findInsertionIndex(matcher, matchers);
      matchers.splice(index, 0, matcher);
      if (matcher.record.name && !isAliasRecord(matcher))
        matcherMap.set(matcher.record.name, matcher);
    }
    function resolve2(location2, currentLocation) {
      let matcher;
      let params = {};
      let path;
      let name;
      if ("name" in location2 && location2.name) {
        matcher = matcherMap.get(location2.name);
        if (!matcher)
          throw createRouterError(1, {
            location: location2
          });
        name = matcher.record.name;
        params = assign(
          // paramsFromLocation is a new object
          paramsFromLocation(
            currentLocation.params,
            // only keep params that exist in the resolved location
            // only keep optional params coming from a parent record
            matcher.keys.filter((k2) => !k2.optional).concat(matcher.parent ? matcher.parent.keys.filter((k2) => k2.optional) : []).map((k2) => k2.name)
          ),
          // discard any existing params in the current location that do not exist here
          // #1497 this ensures better active/exact matching
          location2.params && paramsFromLocation(location2.params, matcher.keys.map((k2) => k2.name))
        );
        path = matcher.stringify(params);
      } else if (location2.path != null) {
        path = location2.path;
        matcher = matchers.find((m2) => m2.re.test(path));
        if (matcher) {
          params = matcher.parse(path);
          name = matcher.record.name;
        }
      } else {
        matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find((m2) => m2.re.test(currentLocation.path));
        if (!matcher)
          throw createRouterError(1, {
            location: location2,
            currentLocation
          });
        name = matcher.record.name;
        params = assign({}, currentLocation.params, location2.params);
        path = matcher.stringify(params);
      }
      const matched = [];
      let parentMatcher = matcher;
      while (parentMatcher) {
        matched.unshift(parentMatcher.record);
        parentMatcher = parentMatcher.parent;
      }
      return {
        name,
        path,
        params,
        matched,
        meta: mergeMetaFields(matched)
      };
    }
    routes2.forEach((route) => addRoute(route));
    function clearRoutes() {
      matchers.length = 0;
      matcherMap.clear();
    }
    return {
      addRoute,
      resolve: resolve2,
      removeRoute,
      clearRoutes,
      getRoutes,
      getRecordMatcher
    };
  }
  function paramsFromLocation(params, keys) {
    const newParams = {};
    for (const key of keys) {
      if (key in params)
        newParams[key] = params[key];
    }
    return newParams;
  }
  function normalizeRouteRecord(record) {
    return {
      path: record.path,
      redirect: record.redirect,
      name: record.name,
      meta: record.meta || {},
      aliasOf: void 0,
      beforeEnter: record.beforeEnter,
      props: normalizeRecordProps(record),
      children: record.children || [],
      instances: {},
      leaveGuards: /* @__PURE__ */ new Set(),
      updateGuards: /* @__PURE__ */ new Set(),
      enterCallbacks: {},
      components: "components" in record ? record.components || null : record.component && { default: record.component }
    };
  }
  function normalizeRecordProps(record) {
    const propsObject = {};
    const props = record.props || false;
    if ("component" in record) {
      propsObject.default = props;
    } else {
      for (const name in record.components)
        propsObject[name] = typeof props === "object" ? props[name] : props;
    }
    return propsObject;
  }
  function isAliasRecord(record) {
    while (record) {
      if (record.record.aliasOf)
        return true;
      record = record.parent;
    }
    return false;
  }
  function mergeMetaFields(matched) {
    return matched.reduce((meta, record) => assign(meta, record.meta), {});
  }
  function mergeOptions(defaults2, partialOptions) {
    const options = {};
    for (const key in defaults2) {
      options[key] = key in partialOptions ? partialOptions[key] : defaults2[key];
    }
    return options;
  }
  function findInsertionIndex(matcher, matchers) {
    let lower = 0;
    let upper = matchers.length;
    while (lower !== upper) {
      const mid = lower + upper >> 1;
      const sortOrder = comparePathParserScore(matcher, matchers[mid]);
      if (sortOrder < 0) {
        upper = mid;
      } else {
        lower = mid + 1;
      }
    }
    const insertionAncestor = getInsertionAncestor(matcher);
    if (insertionAncestor) {
      upper = matchers.lastIndexOf(insertionAncestor, upper - 1);
    }
    return upper;
  }
  function getInsertionAncestor(matcher) {
    let ancestor = matcher;
    while (ancestor = ancestor.parent) {
      if (isMatchable(ancestor) && comparePathParserScore(matcher, ancestor) === 0) {
        return ancestor;
      }
    }
    return;
  }
  function isMatchable({ record }) {
    return !!(record.name || record.components && Object.keys(record.components).length || record.redirect);
  }
  function parseQuery(search) {
    const query = {};
    if (search === "" || search === "?")
      return query;
    const hasLeadingIM = search[0] === "?";
    const searchParams = (hasLeadingIM ? search.slice(1) : search).split("&");
    for (let i2 = 0; i2 < searchParams.length; ++i2) {
      const searchParam = searchParams[i2].replace(PLUS_RE, " ");
      const eqPos = searchParam.indexOf("=");
      const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
      const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));
      if (key in query) {
        let currentValue = query[key];
        if (!isArray(currentValue)) {
          currentValue = query[key] = [currentValue];
        }
        currentValue.push(value);
      } else {
        query[key] = value;
      }
    }
    return query;
  }
  function stringifyQuery(query) {
    let search = "";
    for (let key in query) {
      const value = query[key];
      key = encodeQueryKey(key);
      if (value == null) {
        if (value !== void 0) {
          search += (search.length ? "&" : "") + key;
        }
        continue;
      }
      const values = isArray(value) ? value.map((v2) => v2 && encodeQueryValue(v2)) : [value && encodeQueryValue(value)];
      values.forEach((value2) => {
        if (value2 !== void 0) {
          search += (search.length ? "&" : "") + key;
          if (value2 != null)
            search += "=" + value2;
        }
      });
    }
    return search;
  }
  function normalizeQuery(query) {
    const normalizedQuery = {};
    for (const key in query) {
      const value = query[key];
      if (value !== void 0) {
        normalizedQuery[key] = isArray(value) ? value.map((v2) => v2 == null ? null : "" + v2) : value == null ? value : "" + value;
      }
    }
    return normalizedQuery;
  }
  const matchedRouteKey = Symbol("");
  const viewDepthKey = Symbol("");
  const routerKey = Symbol("");
  const routeLocationKey = Symbol("");
  const routerViewLocationKey = Symbol("");
  function useCallbacks() {
    let handlers = [];
    function add2(handler) {
      handlers.push(handler);
      return () => {
        const i2 = handlers.indexOf(handler);
        if (i2 > -1)
          handlers.splice(i2, 1);
      };
    }
    function reset2() {
      handlers = [];
    }
    return {
      add: add2,
      list: () => handlers.slice(),
      reset: reset2
    };
  }
  function guardToPromiseFn(guard, to, from, record, name, runWithContext = (fn2) => fn2()) {
    const enterCallbackArray = record && // name is defined if record is because of the function overload
    (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
    return () => new Promise((resolve2, reject) => {
      const next = (valid) => {
        if (valid === false) {
          reject(createRouterError(4, {
            from,
            to
          }));
        } else if (valid instanceof Error) {
          reject(valid);
        } else if (isRouteLocation(valid)) {
          reject(createRouterError(2, {
            from: to,
            to: valid
          }));
        } else {
          if (enterCallbackArray && // since enterCallbackArray is truthy, both record and name also are
          record.enterCallbacks[name] === enterCallbackArray && typeof valid === "function") {
            enterCallbackArray.push(valid);
          }
          resolve2();
        }
      };
      const guardReturn = runWithContext(() => guard.call(record && record.instances[name], to, from, next));
      let guardCall = Promise.resolve(guardReturn);
      if (guard.length < 3)
        guardCall = guardCall.then(next);
      guardCall.catch((err) => reject(err));
    });
  }
  function extractComponentsGuards(matched, guardType, to, from, runWithContext = (fn2) => fn2()) {
    const guards = [];
    for (const record of matched) {
      for (const name in record.components) {
        let rawComponent = record.components[name];
        if (guardType !== "beforeRouteEnter" && !record.instances[name])
          continue;
        if (isRouteComponent(rawComponent)) {
          const options = rawComponent.__vccOpts || rawComponent;
          const guard = options[guardType];
          guard && guards.push(guardToPromiseFn(guard, to, from, record, name, runWithContext));
        } else {
          let componentPromise = rawComponent();
          guards.push(() => componentPromise.then((resolved) => {
            if (!resolved)
              return Promise.reject(new Error(`Couldn't resolve component "${name}" at "${record.path}"`));
            const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
            record.components[name] = resolvedComponent;
            const options = resolvedComponent.__vccOpts || resolvedComponent;
            const guard = options[guardType];
            return guard && guardToPromiseFn(guard, to, from, record, name, runWithContext)();
          }));
        }
      }
    }
    return guards;
  }
  function isRouteComponent(component) {
    return typeof component === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
  }
  function useLink(props) {
    const router2 = inject(routerKey);
    const currentRoute = inject(routeLocationKey);
    const route = computed(() => {
      const to = unref(props.to);
      return router2.resolve(to);
    });
    const activeRecordIndex = computed(() => {
      const { matched } = route.value;
      const { length } = matched;
      const routeMatched = matched[length - 1];
      const currentMatched = currentRoute.matched;
      if (!routeMatched || !currentMatched.length)
        return -1;
      const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
      if (index > -1)
        return index;
      const parentRecordPath = getOriginalPath(matched[length - 2]);
      return (
        // we are dealing with nested routes
        length > 1 && // if the parent and matched route have the same path, this link is
        // referring to the empty child. Or we currently are on a different
        // child of the same parent
        getOriginalPath(routeMatched) === parentRecordPath && // avoid comparing the child with its parent
        currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index
      );
    });
    const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
    const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
    function navigate(e2 = {}) {
      if (guardEvent(e2)) {
        return router2[unref(props.replace) ? "replace" : "push"](
          unref(props.to)
          // avoid uncaught errors are they are logged anyway
        ).catch(noop);
      }
      return Promise.resolve();
    }
    return {
      route,
      href: computed(() => route.value.href),
      isActive,
      isExactActive,
      navigate
    };
  }
  const RouterLinkImpl = /* @__PURE__ */ defineComponent({
    name: "RouterLink",
    compatConfig: { MODE: 3 },
    props: {
      to: {
        type: [String, Object],
        required: true
      },
      replace: Boolean,
      activeClass: String,
      // inactiveClass: String,
      exactActiveClass: String,
      custom: Boolean,
      ariaCurrentValue: {
        type: String,
        default: "page"
      }
    },
    useLink,
    setup(props, { slots }) {
      const link = reactive(useLink(props));
      const { options } = inject(routerKey);
      const elClass = computed(() => ({
        [getLinkClass(props.activeClass, options.linkActiveClass, "router-link-active")]: link.isActive,
        // [getLinkClass(
        //   props.inactiveClass,
        //   options.linkInactiveClass,
        //   'router-link-inactive'
        // )]: !link.isExactActive,
        [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active")]: link.isExactActive
      }));
      return () => {
        const children = slots.default && slots.default(link);
        return props.custom ? children : h$1("a", {
          "aria-current": link.isExactActive ? props.ariaCurrentValue : null,
          href: link.href,
          // this would override user added attrs but Vue will still add
          // the listener, so we end up triggering both
          onClick: link.navigate,
          class: elClass.value
        }, children);
      };
    }
  });
  const RouterLink = RouterLinkImpl;
  function guardEvent(e2) {
    if (e2.metaKey || e2.altKey || e2.ctrlKey || e2.shiftKey)
      return;
    if (e2.defaultPrevented)
      return;
    if (e2.button !== void 0 && e2.button !== 0)
      return;
    if (e2.currentTarget && e2.currentTarget.getAttribute) {
      const target = e2.currentTarget.getAttribute("target");
      if (/\b_blank\b/i.test(target))
        return;
    }
    if (e2.preventDefault)
      e2.preventDefault();
    return true;
  }
  function includesParams(outer, inner) {
    for (const key in inner) {
      const innerValue = inner[key];
      const outerValue = outer[key];
      if (typeof innerValue === "string") {
        if (innerValue !== outerValue)
          return false;
      } else {
        if (!isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i2) => value !== outerValue[i2]))
          return false;
      }
    }
    return true;
  }
  function getOriginalPath(record) {
    return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
  }
  const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
  const RouterViewImpl = /* @__PURE__ */ defineComponent({
    name: "RouterView",
    // #674 we manually inherit them
    inheritAttrs: false,
    props: {
      name: {
        type: String,
        default: "default"
      },
      route: Object
    },
    // Better compat for @vue/compat users
    // https://github.com/vuejs/router/issues/1315
    compatConfig: { MODE: 3 },
    setup(props, { attrs, slots }) {
      const injectedRoute = inject(routerViewLocationKey);
      const routeToDisplay = computed(() => props.route || injectedRoute.value);
      const injectedDepth = inject(viewDepthKey, 0);
      const depth = computed(() => {
        let initialDepth = unref(injectedDepth);
        const { matched } = routeToDisplay.value;
        let matchedRoute;
        while ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) {
          initialDepth++;
        }
        return initialDepth;
      });
      const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth.value]);
      provide(viewDepthKey, computed(() => depth.value + 1));
      provide(matchedRouteKey, matchedRouteRef);
      provide(routerViewLocationKey, routeToDisplay);
      const viewRef = ref();
      watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {
        if (to) {
          to.instances[name] = instance;
          if (from && from !== to && instance && instance === oldInstance) {
            if (!to.leaveGuards.size) {
              to.leaveGuards = from.leaveGuards;
            }
            if (!to.updateGuards.size) {
              to.updateGuards = from.updateGuards;
            }
          }
        }
        if (instance && to && // if there is no instance but to and from are the same this might be
        // the first visit
        (!from || !isSameRouteRecord(to, from) || !oldInstance)) {
          (to.enterCallbacks[name] || []).forEach((callback) => callback(instance));
        }
      }, { flush: "post" });
      return () => {
        const route = routeToDisplay.value;
        const currentName = props.name;
        const matchedRoute = matchedRouteRef.value;
        const ViewComponent = matchedRoute && matchedRoute.components[currentName];
        if (!ViewComponent) {
          return normalizeSlot(slots.default, { Component: ViewComponent, route });
        }
        const routePropsOption = matchedRoute.props[currentName];
        const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
        const onVnodeUnmounted = (vnode) => {
          if (vnode.component.isUnmounted) {
            matchedRoute.instances[currentName] = null;
          }
        };
        const component = h$1(ViewComponent, assign({}, routeProps, attrs, {
          onVnodeUnmounted,
          ref: viewRef
        }));
        return (
          // pass the vnode to the slot as a prop.
          // h and <component :is="..."> both accept vnodes
          normalizeSlot(slots.default, { Component: component, route }) || component
        );
      };
    }
  });
  function normalizeSlot(slot, data) {
    if (!slot)
      return null;
    const slotContent = slot(data);
    return slotContent.length === 1 ? slotContent[0] : slotContent;
  }
  const RouterView = RouterViewImpl;
  function createRouter(options) {
    const matcher = createRouterMatcher(options.routes, options);
    const parseQuery$1 = options.parseQuery || parseQuery;
    const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
    const routerHistory = options.history;
    const beforeGuards = useCallbacks();
    const beforeResolveGuards = useCallbacks();
    const afterGuards = useCallbacks();
    const currentRoute = shallowRef(START_LOCATION_NORMALIZED);
    let pendingLocation = START_LOCATION_NORMALIZED;
    if (isBrowser && options.scrollBehavior && "scrollRestoration" in history) {
      history.scrollRestoration = "manual";
    }
    const normalizeParams = applyToParams.bind(null, (paramValue) => "" + paramValue);
    const encodeParams = applyToParams.bind(null, encodeParam);
    const decodeParams = (
      // @ts-expect-error: intentionally avoid the type check
      applyToParams.bind(null, decode)
    );
    function addRoute(parentOrRoute, route) {
      let parent;
      let record;
      if (isRouteName(parentOrRoute)) {
        parent = matcher.getRecordMatcher(parentOrRoute);
        record = route;
      } else {
        record = parentOrRoute;
      }
      return matcher.addRoute(record, parent);
    }
    function removeRoute(name) {
      const recordMatcher = matcher.getRecordMatcher(name);
      if (recordMatcher) {
        matcher.removeRoute(recordMatcher);
      }
    }
    function getRoutes() {
      return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);
    }
    function hasRoute(name) {
      return !!matcher.getRecordMatcher(name);
    }
    function resolve2(rawLocation, currentLocation) {
      currentLocation = assign({}, currentLocation || currentRoute.value);
      if (typeof rawLocation === "string") {
        const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
        const matchedRoute2 = matcher.resolve({ path: locationNormalized.path }, currentLocation);
        const href2 = routerHistory.createHref(locationNormalized.fullPath);
        return assign(locationNormalized, matchedRoute2, {
          params: decodeParams(matchedRoute2.params),
          hash: decode(locationNormalized.hash),
          redirectedFrom: void 0,
          href: href2
        });
      }
      let matcherLocation;
      if (rawLocation.path != null) {
        matcherLocation = assign({}, rawLocation, {
          path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path
        });
      } else {
        const targetParams = assign({}, rawLocation.params);
        for (const key in targetParams) {
          if (targetParams[key] == null) {
            delete targetParams[key];
          }
        }
        matcherLocation = assign({}, rawLocation, {
          params: encodeParams(targetParams)
        });
        currentLocation.params = encodeParams(currentLocation.params);
      }
      const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
      const hash = rawLocation.hash || "";
      matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
      const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {
        hash: encodeHash(hash),
        path: matchedRoute.path
      }));
      const href = routerHistory.createHref(fullPath);
      return assign({
        fullPath,
        // keep the hash encoded so fullPath is effectively path + encodedQuery +
        // hash
        hash,
        query: (
          // if the user is using a custom query lib like qs, we might have
          // nested objects, so we keep the query as is, meaning it can contain
          // numbers at `$route.query`, but at the point, the user will have to
          // use their own type anyway.
          // https://github.com/vuejs/router/issues/328#issuecomment-649481567
          stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
        )
      }, matchedRoute, {
        redirectedFrom: void 0,
        href
      });
    }
    function locationAsObject(to) {
      return typeof to === "string" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign({}, to);
    }
    function checkCanceledNavigation(to, from) {
      if (pendingLocation !== to) {
        return createRouterError(8, {
          from,
          to
        });
      }
    }
    function push(to) {
      return pushWithRedirect(to);
    }
    function replace(to) {
      return push(assign(locationAsObject(to), { replace: true }));
    }
    function handleRedirectRecord(to) {
      const lastMatched = to.matched[to.matched.length - 1];
      if (lastMatched && lastMatched.redirect) {
        const { redirect } = lastMatched;
        let newTargetLocation = typeof redirect === "function" ? redirect(to) : redirect;
        if (typeof newTargetLocation === "string") {
          newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : (
            // force empty params
            { path: newTargetLocation }
          );
          newTargetLocation.params = {};
        }
        return assign({
          query: to.query,
          hash: to.hash,
          // avoid transferring params if the redirect has a path
          params: newTargetLocation.path != null ? {} : to.params
        }, newTargetLocation);
      }
    }
    function pushWithRedirect(to, redirectedFrom) {
      const targetLocation = pendingLocation = resolve2(to);
      const from = currentRoute.value;
      const data = to.state;
      const force = to.force;
      const replace2 = to.replace === true;
      const shouldRedirect = handleRedirectRecord(targetLocation);
      if (shouldRedirect)
        return pushWithRedirect(
          assign(locationAsObject(shouldRedirect), {
            state: typeof shouldRedirect === "object" ? assign({}, data, shouldRedirect.state) : data,
            force,
            replace: replace2
          }),
          // keep original redirectedFrom if it exists
          redirectedFrom || targetLocation
        );
      const toLocation = targetLocation;
      toLocation.redirectedFrom = redirectedFrom;
      let failure;
      if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
        failure = createRouterError(16, { to: toLocation, from });
        handleScroll(
          from,
          from,
          // this is a push, the only way for it to be triggered from a
          // history.listen is with a redirect, which makes it become a push
          true,
          // This cannot be the first navigation because the initial location
          // cannot be manually navigated to
          false
        );
      }
      return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch((error) => isNavigationFailure(error) ? (
        // navigation redirects still mark the router as ready
        isNavigationFailure(
          error,
          2
          /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
        ) ? error : markAsReady(error)
      ) : (
        // reject any unknown error
        triggerError(error, toLocation, from)
      )).then((failure2) => {
        if (failure2) {
          if (isNavigationFailure(
            failure2,
            2
            /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
          )) {
            return pushWithRedirect(
              // keep options
              assign({
                // preserve an existing replacement but allow the redirect to override it
                replace: replace2
              }, locationAsObject(failure2.to), {
                state: typeof failure2.to === "object" ? assign({}, data, failure2.to.state) : data,
                force
              }),
              // preserve the original redirectedFrom if any
              redirectedFrom || toLocation
            );
          }
        } else {
          failure2 = finalizeNavigation(toLocation, from, true, replace2, data);
        }
        triggerAfterEach(toLocation, from, failure2);
        return failure2;
      });
    }
    function checkCanceledNavigationAndReject(to, from) {
      const error = checkCanceledNavigation(to, from);
      return error ? Promise.reject(error) : Promise.resolve();
    }
    function runWithContext(fn2) {
      const app = installedApps.values().next().value;
      return app && typeof app.runWithContext === "function" ? app.runWithContext(fn2) : fn2();
    }
    function navigate(to, from) {
      let guards;
      const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);
      guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to, from);
      for (const record of leavingRecords) {
        record.leaveGuards.forEach((guard) => {
          guards.push(guardToPromiseFn(guard, to, from));
        });
      }
      const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards).then(() => {
        guards = [];
        for (const guard of beforeGuards.list()) {
          guards.push(guardToPromiseFn(guard, to, from));
        }
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards);
      }).then(() => {
        guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to, from);
        for (const record of updatingRecords) {
          record.updateGuards.forEach((guard) => {
            guards.push(guardToPromiseFn(guard, to, from));
          });
        }
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards);
      }).then(() => {
        guards = [];
        for (const record of enteringRecords) {
          if (record.beforeEnter) {
            if (isArray(record.beforeEnter)) {
              for (const beforeEnter of record.beforeEnter)
                guards.push(guardToPromiseFn(beforeEnter, to, from));
            } else {
              guards.push(guardToPromiseFn(record.beforeEnter, to, from));
            }
          }
        }
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards);
      }).then(() => {
        to.matched.forEach((record) => record.enterCallbacks = {});
        guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to, from, runWithContext);
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards);
      }).then(() => {
        guards = [];
        for (const guard of beforeResolveGuards.list()) {
          guards.push(guardToPromiseFn(guard, to, from));
        }
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards);
      }).catch((err) => isNavigationFailure(
        err,
        8
        /* ErrorTypes.NAVIGATION_CANCELLED */
      ) ? err : Promise.reject(err));
    }
    function triggerAfterEach(to, from, failure) {
      afterGuards.list().forEach((guard) => runWithContext(() => guard(to, from, failure)));
    }
    function finalizeNavigation(toLocation, from, isPush, replace2, data) {
      const error = checkCanceledNavigation(toLocation, from);
      if (error)
        return error;
      const isFirstNavigation = from === START_LOCATION_NORMALIZED;
      const state = !isBrowser ? {} : history.state;
      if (isPush) {
        if (replace2 || isFirstNavigation)
          routerHistory.replace(toLocation.fullPath, assign({
            scroll: isFirstNavigation && state && state.scroll
          }, data));
        else
          routerHistory.push(toLocation.fullPath, data);
      }
      currentRoute.value = toLocation;
      handleScroll(toLocation, from, isPush, isFirstNavigation);
      markAsReady();
    }
    let removeHistoryListener;
    function setupListeners() {
      if (removeHistoryListener)
        return;
      removeHistoryListener = routerHistory.listen((to, _from, info) => {
        if (!router2.listening)
          return;
        const toLocation = resolve2(to);
        const shouldRedirect = handleRedirectRecord(toLocation);
        if (shouldRedirect) {
          pushWithRedirect(assign(shouldRedirect, { replace: true }), toLocation).catch(noop);
          return;
        }
        pendingLocation = toLocation;
        const from = currentRoute.value;
        if (isBrowser) {
          saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());
        }
        navigate(toLocation, from).catch((error) => {
          if (isNavigationFailure(
            error,
            4 | 8
            /* ErrorTypes.NAVIGATION_CANCELLED */
          )) {
            return error;
          }
          if (isNavigationFailure(
            error,
            2
            /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
          )) {
            pushWithRedirect(
              error.to,
              toLocation
              // avoid an uncaught rejection, let push call triggerError
            ).then((failure) => {
              if (isNavigationFailure(
                failure,
                4 | 16
                /* ErrorTypes.NAVIGATION_DUPLICATED */
              ) && !info.delta && info.type === NavigationType.pop) {
                routerHistory.go(-1, false);
              }
            }).catch(noop);
            return Promise.reject();
          }
          if (info.delta) {
            routerHistory.go(-info.delta, false);
          }
          return triggerError(error, toLocation, from);
        }).then((failure) => {
          failure = failure || finalizeNavigation(
            // after navigation, all matched components are resolved
            toLocation,
            from,
            false
          );
          if (failure) {
            if (info.delta && // a new navigation has been triggered, so we do not want to revert, that will change the current history
            // entry while a different route is displayed
            !isNavigationFailure(
              failure,
              8
              /* ErrorTypes.NAVIGATION_CANCELLED */
            )) {
              routerHistory.go(-info.delta, false);
            } else if (info.type === NavigationType.pop && isNavigationFailure(
              failure,
              4 | 16
              /* ErrorTypes.NAVIGATION_DUPLICATED */
            )) {
              routerHistory.go(-1, false);
            }
          }
          triggerAfterEach(toLocation, from, failure);
        }).catch(noop);
      });
    }
    let readyHandlers = useCallbacks();
    let errorListeners = useCallbacks();
    let ready;
    function triggerError(error, to, from) {
      markAsReady(error);
      const list = errorListeners.list();
      if (list.length) {
        list.forEach((handler) => handler(error, to, from));
      } else {
        console.error(error);
      }
      return Promise.reject(error);
    }
    function isReady() {
      if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
        return Promise.resolve();
      return new Promise((resolve22, reject) => {
        readyHandlers.add([resolve22, reject]);
      });
    }
    function markAsReady(err) {
      if (!ready) {
        ready = !err;
        setupListeners();
        readyHandlers.list().forEach(([resolve22, reject]) => err ? reject(err) : resolve22());
        readyHandlers.reset();
      }
      return err;
    }
    function handleScroll(to, from, isPush, isFirstNavigation) {
      const { scrollBehavior } = options;
      if (!isBrowser || !scrollBehavior)
        return Promise.resolve();
      const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
      return nextTick().then(() => scrollBehavior(to, from, scrollPosition)).then((position) => position && scrollToPosition(position)).catch((err) => triggerError(err, to, from));
    }
    const go = (delta) => routerHistory.go(delta);
    let started;
    const installedApps = /* @__PURE__ */ new Set();
    const router2 = {
      currentRoute,
      listening: true,
      addRoute,
      removeRoute,
      clearRoutes: matcher.clearRoutes,
      hasRoute,
      getRoutes,
      resolve: resolve2,
      options,
      push,
      replace,
      go,
      back: () => go(-1),
      forward: () => go(1),
      beforeEach: beforeGuards.add,
      beforeResolve: beforeResolveGuards.add,
      afterEach: afterGuards.add,
      onError: errorListeners.add,
      isReady,
      install(app) {
        const router22 = this;
        app.component("RouterLink", RouterLink);
        app.component("RouterView", RouterView);
        app.config.globalProperties.$router = router22;
        Object.defineProperty(app.config.globalProperties, "$route", {
          enumerable: true,
          get: () => unref(currentRoute)
        });
        if (isBrowser && // used for the initial navigation client side to avoid pushing
        // multiple times when the router is used in multiple apps
        !started && currentRoute.value === START_LOCATION_NORMALIZED) {
          started = true;
          push(routerHistory.location).catch((err) => {
          });
        }
        const reactiveRoute = {};
        for (const key in START_LOCATION_NORMALIZED) {
          Object.defineProperty(reactiveRoute, key, {
            get: () => currentRoute.value[key],
            enumerable: true
          });
        }
        app.provide(routerKey, router22);
        app.provide(routeLocationKey, shallowReactive(reactiveRoute));
        app.provide(routerViewLocationKey, currentRoute);
        const unmountApp = app.unmount;
        installedApps.add(app);
        app.unmount = function() {
          installedApps.delete(app);
          if (installedApps.size < 1) {
            pendingLocation = START_LOCATION_NORMALIZED;
            removeHistoryListener && removeHistoryListener();
            removeHistoryListener = null;
            currentRoute.value = START_LOCATION_NORMALIZED;
            started = false;
            ready = false;
          }
          unmountApp();
        };
      }
    };
    function runGuardQueue(guards) {
      return guards.reduce((promise, guard) => promise.then(() => runWithContext(guard)), Promise.resolve());
    }
    return router2;
  }
  function extractChangingRecords(to, from) {
    const leavingRecords = [];
    const updatingRecords = [];
    const enteringRecords = [];
    const len = Math.max(from.matched.length, to.matched.length);
    for (let i2 = 0; i2 < len; i2++) {
      const recordFrom = from.matched[i2];
      if (recordFrom) {
        if (to.matched.find((record) => isSameRouteRecord(record, recordFrom)))
          updatingRecords.push(recordFrom);
        else
          leavingRecords.push(recordFrom);
      }
      const recordTo = to.matched[i2];
      if (recordTo) {
        if (!from.matched.find((record) => isSameRouteRecord(record, recordTo))) {
          enteringRecords.push(recordTo);
        }
      }
    }
    return [leavingRecords, updatingRecords, enteringRecords];
  }
  function useRouter() {
    return inject(routerKey);
  }
  function useRoute(_name) {
    return inject(routeLocationKey);
  }
  const _hoisted_1$V = { class: "dark:bg-gray-800" };
  const _hoisted_2$O = {
    key: 0,
    class: "rounded-md bg-red-50 dark:bg-red-900 p-4 mb-4"
  };
  const _hoisted_3$J = { class: "flex mb-8" };
  const _hoisted_4$C = { class: "flex-shrink-0" };
  const _hoisted_5$A = { class: "ml-3" };
  const _hoisted_6$w = /* @__PURE__ */ createBaseVNode("h3", { class: "text-sm font-medium text-red-800 dark:text-red-100" }, "Error", -1);
  const _hoisted_7$s = { class: "mt-2 text-sm text-red-700 dark:text-red-200" };
  const _hoisted_8$q = {
    key: 1,
    class: "rounded-md bg-green-50 dark:bg-green-900 p-4 mb-4"
  };
  const _hoisted_9$r = { class: "flex mb-8" };
  const _hoisted_10$o = { class: "flex-shrink-0" };
  const _hoisted_11$n = { class: "ml-3" };
  const _hoisted_12$k = /* @__PURE__ */ createBaseVNode("h3", { class: "text-sm font-medium text-green-800 dark:text-green-100" }, "Success", -1);
  const _hoisted_13$j = { class: "mt-2 text-sm text-green-700 dark:text-green-200" };
  const _sfc_main$Y = {
    __name: "BasicFormAlerts",
    props: {
      success: String,
      error: String
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$V, [
          __props.error ? (openBlock(), createElementBlock("div", _hoisted_2$O, [
            createBaseVNode("div", _hoisted_3$J, [
              createBaseVNode("div", _hoisted_4$C, [
                createVNode(unref(Icon), {
                  icon: "mdi:fire-circle",
                  class: "h-5 w-5 text-red-400 dark:text-red-300",
                  "aria-hidden": "true"
                })
              ]),
              createBaseVNode("div", _hoisted_5$A, [
                _hoisted_6$w,
                createBaseVNode("div", _hoisted_7$s, [
                  createBaseVNode("p", null, toDisplayString(__props.error), 1)
                ])
              ])
            ])
          ])) : createCommentVNode("", true),
          __props.success ? (openBlock(), createElementBlock("div", _hoisted_8$q, [
            createBaseVNode("div", _hoisted_9$r, [
              createBaseVNode("div", _hoisted_10$o, [
                createVNode(unref(Icon), {
                  icon: "mdi:check-circle",
                  class: "h-5 w-5 text-green-400 dark:text-green-300",
                  "aria-hidden": "true"
                })
              ]),
              createBaseVNode("div", _hoisted_11$n, [
                _hoisted_12$k,
                createBaseVNode("div", _hoisted_13$j, [
                  createBaseVNode("p", null, toDisplayString(__props.success), 1)
                ])
              ])
            ])
          ])) : createCommentVNode("", true)
        ]);
      };
    }
  };
  const _hoisted_1$U = { class: "min-w-[320px]" };
  const _hoisted_2$N = ["disabled"];
  const _hoisted_3$I = /* @__PURE__ */ createBaseVNode("input", {
    type: "hidden",
    name: "utf8",
    value: "✓"
  }, null, -1);
  const _hoisted_4$B = ["value"];
  const _hoisted_5$z = ["value"];
  const _hoisted_6$v = { class: "flex w-full mb-4 space-x-2" };
  const _sfc_main$X = /* @__PURE__ */ defineComponent({
    __name: "SecretForm",
    props: {
      enabled: { type: Boolean, default: true },
      withRecipient: { type: Boolean, default: false },
      withAsterisk: { type: Boolean, default: false },
      withGenerate: { type: Boolean, default: false }
    },
    setup(__props) {
      const csrfStore = useCsrfStore();
      const props = __props;
      const formFields = window.form_fields;
      const domainsEnabled = window.domains_enabled;
      const availableDomains = window.custom_domains || [];
      const defaultDomain = window.site_host;
      const hasInitialContent = computed(() => Boolean(formFields == null ? void 0 : formFields.secret));
      if (!availableDomains.includes(defaultDomain)) {
        availableDomains.push(defaultDomain);
      }
      const getSavedDomain = () => {
        const savedDomain = localStorage.getItem("selectedDomain");
        return savedDomain && availableDomains.includes(savedDomain) ? savedDomain : availableDomains[0];
      };
      const selectedDomain = ref(getSavedDomain());
      watch(selectedDomain, (newDomain) => {
        localStorage.setItem("selectedDomain", newDomain);
      });
      const secretContent = ref("");
      const isFormValid = computed(() => {
        return secretContent.value.length > 0 || hasInitialContent.value;
      });
      const updateSelectedDomain = (domain) => {
        selectedDomain.value = domain;
      };
      const isGenerateDisabled = computed(() => isFormValid.value);
      const isCreateDisabled = computed(() => !isFormValid.value);
      const router2 = useRouter();
      const formKind = ref("");
      const handleButtonClick = (kind) => {
        formKind.value = kind;
        submitForm();
      };
      const {
        isSubmitting,
        error,
        success,
        submitForm
      } = useFormSubmission({
        url: "/api/v2/secret/conceal",
        successMessage: "",
        onSuccess: (data) => {
          router2.push({
            name: "Metadata link",
            params: { metadataKey: data.record.metadata.key }
          });
        },
        onError: (data) => {
          console.error("Error fetching secret:", data);
          csrfStore.checkShrimpValidity();
        },
        getFormData: () => {
          const form = document.getElementById("createSecret");
          const formData = new FormData(form);
          formData.append("kind", formKind.value);
          return formData;
        }
      });
      return (_ctx, _cache) => {
        var _a;
        return openBlock(), createElementBlock("div", _hoisted_1$U, [
          createVNode(_sfc_main$Y, {
            success: unref(success),
            error: unref(error)
          }, null, 8, ["success", "error"]),
          createBaseVNode("form", {
            id: "createSecret",
            method: "post",
            autocomplete: "off",
            onSubmit: _cache[3] || (_cache[3] = withModifiers(
              //@ts-ignore
              (...args) => unref(submitForm) && unref(submitForm)(...args),
              ["prevent"]
            )),
            action: "/api/v2/secret/conceal",
            class: "form-horizontal",
            disabled: !props.enabled
          }, [
            _hoisted_3$I,
            createBaseVNode("input", {
              type: "hidden",
              name: "shrimp",
              value: unref(csrfStore).shrimp
            }, null, 8, _hoisted_4$B),
            createBaseVNode("input", {
              type: "hidden",
              name: "share_domain",
              value: selectedDomain.value
            }, null, 8, _hoisted_5$z),
            createVNode(SecretContentInputArea, {
              availableDomains: unref(availableDomains),
              initialDomain: selectedDomain.value,
              initialContent: ((_a = unref(formFields)) == null ? void 0 : _a.secret) || "",
              withDomainDropdown: unref(domainsEnabled),
              "onUpdate:selectedDomain": updateSelectedDomain,
              "onUpdate:content": _cache[0] || (_cache[0] = ($event) => secretContent.value = $event)
            }, null, 8, ["availableDomains", "initialDomain", "initialContent", "withDomainDropdown"]),
            createVNode(_sfc_main$11, { default_domain: selectedDomain.value }, null, 8, ["default_domain"]),
            createVNode(_sfc_main$$, {
              withRecipient: props.withRecipient,
              withExpiry: true,
              withPassphrase: true
            }, null, 8, ["withRecipient"]),
            createBaseVNode("div", _hoisted_6$v, [
              createVNode(_sfc_main$_, {
                disabled: isGenerateDisabled.value || unref(isSubmitting),
                onClick: _cache[1] || (_cache[1] = ($event) => handleButtonClick("generate"))
              }, null, 8, ["disabled"]),
              createVNode(_sfc_main$Z, {
                disabled: isCreateDisabled.value || unref(isSubmitting),
                "with-asterisk": _ctx.withAsterisk,
                onClick: _cache[2] || (_cache[2] = ($event) => handleButtonClick("share"))
              }, null, 8, ["disabled", "with-asterisk"])
            ])
          ], 40, _hoisted_2$N)
        ]);
      };
    }
  });
  const _sfc_main$W = {};
  const _withScopeId$3 = (n2) => (pushScopeId("data-v-b0241b04"), n2 = n2(), popScopeId(), n2);
  const _hoisted_1$T = { class: "w-full bg-gray-100 dark:bg-gray-800 border-t border-b border-gray-200 dark:border-gray-700 mb-6" };
  const _hoisted_2$M = { class: "container mx-auto py-2 px-4" };
  const _hoisted_3$H = { class: "flex flex-col md:flex-row items-center justify-between" };
  const _hoisted_4$A = { class: "flex items-center space-x-3 mb-0 md:mb-0" };
  const _hoisted_5$y = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("svg", {
    class: "sm:w-8 sm:h-8 md:w-5 md:h-5 w-12 h-12 text-brand-500 hidden sm:block",
    fill: "none",
    stroke: "currentColor",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24"
  }, [
    /* @__PURE__ */ createBaseVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z"
    })
  ], -1));
  const _hoisted_6$u = { class: "text-lg md:text-sm font-semibold font-brand text-gray-700 dark:text-gray-300 uppercase hidden sm:block" };
  const _hoisted_7$r = { class: "flex w-full sm:w-auto font-brand" };
  const _hoisted_8$p = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("span", { class: "sm:hidden" }, "Now with custom domains", -1));
  const _hoisted_9$q = { class: "hidden sm:inline" };
  const _hoisted_10$n = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("svg", {
    class: "ml-2 w-5 h-5 md:w-4 md:h-4",
    fill: "none",
    stroke: "currentColor",
    viewBox: "0 0 24 24",
    width: "24",
    height: "24",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    /* @__PURE__ */ createBaseVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M9 5l7 7-7 7"
    })
  ], -1));
  function _sfc_render$5(_ctx, _cache) {
    const _component_router_link = resolveComponent("router-link");
    return openBlock(), createElementBlock("div", _hoisted_1$T, [
      createBaseVNode("div", _hoisted_2$M, [
        createBaseVNode("div", _hoisted_3$H, [
          createBaseVNode("div", _hoisted_4$A, [
            _hoisted_5$y,
            createBaseVNode("span", _hoisted_6$u, toDisplayString(_ctx.$t("web.homepage.cta_title")), 1)
          ]),
          createBaseVNode("div", _hoisted_7$r, [
            createVNode(_component_router_link, {
              to: "/pricing",
              class: "w-full sm:w-auto inline-flex items-center justify-center px-6 py-4 sm:py-2 md:px-4 md:py-1 text-xl sm:text-base md:text-xs font-semibold text-brand-500 bg-white hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-brand-500 rounded-md border border-brand-500 transition duration-150 animate-throb dark:text-white dark:bg-brand-500 dark:hover:bg-brand-600"
            }, {
              default: withCtx(() => [
                _hoisted_8$p,
                createBaseVNode("span", _hoisted_9$q, toDisplayString(_ctx.$t("web.homepage.explore_premium_plans")), 1),
                _hoisted_10$n
              ]),
              _: 1
            })
          ])
        ])
      ])
    ]);
  }
  const HomepagePlansCTA = /* @__PURE__ */ _export_sfc(_sfc_main$W, [["render", _sfc_render$5], ["__scopeId", "data-v-b0241b04"]]);
  const _sfc_main$V = {};
  const _hoisted_1$S = { class: "flex flex-col items-center text-center" };
  const _hoisted_2$L = { class: "font-base mb-2 sm:mx-12 md:mx-2 text-gray-600 dark:text-gray-100 sm:block" };
  const _hoisted_3$G = { class: "mb-6 mx-12 sm:mx-2 text-base text-gray-400 dark:text-gray-400 italic" };
  function _sfc_render$4(_ctx, _cache) {
    return openBlock(), createElementBlock("div", _hoisted_1$S, [
      createBaseVNode("h3", _hoisted_2$L, toDisplayString(_ctx.$t("web.homepage.tagline1")), 1),
      createBaseVNode("p", _hoisted_3$G, toDisplayString(_ctx.$t("web.homepage.tagline2")), 1)
    ]);
  }
  const HomepageTaglines = /* @__PURE__ */ _export_sfc(_sfc_main$V, [["render", _sfc_render$4]]);
  const _hoisted_1$R = { class: "my-6" };
  const _hoisted_2$K = {
    key: 2,
    class: "flex flex-col items-center text-center my-6"
  };
  const _hoisted_3$F = { class: "text-sm text-gray-400 italic dark:text-gray-400 mb-4" };
  const _sfc_main$U = /* @__PURE__ */ defineComponent({
    __name: "Homepage",
    setup(__props) {
      const authenticated = window.authenticated;
      const authenticationSettings = window.authentication;
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$R, [
          !unref(authenticated) ? (openBlock(), createBlock(HomepageTaglines, {
            key: 0,
            class: "my-6"
          })) : createCommentVNode("", true),
          unref(authenticationSettings).signup ? (openBlock(), createBlock(HomepagePlansCTA, {
            key: 1,
            class: ""
          })) : createCommentVNode("", true),
          createVNode(_sfc_main$X, {
            class: "",
            withRecipient: false,
            withAsterisk: true,
            withGenerate: true
          }),
          !unref(authenticated) ? (openBlock(), createElementBlock("div", _hoisted_2$K, [
            createBaseVNode("p", _hoisted_3$F, toDisplayString(_ctx.$t("web.homepage.secret_hint")), 1)
          ])) : createCommentVNode("", true)
        ]);
      };
    }
  });
  const _hoisted_1$Q = { class: "mb-6" };
  const _hoisted_2$J = {
    key: 0,
    class: "text-xl font-brand flex space-x-4"
  };
  const _hoisted_3$E = { class: "block sm:hidden" };
  const _hoisted_4$z = { class: "hidden sm:block" };
  const _hoisted_5$x = { class: "ml-2 bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded-full px-2 py-0.5 text-xs font-medium" };
  const _hoisted_6$t = { key: 0 };
  const _hoisted_7$q = /* @__PURE__ */ createBaseVNode("span", { class: "block sm:hidden" }, "Domains", -1);
  const _hoisted_8$o = /* @__PURE__ */ createBaseVNode("span", { class: "hidden sm:block" }, "Custom Domains", -1);
  const _hoisted_9$p = { class: "ml-2 bg-gray-200 font-medium dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded-full px-2 py-0.5 text-xs" };
  const _sfc_main$T = /* @__PURE__ */ defineComponent({
    __name: "DashboardTabNav",
    setup(__props) {
      const { authenticated, metadata_record_count, domains_enabled, plan, custom_domains_record_count } = useWindowProps(["authenticated", "metadata_record_count", "domains_enabled", "plan", "custom_domains_record_count"]);
      const planAllowsCustomDomains = computed(() => {
        var _a;
        return ((_a = plan.value.options) == null ? void 0 : _a.custom_domains) === true;
      });
      return (_ctx, _cache) => {
        const _component_router_link = resolveComponent("router-link");
        return openBlock(), createElementBlock("nav", _hoisted_1$Q, [
          unref(authenticated) ? (openBlock(), createElementBlock("ul", _hoisted_2$J, [
            createBaseVNode("li", null, [
              createVNode(_component_router_link, {
                to: "/",
                class: "text-gray-700 font-bold underline dark:text-gray-300 hover:underline dark:hover:text-grey-500 transition-colors"
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(_ctx.$t("web.COMMON.title_home")), 1)
                ]),
                _: 1
              })
            ]),
            createBaseVNode("li", null, [
              createVNode(_component_router_link, {
                to: "/recent",
                class: "text-gray-700 dark:text-gray-300 hover:underline hover:text-grey-500 dark:hover:text-grey-500 transition-colors flex items-center"
              }, {
                default: withCtx(() => [
                  createBaseVNode("span", _hoisted_3$E, toDisplayString(_ctx.$t("web.COMMON.secret")), 1),
                  createBaseVNode("span", _hoisted_4$z, toDisplayString(_ctx.$t("web.COMMON.title_recent_secrets")), 1),
                  createBaseVNode("span", _hoisted_5$x, toDisplayString(unref(metadata_record_count)), 1)
                ]),
                _: 1
              })
            ]),
            unref(domains_enabled) && planAllowsCustomDomains.value ? (openBlock(), createElementBlock("li", _hoisted_6$t, [
              createVNode(_component_router_link, {
                to: "/account/domains",
                class: "text-gray-700 dark:text-gray-300 hover:underline hover:text-grey-500 dark:hover:text-grey-500 transition-colors flex items-center"
              }, {
                default: withCtx(() => [
                  _hoisted_7$q,
                  _hoisted_8$o,
                  createBaseVNode("span", _hoisted_9$p, toDisplayString(unref(custom_domains_record_count)), 1)
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]);
      };
    }
  });
  const _hoisted_1$P = { class: "my-6" };
  const _sfc_main$S = /* @__PURE__ */ defineComponent({
    __name: "DashboardIndex",
    setup(__props) {
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$P, [
          createVNode(_sfc_main$T),
          createVNode(_sfc_main$X, {
            withGenerate: true,
            withRecipient: true
          })
        ]);
      };
    }
  });
  function useFetchData({ url, onSuccess, onError }) {
    const records = ref([]);
    const details = ref(null);
    const isLoading = ref(false);
    const error = ref("");
    const count = ref(0);
    const custid = ref(null);
    const fetchData = async () => {
      isLoading.value = true;
      error.value = "";
      try {
        const response = await fetch(url, {
          method: "GET",
          headers: {
            "Content-Type": "application/json"
          }
        });
        if (!response.ok) {
          throw new Error(`Failed to fetch data from ${url}`);
        }
        const jsonData = await response.json();
        if ("record" in jsonData) {
          records.value = [jsonData.record];
          count.value = 1;
          details.value = jsonData.details || null;
        } else if ("records" in jsonData) {
          records.value = jsonData.records;
          count.value = jsonData.count;
          custid.value = jsonData.custid;
          details.value = jsonData.details || null;
        } else {
          throw new Error("Unexpected response format");
        }
        if (onSuccess) {
          onSuccess(records.value, details.value);
        }
      } catch (err) {
        if (err instanceof Error) {
          error.value = err.message;
        } else {
          console.error("An unexpected error occurred", err);
          error.value = "An unexpected error occurred";
        }
        if (onError) {
          onError(err);
        }
      } finally {
        isLoading.value = false;
      }
    };
    return {
      records,
      details,
      isLoading,
      error,
      count,
      custid,
      fetchData
    };
  }
  function useFetchDataRecord(options) {
    const { records, details, isLoading, error, count, custid, fetchData } = useFetchData(options);
    const record = computed(() => records.value[0] || null);
    return {
      record,
      details,
      isLoading,
      error,
      count,
      custid,
      fetchData
    };
  }
  const _hoisted_1$O = {
    key: 0,
    class: "text-gray-600 dark:text-gray-400"
  };
  const _hoisted_2$I = /* @__PURE__ */ createBaseVNode("span", { class: "text-gray-500 dark:text-gray-400 ml-2" }, "-", -1);
  const _hoisted_3$D = ["title"];
  const _hoisted_4$y = /* @__PURE__ */ createBaseVNode("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    class: "h-5 w-5 inline",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    width: "20",
    height: "20"
  }, [
    /* @__PURE__ */ createBaseVNode("path", {
      "fill-rule": "evenodd",
      d: "M12.395 2.553a1 1 0 00-1.45-.385c-.345.23-.614.558-.822.88-.214.33-.403.713-.57 1.116-.334.804-.614 1.768-.84 2.734a31.365 31.365 0 00-.613 3.58 2.64 2.64 0 01-.945-1.067c-.328-.68-.398-1.534-.398-2.654A1 1 0 005.05 6.05 6.981 6.981 0 003 11a7 7 0 1011.95-4.95c-.592-.591-.98-.985-1.348-1.467-.363-.476-.724-1.063-1.207-2.03zM12.12 15.12A3 3 0 017 13s.879.5 2.5.5c0-1 .5-4 1.25-4.5.5 1 .786 1.293 1.371 1.879A2.99 2.99 0 0113 13a2.99 2.99 0 01-.879 2.121z",
      "clip-rule": "evenodd"
    })
  ], -1);
  const _sfc_main$R = /* @__PURE__ */ defineComponent({
    __name: "SecretMetadataTableItem",
    props: {
      secretMetadata: {}
    },
    setup(__props) {
      const props = __props;
      const linkClass = computed(() => {
        return props.secretMetadata.is_destroyed ? "line-through italic text-gray-400 dark:text-gray-500" : "no-underline";
      });
      const displayKey = computed(() => {
        return `${props.secretMetadata.shortkey}`;
      });
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock(Fragment, null, [
          createVNode(unref(RouterLink), {
            to: { name: "Metadata link", params: { metadataKey: _ctx.secretMetadata.key } },
            class: normalizeClass([linkClass.value, "hover:text-brand-500 dark:hover:text-brand-500 transition-colors"]),
            title: _ctx.secretMetadata.is_destroyed ? "RECEIVED" : "NOT RECEIVED"
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(displayKey.value) + " ", 1),
              _ctx.secretMetadata.show_recipients ? (openBlock(), createElementBlock("span", _hoisted_1$O, " (" + toDisplayString(_ctx.$t("web.COMMON.sent_to")) + " " + toDisplayString(_ctx.secretMetadata.recipients) + ") ", 1)) : createCommentVNode("", true)
            ]),
            _: 1
          }, 8, ["to", "class", "title"]),
          _hoisted_2$I,
          createBaseVNode("em", {
            class: "text-gray-500 dark:text-gray-400 italic",
            title: _ctx.secretMetadata.updated
          }, toDisplayString(_ctx.secretMetadata.is_received ? _ctx.$t("web.COMMON.word_received") : "") + " " + toDisplayString(_ctx.secretMetadata.is_burned ? _ctx.$t("web.COMMON.word_burned") : "") + " " + toDisplayString(_ctx.secretMetadata.stamp), 9, _hoisted_3$D),
          !_ctx.secretMetadata.is_destroyed ? (openBlock(), createBlock(unref(RouterLink), {
            key: 0,
            to: { name: "Burn secret", params: { metadataKey: _ctx.secretMetadata.key } },
            class: "burn-secret ml-2 text-red-500 hover:text-red-600 dark:text-red-400 dark:hover:text-red-300 transition-colors",
            title: _ctx.$t("web.COMMON.burn_this_secret")
          }, {
            default: withCtx(() => [
              _hoisted_4$y
            ]),
            _: 1
          }, 8, ["to", "title"])) : createCommentVNode("", true)
        ], 64);
      };
    }
  });
  const _hoisted_1$N = { class: "space-y-8" };
  const _hoisted_2$H = { class: "text-2xl font-semibold mb-4 text-gray-800 dark:text-gray-200" };
  const _hoisted_3$C = {
    key: 0,
    class: "space-y-1"
  };
  const _hoisted_4$x = {
    key: 1,
    class: "text-gray-600 dark:text-gray-400 italic"
  };
  const _hoisted_5$w = { class: "text-2xl font-semibold mb-4 text-gray-800 dark:text-gray-200" };
  const _hoisted_6$s = {
    key: 0,
    class: "space-y-1"
  };
  const _hoisted_7$p = {
    key: 1,
    class: "text-gray-600 dark:text-gray-400 italic"
  };
  const _hoisted_8$n = { key: 1 };
  const _hoisted_9$o = { class: "text-2xl font-semibold mb-4 text-gray-800 dark:text-gray-200" };
  const _hoisted_10$m = { class: "text-gray-600 dark:text-gray-400 italic" };
  const _sfc_main$Q = /* @__PURE__ */ defineComponent({
    __name: "SecretMetadataTable",
    props: {
      hasItems: { type: Boolean },
      notReceived: {},
      received: {}
    },
    setup(__props) {
      return (_ctx, _cache) => {
        const _component_router_link = resolveComponent("router-link");
        return openBlock(), createElementBlock("div", _hoisted_1$N, [
          _ctx.hasItems ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createBaseVNode("section", null, [
              createBaseVNode("h3", _hoisted_2$H, toDisplayString(_ctx.$t("web.dashboard.title_not_received")), 1),
              _ctx.notReceived ? (openBlock(), createElementBlock("ul", _hoisted_3$C, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.notReceived, (item) => {
                  return openBlock(), createElementBlock("li", {
                    key: item.identifier
                  }, [
                    createVNode(_sfc_main$R, { secretMetadata: item }, null, 8, ["secretMetadata"])
                  ]);
                }), 128))
              ])) : (openBlock(), createElementBlock("p", _hoisted_4$x, [
                createTextVNode(" Go on then. "),
                createVNode(_component_router_link, {
                  to: "/",
                  class: "text-brand-500 hover:underline"
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(_ctx.$t("web.COMMON.share_a_secret")), 1)
                  ]),
                  _: 1
                }),
                createTextVNode("! ")
              ]))
            ]),
            createBaseVNode("section", null, [
              createBaseVNode("h3", _hoisted_5$w, toDisplayString(_ctx.$t("web.dashboard.title_received")), 1),
              _ctx.received ? (openBlock(), createElementBlock("ul", _hoisted_6$s, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.received, (item) => {
                  return openBlock(), createElementBlock("li", {
                    key: item.identifier
                  }, [
                    createVNode(_sfc_main$R, { secretMetadata: item }, null, 8, ["secretMetadata"])
                  ]);
                }), 128))
              ])) : (openBlock(), createElementBlock("p", _hoisted_7$p, toDisplayString(_ctx.$t("web.COMMON.word_none")), 1))
            ])
          ], 64)) : createCommentVNode("", true),
          !_ctx.hasItems ? (openBlock(), createElementBlock("section", _hoisted_8$n, [
            createBaseVNode("h3", _hoisted_9$o, toDisplayString(_ctx.$t("web.dashboard.title_no_recent_secrets")), 1),
            createBaseVNode("p", _hoisted_10$m, [
              createTextVNode(" Go on then. "),
              createVNode(_component_router_link, {
                to: "/",
                class: "text-brand-500 hover:underline"
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(_ctx.$t("web.COMMON.share_a_secret")), 1)
                ]),
                _: 1
              }),
              createTextVNode("! ")
            ])
          ])) : createCommentVNode("", true)
        ]);
      };
    }
  });
  const _sfc_main$P = /* @__PURE__ */ defineComponent({
    __name: "DashboardRecent",
    setup(__props) {
      const { details, fetchData: fetchDomains } = useFetchData({
        url: "/api/v2/private/recent"
      });
      onMounted(fetchDomains);
      return (_ctx, _cache) => {
        var _a, _b, _c;
        return openBlock(), createElementBlock("div", null, [
          createVNode(_sfc_main$T),
          createVNode(_sfc_main$Q, {
            hasItems: (_a = unref(details)) == null ? void 0 : _a.has_items,
            notReceived: (_b = unref(details)) == null ? void 0 : _b.notreceived,
            received: (_c = unref(details)) == null ? void 0 : _c.received,
            title: "Received"
          }, null, 8, ["hasItems", "notReceived", "received"])
        ]);
      };
    }
  });
  const _hoisted_1$M = {
    key: 0,
    class: "px-4 py-3 rounded relative border bg-red-100 border-red-400 text-red-700 dark:bg-red-800 dark:border-red-600 dark:text-red-100 mb-4"
  };
  const _hoisted_2$G = /* @__PURE__ */ createBaseVNode("strong", { class: "font-bold" }, "Cannot burn!", -1);
  const _hoisted_3$B = { class: "block sm:inline" };
  const _hoisted_4$w = ["href"];
  const _hoisted_5$v = { key: 1 };
  const _hoisted_6$r = { class: "mb-6" };
  const _hoisted_7$o = { class: "text-lg text-gray-600 dark:text-gray-400" };
  const _hoisted_8$m = {
    key: 0,
    class: "text-xl font-semibold mt-2 text-gray-800 dark:text-gray-200"
  };
  const _hoisted_9$n = ["value"];
  const _hoisted_10$l = /* @__PURE__ */ createBaseVNode("input", {
    type: "hidden",
    name: "continue",
    value: "true"
  }, null, -1);
  const _hoisted_11$m = { key: 0 };
  const _hoisted_12$j = /* @__PURE__ */ createBaseVNode("input", {
    type: "password",
    name: "passphrase",
    id: "passField",
    class: "w-full px-3 py-2 border rounded-md border-gray-300 bg-white dark:bg-gray-800 dark:border-gray-600 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-brand-500",
    placeholder: "Enter the passphrase here"
  }, null, -1);
  const _hoisted_13$i = [
    _hoisted_12$j
  ];
  const _hoisted_14$f = ["disabled"];
  const _hoisted_15$f = /* @__PURE__ */ createBaseVNode("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    class: "h-5 w-5 mr-2",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    width: "20",
    height: "20"
  }, [
    /* @__PURE__ */ createBaseVNode("path", {
      "fill-rule": "evenodd",
      d: "M12.395 2.553a1 1 0 00-1.45-.385c-.345.23-.614.558-.822.88-.214.33-.403.713-.57 1.116-.334.804-.614 1.768-.84 2.734a31.365 31.365 0 00-.613 3.58 2.64 2.64 0 01-.945-1.067c-.328-.68-.398-1.534-.398-2.654A1 1 0 005.05 6.05 6.981 6.981 0 003 11a7 7 0 1011.95-4.95c-.592-.591-.98-.985-1.348-1.467-.363-.476-.724-1.063-1.207-2.03zM12.12 15.12A3 3 0 017 13s.879.5 2.5.5c0-1 .5-4 1.25-4.5.5 1 .786 1.293 1.371 1.879A2.99 2.99 0 0113 13a2.99 2.99 0 01-.879 2.121z",
      "clip-rule": "evenodd"
    })
  ], -1);
  const _hoisted_16$e = ["href"];
  const _hoisted_17$f = /* @__PURE__ */ createBaseVNode("hr", { class: "border-gray-300 dark:border-gray-600" }, null, -1);
  const _hoisted_18$d = { class: "text-md text-gray-600 dark:text-gray-400" };
  const _sfc_main$O = /* @__PURE__ */ defineComponent({
    __name: "BurnSecret",
    props: {
      metadataKey: {}
    },
    setup(__props) {
      const csrfStore = useCsrfStore();
      const props = __props;
      const { record, details, fetchData: fetchMetadata } = useFetchDataRecord({
        url: `/api/v2/private/${props.metadataKey}`
      });
      const router2 = useRouter();
      const {
        isSubmitting,
        error,
        success,
        submitForm
      } = useFormSubmission({
        url: `/api/v2/private/${props.metadataKey}/burn`,
        successMessage: "",
        onSuccess: (data) => {
          router2.push({
            name: "Metadata link",
            params: { metadataKey: data.record.key }
          });
        },
        onError: (data) => {
          console.error("Error fetching secret:", data);
        }
      });
      onMounted(fetchMetadata);
      return (_ctx, _cache) => {
        var _a, _b, _c, _d, _e, _f;
        return openBlock(), createElementBlock("div", null, [
          createVNode(_sfc_main$Y, {
            success: unref(success),
            error: unref(error)
          }, null, 8, ["success", "error"]),
          ((_a = unref(details)) == null ? void 0 : _a.is_destroyed) ? (openBlock(), createElementBlock("div", _hoisted_1$M, [
            _hoisted_2$G,
            createBaseVNode("template", null, [
              createBaseVNode("span", _hoisted_3$B, [
                unref(details).is_received ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  createTextVNode(" The secret has already been viewed (" + toDisplayString(unref(details).received_date) + "). ", 1)
                ], 64)) : createCommentVNode("", true),
                unref(details).is_burned ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createTextVNode(" The secret has already been burned (" + toDisplayString(unref(details).burned_date) + "). ", 1)
                ], 64)) : createCommentVNode("", true)
              ])
            ]),
            createBaseVNode("a", {
              href: (_b = unref(record)) == null ? void 0 : _b.metadata_url,
              class: "block w-full py-2 px-4 mt-2 bg-gray-200 text-gray-700 rounded text-center hover:bg-gray-300 transition duration-200 dark:bg-gray-700 dark:text-gray-200 dark:hover:bg-gray-600"
            }, "Back", 8, _hoisted_4$w)
          ])) : (openBlock(), createElementBlock("div", _hoisted_5$v, [
            createBaseVNode("div", _hoisted_6$r, [
              createBaseVNode("span", _hoisted_7$o, toDisplayString(_ctx.$t("web.COMMON.secret")) + ": " + toDisplayString((_c = unref(record)) == null ? void 0 : _c.secret_shortkey), 1),
              ((_d = unref(details)) == null ? void 0 : _d.has_passphrase) ? (openBlock(), createElementBlock("h2", _hoisted_8$m, toDisplayString(_ctx.$t("web.private.requires_passphrase")), 1)) : createCommentVNode("", true)
            ]),
            createBaseVNode("form", {
              method: "POST",
              onSubmit: _cache[0] || (_cache[0] = withModifiers(
                //@ts-ignore
                (...args) => unref(submitForm) && unref(submitForm)(...args),
                ["prevent"]
              )),
              class: "space-y-4"
            }, [
              createBaseVNode("input", {
                type: "hidden",
                name: "shrimp",
                value: unref(csrfStore).shrimp
              }, null, 8, _hoisted_9$n),
              _hoisted_10$l,
              ((_e = unref(details)) == null ? void 0 : _e.has_passphrase) ? (openBlock(), createElementBlock("div", _hoisted_11$m, _hoisted_13$i)) : createCommentVNode("", true),
              createBaseVNode("button", {
                type: "submit",
                disabled: unref(isSubmitting),
                class: "w-full py-2 px-4 rounded-md bg-yellow-400 text-gray-800 hover:bg-yellow-300 focus:outline-none focus:ring-2 focus:ring-yellow-400 focus:ring-offset-2 dark:focus:ring-offset-gray-800 transition duration-200 flex items-center justify-center"
              }, [
                _hoisted_15$f,
                createTextVNode(" " + toDisplayString(_ctx.$t("web.COMMON.word_confirm")) + ": " + toDisplayString(_ctx.$t("web.COMMON.burn_this_secret")), 1)
              ], 8, _hoisted_14$f),
              createBaseVNode("a", {
                href: (_f = unref(record)) == null ? void 0 : _f.metadata_url,
                class: "block w-full py-2 px-4 rounded text-center bg-gray-200 text-gray-700 hover:bg-gray-300 dark:bg-gray-700 dark:text-gray-200 dark:hover:bg-gray-600 transition duration-200"
              }, toDisplayString(_ctx.$t("web.COMMON.word_cancel")), 9, _hoisted_16$e),
              _hoisted_17$f,
              createBaseVNode("p", _hoisted_18$d, toDisplayString(_ctx.$t("web.COMMON.burn_this_secret_confirm_hint")), 1)
            ], 32)
          ]))
        ]);
      };
    }
  });
  const _hoisted_1$L = {
    id: "createSecret",
    method: "post",
    autocomplete: "off",
    action: "/incoming",
    class: "space-y-6"
  };
  const _hoisted_2$F = ["value"];
  const _hoisted_3$A = ["placeholder"];
  const _hoisted_4$v = { class: "bg-gray-50 dark:bg-gray-700 p-4 rounded-lg" };
  const _hoisted_5$u = { class: "text-lg font-medium text-gray-900 dark:text-white mb-4" };
  const _hoisted_6$q = { class: "space-y-4" };
  const _hoisted_7$n = {
    for: "ticketnoField",
    class: "block font-medium text-gray-700 dark:text-gray-300"
  };
  const _hoisted_8$l = /* @__PURE__ */ createBaseVNode("svg", {
    class: "w-5 h-5 inline-block mr-1",
    fill: "none",
    stroke: "currentColor",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    /* @__PURE__ */ createBaseVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M15 5v2m0 4v2m0 4v2M5 5a2 2 0 00-2 2v3a2 2 0 110 4v3a2 2 0 002 2h14a2 2 0 002-2v-3a2 2 0 110-4V7a2 2 0 00-2-2H5z"
    })
  ], -1);
  const _hoisted_9$m = ["placeholder"];
  const _hoisted_10$k = {
    for: "recipientField",
    class: "block font-medium text-gray-700 dark:text-gray-300"
  };
  const _hoisted_11$l = /* @__PURE__ */ createBaseVNode("svg", {
    class: "w-5 h-5 inline-block mr-1",
    fill: "none",
    stroke: "currentColor",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    /* @__PURE__ */ createBaseVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M16 12a4 4 0 10-8 0 4 4 0 008 0zm0 0v1.5a2.5 2.5 0 005 0V12a9 9 0 10-9 9m4.5-1.206a8.959 8.959 0 01-4.5 1.207"
    })
  ], -1);
  const _hoisted_12$i = { class: "mt-1 text-gray-900 dark:text-gray-100" };
  const _hoisted_13$h = ["disabled"];
  const _hoisted_14$e = {
    key: 0,
    class: "animate-spin -ml-1 mr-3 h-5 w-5 text-white",
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24"
  };
  const _hoisted_15$e = /* @__PURE__ */ createBaseVNode("circle", {
    class: "opacity-25",
    cx: "12",
    cy: "12",
    r: "10",
    stroke: "currentColor",
    "stroke-width": "4"
  }, null, -1);
  const _hoisted_16$d = /* @__PURE__ */ createBaseVNode("path", {
    class: "opacity-75",
    fill: "currentColor",
    d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
  }, null, -1);
  const _hoisted_17$e = [
    _hoisted_15$e,
    _hoisted_16$d
  ];
  const _hoisted_18$c = { key: 1 };
  const _hoisted_19$b = { key: 2 };
  const _sfc_main$N = /* @__PURE__ */ defineComponent({
    __name: "InboundSecretForm",
    props: {
      enabled: { type: Boolean, default: true },
      title: {}
    },
    setup(__props) {
      const csrfStore = useCsrfStore();
      const isLoading = ref(false);
      const { incoming_recipient } = useWindowProps(["incoming_recipient"]);
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", null, [
          createBaseVNode("h3", null, toDisplayString(_ctx.title), 1),
          createBaseVNode("form", _hoisted_1$L, [
            createBaseVNode("input", {
              type: "hidden",
              name: "shrimp",
              value: unref(csrfStore).shrimp
            }, null, 8, _hoisted_2$F),
            createBaseVNode("div", null, [
              createBaseVNode("textarea", {
                rows: "7",
                class: "w-full px-3 py-2 border rounded-lg text-lg focus:outline-none focus:ring-brandcomp-500 focus:border-brandcomp-500 text-gray-700 dark:text-gray-300 dark:bg-gray-700 dark:border-gray-600 transition duration-150 ease-in-out",
                name: "secret",
                autocomplete: "off",
                placeholder: _ctx.$t("web.incoming.incoming_secret_placeholder")
              }, null, 8, _hoisted_3$A)
            ]),
            createBaseVNode("div", _hoisted_4$v, [
              createBaseVNode("h3", _hoisted_5$u, toDisplayString(_ctx.$t("web.incoming.incoming_secret_options")), 1),
              createBaseVNode("div", _hoisted_6$q, [
                createBaseVNode("div", null, [
                  createBaseVNode("label", _hoisted_7$n, [
                    _hoisted_8$l,
                    createTextVNode(" " + toDisplayString(_ctx.$t("web.incoming.incoming_ticket_number")) + ": ", 1)
                  ]),
                  createBaseVNode("input", {
                    type: "text",
                    name: "ticketno",
                    id: "ticketnoField",
                    class: "mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-brandcomp-500 focus:border-brandcomp-500 dark:bg-gray-600 dark:border-gray-500 dark:text-white transition duration-150 ease-in-out",
                    placeholder: _ctx.$t("web.incoming.incoming_ticket_number_hint"),
                    required: "",
                    autocomplete: "off"
                  }, null, 8, _hoisted_9$m)
                ]),
                createBaseVNode("div", null, [
                  createBaseVNode("label", _hoisted_10$k, [
                    _hoisted_11$l,
                    createTextVNode(" " + toDisplayString(_ctx.$t("web.incoming.incoming_recipient_address")) + ": ", 1)
                  ]),
                  createBaseVNode("div", _hoisted_12$i, toDisplayString(unref(incoming_recipient)), 1)
                ])
              ])
            ]),
            createBaseVNode("button", {
              type: "submit",
              name: "kind",
              value: "share",
              disabled: isLoading.value,
              class: "w-full flex justify-center items-center py-2 px-4 border border-transparent rounded-md shadow-sm font-semibold text-lg text-white bg-brand-600 hover:bg-brand-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-brand-500 dark:bg-brand-500 dark:hover:bg-brand-600 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed transition duration-150 ease-in-out"
            }, [
              isLoading.value ? (openBlock(), createElementBlock("svg", _hoisted_14$e, _hoisted_17$e)) : createCommentVNode("", true),
              !isLoading.value ? (openBlock(), createElementBlock("span", _hoisted_18$c, toDisplayString(_ctx.$t("web.incoming.incoming_button_create")), 1)) : (openBlock(), createElementBlock("span", _hoisted_19$b, toDisplayString(_ctx.$t("web.incoming.incoming_button_creating")), 1))
            ], 8, _hoisted_13$h)
          ])
        ]);
      };
    }
  });
  const _hoisted_1$K = { class: "bg-white dark:bg-gray-800 shadow-md rounded-lg p-6" };
  const _sfc_main$M = /* @__PURE__ */ defineComponent({
    __name: "IncomingSupportSecret",
    setup(__props) {
      const { authenticated } = useWindowProps(["authenticated"]);
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$K, [
          unref(authenticated) ? (openBlock(), createBlock(HomepageTaglines, { key: 0 })) : createCommentVNode("", true),
          createVNode(_sfc_main$N, {
            enabled: true,
            title: "Support Details"
          })
        ]);
      };
    }
  });
  const _hoisted_1$J = { key: 0 };
  const _hoisted_2$E = /* @__PURE__ */ createBaseVNode("svg", {
    class: "inline-block w-5 h-5 mr-2",
    fill: "none",
    stroke: "currentColor",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20"
  }, [
    /* @__PURE__ */ createBaseVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M17.657 18.657A8 8 0 016.343 7.343S7 9 9 10c0-2 .5-5 2.986-7C14 5 16.09 5.777 17.656 7.343A7.975 7.975 0 0120 13a7.975 7.975 0 01-2.343 5.657z"
    }),
    /* @__PURE__ */ createBaseVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M9.879 16.121A3 3 0 1012.015 11L11 14H9c0 .768.293 1.536.879 2.121z"
    })
  ], -1);
  const _hoisted_3$z = { class: "text-sm text-gray-500 dark:text-gray-400 mb-4" };
  const _hoisted_4$u = /* @__PURE__ */ createBaseVNode("hr", { class: "w-1/4 my-4 mx-auto border-gray-200 dark:border-gray-600" }, null, -1);
  const _sfc_main$L = /* @__PURE__ */ defineComponent({
    __name: "BurnButtonForm",
    props: {
      metadata: {},
      details: {}
    },
    setup(__props) {
      return (_ctx, _cache) => {
        const _component_router_link = resolveComponent("router-link");
        return !_ctx.details.is_destroyed ? (openBlock(), createElementBlock("div", _hoisted_1$J, [
          createVNode(_component_router_link, {
            to: { name: "Burn secret", params: { metadataKey: _ctx.metadata.key } },
            class: "block w-full px-4 py-2 mb-4 text-center text-base bg-yellow-400 rounded-md text-gray-800 hover:bg-yellow-300 focus:outline-none focus:ring-2 focus:ring-yellow-400 focus:ring-offset-2 dark:focus:ring-offset-gray-800"
          }, {
            default: withCtx(() => [
              _hoisted_2$E,
              createTextVNode(" " + toDisplayString(_ctx.$t("web.COMMON.burn_this_secret")), 1)
            ]),
            _: 1
          }, 8, ["to"]),
          createBaseVNode("p", _hoisted_3$z, " * " + toDisplayString(_ctx.$t("web.COMMON.burn_this_secret_hint")) + ". ", 1),
          _hoisted_4$u
        ])) : createCommentVNode("", true);
      };
    }
  });
  function useClipboard() {
    const isCopied = ref(false);
    const copyToClipboard = async (text) => {
      try {
        await navigator.clipboard.writeText(text);
        isCopied.value = true;
        setTimeout(() => {
          isCopied.value = false;
        }, 2e3);
      } catch (err) {
        console.error("Failed to copy text: ", err);
      }
    };
    return {
      isCopied,
      copyToClipboard
    };
  }
  const _hoisted_1$I = { class: "mb-4" };
  const _hoisted_2$D = { class: "text-base text-gray-600 dark:text-gray-400 mb-2" };
  const _hoisted_3$y = { class: "relative" };
  const _hoisted_4$t = ["value"];
  const _hoisted_5$t = ["title"];
  const _hoisted_6$p = {
    key: 0,
    xmlns: "http://www.w3.org/2000/svg",
    class: "h-5 w-5",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor",
    width: "20",
    height: "20"
  };
  const _hoisted_7$m = /* @__PURE__ */ createBaseVNode("path", {
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "2",
    d: "M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"
  }, null, -1);
  const _hoisted_8$k = [
    _hoisted_7$m
  ];
  const _hoisted_9$l = {
    key: 1,
    xmlns: "http://www.w3.org/2000/svg",
    class: "h-5 w-5 text-green-500",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor",
    width: "20",
    height: "20"
  };
  const _hoisted_10$j = /* @__PURE__ */ createBaseVNode("path", {
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "2",
    d: "M5 13l4 4L19 7"
  }, null, -1);
  const _hoisted_11$k = [
    _hoisted_10$j
  ];
  const _hoisted_12$h = {
    key: 0,
    class: "mt-2 font-bold text-gray-800 dark:text-gray-200"
  };
  const _sfc_main$K = /* @__PURE__ */ defineComponent({
    __name: "SecretLink",
    props: {
      metadata: {},
      details: {}
    },
    setup(__props) {
      const props = __props;
      const { isCopied, copyToClipboard } = useClipboard();
      const copySecretUrl = () => {
        copyToClipboard(props.metadata.share_url);
      };
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$I, [
          createBaseVNode("p", _hoisted_2$D, toDisplayString(_ctx.$t("web.private.pretext")), 1),
          createBaseVNode("div", _hoisted_3$y, [
            createBaseVNode("input", {
              id: "secreturi",
              class: "w-full pr-10 px-3 py-2 bg-gray-100 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-brand-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white",
              value: _ctx.metadata.share_url,
              readonly: ""
            }, null, 8, _hoisted_4$t),
            createBaseVNode("button", {
              onClick: copySecretUrl,
              title: unref(isCopied) ? "Copied!" : "Copy to clipboard",
              class: "absolute inset-y-0 right-0 px-3 flex items-center text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200",
              "aria-label": "Copy to clipboard"
            }, [
              !unref(isCopied) ? (openBlock(), createElementBlock("svg", _hoisted_6$p, _hoisted_8$k)) : (openBlock(), createElementBlock("svg", _hoisted_9$l, _hoisted_11$k))
            ], 8, _hoisted_5$t)
          ]),
          _ctx.details.has_passphrase ? (openBlock(), createElementBlock("p", _hoisted_12$h, toDisplayString(_ctx.$t("web.private.requires_passphrase")), 1)) : createCommentVNode("", true)
        ]);
      };
    }
  });
  const _hoisted_1$H = {
    key: 0,
    class: "mb-4"
  };
  const _hoisted_2$C = { key: 0 };
  const _hoisted_3$x = { class: "mb-2 italic text-gray-600 dark:text-gray-400" };
  const _hoisted_4$s = ["value", "rows"];
  const _hoisted_5$s = { class: "text-sm text-gray-500 dark:text-gray-400" };
  const _hoisted_6$o = { key: 1 };
  const _hoisted_7$l = ["value"];
  const _hoisted_8$j = { key: 2 };
  const _hoisted_9$k = {
    key: 1,
    class: "mb-4"
  };
  const _hoisted_10$i = { class: "mb-2 text-gray-600 dark:text-gray-400" };
  const _hoisted_11$j = /* @__PURE__ */ createBaseVNode("input", {
    class: "w-full px-3 py-2 bg-gray-100 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-brand-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white",
    value: "*******************",
    disabled: ""
  }, null, -1);
  const _sfc_main$J = /* @__PURE__ */ defineComponent({
    __name: "MetadataDisplayCase",
    props: {
      metadata: {},
      details: {}
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return _ctx.details.show_secret ? (openBlock(), createElementBlock("div", _hoisted_1$H, [
          _ctx.details.can_decrypt ? (openBlock(), createElementBlock("div", _hoisted_2$C, [
            createBaseVNode("p", _hoisted_3$x, toDisplayString(_ctx.$t("web.COMMON.secret")) + " (" + toDisplayString(_ctx.metadata.secret_shortkey) + "): ", 1),
            createBaseVNode("textarea", {
              class: "w-full px-3 py-2 bg-gray-100 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-brand-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white font-mono text-base leading-[1.2] tracking-wider resize-none",
              readonly: "",
              value: _ctx.details.secret_value,
              rows: _ctx.details.display_lines
            }, null, 8, _hoisted_4$s),
            createBaseVNode("span", _hoisted_5$s, "(" + toDisplayString(_ctx.$t("web.private.only_see_once")) + ")", 1)
          ])) : (openBlock(), createElementBlock("div", _hoisted_6$o, [
            createBaseVNode("input", {
              id: "displayedsecret",
              class: "w-full px-3 py-2 bg-gray-100 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-brand-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white",
              value: _ctx.$t("web.private.this_msg_is_encrypted"),
              readonly: ""
            }, null, 8, _hoisted_7$l)
          ])),
          _ctx.details.is_truncated ? (openBlock(), createElementBlock("div", _hoisted_8$j, [
            createBaseVNode("strong", null, toDisplayString(_ctx.$t("web.COMMON.warning")), 1),
            createTextVNode(" " + toDisplayString(_ctx.$t("web.COMMON.secret_was_truncated")), 1)
          ])) : createCommentVNode("", true)
        ])) : (openBlock(), createElementBlock("div", _hoisted_9$k, [
          createBaseVNode("p", _hoisted_10$i, toDisplayString(_ctx.$t("web.COMMON.secret")) + " (" + toDisplayString(_ctx.metadata.secret_shortkey) + "): ", 1),
          _hoisted_11$j
        ]));
      };
    }
  });
  const _hoisted_1$G = {
    key: 0,
    class: "text-sm text-gray-600 dark:text-gray-400"
  };
  const _hoisted_2$B = /* @__PURE__ */ createBaseVNode("h3", { class: "text-lg font-semibold text-gray-800 dark:text-gray-200 mb-2" }, "F.A.Q.", -1);
  const _hoisted_3$w = /* @__PURE__ */ createStaticVNode('<h4 class="font-semibold mt-4 mb-2">Why can&#39;t I see my passphrase?</h4><p class="mb-4"> We can&#39;t show it to you because we don&#39;t know what it is. When you create a secret with a passphrase, we immediately hash it with <a href="https://en.wikipedia.org/wiki/Bcrypt" class="text-brand-500 hover:underline">bcrypt</a>. Since we don&#39;t store the passphrase, we have no way to show it to you. That also means when you include a passphrase, we have no way to decrypt your secret. </p><h4 class="font-semibold mt-4 mb-2">Why can&#39;t I see the secret value?</h4><p class="mb-4"> We display the value for you so that you can verify it but we do that once so that if someone gets this private page (in your browser history or if you accidentally send the private link instead of the secret one), they won&#39;t see the secret value. </p>', 4);
  const _hoisted_7$k = /* @__PURE__ */ createStaticVNode('<h4 class="font-semibold mt-4 mb-2">What happens when I burn a secret?</h4><p class="mb-4"> Burning a secret will delete it before it has been read. If you send someone a secret link and burn the secret before they view it, they will not be able to read it. In fact, it will look to them like the secret never existed at all. </p><h4 class="font-semibold mt-4 mb-2">Why can I only see the secret value once?</h4><p class="mb-4"> We display the value for you so that you can verify it but we do that once so that if someone gets this private page (in your browser history or if you accidentally send the private link instead of the secret one), they won&#39;t see the secret value. </p><h4 class="font-semibold mt-4 mb-2">How long will the secret be available?</h4>', 5);
  const _hoisted_12$g = { class: "mb-4" };
  const _hoisted_13$g = {
    key: 1,
    class: "text-sm text-gray-600 dark:text-gray-400"
  };
  const _hoisted_14$d = /* @__PURE__ */ createBaseVNode("h3", { class: "text-lg font-semibold text-gray-800 dark:text-gray-200 mb-2" }, "F.A.Q.", -1);
  const _hoisted_15$d = /* @__PURE__ */ createBaseVNode("h4", { class: "font-semibold mt-4 mb-2" }, "What if I forgot to copy the shared link?", -1);
  const _hoisted_16$c = /* @__PURE__ */ createBaseVNode("p", { class: "mb-4" }, "You need to create a new secret. We can't retrieve it for you.", -1);
  const _hoisted_17$d = /* @__PURE__ */ createBaseVNode("h4", { class: "font-semibold mt-4 mb-2" }, "How long will the secret be available?", -1);
  const _hoisted_18$b = { class: "mb-4" };
  const _hoisted_19$a = /* @__PURE__ */ createBaseVNode("h4", { class: "font-semibold mt-4 mb-2" }, "What happens when I burn a secret?", -1);
  const _hoisted_20$8 = /* @__PURE__ */ createBaseVNode("p", { class: "mb-4" }, " Burning a secret will delete it before it has been read. If you send someone a secret link and burn the secret before they view it, they will not be able to read it. In fact, it will look to them like the secret never existed at all. ", -1);
  const _sfc_main$I = /* @__PURE__ */ defineComponent({
    __name: "MetadataFAQ",
    props: {
      metadata: {},
      details: {}
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return _ctx.details.show_secret ? (openBlock(), createElementBlock("div", _hoisted_1$G, [
          _hoisted_2$B,
          _ctx.details.has_passphrase ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            _hoisted_3$w
          ], 64)) : createCommentVNode("", true),
          _hoisted_7$k,
          createBaseVNode("p", _hoisted_12$g, " The secret link will be available for " + toDisplayString(_ctx.metadata.expiration_stamp) + " or until it's viewed. ", 1)
        ])) : (openBlock(), createElementBlock("div", _hoisted_13$g, [
          _hoisted_14$d,
          !_ctx.details.show_secret_link ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            _hoisted_15$d,
            _hoisted_16$c
          ], 64)) : createCommentVNode("", true),
          _hoisted_17$d,
          createBaseVNode("p", _hoisted_18$b, " The secret link will be available for " + toDisplayString(_ctx.metadata.expiration_stamp) + " or until it's viewed. ", 1),
          _hoisted_19$a,
          _hoisted_20$8
        ]));
      };
    }
  });
  const _hoisted_1$F = { key: 0 };
  const _hoisted_2$A = { key: 1 };
  const _hoisted_3$v = {
    key: 1,
    class: "text-lg font-semibold text-gray-800 dark:text-gray-200 mb-4"
  };
  const _hoisted_4$r = { class: "text-gray-600 dark:text-gray-400 mb-4" };
  const _hoisted_5$r = { class: "text-sm text-gray-500 dark:text-gray-400" };
  const _hoisted_6$n = { class: "text-sm text-gray-500 dark:text-gray-400" };
  const _hoisted_7$j = { class: "text-sm text-gray-500 dark:text-gray-400" };
  const _hoisted_8$i = /* @__PURE__ */ createBaseVNode("a", {
    href: "/",
    class: "block w-2/3 mx-auto px-4 py-2 mb-4 text-center rounded-md border-2 text-base font-medium bg-gray-200 text-gray-800 border-gray-300 dark:bg-gray-700 dark:text-gray-200 dark:border-gray-800 hover:bg-gray-100 hover:border-grey-200 dark:hover:bg-gray-600 dark:hover:border-gray-600"
  }, "Create another secret", -1);
  const _sfc_main$H = /* @__PURE__ */ defineComponent({
    __name: "ShowMetadata",
    props: {
      metadataKey: {}
    },
    setup(__props) {
      const props = __props;
      const { record, details, isLoading, error, fetchData: fetchMetadata } = useFetchDataRecord({
        url: `/api/v2/private/${props.metadataKey}`
      });
      onMounted(fetchMetadata);
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", null, [
          createVNode(_sfc_main$T),
          createVNode(_sfc_main$Y, { error: unref(error) }, null, 8, ["error"]),
          unref(isLoading) ? (openBlock(), createElementBlock("div", _hoisted_1$F, "Loading...")) : unref(record) && unref(details) ? (openBlock(), createElementBlock("div", _hoisted_2$A, [
            unref(details).show_secret_link ? (openBlock(), createBlock(_sfc_main$K, {
              key: 0,
              metadata: unref(record),
              details: unref(details)
            }, null, 8, ["metadata", "details"])) : createCommentVNode("", true),
            unref(details).show_recipients ? (openBlock(), createElementBlock("h3", _hoisted_3$v, toDisplayString(_ctx.$t("web.COMMON.sent_to")) + " " + toDisplayString(unref(record).recipients), 1)) : createCommentVNode("", true),
            createVNode(_sfc_main$J, {
              metadata: unref(record),
              details: unref(details)
            }, null, 8, ["metadata", "details"]),
            createBaseVNode("p", _hoisted_4$r, [
              unref(details).is_received ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createBaseVNode("em", null, toDisplayString(_ctx.$t("web.COMMON.received")) + " " + toDisplayString(unref(details).received_date) + ". ", 1),
                createBaseVNode("span", _hoisted_5$r, "(" + toDisplayString(unref(details).received_date_utc) + ")", 1)
              ], 64)) : unref(details).is_burned ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createBaseVNode("em", null, toDisplayString(_ctx.$t("web.COMMON.burned")) + " " + toDisplayString(unref(details).burned_date) + ". ", 1),
                createBaseVNode("span", _hoisted_6$n, "(" + toDisplayString(unref(details).burned_date_utc) + ")", 1)
              ], 64)) : !unref(details).is_destroyed ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                createBaseVNode("strong", null, toDisplayString(_ctx.$t("web.COMMON.expires_in")) + " " + toDisplayString(unref(record).expiration_stamp) + ". ", 1),
                createBaseVNode("span", _hoisted_7$j, "(" + toDisplayString(unref(record).created_date_utc) + ")", 1)
              ], 64)) : createCommentVNode("", true)
            ]),
            createVNode(_sfc_main$L, {
              metadata: unref(record),
              details: unref(details)
            }, null, 8, ["metadata", "details"]),
            _hoisted_8$i,
            createVNode(_sfc_main$I, {
              metadata: unref(record),
              details: unref(details)
            }, null, 8, ["metadata", "details"])
          ])) : createCommentVNode("", true)
        ]);
      };
    }
  });
  const _hoisted_1$E = { class: "relative" };
  const _hoisted_2$z = ["rows", "value"];
  const _hoisted_3$u = ["title"];
  const _hoisted_4$q = {
    key: 0,
    xmlns: "http://www.w3.org/2000/svg",
    class: "h-5 w-5 text-gray-600 dark:text-gray-300",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor"
  };
  const _hoisted_5$q = /* @__PURE__ */ createBaseVNode("path", {
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "2",
    d: "M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"
  }, null, -1);
  const _hoisted_6$m = [
    _hoisted_5$q
  ];
  const _hoisted_7$i = {
    key: 1,
    xmlns: "http://www.w3.org/2000/svg",
    class: "h-5 w-5 text-green-500",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor"
  };
  const _hoisted_8$h = /* @__PURE__ */ createBaseVNode("path", {
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "2",
    d: "M5 13l4 4L19 7"
  }, null, -1);
  const _hoisted_9$j = [
    _hoisted_8$h
  ];
  const _hoisted_10$h = {
    key: 0,
    class: "text-sm text-gray-500 dark:text-gray-400"
  };
  const _hoisted_11$i = {
    key: 1,
    class: "bg-brandcomp-100 border-l-4 border-brandcomp-500 text-blue-700 p-4 text-sm dark:bg-blue-800 dark:text-blue-200"
  };
  const _hoisted_12$f = { class: "mt-4" };
  const _hoisted_13$f = {
    key: 0,
    class: "bg-gray-100 border-l-4 border-gray-400 text-gray-700 my-16 p-4 mb-4 dark:bg-gray-800 dark:border-gray-600 dark:text-gray-300"
  };
  const _hoisted_14$c = /* @__PURE__ */ createBaseVNode("button", {
    type: "button",
    class: "float-right hover:text-gray-900 dark:hover:text-gray-100",
    onclick: "this.parentElement.remove()"
  }, " × ", -1);
  const _hoisted_15$c = /* @__PURE__ */ createBaseVNode("p", null, " Once you've finished viewing the secret, feel free to navigate away from this page or close the window. ", -1);
  const _hoisted_16$b = [
    _hoisted_14$c,
    _hoisted_15$c
  ];
  const _hoisted_17$c = { key: 1 };
  const _hoisted_18$a = {
    href: "/signin",
    class: "block w-full px-4 py-2 text-center text-brand-500 bg-white border border-brand-500 rounded-md hover:bg-brand-50 focus:outline-none focus:ring-2 focus:ring-brand-500 focus:ring-offset-2 dark:bg-gray-800 dark:text-brand-400 dark:border-brand-400 dark:hover:bg-gray-700"
  };
  const _hoisted_19$9 = { class: "text-center pt-20 text-xs text-gray-400 dark:text-gray-600" };
  const _hoisted_20$7 = ["href"];
  const _sfc_main$G = /* @__PURE__ */ defineComponent({
    __name: "SecretDisplayCase",
    props: {
      secret: {},
      details: {}
    },
    setup(__props) {
      const props = __props;
      const siteHost = useWindowProp("site_host");
      const { isCopied, copyToClipboard } = useClipboard();
      const copySecretContent = () => {
        if (props.secret.secret_value === void 0) {
          return;
        }
        copyToClipboard(props.secret.secret_value);
      };
      const closeTruncatedWarning = (event) => {
        var _a;
        (_a = event.target.closest(".bg-brandcomp-100")) == null ? void 0 : _a.remove();
      };
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock(Fragment, null, [
          createBaseVNode("div", _hoisted_1$E, [
            createBaseVNode("textarea", {
              class: "w-full px-3 py-2 border border-gray-300 rounded-md resize-none dark:border-gray-600 dark:text-white dark:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-brand-500 font-mono text-base leading-[1.2] tracking-wider bg-gray-100",
              readonly: "",
              rows: _ctx.details.display_lines,
              value: _ctx.secret.secret_value
            }, null, 8, _hoisted_2$z),
            createBaseVNode("button", {
              onClick: copySecretContent,
              title: unref(isCopied) ? "Copied!" : "Copy to clipboard",
              class: "absolute top-2 right-2 p-1.5 bg-gray-200 dark:bg-gray-600 rounded-md hover:bg-gray-300 dark:hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-brand-500 transition-colors duration-200",
              "aria-label": "Copy to clipboard"
            }, [
              !unref(isCopied) ? (openBlock(), createElementBlock("svg", _hoisted_4$q, _hoisted_6$m)) : (openBlock(), createElementBlock("svg", _hoisted_7$i, _hoisted_9$j))
            ], 8, _hoisted_3$u)
          ]),
          !_ctx.secret.verification ? (openBlock(), createElementBlock("p", _hoisted_10$h, " (" + toDisplayString(_ctx.$t("web.COMMON.careful_only_see_once")) + ") ", 1)) : createCommentVNode("", true),
          _ctx.secret.is_truncated ? (openBlock(), createElementBlock("div", _hoisted_11$i, [
            createBaseVNode("button", {
              type: "button",
              class: "float-right",
              onClick: closeTruncatedWarning
            }, "×"),
            createBaseVNode("strong", null, toDisplayString(_ctx.$t("web.COMMON.warning")), 1),
            createTextVNode(" " + toDisplayString(_ctx.$t("web.shared.secret_was_truncated")) + " " + toDisplayString(_ctx.secret.original_size) + ". ", 1)
          ])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_12$f, [
            !_ctx.secret.verification ? (openBlock(), createElementBlock("div", _hoisted_13$f, _hoisted_16$b)) : (openBlock(), createElementBlock("div", _hoisted_17$c, [
              createBaseVNode("a", _hoisted_18$a, toDisplayString(_ctx.$t("web.COMMON.login_to_your_account")), 1)
            ]))
          ]),
          createBaseVNode("div", _hoisted_19$9, [
            createBaseVNode("a", {
              href: `https://${unref(siteHost)}`,
              class: "hover:underline",
              rel: "noopener noreferrer"
            }, " Powered by Onetime Secret ", 8, _hoisted_20$7)
          ])
        ], 64);
      };
    }
  });
  const _sfc_main$F = {};
  const _hoisted_1$D = /* @__PURE__ */ createStaticVNode('<div class="bg-white dark:bg-gray-900"><div class="max-w-7xl mx-auto py-12 px-4 sm:py-16 sm:px-6 lg:px-8"><div class="text-center"><h2 class="text-base font-semibold text-brandcomp-700 dark:text-brandcomp-600 tracking-wide uppercase opacity-40"> Onetime Secret </h2><h3 class="mt-1 text-3xl font-extrabold text-gray-500 dark:text-gray-300 sm:text-3xl sm:tracking-tight lg:text-4xl"> You&#39;ve got (secret) mail </h3><p class="max-w-xl mt-5 mx-auto text-xl text-gray-400 dark:text-gray-400"> A secure, one-time message awaits you. <br> Before you open it, here&#39;s what you should know: </p></div></div></div><div class="bg-white dark:bg-gray-900"><div class="max-w-7xl mx-auto py-8 px-4 sm:px-6 lg:py-12 lg:px-8"><div class="lg:grid lg:grid-cols-3 lg:gap-8"><div><h3 class="text-lg font-medium text-gray-600 dark:text-white">What is this?</h3><p class="mt-3 text-base text-gray-400 dark:text-gray-300"> Onetime Secret is a secure way to share sensitive information that self-destructs after a single viewing. </p></div><div class="mt-8 lg:mt-0"><h3 class="text-lg font-medium text-gray-600 dark:text-white">Is it secure?</h3><p class="mt-3 text-base text-gray-400 dark:text-gray-300"> Yes. After viewing, the secret is permanently deleted from our servers, ensuring your privacy. </p></div><div class="mt-8 lg:mt-0"><h3 class="text-lg font-medium text-gray6900 dark:text-white whitespace-nowrap"> What happens next? </h3><p class="mt-3 text-base text-gray-400 dark:text-gray-300"> When ready, click the &quot;View Secret&quot; button at the top of the page to reveal your one-time message. </p></div></div></div></div>', 2);
  const _hoisted_3$t = [
    _hoisted_1$D
  ];
  function _sfc_render$3(_ctx, _cache) {
    return openBlock(), createElementBlock("div", null, _hoisted_3$t);
  }
  const SecretRecipientOnboardingContent = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["render", _sfc_render$3]]);
  const _sfc_main$E = {};
  const _hoisted_1$C = { class: "bg-white dark:bg-gray-800 shadow-md rounded-lg p-8" };
  const _hoisted_2$y = /* @__PURE__ */ createStaticVNode('<div class="text-center mb-8"><svg class="mx-auto w-20 h-20 text-brand-500" width="60" height="60" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M12 15V17M12 7V13M21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg></div><h1 class="text-3xl font-bold text-gray-800 dark:text-white mb-6" aria-label="Information no longer available"> That information is no longer available. </h1><p class="text-lg text-gray-600 dark:text-gray-300 mb-8"><em>Welcome to Onetime Secret.</em> Sensitive information shared through our service can only be accessed once. Once viewed, the content is permanently deleted from our servers to ensure confidentiality. This approach helps protect your sensitive data by limiting its exposure and preventing unauthorized access. </p><div class="bg-brandcomp-50 dark:bg-brandcomp-900 border-l-4 border-brandcomp-500 p-5 mb-8"><p class="text-lg text-brandcomp-700 dark:text-brandcomp-200 font-medium"> If you&#39;re unsure what to do next, please follow up with the person who sent you this link for more information. </p></div>', 4);
  function _sfc_render$2(_ctx, _cache) {
    const _component_router_link = resolveComponent("router-link");
    return openBlock(), createElementBlock("div", _hoisted_1$C, [
      _hoisted_2$y,
      createVNode(_component_router_link, {
        to: "/",
        class: "inline-block bg-white font-brand hover:border-brand-600 text-brand-500 font-medium py-3 px-6 border-2 rounded-lg transition duration-300 ease-in-out text-lg",
        "aria-label": "Return to home page"
      }, {
        default: withCtx(() => [
          createTextVNode(" Return to Home ")
        ]),
        _: 1
      })
    ]);
  }
  const UnknownSecret = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["render", _sfc_render$2]]);
  const _hoisted_1$B = { class: "mt-24" };
  const _hoisted_2$x = { key: 0 };
  const _hoisted_3$s = {
    key: 1,
    class: "space-y-20"
  };
  const _hoisted_4$p = {
    key: 0,
    class: "bg-amber-50 border-l-4 border-amber-400 text-amber-700 p-4 mb-4 dark:bg-amber-900 dark:border-amber-500 dark:text-amber-100"
  };
  const _hoisted_5$p = { class: "font-medium" };
  const _hoisted_6$l = {
    key: 1,
    class: "bg-brand-50 border-l-4 border-brand-400 text-brand-700 p-4 mb-4 dark:bg-brand-900 dark:border-brand-500 dark:text-brand-100"
  };
  const _hoisted_7$h = { key: 2 };
  const _hoisted_8$g = { class: "" };
  const _hoisted_9$i = {
    key: 0,
    class: "text-md text-gray-600 dark:text-gray-400"
  };
  const _hoisted_10$g = {
    key: 1,
    class: "text-xl font-bold text-gray-800 dark:text-gray-200"
  };
  const _hoisted_11$h = ["value"];
  const _hoisted_12$e = /* @__PURE__ */ createBaseVNode("input", {
    name: "continue",
    type: "hidden",
    value: "true"
  }, null, -1);
  const _hoisted_13$e = ["placeholder"];
  const _hoisted_14$b = ["disabled"];
  const _hoisted_15$b = { class: "text-right items-center mt-4" };
  const _hoisted_16$a = { class: "text-sm text-gray-500 dark:text-gray-400 italic" };
  const _hoisted_17$b = { key: 0 };
  const _hoisted_18$9 = {
    key: 3,
    class: "space-y-4"
  };
  const _hoisted_19$8 = { class: "text-gray-600 dark:text-gray-400" };
  const _sfc_main$D = /* @__PURE__ */ defineComponent({
    __name: "ShowSecret",
    props: {
      secretKey: {}
    },
    setup(__props) {
      const csrfStore = useCsrfStore();
      const route = useRoute();
      const props = __props;
      const initialData = computed(() => route.meta.initialData);
      const passphrase = ref("");
      const finalRecord = ref(null);
      const finalDetails = ref(null);
      const closeWarning = (event) => {
        var _a;
        (_a = event.target.closest(".bg-amber-50, .bg-brand-50")) == null ? void 0 : _a.remove();
      };
      const {
        isSubmitting,
        error: submissionError,
        success,
        submitForm
      } = useFormSubmission({
        url: `/api/v2/secret/${props.secretKey}`,
        successMessage: "",
        onSuccess: (data) => {
          finalRecord.value = data.record;
          finalDetails.value = data.details;
        },
        onError: (data) => {
          console.error("Error fetching secret:", data);
        }
      });
      const record = computed(() => {
        var _a;
        return finalRecord.value || (((_a = initialData == null ? void 0 : initialData.value.data) == null ? void 0 : _a.record) ?? null);
      });
      const details = computed(() => {
        var _a;
        return finalDetails.value || (((_a = initialData == null ? void 0 : initialData.value.data) == null ? void 0 : _a.details) ?? null);
      });
      const isLoading = computed(() => isSubmitting.value);
      const error = computed(() => submissionError.value);
      watch(finalRecord, (newValue) => {
        if (newValue) {
          console.log("Secret fetched successfully");
        }
      });
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$B, [
          isLoading.value ? (openBlock(), createElementBlock("div", _hoisted_2$x, "Loading...")) : record.value && details.value ? (openBlock(), createElementBlock("div", _hoisted_3$s, [
            !details.value.verification && details.value.is_owner && !details.value.show_secret ? (openBlock(), createElementBlock("div", _hoisted_4$p, [
              createBaseVNode("button", {
                type: "button",
                class: "float-right hover:text-amber-900 dark:hover:text-amber-50",
                onClick: closeWarning
              }, " × "),
              createBaseVNode("strong", _hoisted_5$p, toDisplayString(_ctx.$t("web.COMMON.warning")), 1),
              createTextVNode(" " + toDisplayString(_ctx.$t("web.shared.you_created_this_secret")), 1)
            ])) : createCommentVNode("", true),
            !details.value.verification && details.value.is_owner && details.value.show_secret ? (openBlock(), createElementBlock("div", _hoisted_6$l, [
              createBaseVNode("button", {
                type: "button",
                class: "float-right hover:text-brand-900 dark:hover:text-brand-50",
                onClick: closeWarning
              }, " × "),
              createTextVNode(" " + toDisplayString(_ctx.$t("web.shared.viewed_own_secret")), 1)
            ])) : createCommentVNode("", true),
            !details.value.show_secret ? (openBlock(), createElementBlock("div", _hoisted_7$h, [
              createBaseVNode("div", _hoisted_8$g, [
                createVNode(_sfc_main$Y, {
                  success: unref(success),
                  error: error.value
                }, null, 8, ["success", "error"]),
                details.value.verification && !details.value.has_passphrase ? (openBlock(), createElementBlock("p", _hoisted_9$i, toDisplayString(_ctx.$t("web.COMMON.click_to_verify")), 1)) : createCommentVNode("", true),
                details.value.has_passphrase ? (openBlock(), createElementBlock("h2", _hoisted_10$g, toDisplayString(_ctx.$t("web.shared.requires_passphrase")), 1)) : createCommentVNode("", true),
                createBaseVNode("form", {
                  onSubmit: _cache[1] || (_cache[1] = withModifiers(
                    //@ts-ignore
                    (...args) => unref(submitForm) && unref(submitForm)(...args),
                    ["prevent"]
                  )),
                  class: "space-y-4"
                }, [
                  createBaseVNode("input", {
                    name: "shrimp",
                    type: "hidden",
                    value: unref(csrfStore).shrimp
                  }, null, 8, _hoisted_11$h),
                  _hoisted_12$e,
                  details.value.has_passphrase ? withDirectives((openBlock(), createElementBlock("input", {
                    key: 0,
                    type: "password",
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => passphrase.value = $event),
                    name: "passphrase",
                    class: "w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-brand-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white",
                    placeholder: _ctx.$t("web.COMMON.enter_passphrase_here")
                  }, null, 8, _hoisted_13$e)), [
                    [vModelText, passphrase.value]
                  ]) : createCommentVNode("", true),
                  createBaseVNode("button", {
                    type: "submit",
                    disabled: unref(isSubmitting),
                    class: "w-full px-6 py-3 text-3xl font-semibold text-white bg-brand-500 rounded-md hover:bg-brand-600 focus:outline-none focus:ring-2 focus:ring-brand-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 transition duration-150 ease-in-out"
                  }, toDisplayString(unref(isSubmitting) ? _ctx.$t("web.COMMON.submitting") : _ctx.$t("web.COMMON.click_to_continue")), 9, _hoisted_14$b)
                ], 32),
                createBaseVNode("div", _hoisted_15$b, [
                  createBaseVNode("p", _hoisted_16$a, toDisplayString(_ctx.$t("web.COMMON.careful_only_see_once")), 1)
                ])
              ]),
              !record.value.verification ? (openBlock(), createElementBlock("div", _hoisted_17$b, [
                createVNode(SecretRecipientOnboardingContent)
              ])) : createCommentVNode("", true)
            ])) : (openBlock(), createElementBlock("div", _hoisted_18$9, [
              createBaseVNode("h2", _hoisted_19$8, toDisplayString(_ctx.$t("web.shared.this_message_for_you")), 1),
              createVNode(_sfc_main$G, {
                secret: record.value,
                details: details.value
              }, null, 8, ["secret", "details"])
            ]))
          ])) : !record.value ? (openBlock(), createBlock(UnknownSecret, { key: 2 })) : createCommentVNode("", true)
        ]);
      };
    }
  });
  async function fetchInitialSecret(secretKey) {
    try {
      const response = await axios.get(`/api/v2/secret/${secretKey}`);
      return {
        data: response.data,
        error: null,
        status: response.status
      };
    } catch (error) {
      if (axios.isAxiosError(error)) {
        const axiosError = error;
        if (axiosError.response) {
          const { status, data } = axiosError.response;
          if (status === 404) {
            return {
              data: null,
              error: "Secret not found or already viewed",
              status: 404
            };
          }
          return {
            data: null,
            error: data.message || "An error occurred while fetching the secret",
            status
          };
        } else if (axiosError.request) {
          return {
            data: null,
            error: "No response received from server",
            status: null
          };
        }
      }
      return {
        data: null,
        error: "An unexpected error occurred",
        status: null
      };
    }
  }
  const authState = ref(window.authenticated);
  const routes = [
    {
      path: "/",
      component: _sfc_main$U,
      beforeEnter: (to, from, next) => {
        if (authState.value) {
          next({ name: "Dashboard" });
        } else {
          next();
        }
      },
      meta: {
        layoutProps: {
          displayMasthead: true,
          displayLinks: true,
          displayFeedback: true
        }
      }
    },
    {
      path: "/secret/:secretKey",
      name: "Secret link",
      component: _sfc_main$D,
      //component: () => import('@/views/secrets/ShowSecret.vue'),
      props: true,
      meta: {
        layout: _sfc_main$14,
        layoutProps: {
          displayMasthead: false,
          displayLinks: false,
          displayFeedback: false,
          displayVersion: false,
          displayPoweredBy: true,
          noCache: true
        }
      },
      beforeEnter: async (to, from, next) => {
        try {
          const secretKey = to.params.secretKey;
          const initialData = await fetchInitialSecret(secretKey);
          to.meta.initialData = initialData;
          next();
        } catch (error) {
          console.error("Error fetching initial page data:", error);
          next(new Error("Failed to fetch initial page data"));
        }
      }
    },
    {
      path: "/private/:metadataKey",
      name: "Metadata link",
      component: _sfc_main$H,
      props: true,
      meta: {
        layoutProps: {
          displayFeedback: false,
          noCache: true
        }
      }
    },
    {
      path: "/private/:metadataKey/burn",
      name: "Burn secret",
      component: _sfc_main$O,
      props: true,
      meta: {
        layoutProps: {
          displayFeedback: false
        }
      }
    },
    {
      path: "/dashboard",
      name: "Dashboard",
      component: _sfc_main$S,
      meta: { requiresAuth: true }
    },
    {
      path: "/recent",
      name: "Recents",
      component: _sfc_main$P,
      meta: { requiresAuth: true }
    },
    {
      path: "/incoming",
      name: "Inbound Secrets",
      component: _sfc_main$M,
      meta: { requiresAuth: false }
    },
    {
      path: "/account/domains/:domain/verify",
      name: "AccountDomainVerify",
      component: () => __vitePreload(() => Promise.resolve().then(() => AccountDomainVerify), false ? __VITE_PRELOAD__ : void 0),
      meta: { requiresAuth: true },
      props: true
    },
    {
      path: "/account/domains/add",
      name: "AccountDomainAdd",
      component: () => __vitePreload(() => Promise.resolve().then(() => AccountDomainAdd), false ? __VITE_PRELOAD__ : void 0),
      meta: {
        requiresAuth: true,
        layoutProps: {
          displayFeedback: false
        }
      },
      props: true
    },
    {
      path: "/account/domains",
      name: "AccountDomains",
      component: () => __vitePreload(() => Promise.resolve().then(() => AccountDomains), false ? __VITE_PRELOAD__ : void 0),
      meta: { requiresAuth: true },
      props: true
    },
    {
      path: "/account",
      name: "Account",
      component: () => __vitePreload(() => Promise.resolve().then(() => AccountIndex), false ? __VITE_PRELOAD__ : void 0),
      meta: {
        requiresAuth: true
      }
    },
    {
      path: "/colonel",
      name: "Colonel",
      component: () => __vitePreload(() => Promise.resolve().then(() => ColonelIndex), false ? __VITE_PRELOAD__ : void 0),
      meta: {
        isAdmin: true,
        requiresAuth: true,
        layout: _sfc_main$15
      },
      props: true
    },
    {
      path: "/signin",
      name: "Sign In",
      component: () => __vitePreload(() => Promise.resolve().then(() => Signin), false ? __VITE_PRELOAD__ : void 0),
      meta: {
        //layout: WideLayout,
        layoutProps: {
          displayMasthead: true,
          displayNavigation: false,
          displayLinks: false,
          displayFeedback: false,
          displayVersion: false
        }
      }
    },
    {
      path: "/signup",
      children: [
        {
          path: "",
          name: "Sign Up",
          component: () => __vitePreload(() => Promise.resolve().then(() => Signup), false ? __VITE_PRELOAD__ : void 0)
        },
        {
          path: ":planCode",
          name: "Sign Up with Plan",
          component: () => __vitePreload(() => Promise.resolve().then(() => Signup), false ? __VITE_PRELOAD__ : void 0),
          props: true
        }
      ],
      meta: {
        layoutProps: {
          displayMasthead: true,
          displayNavigation: false,
          displayLinks: false,
          displayFeedback: false,
          displayVersion: false
        }
      }
    },
    {
      path: "/info/privacy",
      name: "Privacy Policy",
      component: () => __vitePreload(() => Promise.resolve().then(() => PrivacyDoc), false ? __VITE_PRELOAD__ : void 0),
      props: true
    },
    {
      path: "/info/terms",
      name: "Terms of Use",
      component: () => __vitePreload(() => Promise.resolve().then(() => TermsDoc$1), false ? __VITE_PRELOAD__ : void 0),
      props: true
    },
    {
      path: "/info/security",
      name: "Security Policy",
      component: () => __vitePreload(() => Promise.resolve().then(() => SecurityDoc), false ? __VITE_PRELOAD__ : void 0),
      props: true
    },
    {
      path: "/pricing",
      name: "Pricing",
      component: () => __vitePreload(() => Promise.resolve().then(() => PricingDual$1), false ? __VITE_PRELOAD__ : void 0),
      meta: {
        layout: _sfc_main$13,
        layoutProps: {
          displayMasthead: true,
          displayLinks: true,
          displayFeedback: true,
          displayVersion: true,
          displayPoweredBy: true
        }
      },
      props: true
    },
    {
      path: "/feedback",
      name: "Feedback",
      component: () => __vitePreload(() => Promise.resolve().then(() => Feedback), false ? __VITE_PRELOAD__ : void 0),
      meta: {
        layoutProps: {
          displayMasthead: true,
          displayLinks: true,
          displayFeedback: false
        }
      }
    },
    {
      path: "/forgot",
      name: "Forgot",
      component: () => __vitePreload(() => Promise.resolve().then(() => PasswordReset), false ? __VITE_PRELOAD__ : void 0)
    },
    {
      path: "/about",
      name: "About",
      component: () => __vitePreload(() => Promise.resolve().then(() => About), false ? __VITE_PRELOAD__ : void 0)
    },
    {
      path: "/translations",
      name: "Translations",
      component: () => __vitePreload(() => Promise.resolve().then(() => Translations), false ? __VITE_PRELOAD__ : void 0)
    },
    {
      path: "/logout",
      name: "Logout",
      component: { render: () => null },
      // Dummy component
      beforeEnter: () => {
        localStorage.clear();
        const languageStore = useLanguageStore();
        const csrfStore = useCsrfStore();
        languageStore.$reset();
        csrfStore.$reset();
        authState.value = false;
        window.location.href = "/logout";
      }
    }
  ];
  const router = createRouter({
    history: createWebHistory(),
    routes
  });
  router.beforeEach((to) => {
    if (to.meta.requiresAuth && !authState.value) {
      return {
        path: "/login",
        // save the location we were at to come back later
        query: { redirect: to.fullPath }
      };
    }
  });
  const _sfc_main$C = /* @__PURE__ */ defineComponent({
    __name: "App",
    setup(__props) {
      const { locale: locale2 } = useI18n();
      const route = useRoute();
      const {
        ot_version,
        cust,
        authentication,
        authenticated,
        plans_enabled,
        support_host
      } = useWindowProps([
        "ot_version",
        "cust",
        "is_default_locale",
        "authentication",
        "authenticated",
        "display_links",
        "plans_enabled",
        "support_host",
        "display_masthead"
      ]);
      const layout = computed(() => {
        return route.meta.layout || _sfc_main$15;
      });
      const layoutProps = computed(() => {
        const defaultProps = {
          authenticated: authenticated.value,
          authentication: authentication.value,
          colonel: false,
          cust: cust.value,
          onetimeVersion: ot_version.value,
          supportHost: support_host.value,
          plansEnabled: plans_enabled.value,
          defaultLocale: locale2.value,
          isDefaultLocale: true
          // Initially display the default layout with everything in the
          // header and footer hidden. These can be overridden by the
          // route.meta.layoutProps object or in the layout components
          // themselves. This prevents the header and footer from being
          // displayed on pages where they are not needed, esp in the ca
          // case where a slow connection causes the default layout to
          // be displayed before the route-specific layout is loaded.
          //displayMasthead: false,
          //displayLinks: false,
          //displayVersion: false,
          //displayFeedback: false,
        };
        if (route.meta.layoutProps) {
          const mergedProps = { ...defaultProps, ...route.meta.layoutProps };
          return mergedProps;
        }
        return defaultProps;
      });
      return (_ctx, _cache) => {
        const _component_router_view = resolveComponent("router-view");
        return openBlock(), createBlock(resolveDynamicComponent(layout.value), normalizeProps(guardReactiveProps(layoutProps.value)), {
          default: withCtx(() => [
            createVNode(_component_router_view)
          ]),
          _: 1
        }, 16);
      };
    }
  });
  async function initializeApp() {
    const app = createApp(_sfc_main$C);
    const pinia = createPinia();
    app.use(pinia);
    const languageStore = useLanguageStore();
    const initialLocale = languageStore.initializeCurrentLocale(navigator.language);
    console.log("Initial locale:", initialLocale);
    await setLanguage(initialLocale);
    languageStore.setCurrentLocale(initialLocale);
    watch(
      () => languageStore.currentLocale,
      async (newLocale) => {
        if (newLocale) {
          console.log("Language changed to:", newLocale);
          await setLanguage(newLocale);
        }
      }
    );
    app.use(i18n);
    app.use(router);
    app.mount("#app");
  }
  initializeApp();
  const notice = `
┏┓┳┓┏┓┏┳┓┳┳┳┓┏┓
┃┃┃┃┣  ┃ ┃┃┃┃┣
┗┛┛┗┗┛ ┻ ┻┛ ┗┗┛

`;
  console.debug(notice);
  const web$n = {
    COMMON: {
      broadcast: "",
      description: "احفظ المعلومات الحساسة بعيداً عن سجلات المحادثة ورسائل البريد الالكتروني. اصنع رابطاً سرياً قابل للمشاركة مرة واحدة فقط.",
      keywords: "سر، كلمة مرور، لمرة واحدة، مولد",
      button_create_secret: "اصنع رابطاً سرياً *",
      button_generate_secret: "او استخدم مولد كلمات المرور العشوائية",
      secret_privacy_options: "خيارات الخصوصية",
      secret_passphrase: "كلمة المرور",
      secret_passphrase_hint: "استخدم كلمة او جملة صعبة التخمين",
      secret_recipient_address: "بريد المُرسل إليه",
      secret_placeholder: "...ضع المحتوى السري هنا",
      header_create_account: "إنشاء حساب",
      header_about: "عنا",
      header_sign_in: "تسجيل الدخول",
      header_dashboard: "الحساب",
      header_logout: "تسجيل الخروج",
      secret: "السر",
      received: "تم العرض",
      burned: "احرق",
      expires_in: "ينتهي خلال",
      burn_this_secret: "احرق هذا السر",
      burn_this_secret_hint: "(حرق السر سيحذفه قبل ان تتم قراءته (اضغط للتأكيد",
      burn_this_secret_confirm_hint: "خيار حرق السر دائم ولن تتمكن من التراجع عنه",
      msg_check_email: "تفقد بريدك الالكتروني",
      click_to_continue: "← اضغط للمتابعة",
      click_to_verify: ":المتابعة لتأكيد الحساب",
      error_secret: "لم تضع محتوى لتشاركه",
      error_passphrase: "تأكد من كلمة المرور",
      enter_passphrase_here: "ادخل كلمة المرور هنا",
      view_secret: "اظهر السر",
      careful_only_see_once: "تنبيه: سنظهره مرة واحدة فقط",
      warning: "تحذير",
      oops: "!مهلاً",
      error: "خطأ",
      secret_was_truncated: "تم إقتطاع المحتوى",
      signup_for_more: "انشأ حساباً من اجل المزيد",
      login_to_your_account: "تسجيل الدخول الى حسابك",
      sent_to: " :تم الارسال الى",
      field_email: "البريد الالكتروني",
      field_password: "كلمة المرور",
      field_password2: "قم بتأكيد كلمة المرور",
      button_create_account: "انشأ حساباً",
      share_a_secret: "شارك سراً",
      title_home: "الرئيسية",
      title_recent_secrets: "اخر الاسرار",
      word_none: "لا يوجد",
      word_burned: "احرق",
      word_received: "تم العرض",
      word_confirm: "تأكيد",
      word_cancel: "الغاء",
      feedback_text: "هل لديك استفسار او تعليق؟",
      button_send_feedback: "ارسل",
      verification_sent_to: "تم ارسال التفعيل الى"
    },
    homepage: {
      tagline1: ".ضع كلمة مرور، رسالة سرية او رابطاً خاصاً أدناه",
      tagline2: "لا تستخدم معلوماتك الحساسة في محادثاتك او رسائل البريد",
      secret_hint: ".الرابط السري سيعمل لمرة واحدة فقط ومن ثم يختفي للأبد *",
      secret_form_more_text1: "قم بأنشاء ",
      secret_form_more_text2: "حساب مجاني",
      secret_form_more_text3: ".وتمكن من ارسال السر عبر البريد الالكتروني",
      cta_title: "استخدم نطاقًا مخصصًا",
      cta_subtitle: "ارفع مستوى علامتك التجارية وشارك بثقة",
      cta_feature1: "نطاقك المخصص الخاص",
      cta_feature2: "مشاركة أسرار غير محدودة",
      cta_feature3: "ضوابط خصوصية متقدمة",
      explore_premium_plans: "استكشف الخطط المميزة",
      need_free_account: "هل تبدأ للتو؟",
      sign_up_free: "أنشئ حسابًا مجانيًا"
    },
    "private": {
      pretext: ":شارك هذا الرابط",
      requires_passphrase: ".يتطلب كلمة مرور",
      this_msg_is_encrypted: "هذا المحتوى قد تم تشفيره بكلمة مرورك",
      only_see_once: "ستتمكن من رؤيته لمرة واحدة فقط"
    },
    shared: {
      requires_passphrase: ":هذا المحتوى يتطلب كلمة مرور",
      viewed_own_secret: ".لقد شاهدت سرك، لن يتمكن شخص اخر من مشاهدته",
      you_created_this_secret: ".انت انشأت هذا السر، ان شاهدته، فلن يتمكن المُستلم من مشاهدته",
      your_secret_message: ":رسالتك السرية",
      this_message_for_you: ":هذه الرسالة لك",
      reply_with_secret: "اعد الرد بسر جديد"
    },
    dashboard: {
      title_received: "تم العرض",
      title_not_received: "لم يتم العرض",
      title_no_recent_secrets: "لا اسرار جديدة"
    },
    login: {
      need_an_account: "ترغب بحساب جديد؟",
      forgot_your_password: "هل نسيت كلمة مرورك؟",
      button_sign_in: "تسجيل الدخول",
      enter_your_credentials: "ادخل بياناتك"
    },
    incoming: {
      tagline1: ".ضع كلمة مرور، رسالة سرية او رابطاً خاصاً أدناه",
      tagline2: ".لا تستخدم معلوماتك الحساسة في محادثاتك او رسائل البريد",
      secret_hint: ".الرابط السري سيعمل لمرة واحدة فقط ومن ثم يختفي للأبد *",
      incoming_button_create: "راسل فريق الدعم",
      incoming_secret_options: "معلومات المساعدة",
      incoming_secret_placeholder: "(ادخل اي بيانات قد يحتاجها ممثل الدعم (كلمة مرورك مثلاً",
      incoming_ticket_number: "ادخل رقم التذكرة #",
      incoming_ticket_number_hint: "(ستجد هذا في بريدك الالكتروني (12345 مثلاً",
      incoming_recipient_address: "بريد المرسل",
      incoming_success_message: "تم ارسال الرسالة"
    }
  };
  const email$n = {
    incomingsupport: {
      subject: "[:تذكرة %s]",
      body1: "العميل ارسل هذه البيانات"
    },
    secretlink: {
      subject: "%s ارسل لك سراً",
      body1: "لديك سر مُرسل من قِبل",
      body_tagline: ":ان لم تكن تعرف المُرسل او تعتقد انه سبام، راسلنا بالتفاصيل هنا"
    },
    welcome: {
      subject: "قم بتفعيل حسابك بالموقع",
      body1: "!مرحباً بك في موقع ' سر لمرة واحدة' لدينا سر من اجلك",
      please_verify: ":لطفاً قم بتفعيل حسابك",
      postscript1: "هذا البريد قد تم ارساله الى",
      postscript2: ".ان لم تقم انت بإنشاء هذا الحساب، احذف هذه الرسالة ولن نراسلك مرة اخرى"
    }
  };
  const ar = {
    web: web$n,
    email: email$n
  };
  const ar$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: ar,
    email: email$n,
    web: web$n
  }, Symbol.toStringTag, { value: "Module" }));
  const web$m = {
    COMMON: {
      broadcast: "",
      description: "Дръжте чувствителна информация далеч от вашите чатове и и-мейли. Споделяйте тайна връзка, която е достъпна само веднъж.",
      keywords: "тайна,генератор на пароли,сподели тайна,onetime",
      button_create_secret: "Създай тайна връзка",
      button_generate_secret: "Или генерирай случайна парола.",
      secret_privacy_options: "Опции за поверителност",
      secret_passphrase: "Тайна фраза",
      secret_passphrase_hint: "Дума или фраза, която е трудна за познаване.",
      secret_recipient_address: "Адрес на получател",
      secret_placeholder: "Тайното съдържание отива тук...",
      header_create_account: "Създай акаунт",
      header_about: "Относно",
      header_sign_in: "Вход",
      header_dashboard: "Акаунт",
      header_logout: "Изход",
      secret: "Тайна",
      received: "Получен",
      burned: "Изгорен",
      expires_in: "Изтича след",
      burn_this_secret: "Изгори тази тайна",
      burn_this_secret_hint: "Изгарянето на тайна, ще я изтрие преди да бъде прочетена (кликни за потвърждение)",
      burn_this_secret_confirm_hint: "Изгарянето на тайна е необратим процес ",
      msg_check_email: "Проверете си и-мейла",
      click_to_continue: "Кликни, за да продължиш →",
      click_to_verify: "Продължи, за да си потвърдиш акаунта:",
      error_secret: "Не предоставихте нищо за споделяне",
      error_passphrase: "Проверете тайната фраза още веднъж",
      enter_passphrase_here: "Въведете тайната фраза тук",
      view_secret: "Преглед на тайната",
      careful_only_see_once: "внимавайте: ще ти я покажем само веднъж.",
      warning: "Внимание",
      oops: "Опа!",
      error: "Грешка",
      secret_was_truncated: "Съобщението беше отрязано, защото свърши",
      signup_for_more: "Регистрирайте се за още",
      login_to_your_account: "Влез в акаунта си",
      sent_to: "Изпрати до: ",
      field_email: "И-мейл",
      field_password: "Парола",
      field_password2: "Потвърди паролата",
      button_create_account: "Създай акаунт",
      share_a_secret: "Сподели тайна",
      title_home: "Начало",
      title_recent_secrets: "Скорошни тайни",
      word_none: "Няма",
      word_burned: "изгорени",
      word_received: "получени",
      word_confirm: "Потвърди",
      word_cancel: "Откажи",
      feedback_text: "Имаш въпрос или коментар?",
      button_send_feedback: "Обратна връзка",
      verification_sent_to: "Информация за потвърждаване беше изпратена до"
    },
    homepage: {
      tagline1: "Поставете парола, тайно съобщение или лична връзка долу.",
      tagline2: "Дръжте чувствителна информация далеч от чатове и и-мейли.",
      secret_hint: "* Тайната връзка работи само един път и после изчезва завинаги.",
      secret_form_more_text1: "Регистрирайте се за",
      secret_form_more_text2: "безплатен акаунт",
      secret_form_more_text3: "да поставите фрази за по-добра защита, както и допълнителни опции за поверителност. Дори, ще ви изпратим връзката по и-мейл, ако искате.",
      cta_title: "Използвайте персонализиран домейн",
      cta_subtitle: "Издигнете вашата марка и споделяйте с увереност",
      cta_feature1: "Вашият собствен персонализиран домейн",
      cta_feature2: "Неограничено споделяне на тайни",
      cta_feature3: "Разширени контроли за поверителност",
      explore_premium_plans: "Разгледайте премиум плановете",
      need_free_account: "Тъкмо започвате?",
      sign_up_free: "Създайте безплатен акаунт"
    },
    "private": {
      pretext: "Сподели тази връзка:",
      requires_passphrase: "Изисква фраза.",
      this_msg_is_encrypted: "Това съобщение е криптирано с вашата фраза.",
      only_see_once: "ще го видите само един път"
    },
    shared: {
      requires_passphrase: "Това съобщение изисква фраза:",
      viewed_own_secret: "Прегледахте собствената си тайна. Тя вече е недостъпна за всички.",
      you_created_this_secret: "Вие създадохте тази тайна. Ако я прегледате, тогава получателят няма да има възможност да я види.",
      your_secret_message: "Вашето тайно съобщение:",
      this_message_for_you: "Това съобщение е за теб:",
      reply_with_secret: "Отговори с друга тайна"
    },
    dashboard: {
      title_received: "Полчено",
      title_not_received: "Неполучено",
      title_no_recent_secrets: "Няма скорошни тайни"
    },
    login: {
      need_an_account: "Имате нужда от акаунт?",
      forgot_your_password: "Забравена парола?",
      button_sign_in: "Вход",
      enter_your_credentials: "Въведете си информацията"
    },
    incoming: {
      tagline1: "Поставете парола, тайно съобщение или лична връзка долу.",
      tagline2: "Дръжте чувствителна информация далеч от чатове и и-мейли.",
      secret_hint: "* Тайната връзка работи само един път и после изчезва завинаги.",
      incoming_button_create: "Изпрати до екипа",
      incoming_secret_options: "Помощна информация",
      incoming_secret_placeholder: "Въведете всякаква информация, която ще е от полза на помощният представител (например: системна парола)",
      incoming_ticket_number: "Билет #",
      incoming_ticket_number_hint: "Може да намерите това от и-мейл си (например: 123456)",
      incoming_recipient_address: "Получател",
      incoming_success_message: "Вашият и-мейл беше изпратен"
    }
  };
  const email$m = {
    incomingsupport: {
      subject: "[Билет: %s]",
      body1: "Клиент изпрати следната информация"
    },
    secretlink: {
      subject: "%s Ви изпрати тайна",
      body1: "Имаме тайна за теб от",
      body_tagline: "Ако не познавате изпращача или мислите, че е спам, изпратети ни детайлите тук:"
    },
    welcome: {
      subject: "Потвърдете си тайният акаунт",
      body1: "Добре дошли в Onetime Secret. Имаме тайна за теб!",
      please_verify: "Моля, потвърдете си акаунта:",
      postscript1: "Този и-мейл беше изпратен до"
    }
  };
  const postscript2$2 = "Ако не сте създали този акаунт, изтрийте съобщението и ние няма да Ви безпокоим повече.";
  const bg = {
    web: web$m,
    email: email$m,
    postscript2: postscript2$2
  };
  const bg$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: bg,
    email: email$m,
    postscript2: postscript2$2,
    web: web$m
  }, Symbol.toStringTag, { value: "Module" }));
  const web$l = {
    COMMON: {
      broadcast: "",
      description: "Mantenir protegida la informació confidencial dels meus registres de xat i de correu electrònic. Comparteix un enllaç secret que està disponible sols una vegada.",
      keywords: "secret,generador de contrasenyes,comparteix un secret,una sola vegada",
      button_generate_secret: "O crea una contrasenya aleatòria",
      secret_privacy_options: "Paràmetres de privadesa",
      secret_passphrase_hint: "Un mot o frase que és de mal endevinar",
      secret_recipient_address: "Adreça del destinatari",
      secret_placeholder: "El secret contingut va aquí...",
      header_create_account: "Crea un compte",
      header_about: "Quant a",
      header_sign_in: "Entra a la teva sessió",
      header_dashboard: "Compte",
      header_logout: "Abandona",
      secret: "Secret",
      received: "Rebut",
      burned: "Cremat",
      expires_in: "Caducitat",
      burn_this_secret: "Crema aquest secret",
      burn_this_secret_hint: "Cremar un secret l'eliminarà abans que s'hagi llegit (feu clic per a nfirmar)",
      bun_this_secret_confirm_hint: "La crema d'un secret és permanent i no es pot desfer",
      msg_check_email: "Verifica el correu electrònic",
      click_to_continue: "Clica per a continuar →",
      click_to_verify: "Continua per a verificar el compte:",
      error_secret: "No has fornit res a compartir",
      error_passphrase: "Verifica doblement la frase de contrasenya",
      enter_passphrase_here: "Introdueix la frase aquí",
      view_secret: "Veges el secret",
      careful_only_see_once: "Compte: sols ho mostrarem una vegada",
      warning: "Compte!",
      oops: "Ui!",
      error: "Error",
      secret_was_truncated: "S'ha truncat el missatge car era acabat",
      signup_for_more: "Inscriure-t'hi per a més",
      login_to_your_account: "Entra al teu compte",
      sent_to: "S'ha enviat a:",
      field_email: "Envia",
      field_password: "Contrasenya",
      field_password2: "Confirma la contrasenya",
      button_create_account: "Crea un compte",
      share_a_secret: "Comparteix un secret",
      title_home: "Pàgina inicial",
      title_recent_secrets: "Secrets recents",
      word_none: "Cap mot",
      word_burned: "cremat",
      word_received: "rebut",
      word_confirm: "Confirma",
      word_cancel: "Anul·la",
      feedback_text: "Tens cap demanda o comentari?",
      button_send_feedback: "Envia un comentari",
      verification_sent_to: "S'ha enviat una verificació a"
    },
    homepage: {
      tagline1: "Enganxa una contrasenya, un missatge secret o un enllaç privat a sota.",
      tagline2: "Mantenir protegida la informació sensible del correu electrònic i dels registres de xat",
      secret_hint: "* Un enllaç secret que solament funciona una vegada i després desapareix per sempre.",
      secret_form_more_text1: "Inscriu-t'hi per a obtenir un",
      secret_form_more_text2: "compte gratuït",
      secret_form_more_text3: "afegeix frases de contrasenya per a una més gran seguretat com també amb les opcions de privadesa addicionals Fins i tot t'enviem un correu electrònic cap a l'enllaç, si ho desitges.",
      cta_title: "Utilitzeu un domini personalitzat",
      cta_subtitle: "Eleveu la vostra marca i compartiu amb confiança",
      cta_feature1: "El vostre propi domini personalitzat",
      cta_feature2: "Compartició il·limitada de secrets",
      cta_feature3: "Controls de privadesa avançats",
      explore_premium_plans: "Exploreu els plans premium",
      need_free_account: "Només començant?",
      sign_up_free: "Creeu un compte gratuït"
    },
    "private": {
      pretext: "Comparteix aquest vincle:",
      requires_passphrase: "Requereix una frase de contrasenya.",
      this_msg_is_encrypted: "Aquest missatge està encriptat amb el teu mot de pas.",
      only_see_once: "només ho veuràs aquesta vegada"
    },
    shared: {
      requires_passphrase: "Aquest missatge requereix una frase de contrasenya:",
      viewed_own_secret: "Has vist el teu propi secret. Si l'has vist, el destinatari no el podrà veure pas.",
      you_created_this_secret: "Has creat aquest secret. Si l'has vist, el destinatari no el podrà veure pas.",
      your_secret_message: "El teu missatge secret:",
      this_message_for_you: "Aquest missatge és per a tu:",
      reply_with_secret: "Respon-hi amb un altre secret"
    },
    dashboard: {
      title_received: "Rebut",
      title_not_received: "no s'ha rebut",
      title_no_recent_secrets: "No hi ha secrets recents"
    },
    login: {
      need_an_account: "Et cal un compte?",
      forgot_your_password: "Has oblidat la contrasenya?",
      button_sign_in: "Entra-hi",
      enter_your_credentials: "Introdueix les teves credencials"
    },
    incoming: {
      tagline1: "Enganxa una contrasenya, un missatge secret o un enllaç privat a sota.",
      tagline2: "Mantingues fora la informació sensible del teu correu electrònic i sessions de xat.",
      secret_hint: "* Un enllaç secret que només funciona una vegada i després desapareix per sempre.",
      incoming_button_create: "Envia a la colla del centre d'assistència tècnica",
      incoming_secret_options: "Informació de l'assistència tècnica",
      incoming_secret_placeholder: "Introdueix la informació que haurà de menester el teu representant del servei de l'assistència tècnica (per exemple la teva contrasenya)",
      incoming_ticket_number: "Introdueix el Tiquet#",
      incoming_ticket_number_hint: "Pots trobar això en el teu correu electrònic (per ex., 123456)",
      incoming_recipient_address: "Destinatari del servei tècnic",
      incoming_success_message: "El teu correu electrònic ha estat enviat"
    }
  };
  const email$l = {
    incomingsupport: {
      subject: "[Ticket:% s]",
      body1: "Un client ha enviat la següent informació"
    },
    secretlink: {
      subject: "% s us ha enviat un secret",
      body1: "Tenim un secret per a tu de la part de",
      body_tagline: "Si no coneixes l'expedidor o creus que és correu porqueria, envia'ns-en els detalls aquí:"
    },
    welcome: {
      subject: "Verifiqueu el vostre compte secret d'un sol ús",
      body1: "Benvingut al compte secret d'un sol ús. Tenim un secret per a vós!",
      please_verify: "Verifiqueu el vostre compte:",
      postscript1: "Aquest correu electrònic s'ha enviat a",
      postscript2: "Si no heu creat aquest compte, esborra aquest missatge i ja no us escriurem pas més."
    }
  };
  const ca_ES = {
    web: web$l,
    email: email$l
  };
  const ca_ES$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: ca_ES,
    email: email$l,
    web: web$l
  }, Symbol.toStringTag, { value: "Module" }));
  const web$k = {
    COMMON: {
      broadcast: "",
      description: "使您的消息记录和电子邮箱地址保持隐匿。分享仅可查看一次的密文链接。",
      keywords: "秘密,密码生成器,密文分享,一次性",
      button_create_secret: "创建一条密文",
      button_generate_secret: "生成随机密码",
      secret_privacy_options: "隐私设置",
      secret_passphrase: "密码",
      secret_passphrase_hint: "使用不易被猜测到的密码",
      secret_recipient_address: "接收者地址",
      secret_placeholder: "在此处撰写密文...",
      header_create_account: "创建账户",
      header_about: "关于",
      header_sign_in: "登录",
      header_dashboard: "账户",
      header_logout: "退出帐号",
      secret: "密文",
      received: "已收到",
      burned: "已销毁",
      expires_in: "有效期",
      burn_this_secret: "销毁密文",
      burn_this_secret_hint: "此时销毁密文将在密文未被查看前直接删除（点击确认）",
      burn_this_secret_confirm_hint: "销毁密文将是永久的、不可撤销的操作",
      msg_check_email: "检查您的电子邮箱",
      click_to_continue: "点击继续 →",
      click_to_verify: "继续进行账户认证:",
      error_secret: "您还未提交任何需要加密的内容",
      error_passphrase: "再次确认密码",
      enter_passphrase_here: "在此处填写密码",
      view_secret: "查看密文",
      careful_only_see_once: "请注意：密文仅可查看一次",
      warning: "警告",
      oops: "哦!",
      error: "出错了",
      secret_was_truncated: "您撰写的内容过长，已被删节",
      signup_for_more: "登录以使用更多功能",
      login_to_your_account: "登录您的帐户",
      sent_to: "发送至: ",
      field_email: "电子邮箱",
      field_password: "密码",
      field_password2: "确认密码",
      button_create_account: "创建账户",
      share_a_secret: "分享密文",
      title_home: "主页",
      title_recent_secrets: "近期密文",
      word_none: "无",
      word_burned: "已销毁",
      word_received: "已收到",
      word_confirm: "确认",
      word_cancel: "取消",
      feedback_text: "有疑问或建议？",
      button_send_feedback: "发送反馈",
      verification_sent_to: "验证消息已送至"
    },
    homepage: {
      tagline1: "在下方窗格输入您想要加密的内容。",
      tagline2: "使您的秘密独立于您的电子邮件和聊天记录。",
      secret_hint: "* 密文被加密后将只能被查看一次，之后将永久消失",
      secret_form_more_text1: "注册一个",
      secret_form_more_text2: "免费账户",
      secret_form_more_text3: "并通过邮件发送加密信息",
      cta_title: "使用自定义域名",
      cta_subtitle: "提升您的品牌形象，自信分享：",
      cta_feature1: "您自己的自定义域名",
      cta_feature2: "无限制的秘密分享",
      cta_feature3: "高级隐私控制",
      explore_premium_plans: "探索高级计划",
      need_free_account: "刚刚开始？",
      sign_up_free: "创建免费账户"
    },
    "private": {
      pretext: "分享该链接:",
      requires_passphrase: "需要密码。",
      this_msg_is_encrypted: "消息内容已用密码加密",
      only_see_once: "您只能阅读一次密文内容"
    },
    shared: {
      requires_passphrase: "这条信息需要一个密码：",
      viewed_own_secret: "您已经查看过您的密文。它将永远不会被其他人知晓。",
      you_created_this_secret: "您已创建此密文。一旦您阅读它，它将无法被他人查看。",
      your_secret_message: "您的密文：",
      this_message_for_you: "这是您的消息：",
      reply_with_secret: "用另一条密文回复"
    },
    dashboard: {
      title_received: "已收到",
      title_not_received: "未收到",
      title_no_recent_secrets: "无最近密文"
    },
    login: {
      need_an_account: "需要一个帐户？",
      forgot_your_password: "忘记密码？",
      button_sign_in: "注册",
      enter_your_credentials: "输入验证码"
    },
    incoming: {
      tagline1: "在下方窗格输入您想要加密的内容。",
      tagline2: "使您的秘密独立于您的电子邮件和聊天记录。",
      secret_hint: "* 密文被加密后将只能被查看一次，之后将永久消失",
      incoming_button_create: "发送给技术人员",
      incoming_secret_options: "支持信息",
      incoming_secret_placeholder: "输入必要的、有代表性的支持信息（例：系统密码）",
      incoming_ticket_number: "输入工单编号 #",
      incoming_ticket_number_hint: "您将在您的电子邮件中找到它（例：123456）",
      incoming_recipient_address: "接受地址",
      incoming_success_message: "邮件已发出"
    }
  };
  const email$k = {
    incomingsupport: {
      subject: "[工单号: %s]",
      body1: "一位我们的客户发送了以下信息："
    },
    secretlink: {
      subject: "%s 给您发送了一条密文",
      body1: "我们有一条给您的密文，来自",
      body_tagline: "如果您不认识发送者，或者认为这可能是垃圾信息，在这里告诉我们详细信息："
    },
    welcome: {
      subject: "验证您的 Onetime Secret 帐户",
      body1: "欢迎使用 Onetime Secret ，这里有一条我们发送给您的密文！",
      please_verify: "请验证您的帐户:",
      postscript1: "这封电子邮件被送至",
      postscript2: "如果您并未创建此帐户，请您删除此邮件。我们将不会再和您联系。"
    }
  };
  const cn = {
    web: web$k,
    email: email$k
  };
  const cn$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: cn,
    email: email$k,
    web: web$k
  }, Symbol.toStringTag, { value: "Module" }));
  const web$j = {
    COMMON: {
      broadcast: "",
      description: "Uchovejte citlivé informace mimo své záznamy chatů a emaily. Sdílejte tajný odkaz, který je k dispozici jen jedinkrát.",
      keywords: "tajemství,generátor hesla,sdílet tajemství,jednorázový",
      button_create_secret: "Vytvořit tajný odkaz",
      button_generate_secret: "Nebo vygenerovat náhodné heslo",
      secret_privacy_options: "Možnosti soukromí",
      secret_passphrase: "Heslová fráze",
      secret_passphrase_hint: "Slovo nebo fráze, které je těžké uhodnout",
      secret_recipient_address: "Adresa příjemce",
      secret_placeholder: "Sem patří tajný obsah...",
      header_create_account: "Vytvořit účet",
      header_about: "O aplikaci",
      header_sign_in: "Přihlásit se",
      header_dashboard: "Účet",
      header_logout: "Odhlásit se",
      secret: "Tajemství",
      received: "Přijato",
      burned: "Spáleno",
      expires_in: "Expiruje za",
      burn_this_secret: "Spálit toto tajemství",
      burn_this_secret_hint: "Spálení tajemství jej smaže předtím, než je přečteno (klepněte pro potvrzení)",
      burn_this_secret_confirm_hint: "Spálení tajemství je trvalé a nelze jej vrátit zpět",
      msg_check_email: "Zkontrolujte svůj email",
      click_to_continue: "Klepněte pro pokračování →",
      click_to_verify: "Pokračujte k ověření svého účtu:",
      error_secret: "Nezadali jste nic ke sdílení",
      error_passphrase: "Znovu zkontrolujte tuto heslovou frázi",
      enter_passphrase_here: "Sem vložte heslovou frázi",
      view_secret: "Zobrazit tajemství",
      careful_only_see_once: "opatrně: bude zobrazeno pouze jednou.",
      warning: "Varování",
      oops: "Jejda!",
      error: "Chyba",
      secret_was_truncated: "Zpráva byla zkrácena protože překročila",
      signup_for_more: "Zaregistrujte se pro více",
      login_to_your_account: "Přihlaste se ke svému účtu",
      sent_to: "Poslat komu: ",
      field_email: "Email",
      field_password: "Heslo",
      field_password2: "Potvrdit heslo",
      button_create_account: "Vytvořit účet",
      share_a_secret: "Sdílet tajemství",
      title_home: "Domů",
      title_recent_secrets: "Nedávná tajemství",
      word_none: "Žádný",
      word_burned: "spáleno",
      word_received: "přijato",
      word_confirm: "Potvrdit",
      word_cancel: "Storno",
      feedback_text: "Máte otázku nebo komentář?",
      button_send_feedback: "Poslat odezvu",
      verification_sent_to: "Potvrzení bylo odesláno"
    },
    homepage: {
      tagline1: "Níže vložte heslo, tajnou zprávu nebo soukromý odkaz.",
      tagline2: "Udržujte citlivé informace mimo svůj email a záznamy chatů.",
      secret_hint: "* Tajný odkaz bude fungovat pouze jednou a pak zmizí navždy.",
      secret_form_more_text1: "Zaregistrujte se pro",
      secret_form_more_text2: "účet zdarma",
      secret_form_more_text3: "pro nastavení heslových frází pro větší bezpečnost spolu s více možnostmi soukromí. Můžeme za vás odeslat odkaz emailem, když budete chtít.",
      cta_title: "Použijte vlastní doménu",
      cta_subtitle: "Pozvedněte svou značku a sdílejte s jistotou",
      cta_feature1: "Vaše vlastní přizpůsobená doména",
      cta_feature2: "Neomezené sdílení tajemství",
      cta_feature3: "Pokročilé ovládací prvky soukromí",
      explore_premium_plans: "Prozkoumat prémiové plány",
      need_free_account: "Teprve začínáte?",
      sign_up_free: "Vytvořit bezplatný účet"
    },
    "private": {
      pretext: "Sdílejte tento odkaz:",
      requires_passphrase: "Vyžaduje heslovou frázi.",
      this_msg_is_encrypted: "Tato zpráva je zašifrována vaší heslovou frází.",
      only_see_once: "uvidíte to pouze jednou"
    },
    shared: {
      requires_passphrase: "Tato zpráva vyžaduje heslovou frázi:",
      viewed_own_secret: "Zobrazili jste si své vlastní tajemství. Už není k dispozici pro kohokoli dalšího.",
      you_created_this_secret: "Toto tajemství jste vytvořili vy. Pokud jej zobrazíte, příjemce nebude mít možnost jej zobrazit.",
      your_secret_message: "Vaše tajná zpráva:",
      this_message_for_you: "Tato zpráva je pro vás:",
      reply_with_secret: "Odpovědět jiným tajemstvím"
    },
    dashboard: {
      title_received: "Přijato",
      title_not_received: "Nepřijato",
      title_no_recent_secrets: "Žádná nedávná tajemství"
    },
    login: {
      need_an_account: "Potřebujete účet?",
      forgot_your_password: "Zapomněli jste své heslo?",
      button_sign_in: "Přihlásit se",
      enter_your_credentials: "Vložte své přihlašovací údaje"
    },
    incoming: {
      tagline1: "Níže vložte heslo, tajnou zprávu nebo soukromý odkaz.",
      tagline2: "Udržujte citlivé informace mimo svůj email a záznamy chatů.",
      secret_hint: "* Tajný odkaz bude fungovat pouze jednou a pak zmizí navždy.",
      incoming_button_create: "Odeslat na oddělení podpory",
      incoming_secret_options: "Informace podpory",
      incoming_secret_placeholder: "Zadejte informace, které bude potřebovat pracovník podpory (např. systémové heslo)",
      incoming_ticket_number: "Zadejte číslo ticketu",
      incoming_ticket_number_hint: "Můžete jej nalézt ve svém emailu (např. 123456)",
      incoming_recipient_address: "Adresa podpory",
      incoming_success_message: "Váš email byl odeslán"
    }
  };
  const email$j = {
    incomingsupport: {
      subject: "[Ticket: %s]",
      body1: "Zákazník odeslal následující informace"
    },
    secretlink: {
      subject: "%s vám poslal tajemství",
      body1: "Máme pro vás tajemství od",
      body_tagline: "Pokud neznáte odesílatele nebo myslíte, že jde o spam, pošlete nám detaily zde:"
    },
    welcome: {
      subject: "Ověřte svůj účet pro jednorázové tajemství",
      body1: "Vítejte ve Onetime Secret. Máme pro vás tajemství!",
      please_verify: "Prosím ověřte svůj účet:",
      postscript1: "Tento email byl odeslán",
      postscript2: "Pokud jste nevytvořili tento účet, smažte tuto zprávu a my vás už nebudeme znovu kontaktovat."
    }
  };
  const cs = {
    web: web$j,
    email: email$j
  };
  const cs$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: cs,
    email: email$j,
    web: web$j
  }, Symbol.toStringTag, { value: "Module" }));
  const web$i = {
    COMMON: {
      broadcast: "",
      description: "Hold følsomme informationer udenfor din chat-log og e-mail. Del et hemmeligt link der kun kan tilgås én gang.",
      keywords: "hemmelighed,adgangskode generator,del en hemmelighed,engangsbrug",
      button_create_secret: "Opret et hemmeligt link",
      button_generate_secret: "Eller opret en vilkårlig adgangskode ",
      secret_privacy_options: "Privatlivs-indstillinger",
      secret_passphrase: "Kodeord",
      secret_passphrase_hint: "Et ord eller sætning der er svær at gætte",
      secret_recipient_address: "Modtagers adresse",
      secret_placeholder: "Hemmeligt indhold indsættes her...",
      header_create_account: "Opret konto",
      header_about: "Om",
      header_sign_in: "Log ind",
      header_dashboard: "Konto",
      header_logout: "Log ud",
      secret: "Hemmelighed",
      received: "Modtaget",
      burned: "Destrueret",
      expires_in: "Udløber om",
      burn_this_secret: "Destruér denne hemmelighed",
      burn_this_secret_hint: "Destruéring af en hemmelighed vil slette den før den er blevet læst (klik for at bekræfte)",
      burn_this_secret_confirm_hint: "Destruktion af en hemmelighed er permanent og kan ikke fortrydes",
      msg_check_email: "Tjek din e-mail",
      click_to_continue: "Klik for at fortsætte →",
      click_to_verify: "Fortsæt for at bekræfte din konto:",
      error_secret: "Du har ikke angivet noget til deling",
      error_passphrase: "Dobbelttjek den adgangskode",
      enter_passphrase_here: "Indtast adgangskoden her",
      view_secret: "Se hemmelighed",
      careful_only_see_once: "forsigtig: vi viser den kun én gang.",
      warning: "Advarsel",
      oops: "Ubs!",
      error: "Fejl",
      secret_was_truncated: "Beskeden blev afkortet fordi den var slut",
      signup_for_more: "Tilmeld dig for flere muligheder",
      login_to_your_account: "Log ind på din konto",
      sent_to: "Sendt til: ",
      field_email: "E-mail",
      field_password: "Adgangskode",
      field_password2: "Bekræft adgangskode",
      button_create_account: "Opret konto",
      share_a_secret: "Del en hemmelighed",
      title_home: "Hjem",
      title_recent_secrets: "Nylige hemmeligheder",
      word_none: "Ingen",
      word_burned: "destrueret",
      word_received: "modtaget",
      word_confirm: "Bekræft",
      word_cancel: "Annuller",
      feedback_text: "Spørgsmål eller kommentarer?",
      button_send_feedback: "Send tilbagemelding",
      verification_sent_to: "En bekræftelse blev sendt til"
    },
    homepage: {
      tagline1: "Indsæt en adgangskode, hemmelig besked eller privat link herunder.",
      tagline2: "Hold følsomme informationer udenfor dine e-mails og chat-logs.",
      secret_hint: "* Et hemmeligt link virker kun én gang og forsvinder derefter for altid.",
      secret_form_more_text1: "Tilmeld dig med en",
      secret_form_more_text2: "gratis konto",
      secret_form_more_text3: "og få mulighed for at sende hemmeligheder via e-mails.",
      cta_title: "Brug et tilpasset domæne",
      cta_subtitle: "Løft dit brand og del med selvtillid",
      cta_feature1: "Dit eget tilpassede domæne",
      cta_feature2: "Ubegrænset hemmelig deling",
      cta_feature3: "Avancerede privatlivsindstillinger",
      explore_premium_plans: "Udforsk Premium-planer",
      need_free_account: "Er du lige begyndt?",
      sign_up_free: "Opret en gratis konto"
    },
    "private": {
      pretext: "Del dette link:",
      requires_passphrase: "Kræver en adgangskode.",
      this_msg_is_encrypted: "Denne besked er krypteret med din adgangskode.",
      only_see_once: "du ser kun dette én gang"
    },
    shared: {
      requires_passphrase: "Denne besked kræver en adgangskode:",
      viewed_own_secret: "Du har set din egen hemmelighed. Den er ikke længere tilgængelig for andre.",
      you_created_this_secret: "Du har indtastet denne hemmelighed. Hvis du ser den, vil modtageren ikke kunne se den efterfølgende.",
      your_secret_message: "Din hemmelige besked:",
      this_message_for_you: "Denne besked er til dig:",
      reply_with_secret: "Svar med en anden hemmelighed"
    },
    dashboard: {
      title_received: "Modtaget",
      title_not_received: "Ikke modtaget",
      title_no_recent_secrets: "Ingen nylige hemmeligheder"
    },
    login: {
      need_an_account: "Brug for en konto?",
      forgot_your_password: "Glemt din adgangskode?",
      button_sign_in: "Log ind",
      enter_your_credentials: "Indtast dine oplysninger"
    },
    incoming: {
      tagline1: "Indsæt en adgangskode, hemmelig besked eller et privat link herunder.",
      tagline2: "Hold følsomme informationer udenfor dine e-mails og chat-logs.",
      secret_hint: "* Et hemmeligt link virker kun én gang og forsvinder derefter for altid.",
      incoming_button_create: "Send til supporten",
      incoming_secret_options: "Support information",
      incoming_secret_placeholder: "Indtast information som supporten kan få brug for (såsom adgangskoder til systemer)",
      incoming_ticket_number: "Tilgå supportsag #",
      incoming_ticket_number_hint: "Du kan finde dette i din e-mail indbakke (e.g. 123456)",
      incoming_recipient_address: "Support modtager",
      incoming_success_message: "Din e-mail er sendt"
    }
  };
  const email$i = {
    incomingsupport: {
      subject: "[Supportsag: %s]",
      body1: "En kunde har sendt følgende information"
    },
    secretlink: {
      subject: "%s har sendt dig en hemmelighed",
      body1: "Vi har en hemmelighed til dig fra",
      body_tagline: "Hvis du ikke kender afsenderen, eller mener det er spam, så send os detaljerne her:"
    },
    welcome: {
      subject: "Bekræft din Onetime Secret konto",
      body1: "Velkommen til Onetime Secret. Vi har en hemmelighed til dig!",
      please_verify: "Bekræft venligst din konto:",
      postscript1: "Denne e-mail blev sendt til",
      postscript2: "Hvis du ikke har oprettet denne konto, så slet denne besked - og vi vil ikke kontakte dig igen."
    }
  };
  const da_DK = {
    web: web$i,
    email: email$i
  };
  const da_DK$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: da_DK,
    email: email$i,
    web: web$i
  }, Symbol.toStringTag, { value: "Module" }));
  const web$h = {
    COMMON: {
      broadcast: "",
      description: "Halte sensible Informationen aus deinen Chat-Logs und E-Mails heraus. Teile einen Link, der nur einmal verfügbar ist.",
      keywords: "geheim,Passwort-Generator,Teile ein Geheimnis,einmalig",
      button_create_secret: "Erstelle einen geheimen Link",
      button_generate_secret: "Oder lass ein zufälliges Passwort generieren",
      secret_privacy_options: "Privatsphäre-Einstellungen",
      secret_passphrase: "Passphrase",
      secret_passphrase_hint: "Ein Wort oder eine Phrase, die schwierig zu erraten ist",
      secret_recipient_address: "Empfänger-Adresse",
      secret_placeholder: "Der geheime Inhalt kommt hier hin...",
      header_create_account: "Account erstellen",
      header_about: "Über",
      header_sign_in: "Einloggen",
      header_dashboard: "Account",
      header_logout: "Abmelden",
      secret: "Geheim",
      received: "Erhalten",
      burned: "Zerstört",
      expires_in: "Läuft ab in",
      burn_this_secret: "Zerstöre dieses Geheimnis",
      burn_this_secret_hint: "Die Zerstörung eines Geheimnisses wird es löschen bevor es gelesen wurde (Klicken zum Bestätigen)",
      burn_this_secret_confirm_hint: "Die Zerstörung eines Geheimnisses ist permanent und kann nicht rückgängig gemacht werden",
      msg_check_email: "Überprüfe dein E-Mail-Postfach",
      click_to_continue: "Klicken um fortzufahren →",
      click_to_verify: "Klicke, um deinen Account zu verifizieren:",
      error_secret: "Du hast nichts zum Teilen geliefert",
      error_passphrase: "Prüfe diese Passphrase nochmals",
      enter_passphrase_here: "Gib die Passphrase hier ein",
      view_secret: "Geheimnis anzeigen",
      careful_only_see_once: "Vorsicht: Wir werden es nur einmal zeigen.",
      warning: "Warnung",
      oops: "Ups!",
      error: "Fehler",
      secret_was_truncated: "Die Nachricht wurde gekürzt, weil sie zu lang war.",
      signup_for_more: "Registrieren für mehr",
      login_to_your_account: "In deinen Account einloggen",
      sent_to: "Senden an: ",
      field_email: "E-Mail",
      field_password: "Passwort",
      field_password2: "Passwort bestätigen",
      button_create_account: "Account erstellen",
      share_a_secret: "Teile ein Geheimnis",
      title_home: "Startseite",
      title_recent_secrets: "Letzte Geheimnisse",
      word_none: "Nichts",
      word_burned: "zerstört",
      word_received: "erhalten",
      word_confirm: "Bestätigen",
      word_cancel: "Abbrechen",
      feedback_text: "Hast du eine Frage oder einem Kommentar?",
      button_send_feedback: "Feedback senden",
      verification_sent_to: "Eine Bestätigung wurde gesendet an"
    },
    homepage: {
      tagline1: "Füge ein Passwort, eine geheime Nachricht oder einen privaten Link unten ein.",
      tagline2: "Halte sensible Informationen aus deinen Chat-Logs und E-Mails heraus.",
      secret_hint: "* Ein geheimer Link funktioniert nur einmal und verschwindet danach für immer.",
      secret_form_more_text1: "Registriere dich für einen ",
      secret_form_more_text2: "kostenlosen Account",
      secret_form_more_text3: "um Passphrasen für Extra-Sicherheit zu setzen und zusätzliche Privatsphäre-Optionen nutzen zu können. Wir senden dir den Link sogar per E-Mail, wenn du möchtest.",
      cta_title: "Verwenden Sie eine benutzerdefinierte Domain",
      cta_subtitle: "Stärken Sie Ihre Marke und teilen Sie mit Vertrauen",
      cta_feature1: "Ihre eigene benutzerdefinierte Domain",
      cta_feature2: "Unbegrenztes Teilen von Geheimnissen",
      cta_feature3: "Erweiterte Datenschutzkontrollen",
      explore_premium_plans: "Premium-Pläne erkunden",
      need_free_account: "Gerade erst angefangen?",
      sign_up_free: "Kostenloses Konto erstellen"
    },
    "private": {
      pretext: "Teile diesen Link:",
      requires_passphrase: "Benötigt eine Passphrase.",
      this_msg_is_encrypted: "Diese Nachricht ist mit deiner Passphrase verschlüsselt.",
      only_see_once: "du wirst dies nur einmal sehen"
    },
    shared: {
      requires_passphrase: "Diese Nachricht benötigt eine Passphrase:",
      viewed_own_secret: "Du hast dein eigenes Geheimnis angeschaut. Es ist jetzt nicht mehr verfügbar für jemanden anderen.",
      you_created_this_secret: "Du hast dieses Geheimnis erstellt. Wenn du es anschaust wird der Empfänger nicht in der Lage sein es anzuschauen.",
      your_secret_message: "Deine geheime Nachricht:",
      this_message_for_you: "Diese Nachricht ist für dich:",
      reply_with_secret: "Mit einem Geheimnis antworten"
    },
    dashboard: {
      title_received: "Erhalten",
      title_not_received: "Nicht erhalten",
      title_no_recent_secrets: "Keine kürzlich erstellen Geheimnisse"
    },
    login: {
      need_an_account: "Benötigst du einen Account?",
      forgot_your_password: "Passwort vergessen?",
      button_sign_in: "Einloggen",
      enter_your_credentials: "Gib deine Anmeldedaten ein"
    },
    incoming: {
      tagline1: "Füge ein Passwort, eine geheime Nachricht oder einen privaten Link unten ein.",
      tagline2: "Halte sensible Informationen aus deinen Chat-Logs und E-Mails heraus.",
      secret_hint: "* Ein geheimer Link funktioniert nur einmal und verschwindet danach für immer.",
      incoming_button_create: "An Support-Mitarbeiter senden",
      incoming_secret_options: "Support-Info",
      incoming_secret_placeholder: "Gib alle Informationen ein, die ein Support-Mitarbeiter benötigen wird. (z.B. das System-Passwort) Schreibe dein Anliegen wenn möglich in Englisch.",
      incoming_ticket_number: "Eingabe der Ticket #",
      incoming_ticket_number_hint: "Du kannst dies in deiner E-Mail finden (z.B. 123456)",
      incoming_recipient_address: "Support-Empfänger",
      incoming_success_message: "Deine E-Mail wurde gesendet"
    }
  };
  const email$h = {
    incomingsupport: {
      subject: "[Ticket: %s]",
      body1: "A customer has sent the following info (German user)"
    },
    secretlink: {
      subject: "%s hat dir ein Geheimnis gesendet",
      body1: "Wir haben ein Geheimnis für dich von",
      body_tagline: "Wenn du den Sender nicht kennst oder denkst, dass dies Spam ist, sende uns die Details hier:"
    },
    welcome: {
      subject: "Bestätige deinen Onetime-Secret-Account",
      body1: "Willkommen zu Onetime-Secret. Wir haben ein Geheimnis für dich!",
      please_verify: "Bitte bestätige deinen Account:",
      postscript1: "Diese E-Mail wurde gesendet an:",
      postscript2: "Wenn du diesen Account nicht erstellt hast, entferne diese Nachricht und wir werden dich nicht noch einmal kontaktieren."
    }
  };
  const de = {
    web: web$h,
    email: email$h
  };
  const de$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: de,
    email: email$h,
    web: web$h
  }, Symbol.toStringTag, { value: "Module" }));
  const web$g = {
    COMMON: {
      broadcast: "",
      description: "Κρατήστε ευαίσθητες πληροφορίες μακριά από την αλληλογραφία και τις καταγεγγραμένες συζητήσεις σας. Μοιραστείτε μυστικούς συνδέσμους που διατίθενται μόνο μία φορά.",
      keywords: "μυστικό,γεννήτρια κωδικού πρόσβασης,διαμοιρασμός μυστικού,onetime",
      button_create_secret: "Δημιουργήστε ένα μυστικό σύνδεσμο",
      button_generate_secret: "Ή παράγετε ένα τυχαίο κωδικό πρόσβασης",
      secret_privacy_options: "Επιλογές Ιδιωτικότητας",
      secret_passphrase: "Φράση Πρόσβασης",
      secret_passphrase_hint: "Μία λέξη η φράση που είναι δύσκολο να μαντευτεί",
      secret_recipient_address: "Διεύθυνση Παραλήπτη",
      secret_placeholder: "Γράψτε το μυστικό περιεχόμενο εδώ...",
      header_create_account: "Δημιουργία Λογαριασμού",
      header_about: "Σχετικά",
      header_sign_in: "Σύνδεση",
      header_dashboard: "Λογαριασμός",
      header_logout: "Αποσύνδεση",
      secret: "Μυστικό",
      received: "Ελήφθη",
      burned: "Κάηκε",
      expires_in: "Λήγει σε",
      burn_this_secret: "Κάψτε αυτό το μυστικό",
      burn_this_secret_hint: "Εάν κάψετε ένα μυστικό, διαγράφεται πριν διαβαστεί (πατήστε για επιβεβαίωση)",
      burn_this_secret_confirm_hint: "Το κάψιμο ενός μυστικού είναι μόνιμο και δε μπορεί να αναιρεθεί",
      msg_check_email: "Ελέγξτε την αλληλογραφία σας",
      click_to_continue: "Επιλέξτε για συνέχεια →",
      click_to_verify: "Συνεχίστε για να επαληθεύσετε το λογαριασμό σας:",
      error_secret: "Δεν ορίσατε κάτι προς διαμοιρασμό",
      error_passphrase: "Ξανά ελέγξτε Double check τη φράση πρόσβασης",
      enter_passphrase_here: "Enter the passphrase here",
      view_secret: "Προβολή Μυστικού",
      careful_only_see_once: "προσοχή: θα το φανερώσουμε μόνο μια φορά.",
      warning: "Προειδοποίηση",
      oops: "Ωχ!",
      error: "Σφάλμα",
      secret_was_truncated: "Το μήνυμα κόπηκε επειδή ολοκληρώθηκε",
      signup_for_more: "Εγγραφείτε για περισσότερα",
      login_to_your_account: "Συνδεθείτε στο λογαριασμό σας",
      sent_to: "Εστάλει στο χρήστη: ",
      field_email: "Αλληλογραφία",
      field_password: "Κωδικός Πρόσβασης",
      field_password2: "Επιβεβαίωση Κωδικού Πρόσβασης",
      button_create_account: "Δημιουργήστε Λογαριασμού",
      share_a_secret: "Μοιραστείτε ένα μυστικό",
      title_home: "Αρχική",
      title_recent_secrets: "Πρόσφατα Μυστικά",
      word_none: "Άδειο",
      word_burned: "καμμένο",
      word_received: "ελήφθη",
      word_confirm: "Επιβεβαίωση",
      word_cancel: "Ακύρωση",
      feedback_text: "Έχετε κάποια απορία ή θέλετε να σχολιάσετε;",
      button_send_feedback: "Αποστολή",
      verification_sent_to: "Εστάλει επιβεβαίωση στο χρήστη"
    },
    homepage: {
      tagline1: "Επικολλήστε ένα κωδικό πρόσβασης, μυστικό μήνυμα ή ιδιωτικό σύνδεσμο παρακάτω.",
      tagline2: "Κρατήστε ευαίσθητες πληροφορίες μακριά από την αλληλογραφία και τις καταγεγγραμένες συζητήσεις σας.",
      secret_hint: "* Ο μυστικό σύνδεσμος λειτουργεί μόνο μία φορά και μετά εξαφανίζεται για πάντα.",
      secret_form_more_text1: "Εγγραφείτε και δημιουργήστε",
      secret_form_more_text2: "δωρεάν λογαριασμό",
      secret_form_more_text3: "and be able to send the secret by email.",
      cta_title: "Χρησιμοποιήστε ένα προσαρμοσμένο domain",
      cta_subtitle: "Αναβαθμίστε το brand σας και μοιραστείτε με αυτοπεποίθηση",
      cta_feature1: "Το δικό σας προσαρμοσμένο domain",
      cta_feature2: "Απεριόριστη κοινοποίηση μυστικών",
      cta_feature3: "Προηγμένοι έλεγχοι απορρήτου",
      explore_premium_plans: "Εξερευνήστε τα Premium πλάνα",
      need_free_account: "Μόλις ξεκινάτε;",
      sign_up_free: "Δημιουργήστε ένα δωρεάν λογαριασμό"
    },
    "private": {
      pretext: "Διαμοιράστε το σύνδεσμο:",
      requires_passphrase: "Απαιτεί φράση πρόσβασης.",
      this_msg_is_encrypted: "Αυτό το μήνυμα είναι κρυπτογραφημένο με τη φράση πρόσβασής σας.",
      only_see_once: "Αυτό θα το δείτε μόνο μία φορά"
    },
    shared: {
      requires_passphrase: "Αυτό το μήνυμα απαιτεί φράση πρόσβασης:",
      viewed_own_secret: "Ανοίξατε το δικό σας μυστικό. Δεν είναι πλέον διαθέσιμο σε κανέναν.",
      you_created_this_secret: "Είστε ο δημιουργός αυτού του μυστικού. Εάν το ανοίξετε, ο παραλήπτης δε θα μπορέσει να το δει.",
      your_secret_message: "Το μυστικό σας μήνυμα:",
      this_message_for_you: "Αυτό το μήνυμα είναι για εσάς:",
      reply_with_secret: "Απαντήστε επίσης με μυστικό"
    },
    dashboard: {
      title_received: "Ληφθέντα",
      title_not_received: "Μη Ληφθέντα",
      title_no_recent_secrets: "Δεν υπάρχουν πρόσφατα μυστικά"
    },
    login: {
      need_an_account: "Χρειάζεστε λογαριασμό;",
      forgot_your_password: "Ξεχάσατε το συνθηματικό σας;",
      button_sign_in: "Σύνδεση",
      enter_your_credentials: "Εισάγετε όνομα και κωδικό χρήστη"
    },
    incoming: {
      tagline1: "Επικολλήστε ένα κωδικό πρόσβασης, μυστικό μήνυμα ή ιδιωτικό σύνδεσμο παρακάτω.",
      tagline2: "Κρατήστε ευαίσθητες πληροφορίες μακριά από την αλληλογραφία και τις καταγεγγραμένες συζητήσεις.",
      secret_hint: "* Ο μυστικό σύνδεσμος λειτουργεί μόνο μία φορά και μετά εξαφανίζεται για πάντα.",
      incoming_button_create: "Αποστολή στο Προσωπικό Υποστήριξης",
      incoming_secret_options: "Πληροφορίες Υποστήριξης",
      incoming_secret_placeholder: "Καταγράψτε οποιεσδήποτε πληροφορίες μπορεί να χρειαστεί ο αντιπρόσωπος υποστήριξης (π.χ. κωδικός πρόσβασης συστήματος)",
      incoming_ticket_number: "Εισάγετε Αριθμό Υποστήριξης #",
      incoming_ticket_number_hint: "Μπορείτε να το βρείτε στην αλληλογραφία σας (π.χ. 123456)",
      incoming_recipient_address: "Παραλήπτης Υποστήριξης",
      incoming_success_message: "Η αλληλογραφία σας εστάλει"
    }
  };
  const email$g = {
    incomingsupport: {
      subject: "[Αίτημα Υποστήριξης: %s]",
      body1: "Ένας πελάτης έστειλε τις παρακάτω πληροφορίες"
    },
    secretlink: {
      subject: "%s Ο χρήστης %s σας έστειλε ένα μυστικό",
      body1: "Έχουμε ένα μυστικό για εσάς από το χρήστη",
      body_tagline: "Εάν δε γνωρίζετε τον αποστολέα ή πιστεύεται πως είναι ανεπιθύμητη αλληλογραφία, αποστείλετε μας τις λεπτομέρειες εδώ:"
    },
    welcome: {
      subject: "Εξακρίβωση του Onetime Secret λογαριασμού σας",
      body1: "Καλωσήρθατε στο Onetime Secret. Έχουμε ένα μυστικό για εσάς!",
      please_verify: "Παρακαλούμε εξακριβώστε το λογαριασμό σας:",
      postscript1: "Αυτή η αλληλογραφία στάλθηκε στο",
      postscript2: "Εάν δε δημιουργήσατε αυτόν το λογαριασμό, διαγράψτε αυτό το μήνυμα και δεν θα επικοινωνήσουμε ξανά μαζί σας."
    }
  };
  const el_GR = {
    web: web$g,
    email: email$g
  };
  const el_GR$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: el_GR,
    email: email$g,
    web: web$g
  }, Symbol.toStringTag, { value: "Module" }));
  const web$f = {
    COMMON: {
      broadcast: "",
      description: "Mantén la información confidencial fuera de tus chats y correos electrónicos. Comparte enlaces secretos que estarán disponibles sólo una vez.",
      keywords: "secreto,generador de contraseñas,comparte un secreto,solo una vez",
      button_create_secret: "Crear un enlace secreto",
      button_generate_secret: "O generar una contraseña al azar",
      secret_privacy_options: "Opciones de privacidad",
      secret_passphrase: "Contraseña",
      secret_passphrase_hint: "Una palabra o frase que es difícil de adivinar",
      secret_recipient_address: "Dirección Del Receptor",
      secret_placeholder: "El contenido secreto va aquí...",
      header_create_account: "Crear cuenta",
      header_about: "Acerca",
      header_sign_in: "Ingresar",
      header_dashboard: "Cuenta",
      header_logout: "Salir",
      secret: "Secreto",
      received: "Recibido",
      burned: "Destruido",
      expires_in: "Expira en",
      burn_this_secret: "Destruir este secreto",
      burn_this_secret_hint: "Destruir un secreto lo borrará antes de que haya sido leído (clic para confirmar)",
      burn_this_secret_confirm_hint: "La destrucción de un secreto es permanente y no se puede deshacer",
      msg_check_email: "Consulte su correo electrónico",
      click_to_continue: "Clic para continuar →",
      click_to_verify: "Continúe para verificar su cuenta:",
      error_secret: "Usted no proporcionó nada para compartir",
      error_passphrase: "Vuelva a comprobar la frase de contraseña",
      enter_passphrase_here: "Escriba la frase de contraseña",
      view_secret: "Ver secreto",
      careful_only_see_once: "cuidado: Solo la mostraremos una vez.",
      warning: "Atención",
      oops: "Error!",
      error: "Error",
      secret_was_truncated: "El mensaje se truncó porque tenía más de",
      signup_for_more: "Regístrese para recibir más",
      login_to_your_account: "Accede a tu cuenta",
      sent_to: "Enviar a: ",
      field_email: "Email",
      field_password: "Contraseña",
      field_password2: "Confirmar Contraseñ",
      button_create_account: "Crear Cuenta",
      share_a_secret: "Compartir un secreto",
      title_home: "Inicio",
      title_recent_secrets: "Secretos Recientes",
      word_none: "Ninguno",
      word_burned: "destruido",
      word_received: "recibido",
      word_confirm: "Confirmar",
      word_cancel: "Annuler",
      feedback_text: "¿Tiene alguna pregunta o comentario?",
      button_send_feedback: "Envíanos tus comentarios!",
      verification_sent_to: "Una verificación fue enviada a",
      button_create_incoming: "Send to Support Staff"
    },
    homepage: {
      tagline1: "Pegue una contraseña, mensaje secreto o enlace privado a continuación.",
      tagline2: "Mantener la información confidencial fuera de tus chats y correos electrónicos",
      secret_hint: "* El enlace secreto sólo funciona una vez y luego desaparece para siempre.",
      secret_form_more_text1: "Regístrese para obtener",
      secret_form_more_text2: "una cuenta gratuita",
      secret_form_more_text3: "y poder fijar frases de contraseña para mayor seguridad junto con opciones de privacidad adicionales. Incluso enviaremos el enlace por correo electrónico si usted lo desea.",
      cta_subtitle: "Eleva tu marca y comparte con confianza",
      cta_feature1: "Tu propio dominio personalizado",
      cta_feature2: "Compartición ilimitada de secretos",
      cta_feature3: "Controles de privacidad avanzados",
      explore_premium_plans: "Explora los planes Premium",
      need_free_account: "¿Recién empiezas?",
      sign_up_free: "Crea una cuenta gratuita"
    },
    "private": {
      pretext: "Comparte este enlace:",
      requires_passphrase: "Requiere una contraseña.",
      this_msg_is_encrypted: "Este mensaje está cifrado con su contraseña.",
      only_see_once: "Sólo verá esto esta vez"
    },
    shared: {
      requires_passphrase: "Este mensaje requiere una contraseña:",
      viewed_own_secret: "Ya ha visto su propio secreto. Ya no estará disponible para nadie más.",
      you_created_this_secret: "Usted ha creado este secreto. Si lo ve, el destinatario no podrá verlo.",
      your_secret_message: "Su mensaje secreto:",
      this_message_for_you: "Este mensaje es para usted:",
      reply_with_secret: "Responder con otro secreto"
    },
    dashboard: {
      title_received: "Recibido",
      title_not_received: "No recibido",
      title_no_recent_secrets: "No hay secretos recientes"
    },
    login: {
      need_an_account: "¿Necesita una cuenta?",
      forgot_your_password: "¿Olvidó su contraseña?",
      button_sign_in: "Ingresar",
      enter_your_credentials: "Entre sus credenciales"
    },
    incoming: {
      tagline1: "Paste a password, secret message or private link below.",
      tagline2: "Keep sensitive info out of your email and chat logs.",
      secret_hint: "* A secret link only works once and then disappears forever.",
      incoming_button_create: "Send to Support Staff",
      incoming_secret_options: "Support Info",
      incoming_secret_placeholder: "Enter any information your support representitive will need (e.g. system password)",
      incoming_ticket_number: "Enter Ticket #",
      incoming_ticket_number_hint: "You can find this in your email (e.g. 123456)",
      incoming_recipient_address: "Support recipient",
      incoming_success_message: "Your email has been sent"
    }
  };
  const email$f = {
    incomingsupport: {
      subject: "[Ticket: %s]",
      body1: "A customer has sent the following info"
    },
    secretlink: {
      subject: "%s le ha enviado un secreto",
      body1: "Tenemos un secreto para usted desde",
      body_tagline: "Si no conoce al remitente o cree que este sea un correo no deseado, envíenos los detalles aquí:"
    },
    welcome: {
      subject: "Verifique su cuenta de Onetime Secret",
      body1: "¡Bienvenido a Onetime Secret! ¡Tenemos un secreto para usted!",
      please_verify: "Por favor verifique su cuenta:",
      postscript1: "Este email se le envio a",
      postscript2: "Si usted no ha creado esta cuenta, borre este mensaje y no lo contactaremos de nuevo."
    }
  };
  const es = {
    web: web$f,
    email: email$f
  };
  const es$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: es,
    email: email$f,
    web: web$f
  }, Symbol.toStringTag, { value: "Module" }));
  const web$e = {
    COMMON: {
      broadcast: "",
      description: "Ne stockez aucune information confidentielle dans vos emails ou fils de discussion. Partagez un lien secret, disponible qu'une seule fois.",
      keywords: "secret, générateur de mot de passe, usage unique",
      button_create_secret: "Créer un lien secret",
      button_generate_secret: "Ou générer un mot de passe aléatoire",
      secret_privacy_options: "Paramètres de confidentialité",
      secret_passphrase: "Mot de passe",
      secret_passphrase_hint: "Un mot ou une phrase qui est difficile à deviner",
      secret_recipient_address: "Adresse du destinataire",
      secret_placeholder: "Collez votre contenu secret",
      header_create_account: "Créer un compte",
      header_about: "A propos",
      header_sign_in: "Se connecter",
      header_dashboard: "Compte",
      header_logout: "Déconnexion",
      secret: "Secret",
      received: "Reçu",
      burned: "Supprimé",
      expires_in: "Expire dans",
      burn_this_secret: "Supprimer ce secret",
      burn_this_secret_hint: "Supprimer ce secret le fera disparaître avant qu'il soit lu (cliquez pour confirmer)",
      burn_this_secret_confirm_hint: "La suppression du secret est définitive et ne peut pas être annulée",
      msg_check_email: "Vérifiez votre courriel",
      click_to_continue: "Cliquez pour continuer →",
      click_to_verify: "Continuez pour vérifier votre compte:",
      error_secret: "Il n'y a rien à partager",
      error_passphrase: "Confirmer ce mot de passe",
      enter_passphrase_here: "Saisissez le mot de passe ici",
      view_secret: "Consulter le secret",
      careful_only_see_once: "attention : ne sera affiché qu'une seule fois",
      warning: "Attention",
      oops: "Oups !",
      error: "Bug ",
      secret_was_truncated: "Le message a été tronqué parce qu’il était trop grand",
      signup_for_more: "Créer un compte pour en savoir plus",
      login_to_your_account: "Se connecter à votre compte",
      sent_to: "Envoyé à",
      field_email: "Courriel",
      field_password: "Mot de passe",
      field_password2: "Confirmer le mot de passe",
      button_create_account: "Créer un compte",
      share_a_secret: "Partager un secret",
      title_home: "Accueil",
      title_recent_secrets: "Secrets récents",
      word_none: "Aucun",
      word_burned: "supprimé",
      word_received: "reçu",
      word_confirm: "Confirmer",
      word_cancel: "Annuler",
      feedback_text: "Une question ou un commentaire ?",
      button_send_feedback: "Envoyer une réaction",
      verification_sent_to: "Une vérification a été envoyée à -"
    },
    homepage: {
      tagline1: "Collez votre mot de passe, message secret ou lien privé ci-dessous",
      tagline2: "Ne stockez aucune information confidentielle dans vos emails ou fils de discussion.",
      secret_hint: "* Un lien secret ne fonctionne qu'une fois puis disparaît à jamais. *",
      secret_form_more_text1: "Créez un",
      secret_form_more_text2: "compte gratuit",
      secret_form_more_text3: "pour utiliser des mots de passe à sécurité accrue et acccéder à des options supplémentaires de confidentialité. Nous vous enverrons même le lien par email si vous le soouhaitez.",
      cta_title: "Utilisez un domaine personnalisé",
      cta_subtitle: "Valorisez votre marque et partagez en toute confiance ",
      cta_feature1: "Votre propre domaine personnalisé",
      cta_feature2: "Partage illimité de secrets",
      cta_feature3: "Contrôles de confidentialité avancés",
      explore_premium_plans: "Découvrir les forfaits Premium",
      need_free_account: "Vous débutez ?",
      sign_up_free: "Créer un compte gratuit"
    },
    "private": {
      pretext: "Partager ce lien :",
      requires_passphrase: "Demande un mot de de passe.",
      this_msg_is_encrypted: "Ce message est chiffré avec votre mot de passe.",
      only_see_once: "ne sera lisible qu'une seule fois."
    },
    shared: {
      requires_passphrase: "Lire ce message exige un mot de passe :",
      viewed_own_secret: "Vous avez vu votre propre secret. Il n'est plus disponible pour quelqu'un d'autre.",
      you_created_this_secret: "Vous avez créé ce secret. Si vous le voyez, le destinateur ne pourra plus le voir.",
      your_secret_message: "Votre message secret :",
      this_message_for_you: "Ce message est pour vous :",
      reply_with_secret: "Répondre avec un autre secret"
    },
    dashboard: {
      title_received: "Délivré",
      title_not_received: "Non délivré",
      title_no_recent_secrets: "Pas de secrets récents"
    },
    login: {
      need_an_account: "Besoin d'un compte ?",
      forgot_your_password: "Mot de passe oublié ?",
      button_sign_in: "Se connecter",
      enter_your_credentials: "Saisissez vos identifiants"
    },
    incoming: {
      tagline1: "Collez un mot de passe, message secret ou lien privé ci-dessous",
      tagline2: "Ne stockez aucune information confidentielle dans vos emails ou fils de discussion.",
      secret_hint: "* Un lien secret ne fonctionne qu'une fois puis disparaît à jamais.",
      incoming_button_create: "Envoyer au support",
      incoming_secret_options: "Informations pour le support",
      incoming_secret_placeholder: "Entrez les informations dont nous aurions besoin pour le support (par exemple, mot de passe du système)",
      incoming_ticket_number: "Entrez le numéro de ticket",
      incoming_ticket_number_hint: "Vous pouvez le trouver dans votre courriel (par exemple, 123456)",
      incoming_recipient_address: "Destinataire du support",
      incoming_success_message: " Votre email a été envoyé"
    }
  };
  const email$e = {
    incomingsupport: {
      subject: "[Ticket: %s]",
      body1: "Quelqu'un vous a envoyé les informations suivantes"
    },
    secretlink: {
      subject: "%s vous a envoyé un secret",
      body1: "Un secret vous a été envoyé par",
      body_tagline: "Si vous ne connaissez pas l'expéditeur ou croyez qu'il s'agit de spam, merci de nous contacter en fournissant les détails à : "
    },
    welcome: {
      subject: "Vérifiez votre compte sur OnetimeSecret.com",
      body1: "Bienvenue sur OnetimeSecret.com. On a un secret pour vous !",
      please_verify: "Vérifier votre compte, s'il vous plaît:",
      postscript1: "Ce email a été envoyé à",
      postscript2: "Si vous n’avez pas créé ce compte, supprimez ce message et nous ne vous contacterons plus."
    }
  };
  const fr = {
    web: web$e,
    email: email$e
  };
  const fr$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: fr,
    email: email$e,
    web: web$e
  }, Symbol.toStringTag, { value: "Module" }));
  const web$d = {
    COMMON: {
      broadcast: "",
      description: "Ne stockez pas de données sensibles dans les journaux de vos logiciels de chat ou de messagerie. Partagez un lien secret, qui n'est utilisable qu'une seule fois",
      keywords: "secret, générateur de mot de passe, une fois",
      button_create_secret: "Créer un lien secret",
      button_generate_secret: "Ou générer un mot de passe au hasard",
      secret_privacy_options: "Paramètres de confidentialité",
      secret_passphrase: "Phrase indice",
      secret_passphrase_hint: "Un mot ou une phrase difficile à deviner",
      secret_recipient_address: "Adresse du destinataire",
      secret_placeholder: "Votre contenu secret…",
      header_create_account: "Créer un compte",
      header_about: "À propos",
      header_sign_in: "Se connecter",
      header_dashboard: "Compte",
      header_logout: "Déconnection",
      secret: "Secret",
      received: "Reçu",
      burned: "Brûlé",
      expires_in: "Expire dans",
      burn_this_secret: "Brûler ce secret",
      burn_this_secret_hint: "Brûler un secret le supprimera pour toujours avant qu'il ne soit lu (cliquer pour confirmer)",
      burn_this_secret_confirm_hint: "Brûler un secret est définitif et ne peut pas être annulé",
      msg_check_email: "Vérifier votre e-mail",
      click_to_continue: "Cliquer pour continuer →",
      click_to_verify: "Continuez pour finaliser la vérification de votre compte :",
      error_secret: "Il n'y a rien à partager",
      error_passphrase: "Revérifier cet indice",
      enter_passphrase_here: "Entrez l'indice ici",
      view_secret: "Voir le Secret",
      careful_only_see_once: "attention : on ne le vous montrera qu'une seule fois",
      warning: "Attention",
      oops: "Oups !",
      error: "Erreur",
      secret_was_truncated: "Le message a été tronqué car il est trop grand",
      signup_for_more: "Créer un compte pour en savoir plus",
      login_to_your_account: "Se connecter à votre compte",
      sent_to: "Envoyé à",
      field_email: "Adresse e-mail",
      field_password: "Mot de passe",
      field_password2: "Confirmer le mot de passe",
      button_create_account: "Créer un compte",
      share_a_secret: "Partager un secret",
      title_home: "Accueil",
      title_recent_secrets: "Secrets récents",
      word_none: "Aucun",
      word_burned: "brûlé",
      word_received: "reçu",
      word_confirm: "Confirmer",
      word_cancel: "Annuler",
      feedback_text: "Vous avez une question ou un commentaire ?",
      button_send_feedback: "Envoyer le commentaire",
      verification_sent_to: "Une vérification a été envoyée à"
    },
    homepage: {
      tagline1: "Coller un mot de passe, message secret ou un lien privé ci-dessous",
      tagline2: "Ne stockez pas de données sensibles dans les journaux de vos logiciels de chat ou de messagerie.",
      secret_hint: "* Un lien secret ne fonctionne qu'une fois puis disparaît à jamais.",
      secret_form_more_text1: "Créez un",
      secret_form_more_text2: "compte gratuit",
      secret_form_more_text3: "pour envoyer votre secret par e-mail",
      cta_title: "Utilisez un domaine personnalisé",
      cta_subtitle: "Valorisez votre marque et partagez en toute confiance ",
      cta_feature1: "Votre propre domaine personnalisé",
      cta_feature2: "Partage illimité de secrets",
      cta_feature3: "Contrôles de confidentialité avancés",
      explore_premium_plans: "Découvrir les forfaits Premium",
      need_free_account: "Vous débutez ?",
      sign_up_free: "Créer un compte gratuit"
    },
    "private": {
      pretext: "Partager ce lien :",
      requires_passphrase: "Nécessite un indice.",
      this_msg_is_encrypted: "Ce message est chiffré avec votre indice.",
      only_see_once: "vous ne le verrez qu'une seule fois."
    },
    shared: {
      requires_passphrase: "Ce message nécessite un indice :",
      viewed_own_secret: "Vous avez vu votre propre secret. Il n'est plus disponible pour personne.",
      you_created_this_secret: "Vous avez créé ce secret. Si vous le voyez, le destinateur ne pourra pas le voir.",
      your_secret_message: "Votre message secret :",
      this_message_for_you: "Ce message est pour vous :",
      reply_with_secret: "Répondre avec un autre secret"
    },
    dashboard: {
      title_received: "Reçu",
      title_not_received: "Non reçu",
      title_no_recent_secrets: "Pas de secrets récents"
    },
    login: {
      need_an_account: "Besoin d'un compte ? ",
      forgot_your_password: "J'ai oublié mon mot de passe.",
      button_sign_in: "Se connecter",
      enter_your_credentials: "Entrez vos identifiants"
    },
    incoming: {
      tagline1: "Coller un mot de passe, message secret ou un lien privé ci-dessous",
      tagline2: "Ne stockez pas de données sensibles dans les journaux de vos logiciels de chat ou de messagerie.",
      secret_hint: "* Un lien secret ne fonctionne qu'une fois puis disparaît à jamais.",
      incoming_button_create: "Envoyez au support",
      incoming_secret_options: "Informations sur le support",
      incoming_secret_placeholder: "Entrez les informations dont votre interlocuteur au support aura besoin (par exemple votre mot de passe du système)",
      incoming_ticket_number: "Entrez l'identifiant # du ticket",
      incoming_ticket_number_hint: "Vous pouvez le trouver dans votre mail (par exemple 123456)",
      incoming_recipient_address: "Destinataire du support",
      incoming_success_message: " Votre email a été envoyé"
    }
  };
  const email$d = {
    incomingsupport: {
      subject: "[Ticket: %s]",
      body1: "Un client a envoyé les informations suivantes"
    },
    secretlink: {
      subject: "%s a vous envoyé un secret",
      body1: "Nous avons un secret pour vous de la part de",
      body_tagline: "Si vous ne connaissez pas le destinateur ou croyez qu'il s'agit de spam, envoyez-nous les détails ici :"
    },
    welcome: {
      subject: "Vérifier votre compte Onetime-Secret",
      body1: "Bienvenue sur Onetime-Secret. Nous avons un secret pour vous !",
      please_verify: "Veuillez vérifier votre compte :",
      postscript1: "Cet e-mail a été envoyé à"
    }
  };
  const postscript2$1 = "Si vous n’avez pas créé ce compte, supprimez ce message et nous ne vous contacterons plus.";
  const fr_FR = {
    web: web$d,
    email: email$d,
    postscript2: postscript2$1
  };
  const fr_FR$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: fr_FR,
    email: email$d,
    postscript2: postscript2$1,
    web: web$d
  }, Symbol.toStringTag, { value: "Module" }));
  const web$c = {
    COMMON: {
      broadcast: "",
      description: "שמרו מידע רגיש מחוץ ללוגים של הצטים והמייל. שלחו קישור סודי הזמין לשימוש פעם אחת בלבד.",
      keywords: "סוד,מחולל סיסמאות,שתפו סוד,חד פעמי",
      button_create_secret: "יצרו קישור סודי",
      button_generate_secret: "או יצרו סיסמה רנדומלית",
      secret_privacy_options: "אפשרויות פרטיות",
      secret_passphrase: "סיסמת משפט",
      secret_passphrase_hint: "מילה או משפט שקשה לנחש",
      secret_recipient_address: "כתובת הנמען",
      secret_placeholder: "התוכן הסודי נכנס כאן...",
      header_create_account: "יצירת חשבון",
      header_about: "אודות",
      header_sign_in: "כניסה",
      header_dashboard: "חשבון",
      header_logout: "יציאה",
      secret: "סוד",
      received: "התקבל",
      burned: "בוער",
      expires_in: "פג בעוד",
      burn_this_secret: "ביעור סוד זה",
      burn_this_secret_hint: "ביעור סוד ימחק אותו לפני שנקרא (לחצו לאישור)",
      burn_this_secret_confirm_hint: "ביעור סוד הינו לצמיתות ואינו ניתן לביטול",
      msg_check_email: "בדקו את המייל",
      click_to_continue: "לחצו להמשך →",
      click_to_verify: "המשך לאישור החשבון:",
      error_secret: "לא סיפקתם משהו לשיתוף",
      error_passphrase: "בדקו שוב את סיסמת המשפט",
      enter_passphrase_here: "הכניסו כאן את סיסמת המשפט",
      view_secret: "צפיה בסוד",
      careful_only_see_once: "זהירות: נראה את זה פעם אחת בלבד.",
      warning: "אזהרה",
      oops: "אופס!",
      error: "שגיאה",
      secret_was_truncated: "ההודעה קוצרה כי היא נגמרה",
      signup_for_more: "הרשמו לעוד",
      login_to_your_account: "כניסה לחשבון",
      sent_to: "שליחה אל: ",
      field_email: "מייל",
      field_password: "סיסמה",
      field_password2: "אימות סיסמה",
      button_create_account: "יצירת חשבון",
      share_a_secret: "שיתוף סוד",
      title_home: "בית",
      title_recent_secrets: "סודות אחרונים",
      word_none: "ללא",
      word_burned: "בוער",
      word_received: "התקבל",
      word_confirm: "אישור",
      word_cancel: "ביטול",
      feedback_text: "יש לכם שאלה או הערה?",
      button_send_feedback: "שליחת משוב",
      verification_sent_to: "אימות נשלח אל"
    },
    homepage: {
      tagline1: "הדביקו סיסמה, סוד או קישור פרטי מטה.",
      tagline2: "שלחו קישור סודי הזמין לשימוש פעם אחת בלבד.",
      secret_hint: "* קישור סודי פועל פעם אחת ואז מושמד לעד",
      secret_form_more_text1: "רישום ל",
      secret_form_more_text2: "חשבון חינם",
      secret_form_more_text3: "ותוכלו לשלוח את הסוד במייל.",
      cta_title: "השתמש בדומיין מותאם אישית",
      cta_subtitle: "העצם את המותג שלך ושתף בביטחון",
      cta_feature1: "הדומיין המותאם אישית שלך",
      cta_feature2: "שיתוף סודות בלתי מוגבל",
      cta_feature3: "בקרות פרטיות מתקדמות",
      explore_premium_plans: "גלה תוכניות פרימיום",
      need_free_account: "רק מתחיל?",
      sign_up_free: "צור חשבון חינם"
    },
    "private": {
      pretext: "שתפו קישור זה:",
      requires_passphrase: "דורש סיסמת משפט.",
      this_msg_is_encrypted: "הודעה זו מוצפנת עם סיסמת המשפט שלכם.",
      only_see_once: "תראו את זה פעם אחת בלבד"
    },
    shared: {
      requires_passphrase: "הודעה זו דורשת סיסמת משפט:",
      viewed_own_secret: "צפיתם בסוד שלכם. הוא אינו זמין עוד לאף אחד אחר.",
      you_created_this_secret: "יצרתם את הסוד הזה. אם תצפו בו הנמען לא יוכל לראות אותו.",
      your_secret_message: "ההודעה הסודית שלכם:",
      this_message_for_you: "ההודעה הזו בשבילכם:",
      reply_with_secret: "השיבו עם סוד נוסף"
    },
    dashboard: {
      title_received: "התקבל",
      title_not_received: "לא התקבל",
      title_no_recent_secrets: "אין סודות אחרונים"
    },
    login: {
      need_an_account: "צריכים חשבון?",
      forgot_your_password: "שכחתם את הסיסמה?",
      button_sign_in: "כניסה",
      enter_your_credentials: "הכניסו את פרטי ההזדהות"
    },
    incoming: {
      tagline1: "הדביקו סיסמה, סוד או קישור פרטי מטה.",
      tagline2: "שלחו קישור סודי הזמין לשימוש פעם אחת בלבד.",
      secret_hint: "* קישור סודי פועל פעם אחת ואז מושמד לעד",
      incoming_button_create: "שליחה לצוות התמיכה",
      incoming_secret_options: "פרטי תמיכה",
      incoming_secret_placeholder: "הזינו פרטים שנציג התמיכה עשוי להזדקק לו (כגון סיסמה)",
      incoming_ticket_number: "הכניסו מספר קריאה",
      incoming_ticket_number_hint: "תוכלו למצוא אותו במייל (לדוגמה 123456)",
      incoming_recipient_address: "נמען תמיכה",
      incoming_success_message: "המייל נשלח"
    }
  };
  const email$c = {
    incomingsupport: {
      subject: "[קריאה: %s]",
      body1: "לקוח שלח את הפרטים הבאים"
    },
    secretlink: {
      subject: "%s שלח לך סוד",
      body1: "יש לנו סוד בשבילך מ",
      body_tagline: "אם אתם לא מכירים את השולח או מאמינים שזה ספאם, שלחו לנו את הפרטים כאן:"
    },
    welcome: {
      subject: "אמתו את החשבון סוד חד פעמי שלכם",
      body1: "ברוכים הבאים לסוד חד פעמי! יש לנו סוד בשבילכם!",
      please_verify: "נא אמתו את החשבון שלכם:",
      postscript1: "מייל זה נשלח ל",
      postscript2: "אם לא יצרתם את החשבון, מחקו את ההודעה ולא ניצור עמכם קשר שוב."
    }
  };
  const he$1 = {
    web: web$c,
    email: email$c
  };
  const he$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: he$1,
    email: email$c,
    web: web$c
  }, Symbol.toStringTag, { value: "Module" }));
  const web$b = {
    COMMON: {
      broadcast: "",
      description: "Tartd távol az érzékeny információkat a csevegési naplókból és az e-mailekből. Ossz meg egy titkos linket, amely csak egyszer érhető el.",
      keywords: "titok,jelszógenerátor,titok megosztása,egyszer használatos",
      button_create_secret: "Titkos link létrehozása",
      button_generate_secret: "Vagy generálj egy véletlenszerű jelszót",
      secret_privacy_options: "Adatvédelmi lehetőségek",
      secret_passphrase: "Jelszó",
      secret_passphrase_hint: "Egy szó vagy kifejezés, amelyet nehéz kitalálni.",
      secret_recipient_address: "Címzett címe",
      secret_placeholder: "A titkos tartalom ide kerül...",
      header_create_account: "Fiók létrehozása",
      header_about: "Rólunk",
      header_sign_in: "Belépés",
      header_dashboard: "Fiók",
      header_logout: "Kijelezntkezés",
      secret: "Titok",
      received: "Beérkezett",
      burned: "Elégett",
      expires_in: "Lejár",
      burn_this_secret: "Égesd el ezt a titkot",
      burn_this_secret_hint: "A titok elégetése törli a titkot, mielőtt azt elolvasnák (kattintson a megerősítéshez).",
      burn_this_secret_confirm_hint: "A titok elégetése végleges és nem lehet visszacsinálni.",
      msg_check_email: "Ellenőrizd az e-mailed",
      click_to_continue: "Kattints a folytatáshoz →",
      click_to_verify: "Folytasd fiókod ellenőrzését:",
      error_secret: "Nem adtál semmit, amit megoszthatnánk",
      error_passphrase: "Ellenőrizze kétszer a jelszót",
      enter_passphrase_here: "Adja meg a jelszót itt",
      view_secret: "Titok megtekintése",
      careful_only_see_once: "óvatosan: csak egyszer fogjuk megmutatni.",
      warning: "Figyelmeztetés",
      oops: "Hoppá!",
      error: "Hiba",
      secret_was_truncated: "Az üzenetet lerövidítettük, mert túl hosszú volt.",
      signup_for_more: "Feliratkozás további információkért",
      login_to_your_account: "Bejelentkezés",
      sent_to: "Elküldve a következő címre: ",
      field_email: "Email",
      field_password: "Jelszó",
      field_password2: "Jelszó megerősítése",
      button_create_account: "Fiók létrehozása",
      share_a_secret: "Ossz meg egy titkot",
      title_home: "Kezdőoldal",
      title_recent_secrets: "Legutóbbi titkok",
      word_none: "Nincs",
      word_burned: "elégetve",
      word_received: "kapott",
      word_confirm: "Megerősítés",
      word_cancel: "Mégsem",
      feedback_text: "Kérdésed vagy megjegyzésed van?",
      button_send_feedback: "Külj visszajelzést",
      verification_sent_to: "Ellenőrzést küldtünk a következő címre"
    },
    homepage: {
      tagline1: "Illessz be egy jelszót, titkos üzenetet vagy privát linket az alábbiakban.",
      tagline2: "Tartsd távol az érzékeny információkat az e-mail és a csevegési naplókból.",
      secret_hint: "* A titkos link csak egyszer működik, majd örökre eltűnik.",
      secret_form_more_text1: "Regisztrálj",
      secret_form_more_text2: "ingyenes fiókot",
      secret_form_more_text3: "és képes leszel elküldeni a titkot e-mailben.",
      cta_title: "Használjon egyedi domaint",
      cta_subtitle: "Emelje márkáját és osszon meg magabiztosan",
      cta_feature1: "Saját egyedi domain",
      cta_feature2: "Korlátlan titokkészítés",
      cta_feature3: "Fejlett adatvédelmi beállítások",
      explore_premium_plans: "Fedezze fel a Prémium csomagokat",
      need_free_account: "Csak most kezdi?",
      sign_up_free: "Ingyenes fiók létrehozása"
    },
    "private": {
      pretext: "Oszd meg ezt a linket:",
      requires_passphrase: "Jelszót igényel.",
      this_msg_is_encrypted: "Ez az üzenet a jelszavaddal van titkosítva.",
      only_see_once: "Ezt csak egyszer fogod látni."
    },
    shared: {
      requires_passphrase: "Ehhez az üzenethez szükséges egy jelszó:",
      viewed_own_secret: "Megtekintetted a titkot. Más számára már nem elérhető.",
      you_created_this_secret: "Ezt a titkot Te hoztad létre. Ha megtekinted, a címzett nem láthatja.",
      your_secret_message: "A titkos üzeneted",
      this_message_for_you: "Ez az üzenet neked szól:",
      reply_with_secret: "Válaszolj egy másik titokkal"
    },
    dashboard: {
      title_received: "Received",
      title_not_received: "Not Received",
      title_no_recent_secrets: "Nincs friss titok"
    },
    login: {
      need_an_account: "Szükséged van egy fiókra?",
      forgot_your_password: "Elfelejtetted a jelszavad?",
      button_sign_in: "Bejelentkezés",
      enter_your_credentials: "Add meg a bejelentkezési adatokat"
    },
    incoming: {
      tagline1: "Illeszd be a jelszót, titkos üzenetet vagy privát linket lentebb.",
      tagline2: "Tartsd távol érzékeny információidat az emailjeidtől és chat naplóktól.",
      secret_hint: "* Egy titkos link csak egyszer működik és aztán örökre eltűnik.",
      incoming_button_create: "Küldés a támogató személyzetnek",
      incoming_secret_options: "Támogatási információk",
      incoming_secret_placeholder: "Add meg az összes információt, amire a támogató képviselődnek szüksége lesz (pl. rendszerjelszó)",
      incoming_ticket_number: "Jegy szám megadása",
      incoming_ticket_number_hint: "Ezt megtalálod az emailjeidben (pl. 123456)",
      incoming_recipient_address: "Támogató címzett",
      incoming_success_message: "Az email elküldve."
    }
  };
  const email$b = {
    incomingsupport: {
      subject: "[Jegy: %s]",
      body1: "Egy ügyfél küldte a következő információkat"
    },
    secretlink: {
      subject: "%s titkot küldött neked",
      body1: "Van egy titkos üzenetünk neked",
      body_tagline: "Ha nem ismered az elküldőt, vagy spamnek gondolod, kérjük, küld el nekünk az részleteket itt:"
    },
    welcome: {
      subject: "Ellenőrizd a Onetime Secret fiókod",
      body1: "Üdvözöljük a Onetime Secretben. Van egy titkos üzenetünk neked!",
      please_verify: "Kérjük, erősítsd meg a fiókodat:",
      postscript1: "Ez az email elküldve ide:",
      postscript2: "Ha nem te hoztad létre ezt a fiókot, töröld ezt az üzenetet, és nem fogunk többé kapcsolatba lépni veled."
    }
  };
  const hu = {
    web: web$b,
    email: email$b
  };
  const hu$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: hu,
    email: email$b,
    web: web$b
  }, Symbol.toStringTag, { value: "Module" }));
  const web$a = {
    COMMON: {
      broadcast: "",
      description: "Mantieni le informazioni sensibili fuori dalle email e dai log delle chat. Condividi un link segreto che è disponibile una volta sola.",
      keywords: "segreto,generatore di password, condividere un segreto, una volta sola",
      button_create_secret: "Crea un link segreto",
      button_generate_secret: "O genera una password casuale",
      secret_privacy_options: "Opzioni Privacy",
      secret_passphrase: "Password",
      secret_passphrase_hint: " Una parola o una frase difficile da indovinare",
      secret_recipient_address: "Indirizzo destinatario",
      secret_placeholder: "Il contenuto segreto va qui...",
      header_create_account: "Crea Account",
      header_about: "Informazioni",
      header_sign_in: "Entra",
      header_dashboard: "Account",
      header_logout: "Esci",
      secret: "Segreto",
      received: "Ricevuto",
      burned: "Bruciato",
      expires_in: "Scade tra",
      burn_this_secret: "Brucia questo segreto",
      burn_this_secret_hint: "Bruciando un segreto questo verrà eliminato prima che venga letto (fai clic per continuare)",
      burn_this_secret_confirm_hint: "Bruciare un segreto è permanente e non può essere annullato",
      msg_check_email: "Controlla la tua email",
      click_to_continue: "Fai clic per continuare →",
      click_to_verify: "Continua per verificare il tuo account:",
      error_secret: "Non hai ancora niente da condividere",
      error_passphrase: "Ricontrolla la password",
      enter_passphrase_here: "Inserisci qui la password",
      view_secret: "Visualizza segreto",
      careful_only_see_once: "attenzione: verrà mostrato solo una volta.",
      warning: "Attenzione",
      oops: "Oops!",
      error: "Errore",
      secret_was_truncated: "Il messaggio è stato troncato perché era finito",
      signup_for_more: "Iscriviti per altro",
      login_to_your_account: "Entra nel tuo account",
      sent_to: "Inviato a: ",
      field_email: "Email",
      field_password: "Password",
      field_password2: "Conferma Password",
      button_create_account: "Crea account",
      share_a_secret: "Condividi un segreto",
      title_home: "Home",
      title_recent_secrets: "Segreti recenti",
      word_none: "Nessuno",
      word_burned: "bruciati",
      word_received: "ricevuti",
      word_confirm: "Conferma",
      word_cancel: "Annulla",
      feedback_text: "Hai una domanda o un commento?",
      button_send_feedback: "Invia un feedback",
      verification_sent_to: "Una verifica è stata inviata su"
    },
    homepage: {
      tagline1: "Incolla una password, messaggio segreto o un link privato qui sotto.",
      tagline2: "Mantieni le informazioni sensibili fuori dalle email e dai log delle chat.",
      secret_hint: "* Un link segreto funziona una sola volta e quindi sparisce per sempre.",
      secret_form_more_text1: "Iscriviti per un",
      secret_form_more_text2: "account gratuito",
      secret_form_more_text3: "e invia i tuoi segreti per email.",
      cta_title: "Usa un dominio personalizzato",
      cta_subtitle: "Eleva il tuo marchio e condividi con fiducia",
      cta_feature1: "Il tuo dominio personalizzato",
      cta_feature2: "Condivisione illimitata di segreti",
      cta_feature3: "Controlli avanzati sulla privacy",
      explore_premium_plans: "Esplora i piani Premium",
      need_free_account: "Stai iniziando ora?",
      sign_up_free: "Crea un account gratuito"
    },
    "private": {
      pretext: "Condividi questo link:",
      requires_passphrase: "Richiede una password.",
      this_msg_is_encrypted: "Questo messaggio è criptato con la tua password.",
      only_see_once: "lo vedrai solo questa volta"
    },
    shared: {
      requires_passphrase: "Questo messaggio richiede una password:",
      viewed_own_secret: "Hai visto il tuo segreto. Questo non è più disponibile per nessun altro.",
      you_created_this_secret: "Tu hai creato questo segreto. Se lo vedi tu, il destinatario non sarà in grado di vederlo.",
      your_secret_message: "Il tuo messaggio segreto:",
      this_message_for_you: "Questo messaggio è per te:",
      reply_with_secret: "Rispondi con un altro segreto"
    },
    dashboard: {
      title_received: "Ricevuto",
      title_not_received: "Non ricevuto",
      title_no_recent_secrets: "Nessun segreto recente"
    },
    login: {
      need_an_account: "Hai bisogno di un account?",
      forgot_your_password: "Password dimenticata?",
      button_sign_in: "Entra",
      enter_your_credentials: "Inserisci le tue credenziali"
    },
    incoming: {
      tagline1: "Incolla una password, messaggio segreto o un link privato qui sotto.",
      tagline2: "Mantieni le informazioni sensibili fuori dalle email e dai log delle chat.",
      secret_hint: "* Un link segreto funziona una sola volta e quindi sparisce per sempre.",
      incoming_button_create: "Invia alla squadra di supporto",
      incoming_secret_options: "Informazioni supporto",
      incoming_secret_placeholder: "Inserisci le informazioni di cui il tuo rappresentante di supporto avrà bisogno (p.e. password di sistema)",
      incoming_ticket_number: "Inserisci ticket #",
      incoming_ticket_number_hint: "Lo puoi trovare nella tua email (p.e. 123456)",
      incoming_recipient_address: "Destinatario supporto",
      incoming_success_message: "La tua email è stata inviata"
    }
  };
  const email$a = {
    incomingsupport: {
      subject: "[Ticket: %s]",
      body1: "Un cliente ha inviato le seguenti informazioni"
    },
    secretlink: {
      subject: "%s ti ha inviato un segreto",
      body1: "Abbiamo un segreto per te da parte di",
      body_tagline: "Se non conosci il mittente o pensi che possa essere spam, inviaci i dettagli qui:"
    },
    welcome: {
      subject: "Verifica il tuo account Onetime Secret",
      body1: "Benvenuto su Onetime Secret. Abbiamo un segreto per te!",
      please_verify: "Verifica il tuo account:",
      postscript1: "Questa email è stata inviata a",
      postscript2: "Se non hai creato questo account, elimina questo messaggio e non verrai ricontattato di nuovo."
    }
  };
  const it_IT = {
    web: web$a,
    email: email$a
  };
  const it_IT$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: it_IT,
    email: email$a,
    web: web$a
  }, Symbol.toStringTag, { value: "Module" }));
  const web$9 = {
    COMMON: {
      broadcast: "",
      description: "Zorg ervoor dat geheime informatie buiten chat logs en E-mail blijft. Deel een geheime link welke maar één keer beschikbaar is.",
      keywords: "geheim,wachtwoord generator,deel geheim,een keer",
      button_create_secret: "Creëer een geheime link",
      button_generate_secret: "Of genereer een geheim wachtwoord",
      secret_privacy_options: "Privacy Opties",
      secret_passphrase: "Wachtwoordzin",
      secret_passphrase_hint: "Een woord of een zin wat lastig te raden is.",
      secret_recipient_address: "Adres ontvanger",
      secret_placeholder: "De geheime informatie komt hier...",
      header_create_account: "Creëer Account",
      header_about: "Over",
      header_sign_in: "Log in",
      header_dashboard: "Account",
      header_logout: "Uitloggen",
      secret: "Geheim",
      received: "Ontvangen",
      burned: "Verbrand",
      expires_in: "Verloopt in",
      burn_this_secret: "Verbrand dit geheim",
      burn_this_secret_hint: "Het verbranden van een geheim vernietigt het bericht voor het is gelezen (klik om te bevestigen)",
      burn_this_secret_confirm_hint: "Het verbranden van een geheim is permanent en kan niet ongedaan gemaakt worden.",
      msg_check_email: "Controleer uw E-mail",
      click_to_continue: "Klik om door te gaan →",
      click_to_verify: "Ga door om uw account te verifiëren:",
      error_secret: "Je heb niets opgegeven om te delen.",
      error_passphrase: "Controleer nogmaals de wachtwoordzin",
      enter_passphrase_here: "Vul hier uw wachtwoordzin in",
      view_secret: "Bekijk het geheim",
      careful_only_see_once: "Pas op: we laten het maar één keer zien",
      warning: "Waarschuwing",
      oops: "Oops!",
      error: "Fout",
      secret_was_truncated: "Het bericht is afgekort omdat het klaar is.",
      signup_for_more: "Schrijf in voor meer",
      login_to_your_account: "Meld aan in je account",
      sent_to: "Vertuur naar: ",
      field_email: "E-mail",
      field_password: "Wachtwoord",
      field_password2: "Bevestig wachtwoord",
      button_create_account: "Creëer Account",
      share_a_secret: "Deel een geheim",
      title_home: "Home",
      title_recent_secrets: "Recente geheimen",
      word_none: "Geen",
      word_burned: "Verbrand",
      word_received: "Ontvangen",
      word_confirm: "Bevestig",
      word_cancel: "Annuleer",
      feedback_text: "Heeft u een vraag of opmerking?",
      button_send_feedback: "Stuur Feedback",
      verification_sent_to: "Een verificatie is verstuurd naar"
    },
    homepage: {
      tagline1: "Plak het wachtwoord, geheime bericht of privé link beneden",
      tagline2: "Hou gevoelige informatie buiten chat logs en E-mail",
      secret_hint: "* Een geheime link werkt maar één keer en verdwijnt daarna voor altijd.",
      secret_form_more_text1: "Schrijf in voor een",
      secret_form_more_text2: "gratis account",
      secret_form_more_text3: "Om  wachtwoordzinnen voor extra beveiliging samen met additionele privacy opties. We sturen u zelfs een link als u dat wilt.",
      cta_title: "Gebruik een aangepast domein",
      cta_subtitle: "Verhoog je merk en deel met vertrouwen",
      cta_feature1: "Je eigen aangepaste domein",
      cta_feature2: "Onbeperkt geheimen delen",
      cta_feature3: "Geavanceerde privacycontroles",
      explore_premium_plans: "Verken Premium-abonnementen",
      need_free_account: "Net begonnen?",
      sign_up_free: "Maak een gratis account aan"
    },
    "private": {
      pretext: "Deel een link:",
      requires_passphrase: "Wachtwoordzin verplicht.",
      this_msg_is_encrypted: "Dit bericht is versleuteld met uw wachtwoordzin.",
      only_see_once: "Je zult dit maar één keer zien."
    },
    shared: {
      requires_passphrase: "Een wachtwoord zin is verplicht voor dit bericht:",
      viewed_own_secret: "Je bekeek je eigen bericht, het is voor niemand meer zichtbaar.",
      you_created_this_secret: "Je heb een geheim gemaakt. Als je het bekijkt de ontvanger kan het niet meer lezen.",
      your_secret_message: "Uw geheime bericht:",
      this_message_for_you: "Dit bericht is voor u:",
      reply_with_secret: "Beantwoord met een ander geheim"
    },
    dashboard: {
      title_received: "Ontvangen",
      title_not_received: "Niet ontvangen",
      title_no_recent_secrets: "Geen recente geheimen"
    },
    login: {
      need_an_account: "Een account nodig?",
      forgot_your_password: "Wachtwoord vergeten?",
      button_sign_in: "Log in",
      enter_your_credentials: "Vul je inloggegevens in"
    },
    incoming: {
      tagline1: "Plak het wachtwoord, geheime bericht of privé link beneden",
      tagline2: "Hou gevoelige informatie buiten chat logs en E-mail",
      secret_hint: "* Een geheime link werkt maar één keer en verdwijnt daarna voor altijd.",
      incoming_button_create: "Stuur naar een support medewerker",
      incoming_secret_options: "Support informatie",
      incoming_secret_placeholder: "Geef willekeurige die je support medewerker nodig heeft (bijvoorbeeld een systeem wachtwoord)",
      incoming_ticket_number: "Vul Ticket #",
      incoming_ticket_number_hint: "Je kunt deze terug vinden in uw E-mail (bv 123456)",
      incoming_recipient_address: "Support ontvanger",
      incoming_success_message: "Uw E-mailbericht is verstuurd."
    }
  };
  const email$9 = {
    incomingsupport: {
      subject: "[Ticket: %s]",
      body1: "Een klant heeft u de volgende informatie verstuurd."
    },
    secretlink: {
      subject: "%s Heeft u een geheim verstuurd.",
      body1: "We hebben een geheim voor u van",
      body_tagline: "Als je de afzender niet kent of denkt dat het spam is, stuur ons de gegevens hier:"
    },
    welcome: {
      subject: "Verifieer  uw Onetime Secret account",
      body1: "Welkom bij Onetime Secret. We hebben een geheim voor u!",
      please_verify: "Bevestig uw account alstublieft:",
      postscript1: "Deze E-mail is verstuurd naar",
      postscript2: "Als u dit account niet heeft aangemaakt negeer dit bericht, we zullen u niet meer lastig vallen."
    }
  };
  const nl = {
    web: web$9,
    email: email$9
  };
  const nl$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: nl,
    email: email$9,
    web: web$9
  }, Symbol.toStringTag, { value: "Module" }));
  const web$8 = {
    COMMON: {
      broadcast: "",
      description: "Bezpiecznie udostępniaj poufne informacje na czatach i pocztą e-mail. Udostępnij tajne łącze, które jest dostępne tylko jeden raz.",
      keywords: "sekret,generator haseł,sekretne linki,jednorazowe",
      button_create_secret: "Utwórz tajne łącze",
      button_generate_secret: "Lub wygeneruj losowe hasło",
      secret_privacy_options: "Ustawienia prywatności",
      secret_passphrase: "Hasło",
      secret_passphrase_hint: "Trudne do odgadnięcia słowo lub fraza",
      secret_recipient_address: "Adres Odbiorcy",
      secret_placeholder: "Napisz wiadomość...",
      header_create_account: "Utwórz konto",
      header_about: "O nas",
      header_sign_in: "Zaloguj",
      header_dashboard: "Konto",
      header_logout: "Wyloguj",
      secret: "Sekret",
      received: "Odebrana",
      burned: "Unieważniona",
      expires_in: "Wygasa w",
      burn_this_secret: "unieważnij poufną wiadomość",
      burn_this_secret_hint: "Unieważnienie spowoduje wygaśnięcie tajnego łącza przed jego użyciem oraz bezpowrotne usunięcie wiadomości z serwera (kliknij, aby potwierdzić)",
      burn_this_secret_confirm_hint: "Unieważnienie jest trwałe i nieodwracalne",
      msg_check_email: "Sprawdź swoją skrzynkę e-mail",
      click_to_continue: "Kliknij aby kontynuować →",
      click_to_verify: "Kontynuuj weryfikację swojego konta:",
      error_secret: "Nie podałeś niczego do udostępnienia",
      error_passphrase: "Nieprawidłowe hasło, spróbuj jeszcze raz!",
      enter_passphrase_here: "Wprowadź hasło tutaj",
      view_secret: "Pokaż poufną wiadomość",
      careful_only_see_once: "uwaga: ta wiadomość wyświetli się tylko raz, a następnie ulegnie samozniszczeniu",
      warning: "Ostrzeżenie",
      oops: "Ups!",
      error: "Błąd",
      secret_was_truncated: "Wiadomość została obcięta ponieważ była dłuższa niż",
      signup_for_more: "Zarejestruj się, aby uzyskać więcej",
      login_to_your_account: "Zaloguj się na swoje konto",
      sent_to: "Wyślij do: ",
      field_email: "E-mail",
      field_password: "Hasło",
      field_password2: "Potwierdź Hasło",
      button_create_account: "Utwórz Konto",
      share_a_secret: "Udostępnij poufną wiadomość",
      title_home: "Strona główna",
      title_recent_secrets: "Ostatnie Sekrety",
      word_none: "Brak",
      word_burned: "unieważnione",
      word_received: "odebrane",
      word_confirm: "Potwierdź",
      word_cancel: "Anuluj",
      feedback_text: "Masz pytanie lub komentarz?",
      button_send_feedback: "Wyślij Opinię",
      verification_sent_to: "Wysłano potwierdzenie na"
    },
    homepage: {
      tagline1: "Umieść hasło, tajną wiadomość lub prywatny link poniżej.",
      tagline2: "Bezpiecznie przekazuj poufne informacje na czatach i pocztą e-mail.",
      secret_hint: "* Tajne łącze działa tylko raz, a następnie wygasa na zawsze.",
      secret_form_more_text1: "Zarejestruj się po",
      secret_form_more_text2: "darmowe konto",
      secret_form_more_text3: "i uzyskaj możliwość wysyłania poufnych wiadomości przez e-mail.",
      cta_title: "Użyj niestandardowej domeny",
      cta_subtitle: "Podnieś wartość swojej marki i udostępniaj z pewnością",
      cta_feature1: "Twoja własna niestandardowa domena",
      cta_feature2: "Nieograniczone udostępnianie sekretów",
      cta_feature3: "Zaawansowane kontrole prywatności",
      explore_premium_plans: "Odkryj plany Premium",
      need_free_account: "Dopiero zaczynasz?",
      sign_up_free: "Utwórz darmowe konto"
    },
    "private": {
      pretext: "Udostępnij to jednorazowe łącze:",
      requires_passphrase: "Wymaga hasła.",
      this_msg_is_encrypted: "Ta wiadomość jest zaszyfrowana hasłem.",
      only_see_once: "zobaczysz to tylko raz"
    },
    shared: {
      requires_passphrase: "Ta wiadomość wymaga podania hasła:",
      viewed_own_secret: "Wyświetliłeś własną wiadomość. Nie jest już dostępna dla nikogo innego.",
      you_created_this_secret: "Utworzyłeś tę wiadomość. Jeśli wyświetlisz ją, odbiorca nie będzie mógł jej zobaczyć.",
      your_secret_message: "Twoja poufna wiadomość:",
      this_message_for_you: "Jednorazowa wiadomość dla Ciebie:",
      reply_with_secret: "Odpowiedz z poufną wiadomością"
    },
    dashboard: {
      title_received: "Odebrane",
      title_not_received: "Nieodebrane",
      title_no_recent_secrets: "Brak ostatnich wiadomości"
    },
    login: {
      need_an_account: "Chcesz założyć konto?",
      forgot_your_password: "Zapomniałeś hasła?",
      button_sign_in: "Logowanie",
      enter_your_credentials: "Wprowadź swoje dane dostępowe"
    },
    incoming: {
      tagline1: "Umieść hasło, tajną wiadomość lub prywatny link poniżej.",
      tagline2: "Bezpiecznie przekazuj poufne informacje na czatach i pocztą e-mail.",
      secret_hint: "* Tajne łącze działa tylko raz, a następnie wygasa na zawsze.",
      incoming_button_create: "Wyślij do Pomocy Technicznej",
      incoming_secret_options: "Informacje o Pomocy Technicznej",
      incoming_secret_placeholder: "Podaj wszelkie niezbędne informacje, które mogą być potrzebne konsultantowi pomocy technicznej (np. hasło systemowe)",
      incoming_ticket_number: "Podaj numer zgłoszenia",
      incoming_ticket_number_hint: "Znajdziesz go w Twoim e-mailu (np. 123456)",
      incoming_recipient_address: "Odbiorca pomocy technicznej",
      incoming_success_message: "Twój e-mail został wysłany"
    }
  };
  const email$8 = {
    incomingsupport: {
      subject: "[Zgłoszenie: %s]",
      body1: "Klient przesłał następujące informacje"
    },
    secretlink: {
      subject: "%s wysłał Ci poufną jednorazową wiadomość",
      body1: "Masz poufną wiadomość od",
      body_tagline: "Jeśli nie znasz nadawcy lub uważasz, że to spam, wyślij nam szczegóły tutaj:"
    },
    welcome: {
      subject: "Potwierdź swoje konto Onetime Secret",
      body1: "Witamy w Onetime Secret. Masz poufną wiadomość!",
      please_verify: "Potwierdź proszę swoje konto:",
      postscript1: "Twój e-mail został wysłany do",
      postscript2: "Jeśli nie założyłeś tego konta, usuń tę wiadomość i nie skontaktujemy się z Tobą ponownie."
    }
  };
  const pl = {
    web: web$8,
    email: email$8
  };
  const pl$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: pl,
    email: email$8,
    web: web$8
  }, Symbol.toStringTag, { value: "Module" }));
  const web$7 = {
    COMMON: {
      broadcast: "",
      description: "Mantenha dados sensíveis fora de seus emails ou logs de conversa. Compartilhe um link secreto que fica disponível somente uma vez.",
      keywords: "segredo,gerador de senha,compartilhar um segredo,único",
      button_create_secret: "Criar link secreto",
      button_generate_secret: "Ou gerar uma senha aleatória",
      secret_privacy_options: "Opções de Privacidade",
      secret_passphrase: "Senha mestre",
      secret_passphrase_hint: "Uma palavra ou frase que seja difícil de adivinhar",
      secret_recipient_address: "Endereço do Destinatário",
      secret_placeholder: "Conteúdo do segredo deve vir aqui...",
      header_create_account: "Criar Conta",
      header_about: "Sobre",
      header_sign_in: "Entrar",
      header_dashboard: "Conta",
      header_logout: "Sair",
      secret: "Segredo",
      received: "Recebido",
      burned: "Removido",
      expires_in: "Expira em",
      burn_this_secret: "Remover este segredo",
      burn_this_secret_hint: "Remover um segredo irá apagá-lo antes de ser lido (clique para confirmar)",
      burn_this_secret_confirm_hint: "Remover um segredo é permanente e não pode ser desfeito",
      msg_check_email: "Verifique seu email",
      click_to_continue: "Clique para continuar →",
      click_to_verify: "Continue para verificar sua conta:",
      error_secret: "Você não forneceu nada para compartilhar",
      error_passphrase: "Verifique a senha mestre",
      enter_passphrase_here: "Entre a senha mestre aqui",
      view_secret: "Ver segredo",
      careful_only_see_once: "cuidado: só será mostrado uma vez.",
      warning: "Atenção",
      oops: "Oops!",
      error: "Erro",
      secret_was_truncated: "A mensagem foi cortada porque tinha mais de",
      signup_for_more: "Cadastre-se para usar mais",
      login_to_your_account: "Entrar na sua conta",
      sent_to: "Enviar para: ",
      field_email: "Email",
      field_password: "Senha",
      field_password2: "Confirmar Senha",
      button_create_account: "Criar Conta",
      share_a_secret: "Compartilhar um segredo",
      title_home: "Home",
      title_recent_secrets: "Segredos Recentes",
      word_none: "Nenhum",
      word_burned: "removido",
      word_received: "recebido",
      word_confirm: "Confirmar",
      word_cancel: "Cancelar",
      feedback_text: "Tem uma pergunta ou comentário?",
      button_send_feedback: "Enviar Feedback",
      verification_sent_to: "Uma verificação foi enviada para"
    },
    homepage: {
      tagline1: "Cole uma senha, mensagem secreta ou link privado abaixo.",
      tagline2: "Mantenha dados sensíveis fora de seus emails ou logs de conversa.",
      secret_hint: "* Um link secreto funciona apenas uma vez e depois desaparece para sempre.",
      secret_form_more_text1: "Cadastre-se para uma",
      secret_form_more_text2: "conta gratuita",
      secret_form_more_text3: "e seja capaz de enviar um segredo por email.",
      cta_title: "Use um domínio personalizado",
      cta_subtitle: "Eleve sua marca e compartilhe com confiança",
      cta_feature1: "Seu próprio domínio personalizado",
      cta_feature2: "Compartilhamento ilimitado de segredos",
      cta_feature3: "Controles avançados de privacidade",
      explore_premium_plans: "Explore os planos Premium",
      need_free_account: "Está apenas começando?",
      sign_up_free: "Crie uma conta gratuita"
    },
    "private": {
      pretext: "Compartilhar este link:",
      requires_passphrase: "Requerir uma senha mestre.",
      this_msg_is_encrypted: "Esta mensagem será criptografada com sua senha mestre.",
      only_see_once: "você só verá isso uma vez"
    },
    shared: {
      requires_passphrase: "Esta mensagem requere uma senha mestre:",
      viewed_own_secret: "Você viu seu próprio segredo. Este não está mais disponível para ninguém.",
      you_created_this_secret: "Você criou este segredo. Se você o ver, o destinatário não será capaz de vê-lo.",
      your_secret_message: "Sua mensagem secreta:",
      this_message_for_you: "Esta mensagem é para você:",
      reply_with_secret: "Responder com outro segredo"
    },
    dashboard: {
      title_received: "Recebido",
      title_not_received: "Não Recebido",
      title_no_recent_secrets: "Nenhum segredo recente"
    },
    login: {
      need_an_account: "Precisa de uma conta?",
      forgot_your_password: "Esqueceu sua senha?",
      button_sign_in: "Entrar",
      enter_your_credentials: "Entre com suas credenciais"
    },
    incoming: {
      tagline1: "Cole uma senha, mensagem secreta ou link privado abaixo.",
      tagline2: "Mantenha dados sensíveis fora de seus emails ou logs de conversa.",
      secret_hint: "* Um link secreto funciona apenas uma vez e depois desaparece para sempre.",
      incoming_button_create: "Enviar para Equipe de Suporte Send to Support Staff",
      incoming_secret_options: "Informações para Suporte",
      incoming_secret_placeholder: "Entre com qualquer informação que seu representante de suporte vai precisar (ex. senha do sistema)",
      incoming_ticket_number: "Entre com número do ticket #",
      incoming_ticket_number_hint: "Você pode encontrar este número no seu email (ex. 123456)",
      incoming_recipient_address: "Destinatário de Suporte",
      incoming_success_message: "Seu email foi enviado"
    }
  };
  const email$7 = {
    incomingsupport: {
      subject: "[Ticket: %s]",
      body1: "Um cliente te enviou a seguinte informação"
    },
    secretlink: {
      subject: "%s te enviou um segredo",
      body1: "Temos um segredo para você de",
      body_tagline: "Se você não conhece o remetente ou acredita ser spam, envie-nos os detalhes aqui:"
    },
    welcome: {
      subject: "Verifique sua conta Onetime Secret",
      body1: "Bem-vindo(a) ao Onetime Secret. Temos um segredo para você!",
      please_verify: "Por favor, verifique sua conta:",
      postscript1: "Este email foi enviado para",
      postscript2: "Se você não criou esta conta, apague esta mensagem e nós não iremos lhe contatar novamente."
    }
  };
  const pt_BR = {
    web: web$7,
    email: email$7
  };
  const pt_BR$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: pt_BR,
    email: email$7,
    web: web$7
  }, Symbol.toStringTag, { value: "Module" }));
  const web$6 = {
    COMMON: {
      broadcast: "",
      description: "Mantenha informações sensíveis fora dos seus registos de chat e e-mail. Partilhe um link secreto que está disponível apenas uma vez.",
      keywords: "secreto,gerador de palavras-passe,partilhar um segredo,uma vez",
      button_create_secret: "Criar um link secreto",
      button_generate_secret: "Ou gerar uma palavra-passe aleatória",
      secret_privacy_options: "Opções de Privacidade",
      secret_passphrase: "Frase-passe",
      secret_passphrase_hint: "Uma palavra ou frase difícil de adivinhar",
      secret_recipient_address: "Endereço do Destinatário",
      secret_placeholder: "O conteúdo secreto vai aqui...",
      header_create_account: "Criar Conta",
      header_about: "Sobre",
      header_sign_in: "Iniciar Sessão",
      header_dashboard: "Conta",
      header_logout: "Terminar Sessão",
      secret: "Segredo",
      received: "Recebido",
      burned: "Destruído",
      expires_in: "Expira em",
      burn_this_secret: "Destruir este segredo",
      burn_this_secret_hint: "Destruir um segredo irá apagá-lo antes de ser lido (clique para confirmar)",
      burn_this_secret_confirm_hint: "Destruir um segredo é permanente e não pode ser desfeito",
      msg_check_email: "Verifique o seu e-mail",
      click_to_continue: "Clique para continuar →",
      click_to_verify: "Continue para verificar a sua conta:",
      error_secret: "Não forneceu nada para partilhar",
      error_passphrase: "Verifique novamente essa frase-passe",
      enter_passphrase_here: "Introduza a frase-passe aqui",
      view_secret: "Ver Segredo",
      careful_only_see_once: "cuidado: só o mostraremos uma vez.",
      warning: "Aviso",
      oops: "Ups!",
      error: "Erro",
      secret_was_truncated: "A mensagem foi truncada porque estava acima de",
      signup_for_more: "Registe-se para mais",
      login_to_your_account: "Inicie sessão na sua conta",
      sent_to: "Enviado para: ",
      field_email: "E-mail",
      field_password: "Palavra-passe",
      field_password2: "Confirmar Palavra-passe",
      button_create_account: "Criar Conta",
      share_a_secret: "Partilhar um segredo",
      title_home: "Início",
      title_recent_secrets: "Segredos Recentes",
      word_none: "Nenhum",
      word_burned: "destruído",
      word_received: "recebido",
      word_confirm: "Confirmar",
      word_cancel: "Cancelar",
      feedback_text: "Tem uma pergunta ou comentário?",
      button_send_feedback: "Enviar Feedback",
      verification_sent_to: "Uma verificação foi enviada para"
    },
    homepage: {
      tagline1: "Cole uma palavra-passe, mensagem secreta ou link privado abaixo.",
      tagline2: "Mantenha informações sensíveis fora do seu e-mail e registos de chat.",
      secret_hint: "* Um link secreto funciona apenas uma vez e depois desaparece para sempre.",
      secret_form_more_text1: "Registe-se para uma",
      secret_form_more_text2: "conta gratuita",
      secret_form_more_text3: "e poder enviar o segredo por e-mail.",
      cta_title: "Use um Domínio Personalizado",
      cta_subtitle: "Eleve a sua marca e partilhe com confiança",
      cta_feature1: "O seu próprio domínio personalizado",
      cta_feature2: "Partilha ilimitada de segredos",
      cta_feature3: "Controlos de privacidade avançados",
      explore_premium_plans: "Explore os Planos Premium",
      need_free_account: "Está a começar?",
      sign_up_free: "Crie uma conta gratuita"
    },
    "private": {
      pretext: "Partilhe este link:",
      requires_passphrase: "Requer uma frase-passe.",
      this_msg_is_encrypted: "Esta mensagem está encriptada com a sua frase-passe.",
      only_see_once: "só verá isto uma vez"
    },
    shared: {
      requires_passphrase: "Esta mensagem requer uma frase-passe:",
      viewed_own_secret: "Visualizou o seu próprio segredo. Já não está disponível para mais ninguém.",
      you_created_this_secret: "Criou este segredo. Se o visualizar, o destinatário não poderá vê-lo.",
      your_secret_message: "A sua mensagem secreta:",
      this_message_for_you: "Esta mensagem é para si:",
      reply_with_secret: "Responder com outro segredo"
    },
    dashboard: {
      title_received: "Recebido",
      title_not_received: "Não Recebido",
      title_no_recent_secrets: "Sem segredos recentes"
    },
    login: {
      need_an_account: "Precisa de uma conta?",
      forgot_your_password: "Esqueceu-se da sua palavra-passe?",
      button_sign_in: "Iniciar Sessão",
      enter_your_credentials: "Introduza as suas credenciais"
    },
    incoming: {
      tagline1: "Cole uma palavra-passe, mensagem secreta ou link privado abaixo.",
      tagline2: "Mantenha informações sensíveis fora do seu e-mail e registos de chat.",
      secret_hint: "* Um link secreto funciona apenas uma vez e depois desaparece para sempre.",
      incoming_button_create: "Enviar para a Equipa de Suporte",
      incoming_secret_options: "Informações de Suporte",
      incoming_secret_placeholder: "Introduza qualquer informação que o seu representante de suporte precisará (por exemplo, palavra-passe do sistema)",
      incoming_ticket_number: "Introduza o Número do Ticket",
      incoming_ticket_number_hint: "Pode encontrar isto no seu e-mail (por exemplo, 123456)",
      incoming_recipient_address: "Destinatário de suporte",
      incoming_success_message: "O seu e-mail foi enviado"
    }
  };
  const email$6 = {
    incomingsupport: {
      subject: "[Ticket: %s]",
      body1: "Um cliente enviou as seguintes informações"
    },
    secretlink: {
      subject: "%s enviou-lhe um segredo",
      body1: "Temos um segredo para si de",
      body_tagline: "Se não conhece o remetente ou acredita que seja spam, envie-nos os detalhes aqui:"
    },
    welcome: {
      subject: "Verifique a sua conta Onetime Secret",
      body1: "Bem-vindo ao Onetime Secret. Temos um segredo para si!",
      please_verify: "Por favor, verifique a sua conta:",
      postscript1: "Este e-mail foi enviado para",
      postscript2: "Se não fez este pedido, pode ignorar este e-mail com segurança."
    }
  };
  const pt_PT = {
    web: web$6,
    email: email$6
  };
  const pt_PT$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: pt_PT,
    email: email$6,
    web: web$6
  }, Symbol.toStringTag, { value: "Module" }));
  const web$5 = {
    COMMON: {
      broadcast: "",
      description: "Не пересылайте конфиденциальную информацию через беседы и эл-почту. Поделитесь ссылкой на тайну, доступную только один раз.",
      keywords: "тайна,генератор паролей,поделиться тайной,одноразовый",
      button_create_secret: "Создать ссылку на тайну",
      button_generate_secret: "Или сгенерировать одноразовый пароль",
      secret_privacy_options: "Настройки приватности",
      secret_passphrase: "Пароль",
      secret_passphrase_hint: "Слово или фраза, которую сложно угадать",
      secret_recipient_address: "Адрес получателя",
      secret_placeholder: "Введите тайное содержимое сюда...",
      header_create_account: "Создать учётную запись",
      header_about: "О нас",
      header_sign_in: "Войти",
      header_dashboard: "Учётная запись",
      header_logout: "Выйти",
      secret: "Тайна",
      received: "Получена",
      burned: "Сожжена",
      expires_in: "Истекает через",
      burn_this_secret: "Сжечь эту тайну",
      burn_this_secret_hint: "Сожжение тайны удалит её до прочтения (щёлкните здесь, чтобы подтвердить)",
      burn_this_secret_confirm_hint: "Сожжение тайны не может быть отменено",
      msg_check_email: "Проверьте вашу эл-почту",
      click_to_continue: "Щёлкните для продолжения →",
      click_to_verify: "Продолжить, чтобы подтвердить вашу учётную запись:",
      error_secret: "Вы не предоставили ничего, чем можно поделиться",
      error_passphrase: "Перепроверить этот пароль",
      enter_passphrase_here: "Введите пароль",
      view_secret: "Посмотреть сообщение",
      careful_only_see_once: "внимание: оно будет показано только раз.",
      warning: "Внимание",
      oops: "Ой!",
      error: "Ошибка",
      secret_was_truncated: "Это сообщение было урезано, так как оно закончилось",
      signup_for_more: "Подпишитесь для дополнительных возможностей",
      login_to_your_account: "Войдите в свою учётную запись",
      sent_to: "Отправить: ",
      field_email: "эл-почта",
      field_password: "Пароль",
      field_password2: "Подтвердите пароль",
      button_create_account: "Создать учётную запись",
      share_a_secret: "Поделиться тайной",
      title_home: "Домашняя",
      title_recent_secrets: "Недавние тайны",
      word_none: "Ничего",
      word_burned: "сожжена",
      word_received: "получена",
      word_confirm: "Подтвердить",
      word_cancel: "Отмена",
      feedback_text: "Есть вопрос или комментарий?",
      button_send_feedback: "Отправить отзыв",
      verification_sent_to: "Подтвреждение было отправлено на"
    },
    homepage: {
      tagline1: "Вставьте пароль, тайное сообщение или закрытую ссылку ниже.",
      tagline2: "Не пересылайте конфиденциальную информацию через беседы и эл-почту.",
      secret_hint: "* Ссылка сработает только один раз, а затем удалится навсегда.",
      secret_form_more_text1: "Создайте",
      secret_form_more_text2: "бесплатную учётную запись",
      secret_form_more_text3: "и получите возможность отправлять тайны по эл-почте.",
      cta_title: "Используйте собственный домен",
      cta_subtitle: "Поднимите свой бренд и делитесь с уверенностью",
      cta_feature1: "Ваш собственный настраиваемый домен",
      cta_feature2: "Безлимитный обмен секретами",
      cta_feature3: "Расширенные настройки конфиденциальности",
      explore_premium_plans: "Изучите премиум-планы",
      need_free_account: "Только начинаете?",
      sign_up_free: "Создать бесплатный аккаунт"
    },
    "private": {
      pretext: "Поделиться этой ссылкой:",
      requires_passphrase: "Требуется пароль.",
      this_msg_is_encrypted: "Это сообщение зашифровано вашим паролем.",
      only_see_once: "вы увидете это только один раз"
    },
    shared: {
      requires_passphrase: "Это сообщение требует пароль:",
      viewed_own_secret: "Вы посмотрели свою тайну. Она никому более не доступна.",
      you_created_this_secret: "Вы создали тайну. Если вы просомтрите её, получатель не сможет увидеть её.",
      your_secret_message: "Ваше тайное сообщение:",
      this_message_for_you: "Это сообщение вам:",
      reply_with_secret: "Ответить другим сообщением"
    },
    dashboard: {
      title_received: "Получено",
      title_not_received: "Не получено",
      title_no_recent_secrets: "Нет недавних тайн"
    },
    login: {
      need_an_account: "Нужна учётная запись",
      forgot_your_password: "Забыли свой пароль?",
      button_sign_in: "Войти",
      enter_your_credentials: "Введите свои учётные сведения"
    },
    incoming: {
      tagline1: "Вставьте пароль, тайное сообщение или частну ссылку ниже.",
      tagline2: "Не пересылайте конфиденциальную информацию через беседы и эл-почту.",
      secret_hint: "* Ссылка сработает только один раз, а затем удалится навсегда.",
      incoming_button_create: "Отправить работникам поддержки",
      incoming_secret_options: "Информация о поддержке",
      incoming_secret_placeholder: "Введите любую информацию, которая может быть нужна специалисту поддержки (например, пароль)",
      incoming_ticket_number: "Введите № запроса",
      incoming_ticket_number_hint: "Вы можете найти его в своём письме (например, 123456)",
      incoming_recipient_address: "Получатель поддержки",
      incoming_success_message: "Ваше письмо было отправлено"
    }
  };
  const email$5 = {
    incomingsupport: {
      subject: "[Запрос: %s]",
      body1: "Клиент отправил следующую информацию"
    },
    secretlink: {
      subject: "%s отправил(а) вам тайну",
      body1: "У нас для вас тайна от",
      body_tagline: "Если вы не знаете отправиетля или считаете, что это спам, отправьте нам подробности здесь:"
    },
    welcome: {
      subject: "Подтвердите свою учётную запись Onetime Secret",
      body1: "Добро пожаловать в Onetime Secret. У нас есть для вас тайна!",
      please_verify: "Пожалуйста, подвтердите свою учётную запись:",
      postscript1: "Это письмо было отпарвлено"
    }
  };
  const postscript2 = "Если вы не создавали эту учётную запись, удалите это сообщение и мы не будем вам больше писать.";
  const ru = {
    web: web$5,
    email: email$5,
    postscript2
  };
  const ru$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: ru,
    email: email$5,
    postscript2,
    web: web$5
  }, Symbol.toStringTag, { value: "Module" }));
  const web$4 = {
    COMMON: {
      broadcast: "",
      description: "Ohranite občutljive informacije izven el. pošte in klepetalnice. Posredujte povezavo za enkratni vpogled.",
      keywords: "secret,password generator,share a secret,onetime",
      button_create_secret: "Ustvari skrivno povezavo",
      button_generate_secret: "Ali generiraj naključno geslo",
      secret_privacy_options: "Zasebnost",
      secret_passphrase: "Geslo",
      secret_passphrase_hint: "Beseda ali fraza, ki jo je težko uganiti",
      secret_recipient_address: "Naslov prejemnika",
      secret_placeholder: "Vnesite skrivno vsebino...",
      header_create_account: "Ustavri raèun",
      header_about: "O",
      header_sign_in: "Vpis",
      header_dashboard: "Račun",
      header_logout: "Izpis",
      secret: "Skrivnost",
      received: "Prejeto",
      burned: "Zbrisano",
      expires_in: "Poteče v",
      burn_this_secret: "Izbriši to skrivnost",
      burn_this_secret_hint: "Brisanje bo izvedeno pred branjem  (potrdi tukaj)",
      burn_this_secret_confirm_hint: "Brisanje je nepovratno",
      msg_check_email: "Preveri e-pošto",
      click_to_continue: "Pritisni z nadaljevanje →",
      click_to_verify: "Pritisni za potrditev računa:",
      error_secret: "Manjka vnos za delitev",
      error_passphrase: "Preveri pravilnost gesla",
      enter_passphrase_here: "Vnesi geslo tukaj",
      view_secret: "Prikaži skrivnost",
      careful_only_see_once: "POZOR!: Samo enkratni prikaz",
      warning: "Opozorilo",
      oops: "Oops!",
      error: "Napaka",
      secret_was_truncated: "Sporočilo je okrnjeno, ker je končano",
      signup_for_more: "Prijavite se za več",
      login_to_your_account: "Prijava v uporabniški račun",
      sent_to: "Prejemnik: ",
      field_email: "E-pošta",
      field_password: "Geslo",
      field_password2: "Potrdi geslo",
      button_create_account: "Ustvari račun",
      share_a_secret: "Deli skrivnost",
      title_home: "Domov",
      title_recent_secrets: "Nedavne skrivnosti",
      word_none: "Nič",
      word_burned: "Uničeno",
      word_received: "Prejeto",
      word_confirm: "Potrdi",
      word_cancel: "Prekliči",
      feedback_text: "Imate vprašanje ali mnenje?",
      button_send_feedback: "Pošlji povratno informacijo",
      verification_sent_to: "Potrditev je bila poslana"
    },
    homepage: {
      tagline1: "Prilepite geslo, sporočilo ali povezavo.",
      tagline2: "Ohranite občutljive informacije izven el. pošte in klepetalnice.",
      secret_hint: "* Povezava je enkratna po uporabi izgine za vedno.",
      secret_form_more_text1: "Prijavite se z ",
      secret_form_more_text2: "zastonj uporabniškim računom",
      secret_form_more_text3: "in pošiljajte skrivnosti po e-pošti.",
      cta_title: "Uporabite prilagojeno domeno",
      cta_subtitle: "Dvignite svojo blagovno znamko in delite z zaupanjem",
      cta_feature1: "Vaša lastna prilagojena domena",
      cta_feature2: "Neomejeno deljenje skrivnosti",
      cta_feature3: "Napredne kontrole zasebnosti",
      explore_premium_plans: "Raziščite Premium načrte",
      need_free_account: "Šele začenjate?",
      sign_up_free: "Ustvarite brezplačen račun"
    },
    "private": {
      pretext: "Deli povezavo",
      requires_passphrase: "Potrebno je geslo.",
      this_msg_is_encrypted: "To sporočilo je šifrirano z vašim geslom.",
      only_see_once: "To boste videli samo enkrat"
    },
    shared: {
      requires_passphrase: "To sporočilo zahteva geslo:",
      viewed_own_secret: "Odprli ste lastno skrivno sporočilo, ki več ni na voljo za vpogled drugim.",
      you_created_this_secret: "Sami ste avtor tega sporočila. Če ga odprete, naslovniku več ne bo dostopno.",
      your_secret_message: "Vaše skrivno sporočilo:",
      this_message_for_you: "To sporočilo ni namenjneno vam:",
      reply_with_secret: "Odgovori s skrivnim sporočilom"
    },
    dashboard: {
      title_received: "Prejeto",
      title_not_received: "Ni prejeto",
      title_no_recent_secrets: "No recent secrets"
    },
    login: {
      need_an_account: "Need an account?",
      forgot_your_password: "Forgot your password?",
      button_sign_in: "Sign In",
      enter_your_credentials: "Enter your credentials"
    },
    incoming: {
      tagline1: "Paste a password, secret message or private link below.",
      tagline2: "Keep sensitive info out of your email and chat logs.",
      secret_hint: "* A secret link only works once and then disappears forever.",
      incoming_button_create: "Send to Support Staff",
      incoming_secret_options: "Support Info",
      incoming_secret_placeholder: "Enter any information your support representative will need (e.g. system password)",
      incoming_ticket_number: "Enter Ticket #",
      incoming_ticket_number_hint: "You can find this in your email (e.g. 123456)",
      incoming_recipient_address: "Support recipient",
      incoming_success_message: "Your email has been sent"
    }
  };
  const email$4 = {
    incomingsupport: {
      subject: "[Ticket: %s]",
      body1: "A customer has sent the following info"
    },
    secretlink: {
      subject: "%s sent you a secret",
      body1: "We have a secret for you from",
      body_tagline: "If you don't know the sender or believe it to be spam, send us the details here:"
    },
    welcome: {
      subject: "Verify your Onetime Secret account",
      body1: "Welcome to Onetime Secret. We have a secret for you!",
      please_verify: "Please verify your account:",
      postscript1: "This email was sent to",
      postscript2: "If you didn't create this account, delete this message and we won't contact you again."
    }
  };
  const sl_SI = {
    web: web$4,
    email: email$4
  };
  const sl_SI$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: sl_SI,
    email: email$4,
    web: web$4
  }, Symbol.toStringTag, { value: "Module" }));
  const web$3 = {
    COMMON: {
      broadcast: "Sändning",
      description: "Behåll känslig information utan att behöva skriva det i Epost eller chattar. Dela en hemlig länk som bara fungerar en gång.",
      keywords: "hemlighet, generera slumpmässigt lösenord, dela en hemlighet, engångbar",
      button_create_secret: "Skapa en hemlig länk",
      button_generate_secret: "eller generera slumpmässigt lösenord",
      secret_privacy_options: "Integritet(hur vi sammlar data om dig)",
      secret_passphrase: "Lösenord",
      secret_passphrase_hint: "Ett lösenord som är svårt att lista ut",
      secret_recipient_address: "motagaren addres",
      secret_placeholder: "Skriv din hemlighet här...",
      header_create_account: "Skapa konto",
      header_about: "Om",
      header_sign_in: "Logga in",
      header_dashboard: "Konto",
      header_logout: "Logga ut",
      secret: "Hemlighet",
      received: "Mottagen",
      burned: "borta",
      expires_in: "Utgår om",
      burn_this_secret: "radera denna hemlighet",
      burn_this_secret_hint: "Radera en hemlighet kommer att radera den innan någon har hunnit läsa den(klicka igen om du har förstått)",
      burn_this_secret_confirm_hint: "Att radera en hemlighet är oåterkalligt och kan inte tas tillbaka när återgärden vidtagits",
      msg_check_email: "Kolla din Epost",
      click_to_continue: "Fortsätt →",
      click_to_verify: "Klicka för att verifiera ditt konto",
      error_secret: "Du har inte skrivt något som en hemlighet",
      error_passphrase: "Något är fel med lösenordet, försök igen",
      enter_passphrase_here: "Skriv lösenordet här",
      view_secret: "Läs hemlighet",
      careful_only_see_once: "Var försiktig, du kan bara se detta EN GÅNG.",
      warning: "Varning",
      oops: "Oj!",
      error: "Något gick fel",
      secret_was_truncated: "det hör meddelandet är truncated b/c it was over",
      signup_for_more: "Logga in för fler funktioner",
      login_to_your_account: "Logga in på ditt konto",
      sent_to: "Skikades till: ",
      field_email: "Epost address",
      field_password: "Lösenord",
      field_password2: "Fortsätt med lösenordet",
      button_create_account: "Skapa konto",
      share_a_secret: "Dela en hemlighet",
      title_home: "Hem",
      title_recent_secrets: "Senaste hemligheterna",
      word_none: "Inga",
      word_burned: "raderad",
      word_received: "mottagen",
      word_confirm: "Fortsätt",
      word_cancel: "Avbryt",
      feedback_text: "Vill du fråga något eller har något att säga?",
      button_send_feedback: "Skika konstruktiv kritik",
      verification_sent_to: "A verification was sent to"
    },
    homepage: {
      tagline1: "Klistra in en hemlighet, lösenord eller hemlig länk här.",
      tagline2: "Keep sensitive info out of your email and chat logs.",
      secret_hint: "* En länk som bara kan användas en gång och sedan försvinner för alltid(en extremt väldigt lång tid).",
      secret_form_more_text1: "Skapa konto för att",
      secret_form_more_text2: "gratis konto",
      secret_form_more_text3: "och kunna skicka via Epost.",
      cta_title: "Använd en anpassad domän",
      cta_subtitle: "Lyft ditt varumärke och dela med förtroende",
      cta_feature1: "Din egen anpassade domän",
      cta_feature2: "Obegränsad hemlig delning",
      cta_feature3: "Avancerade integritetskontroller",
      explore_premium_plans: "Utforska Premium-planer",
      need_free_account: "Precis börjat?",
      sign_up_free: "Skapa ett gratis konto"
    },
    "private": {
      pretext: "Dela denhär länken:",
      requires_passphrase: "Kräver ett lösenord.",
      this_msg_is_encrypted: "Dethär meddelantet är krypterat med ditt lösenord.",
      only_see_once: "su kan bara se det EN gång"
    },
    shared: {
      requires_passphrase: "Dethär meddelandet kräver ett lösenord:",
      viewed_own_secret: "Du titta på din egna hemlighet, vilket räknas som en visning som gör så att personen du tänkte skika den till inte längre kan se den.",
      you_created_this_secret: "Du skapade denna hemlighet, om du tittar på den kommer personen du tänkte dela den med inte kunna se den.",
      your_secret_message: "Ditt hemliga meddelande:",
      this_message_for_you: "Dethär meddelander är till dig:",
      reply_with_secret: "Svara ,med ett annat hemligt meddelande"
    },
    dashboard: {
      title_received: "Mottagen",
      title_not_received: "Inte mottagen",
      title_no_recent_secrets: "Du har inte haft några hemligheter på senaste"
    },
    login: {
      need_an_account: "Behöver du ett konto?",
      forgot_your_password: "Glömt lösenordet?",
      button_sign_in: "Logga in",
      enter_your_credentials: "Skriv in dina uppgifter"
    },
    incoming: {
      tagline1: "Klistra in lösenord, hemligt meddelande eller en hemlig länk nedan.",
      tagline2: "Dela känslig information utan att behöva skriva det i Epost eller chattar.",
      secret_hint: "* En hemlig länk fungerar bara en gång och försvinner sedan för alltid!.",
      incoming_button_create: "Skika till it stödet(Obs: när översättningen skrivs finns stödet inte tillgänlig på svenska)",
      incoming_secret_options: "Information om it stödet",
      incoming_secret_placeholder: "Enter any information your support representative will need (e.g. system password)",
      incoming_ticket_number: "Enter Ticket #",
      incoming_ticket_number_hint: "You can find this in your email (e.g. 123456)",
      incoming_recipient_address: "Support recipient",
      incoming_success_message: "Your email has been sent"
    }
  };
  const email$3 = {
    incomingsupport: {
      subject: "[Ticket: %s]",
      body1: "A customer has sent the following info"
    },
    secretlink: {
      subject: "%s sent you a secret",
      body1: "We have a secret for you from",
      body_tagline: "If you don't know the sender or believe it to be spam, send us the details here:"
    },
    welcome: {
      subject: "Verify your Onetime Secret account",
      body1: "Välkommen till Onetime Secret(hemlighet du bara kan läsa en gång). Vi har en hemlighet till dig!",
      please_verify: "Var vänligt och verifiera att det är du:",
      postscript1: "Det här meddelanter har skickats till dig",
      postscript2: "Ifall du inte har gjord detta så ska du radera meddelandet, vi kommer inte kontakta dig igen."
    }
  };
  const sv_SE = {
    web: web$3,
    email: email$3
  };
  const sv_SE$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: sv_SE,
    email: email$3,
    web: web$3
  }, Symbol.toStringTag, { value: "Module" }));
  const web$2 = {
    COMMON: {
      broadcast: "",
      description: "Hassas bilgilerinizi sohbet geçmişinizde veya e-postalarınızda saklamayın. Sadece tek seferlik gizli bir link ile paylaşın.",
      keywords: "gizli,parola oluşturucu,sır paylaş,tek seferlik",
      button_create_secret: "Gizli link yarat",
      button_generate_secret: "Veya rastgele parola oluştur",
      secret_privacy_options: "Gizlilik Ayarları",
      secret_passphrase: "Parola",
      secret_passphrase_hint: "Tahmin edilmesi zor bir kelime veya cümle",
      secret_recipient_address: "Alıcı Adresi",
      secret_placeholder: "Gizli içerik...",
      header_create_account: "Hesap Oluştur",
      header_about: "Hakkında",
      header_sign_in: "Giriş Yap",
      header_dashboard: "Hesabım",
      header_logout: "Çıkış",
      secret: "Gizli Mesaj",
      received: "Alınan",
      burned: "Yakılan",
      expires_in: "Kalan zaman",
      burn_this_secret: "Bu gizli mesajı yak",
      burn_this_secret_hint: "Gizli mesajı yakmak onu okunmadan önce siler (onaylamak için tıkla)",
      burn_this_secret_confirm_hint: "Gizli mesajı yakmak kalıcıdır ve geri alınamaz",
      msg_check_email: "E-postanı kontrol et",
      click_to_continue: "Devam etmek için tıkla →",
      click_to_verify: "Hesabını doğrulamak için devam et:",
      error_secret: "Paylaşılacak birşey yazmadın",
      error_passphrase: "Yanlış parola",
      enter_passphrase_here: "Parolayı buraya yaz",
      view_secret: "Gizli Mesajı Görüntüle",
      careful_only_see_once: "dikkat: sadece bir defa gösterilecek.",
      warning: "Uyarı",
      oops: "Eyvah!",
      error: "Hata",
      secret_was_truncated: "Fazla uzun olduğu için mesaj kısaltıldı",
      signup_for_more: "Daha fazlası için kaydol",
      login_to_your_account: "Hesabına giriş yap",
      sent_to: "Alıcı(lar): ",
      field_email: "E-posta",
      field_password: "Parola",
      field_password2: "Parolayı Doğrula",
      button_create_account: "Hesap Oluştur",
      share_a_secret: "Gizli Mesaj paylaş",
      title_home: "Ana Sayfa",
      title_recent_secrets: "En Son Gizli Mesajlar",
      word_none: "Hiç",
      word_burned: "yakılan",
      word_received: "alınan",
      word_confirm: "Onayla",
      word_cancel: "İptal",
      feedback_text: "Sorunuz veya yorumunuz mu var?",
      button_send_feedback: "Geribildirim Yolla",
      verification_sent_to: "Doğrulama mesajı gönderilen adres"
    },
    homepage: {
      tagline1: "Aşağıya bir parola, gizli mesaj veya gizli link yapıştırın.",
      tagline2: "Hassas bilgilerinizi sohbet geçmişinizde veya e-postalarınızda saklamayın.",
      secret_hint: "* Gizli linkler sadece bir defa çalışır ve ardından sonsuza dek yok olur.",
      secret_form_more_text1: "Bedava hesap",
      secret_form_more_text2: "için kaydol",
      secret_form_more_text3: "ve daha fazla gizlilik seçeneğine sahip daha güvenli parolalar oluştur. İsterseniz sizin için linki e-posta aracılığıyla bile yollayabiliriz.",
      cta_title: "Özel Alan Adı Kullanın",
      cta_subtitle: "Markanızı yükseltin ve güvenle paylaşın",
      cta_feature1: "Kendi özel alan adınız",
      cta_feature2: "Sınırsız gizli paylaşım",
      cta_feature3: "Gelişmiş gizlilik kontrolleri",
      explore_premium_plans: "Premium Planları Keşfedin",
      need_free_account: "Yeni mi başlıyorsunuz?",
      sign_up_free: "Ücretsiz hesap oluşturun"
    },
    "private": {
      pretext: "Bu linki paylaş:",
      requires_passphrase: "Parola gerektirir.",
      this_msg_is_encrypted: "Bu mesaj parolan ile şifrelenmiştir.",
      only_see_once: "bunu sadece bir defa göreceksin"
    },
    shared: {
      requires_passphrase: "Bu mesaj parola gerektirir:",
      viewed_own_secret: "Kendi gizli mesajını açtın. Onu artık başka kimse göremeyecek.",
      you_created_this_secret: "Bu linki sen oluşturdun. Eğer onu açarsan, alıcı artık onu göremez.",
      your_secret_message: "Gizli mesajın:",
      this_message_for_you: "Bu mesaj senin için:",
      reply_with_secret: "Başka bir gizli mesajla yanıtla"
    },
    dashboard: {
      title_received: "Alınan",
      title_not_received: "Alınmayan",
      title_no_recent_secrets: "Yeni gizli mesaj yok"
    },
    login: {
      need_an_account: "Hesap mı lazım?",
      forgot_your_password: "Şifreni mi unuttun?",
      button_sign_in: "Giriş Yap",
      enter_your_credentials: "Giriş bilgilerini yaz"
    },
    incoming: {
      tagline1: "Aşağıya bir parola, gizli mesaj veya gizli link yapıştırın.",
      tagline2: "Hassas bilgilerinizi sohbet geçmişinizde veya e-postalarınızda saklamayın.",
      secret_hint: "* Gizli linkler sadece bir defa çalışır ve ardından sonsuza dek yok olur.",
      incoming_button_create: "Destek Ekibine yolla",
      incoming_secret_options: "Destek Bilgisi",
      incoming_secret_placeholder: "Destek temsilcinin ihtiyacı olan bilgileri yaz (örn. sistem parolası)",
      incoming_ticket_number: "Bilet Numarasını Yaz",
      incoming_ticket_number_hint: "Bunu e-postanda bulabilirsin (örn. 123456)",
      incoming_recipient_address: "Destek alıcısı",
      incoming_success_message: "E-postan gönderildi"
    }
  };
  const email$2 = {
    incomingsupport: {
      subject: "[Bilet: %s]",
      body1: "Bir müşteri şu bilgileri gönderdi"
    },
    secretlink: {
      subject: "%s sana bir gizli mesaj yolladı",
      body1: "Senin için bir gizli mesaj gönderdi, ",
      body_tagline: "Eğer göndereni tanımıyorsanız veya spam olduğunu düşünüyorsanız, detayları şurdan bize yollayın:"
    },
    welcome: {
      subject: "Onetime Secret hesabınızı doğrulayın",
      body1: "Onetime Secret'a hoşgeldiniz. Sizin için bir gizli mesajımız var!",
      please_verify: "Lütfen hesabınızı doğrulayın:",
      postscript1: "Bu e-posta şu adrese yolandı",
      postscript2: "Eğer bu hesabı siz oluşturmadıysanız, bu mesajı silin ve sizi bir daha rahatsız etmeyeceğiz."
    }
  };
  const tr = {
    web: web$2,
    email: email$2
  };
  const tr$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: tr,
    email: email$2,
    web: web$2
  }, Symbol.toStringTag, { value: "Module" }));
  const web$1 = {
    COMMON: {
      broadcast: "",
      description: "Тримайте конфіденційну інформацію поза своїми чатами та електронною поштою. Поділіться секретним посиланням, яке доступне лише один раз.",
      keywords: "секрет,генератор паролів,поділитися секретом,одноразовий",
      button_create_secret: "Створити секретне посилання",
      button_generate_secret: "Або згенерувати випадковий пароль",
      secret_privacy_options: "Налаштування конфіденційності",
      secret_passphrase: "Парольна фраза",
      secret_passphrase_hint: "Слово або фраза, яку важко вгадати",
      secret_recipient_address: "Адреса отримувача",
      secret_placeholder: "Секретний вміст пишеться тут...",
      header_create_account: "Створити обліковий запис",
      header_about: "Про нас",
      header_sign_in: "Увійти",
      header_dashboard: "Обліковий запис",
      header_logout: "Вийти",
      secret: "Секрет",
      received: "Отримано",
      burned: "Знищено",
      expires_in: "Закінчується через",
      burn_this_secret: "Знищити цей секрет",
      burn_this_secret_hint: "Знищення секрету видалить його до того, як його прочитають (натисніть для підтвердження)",
      burn_this_secret_confirm_hint: "Знищення секрету є постійним і не може бути скасовано",
      msg_check_email: "Перевірте свою електронну пошту",
      click_to_continue: "Натисніть, щоб продовжити →",
      click_to_verify: "Продовжіть, щоб підтвердити ваш обліковий запис:",
      error_secret: "Ви не надали нічого для обміну",
      error_passphrase: "Перевірте ще раз цю парольну фразу",
      enter_passphrase_here: "Введіть парольну фразу тут",
      view_secret: "Переглянути секрет",
      careful_only_see_once: "обережно: ми покажемо це лише один раз.",
      warning: "Попередження",
      oops: "Упс!",
      error: "Помилка",
      secret_was_truncated: "Повідомлення було скорочено, оскільки воно перевищувало",
      signup_for_more: "Зареєструйтеся для більшого",
      login_to_your_account: "Увійдіть у свій обліковий запис",
      sent_to: "Надіслано до: ",
      field_email: "Електронна пошта",
      field_password: "Пароль",
      field_password2: "Підтвердити пароль",
      button_create_account: "Створити обліковий запис",
      share_a_secret: "Поділитися секретом",
      title_home: "Головна",
      title_recent_secrets: "Недавні секрети",
      word_none: "Немає",
      word_burned: "знищено",
      word_received: "отримано",
      word_confirm: "Підтвердити",
      word_cancel: "Скасувати",
      feedback_text: "Маєте питання чи коментар?",
      button_send_feedback: "Надіслати відгук",
      verification_sent_to: "Підтвердження було надіслано на"
    },
    homepage: {
      tagline1: "Вставте пароль, секретне повідомлення або приватне посилання нижче.",
      tagline2: "Тримайте конфіденційну інформацію поза вашою електронною поштою та журналами чату.",
      secret_hint: "* Секретне посилання працює лише один раз, а потім зникає назавжди.",
      secret_form_more_text1: "Зареєструйтеся для",
      secret_form_more_text2: "безкоштовного облікового запису",
      secret_form_more_text3: "і зможете надсилати секрет електронною поштою.",
      cta_title: "Використовуйте власний домен",
      cta_subtitle: "Підніміть свій бренд та діліться з впевненістю",
      cta_feature1: "Ваш власний налаштований домен",
      cta_feature2: "Необмежений обмін секретами",
      cta_feature3: "Розширені налаштування конфіденційності",
      explore_premium_plans: "Дослідіть преміум-плани",
      need_free_account: "Тільки починаєте?",
      sign_up_free: "Створити безкоштовний обліковий запис"
    },
    "private": {
      pretext: "Поділіться цим посиланням:",
      requires_passphrase: "Потрібна парольна фраза.",
      this_msg_is_encrypted: "Це повідомлення зашифровано вашою парольною фразою.",
      only_see_once: "ви побачите це лише один раз"
    },
    shared: {
      requires_passphrase: "Це повідомлення вимагає парольної фрази:",
      viewed_own_secret: "Ви переглянули свій власний секрет. Він більше не доступний для інших.",
      you_created_this_secret: "Ви створили цей секрет. Якщо ви його переглянете, отримувач не зможе його побачити.",
      your_secret_message: "Ваше секретне повідомлення:",
      this_message_for_you: "Це повідомлення для вас:",
      reply_with_secret: "Відповісти іншим секретом"
    },
    dashboard: {
      title_received: "Отримано",
      title_not_received: "Не отримано",
      title_no_recent_secrets: "Немає недавніх секретів"
    },
    login: {
      need_an_account: "Потрібен обліковий запис?",
      forgot_your_password: "Забули пароль?",
      button_sign_in: "Увійти",
      enter_your_credentials: "Введіть свої облікові дані"
    },
    incoming: {
      tagline1: "Вставте пароль, секретне повідомлення або приватне посилання нижче.",
      tagline2: "Тримайте конфіденційну інформацію поза вашою електронною поштою та журналами чату.",
      secret_hint: "* Секретне посилання працює лише один раз, а потім зникає назавжди.",
      incoming_button_create: "Надіслати в службу підтримки",
      incoming_secret_options: "Інформація для підтримки",
      incoming_secret_placeholder: "Введіть будь-яку інформацію, яка буде потрібна вашому представнику підтримки (наприклад, системний пароль)",
      incoming_ticket_number: "Введіть номер звернення #",
      incoming_ticket_number_hint: "Ви можете знайти це у своїй електронній пошті (наприклад, 123456)",
      incoming_recipient_address: "Отримувач підтримки",
      incoming_success_message: "Ваш електронний лист надіслано"
    }
  };
  const email$1 = {
    incomingsupport: {
      subject: "[Звернення: %s]",
      body1: "Клієнт надіслав наступну інформацію"
    },
    secretlink: {
      subject: "%s надіслав вам секрет",
      body1: "У нас є секрет для вас від",
      body_tagline: "Якщо ви не знаєте відправника або вважаєте, що це спам, надішліть нам деталі тут:"
    },
    welcome: {
      subject: "Підтвердіть свій обліковий запис Onetime Secret",
      body1: "Ласкаво просимо до Onetime Secret. У нас є секрет для вас!",
      please_verify: "Будь ласка, підтвердіть свій обліковий запис:",
      postscript1: "Цей електронний лист було надіслано на",
      postscript2: "Якщо ви не робили цього запиту, ви можете безпечно проігнорувати цей електронний лист."
    }
  };
  const uk = {
    web: web$1,
    email: email$1
  };
  const uk$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: uk,
    email: email$1,
    web: web$1
  }, Symbol.toStringTag, { value: "Module" }));
  const web = {
    COMMON: {
      broadcast: "",
      description: "Chia sẽ link dùng một lần (chỉ mở được một lần) để tránh lưu lại những thông tin nhạy cảm trong lịch sử trò chuyện hoặc email của bạn.",
      keywords: "secret,password generator,share a secret,onetime",
      button_create_secret: "Tạo link bí mật",
      button_generate_secret: "Hoặc tạo ra một mật khẩu ngẫu nhiên",
      secret_privacy_options: "Tùy chọn quyền riêng tư",
      secret_passphrase: "Cụm mật khẩu",
      secret_passphrase_hint: "Một từ hoặc đoạn văn khó để đoán được",
      secret_recipient_address: "Địa chỉ người nhận",
      secret_placeholder: "Nội dung bí mật ở đây...",
      header_create_account: "Tạo tài khoản",
      header_about: "Về chúng tôi",
      header_sign_in: "Đăng nhập",
      header_dashboard: "Tài khoản",
      header_logout: "Đăng xuất",
      secret: "Bí mật",
      received: "Đã nhận",
      burned: "Đã hủy",
      expires_in: "Hết hạn trong",
      burn_this_secret: "Hủy thông tin bí mật này",
      burn_this_secret_hint: "Hủy một thông tin bí mật có nghĩa là xóa những thông tin đó đi trước khi nó được đọc bởi ai đó (nhấn để xác nhận)",
      burn_this_secret_confirm_hint: "Việc hủy thông tin bí mật sẽ không thể hoàn tác",
      msg_check_email: "Kiểm tra email của bạn",
      click_to_continue: "Nhấn để tiếp tục →",
      click_to_verify: "Tiếp tục để xác nhận tài khoản của bạn:",
      error_secret: "Dường như bạn chưa nhập thông tin nào cả",
      error_passphrase: "Vui lòng kiểm tra lại cụm mật khẩu",
      enter_passphrase_here: "Nhập cụm mật khẩu ở đây nè",
      view_secret: "Xem thông tin bí mật",
      careful_only_see_once: "Cẩn thận: chúng tôi chỉ hiện thông tin này một lần thôi nhé.",
      warning: "Cảnh báo",
      oops: "Trời ơi!",
      error: "Lỗi rồi",
      secret_was_truncated: "Nội dung tin nhắn đã được cắt bớt, bởi vì nó quá dài",
      signup_for_more: "Đăng nhập để có nhiều tính năng hơn",
      login_to_your_account: "Đăng nhập vào tài khoản của bạn",
      sent_to: "Gởi tới: ",
      field_email: "Email",
      field_password: "Mật khẩu",
      field_password2: "Xác nhận mật khẩu",
      button_create_account: "Tạo tài khoản",
      share_a_secret: "Chia sẽ thông tin bí mật",
      title_home: "Trang chủ",
      title_recent_secrets: "Những bí mật gần đây",
      word_none: "rỗng",
      word_burned: "đã hủy",
      word_received: "đã nhận",
      word_confirm: "Xác nhận",
      word_cancel: "Hủy bỏ",
      feedback_text: "Bạn có câu hỏi hoặc góp ý gì không?",
      button_send_feedback: "Gởi phản hồi",
      verification_sent_to: "Có một yêu cầu xác nhận đã được gởi tới"
    },
    homepage: {
      tagline1: "Dán một mật khẩu, thông tin bí mật hoặc một đường dẫn riêng tư ở phía dưới.",
      tagline2: "Tránh lưu lại những thông tin nhạy cảm ở email hoặc lịch sử trò chuyện.",
      secret_hint: "* Link bí mật chỉ hoạt động duy nhất một lần và sau đó nó sẽ biến mất vĩnh viễn.",
      secret_form_more_text1: "Đăng nhập để",
      secret_form_more_text2: "tài khoản miễn phí",
      secret_form_more_text3: "và có thể gởi bí mật bằng email.",
      cta_title: "Sử dụng tên miền tùy chỉnh",
      cta_subtitle: "Nâng tầm thương hiệu và chia sẻ một cách tự tin",
      cta_feature1: "Tên miền tùy chỉnh của riêng bạn",
      cta_feature2: "Chia sẻ bí mật không giới hạn",
      cta_feature3: "Kiểm soát quyền riêng tư nâng cao",
      explore_premium_plans: "Khám phá các gói Premium",
      need_free_account: "Mới bắt đầu?",
      sign_up_free: "Tạo tài khoản miễn phí"
    },
    "private": {
      pretext: "Chia sẽ liên kết này:",
      requires_passphrase: "Yêu cầu một cụm mật khẩu.",
      this_msg_is_encrypted: "Tin nhắn này được mã hóa bằng cụm mật khẩu của bạn.",
      only_see_once: "bạn chỉ nhìn thấy nó một lần thôi"
    },
    shared: {
      requires_passphrase: "Tin nhắn này cần phải có một cụm mật khẩu:",
      viewed_own_secret: "Bạn đã xem nội dung bí mật này rồi. Sẽ không ai thấy được nó nữa.",
      you_created_this_secret: "Bạn đã tạo bí mật này. Nếu bạn mở nó ra, người khác sẽ không thể thấy nó nữa.",
      your_secret_message: "Tin nhắn bí mật của bạn:",
      this_message_for_you: "Tin nhắn này dành cho bạn:",
      reply_with_secret: "Trả lời lại với một bí mật khác"
    },
    dashboard: {
      title_received: "Đã nhận",
      title_not_received: "Chưa nhận",
      title_no_recent_secrets: "Không có bí mật nào ở đây cả"
    },
    login: {
      need_an_account: "Cần một tại khoản?",
      forgot_your_password: "Quên mật khẩu?",
      button_sign_in: "Đăng nhập",
      enter_your_credentials: "Nhập mật thông tin xác thực"
    },
    incoming: {
      tagline1: "Dán một mật khẩu, thông tin bí mật hoặc một đường dẫn riêng tư ở phía dưới.",
      tagline2: "Tránh lưu lại những thông tin nhạy cảm ở email hoặc lịch sử trò chuyện.",
      secret_hint: "* Link bí mật chỉ hoạt động duy nhất một lần và sau đó nó sẽ biến mất vĩnh viễn.",
      incoming_button_create: "Gởi tới bộ bận hỗ trợ",
      incoming_secret_options: "Thông tin hỗ trợ",
      incoming_secret_placeholder: "Nhập bất cứ thông tin nào mà bạn nghĩ bộ phận hỗ trợ sẽ cần (vd: mật khẩu hệ thống)",
      incoming_ticket_number: "Nhập mã hỗ trợ (ticket) #",
      incoming_ticket_number_hint: "Bạn có thể tìm thấy nó ở trong email của bạn (v.d. 123456)",
      incoming_recipient_address: "Người hỗ trợ",
      incoming_success_message: "Email của bạn đã được gởi đi"
    }
  };
  const email = {
    incomingsupport: {
      subject: "[Ticket: %s]",
      body1: "Có một khách hàng đã gởi thông tin sau"
    },
    secretlink: {
      subject: "%s gởi cho bạn một bí mật",
      body1: "Chúng tôi có một bí mật cho bạn, từ",
      body_tagline: "Nếu bạn không biết ai gởi hoặc nghĩ đây là spam, hãy gởi cho chúng tôi chi tiết ở đây:"
    },
    welcome: {
      subject: "Xác thực tài khoản Onetime Secret",
      body1: "Chào mừng đến với Onetime Secret. Chúng tôi có một bí mật dành cho bạn!",
      please_verify: "Vui lòng xác nhận tài khoản:",
      postscript1: "Email này đã được gởi tới",
      postscript2: "Nếu bạn không tạo tài khoản này, vui lòng xóa tin nhắn này đi, chúng tôi sẽ không làm phiền bạn nữa."
    }
  };
  const vi = {
    web,
    email
  };
  const vi$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: vi,
    email,
    web
  }, Symbol.toStringTag, { value: "Module" }));
  const _hoisted_1$A = { class: "px-4 py-5 sm:p-4" };
  const _sfc_main$B = /* @__PURE__ */ defineComponent({
    __name: "MoreInfoText",
    props: {
      textColor: { default: "text-brandcomp-800 dark:text-gray-100" },
      bgColor: { default: "bg-white dark:bg-gray-800" }
    },
    setup(__props) {
      const isExpanded = ref(false);
      const toggleExpand = (event) => {
        event.preventDefault();
        isExpanded.value = !isExpanded.value;
      };
      const props = __props;
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", {
          class: normalizeClass(`mb-4 ${props.bgColor} shadow sm:rounded-lg relative`)
        }, [
          createBaseVNode("div", _hoisted_1$A, [
            createBaseVNode("button", {
              onClick: toggleExpand,
              class: normalizeClass(`flex items-center text-base font-medium ${props.textColor} hover:text-brandcomp-600 dark:hover:text-brandcomp-400 focus:outline-none`)
            }, [
              createVNode(unref(Icon), {
                icon: isExpanded.value ? "heroicons:chevron-down" : "heroicons:chevron-right",
                class: "h-5 w-5 mr-2"
              }, null, 8, ["icon"]),
              createTextVNode(" " + toDisplayString(isExpanded.value ? "Hide details" : "Expand for more info"), 1)
            ], 2),
            withDirectives(createBaseVNode("div", {
              class: normalizeClass(["absolute left-4 right-4 mt-2 bg-gray-50 dark:bg-gray-700 shadow-lg rounded-lg overflow-hidden transition-all duration-300 ease-in-out z-10 border border-gray-200 dark:border-gray-600", { "max-h-0": !isExpanded.value, "max-h-[500px]": isExpanded.value }])
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2), [
              [vShow, isExpanded.value]
            ])
          ])
        ], 2);
      };
    }
  });
  const _hoisted_1$z = { class: "relative inline-block" };
  const _hoisted_2$w = ["aria-label"];
  const _hoisted_3$r = {
    key: 0,
    class: "w-5 h-5",
    fill: "none",
    stroke: "currentColor",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  };
  const _hoisted_4$o = /* @__PURE__ */ createBaseVNode("path", {
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "2",
    d: "M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"
  }, null, -1);
  const _hoisted_5$o = [
    _hoisted_4$o
  ];
  const _hoisted_6$k = {
    key: 1,
    class: "w-5 h-5 text-green-500",
    fill: "none",
    stroke: "currentColor",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  };
  const _hoisted_7$g = /* @__PURE__ */ createBaseVNode("path", {
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "2",
    d: "M5 13l4 4L19 7"
  }, null, -1);
  const _hoisted_8$f = [
    _hoisted_7$g
  ];
  const _hoisted_9$h = {
    key: 0,
    class: "absolute z-10 px-2 py-1 text-sm text-white bg-gray-900 rounded-md bottom-full left-1/2 transform -translate-x-1/2 -translate-y-2"
  };
  const _sfc_main$A = /* @__PURE__ */ defineComponent({
    __name: "CopyButton",
    props: {
      text: { default: "" },
      interval: { default: 2e3 }
    },
    setup(__props) {
      const props = __props;
      const copied = ref(false);
      const showTooltip = ref(false);
      const copyToClipboard = () => {
        navigator.clipboard.writeText(props.text).then(() => {
          copied.value = true;
          showTooltip.value = true;
          setTimeout(() => {
            copied.value = false;
            showTooltip.value = false;
          }, props.interval);
        });
      };
      onBeforeUnmount(() => {
      });
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$z, [
          createBaseVNode("button", {
            onClick: copyToClipboard,
            onMouseenter: _cache[0] || (_cache[0] = ($event) => showTooltip.value = true),
            onMouseleave: _cache[1] || (_cache[1] = ($event) => showTooltip.value = false),
            class: "text-gray-600 hover:text-gray-900 dark:text-gray-400 dark:hover:text-white focus:outline-none",
            "aria-label": copied.value ? "Copied" : "Copy to clipboard"
          }, [
            !copied.value ? (openBlock(), createElementBlock("svg", _hoisted_3$r, _hoisted_5$o)) : (openBlock(), createElementBlock("svg", _hoisted_6$k, _hoisted_8$f))
          ], 40, _hoisted_2$w),
          showTooltip.value ? (openBlock(), createElementBlock("div", _hoisted_9$h, toDisplayString(copied.value ? "Copied!" : "Copy to clipboard"), 1)) : createCommentVNode("", true)
        ]);
      };
    }
  });
  const _hoisted_1$y = { class: "flex bg-white dark:bg-gray-600 rounded-md" };
  const _hoisted_2$v = {
    class: "w-16 flex-shrink-0 flex items-center justify-end px-3 py-2 bg-gray-100 dark:bg-gray-700 border-r border-gray-200 dark:border-gray-500",
    ref: "labelContainerRef"
  };
  const _hoisted_3$q = { class: "flex-grow flex items-center p-3" };
  const _hoisted_4$n = { class: "flex-grow min-w-0 mr-2" };
  const _hoisted_5$n = { class: "text-gray-800 dark:text-gray-200 block truncate" };
  const _hoisted_6$j = {
    key: 0,
    class: "text-gray-400"
  };
  const _hoisted_7$f = { class: "flex-shrink-0" };
  const _sfc_main$z = /* @__PURE__ */ defineComponent({
    __name: "DetailField",
    props: {
      label: {},
      value: {},
      appendix: {}
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$y, [
          createBaseVNode("div", _hoisted_2$v, [
            createBaseVNode("span", {
              class: "text-sm font-medium text-gray-500 dark:text-gray-300",
              ref: "labelRef"
            }, toDisplayString(_ctx.label) + ":", 513)
          ], 512),
          createBaseVNode("div", _hoisted_3$q, [
            createBaseVNode("div", _hoisted_4$n, [
              createBaseVNode("span", _hoisted_5$n, [
                createTextVNode(toDisplayString(_ctx.value), 1),
                _ctx.appendix ? (openBlock(), createElementBlock("span", _hoisted_6$j, toDisplayString(_ctx.appendix), 1)) : createCommentVNode("", true)
              ])
            ]),
            createBaseVNode("div", _hoisted_7$f, [
              createVNode(_sfc_main$A, { text: _ctx.value }, null, 8, ["text"])
            ])
          ])
        ]);
      };
    }
  });
  const _hoisted_1$x = { class: "max-w-2xl mx-auto p-6 bg-white dark:bg-gray-800 rounded-xl shadow-lg" };
  const _hoisted_2$u = { class: "space-y-6 mb-8" };
  const _hoisted_3$p = { class: "bg-gray-50 dark:bg-gray-700 p-4 rounded-lg" };
  const _hoisted_4$m = /* @__PURE__ */ createBaseVNode("h3", { class: "font-semibold text-lg mb-2 text-gray-800 dark:text-white" }, "1. Create a TXT record", -1);
  const _hoisted_5$m = /* @__PURE__ */ createBaseVNode("p", { class: "mb-2 text-gray-600 dark:text-gray-300" }, "Add this hostname to your DNS configuration:", -1);
  const _hoisted_6$i = { class: "space-y-2" };
  const _hoisted_7$e = { class: "bg-gray-50 dark:bg-gray-700 p-4 rounded-lg" };
  const _hoisted_8$e = /* @__PURE__ */ createBaseVNode("h3", { class: "font-semibold text-lg mb-2 text-gray-800 dark:text-white" }, "2. Create the A record", -1);
  const _hoisted_9$g = { class: "space-y-2" };
  const _hoisted_10$f = /* @__PURE__ */ createBaseVNode("li", { class: "bg-gray-50 dark:bg-gray-700 p-4 rounded-lg" }, [
    /* @__PURE__ */ createBaseVNode("h3", { class: "font-semibold text-lg mb-2 text-gray-800 dark:text-white" }, "3. Wait for propagation"),
    /* @__PURE__ */ createBaseVNode("p", { class: "text-gray-600 dark:text-gray-300" }, "DNS changes can take as little as 60 seconds -- or up to 24 hours -- to take effect.")
  ], -1);
  const _hoisted_11$g = ["disabled"];
  const _hoisted_12$d = { class: "mt-5 flex items-start bg-white dark:bg-gray-800 p-4 rounded-md" };
  const _hoisted_13$d = /* @__PURE__ */ createBaseVNode("p", { class: "text-sm text-gray-500 dark:text-gray-400" }, " It may take a few minutes for your SSL certificate to take effect once you've pointed your DNS A record. ", -1);
  const _sfc_main$y = /* @__PURE__ */ defineComponent({
    __name: "VerifyDomainDetails",
    props: {
      domain: { default: () => ({}) },
      cluster: { default: () => ({}) },
      withVerifyCTA: { type: Boolean, default: false }
    },
    emits: ["domainVerify"],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emit2 = __emit;
      const { isSubmitting, error, success, submitForm } = useFormSubmission({
        url: `/api/v2/account/domains/${props.domain.display_domain}/verify`,
        successMessage: "Domain verification initiated successfully.",
        getFormData: () => new URLSearchParams({
          domain: props.domain.display_domain
        }),
        onSuccess: (data) => {
          console.log("Verification initiated:", data);
          emit2("domainVerify", data);
        },
        onError: (data) => {
          console.error("Verification failed:", data);
        }
      });
      const buttonDisabledDelay = ref(false);
      const isButtonDisabled = computed(() => isSubmitting.value || buttonDisabledDelay.value);
      const verify = () => {
        console.info("Refreshing DNS verification details...");
        submitForm().finally(() => {
          buttonDisabledDelay.value = true;
          setTimeout(() => {
            buttonDisabledDelay.value = false;
          }, 1e4);
        });
      };
      return (_ctx, _cache) => {
        var _a, _b, _c;
        return openBlock(), createElementBlock("div", _hoisted_1$x, [
          createBaseVNode("ol", _hoisted_2$u, [
            createBaseVNode("li", _hoisted_3$p, [
              _hoisted_4$m,
              _hoisted_5$m,
              createBaseVNode("div", _hoisted_6$i, [
                createVNode(_sfc_main$z, {
                  label: "Type",
                  value: "TXT"
                }),
                createVNode(_sfc_main$z, {
                  label: "Host",
                  value: _ctx.domain.txt_validation_host,
                  appendix: `.${_ctx.domain.base_domain}`
                }, null, 8, ["value", "appendix"]),
                createVNode(_sfc_main$z, {
                  label: "Value",
                  value: _ctx.domain.txt_validation_value
                }, null, 8, ["value"])
              ])
            ]),
            createBaseVNode("li", _hoisted_7$e, [
              _hoisted_8$e,
              createBaseVNode("div", _hoisted_9$g, [
                createVNode(_sfc_main$z, {
                  label: "Type",
                  value: "A"
                }),
                createVNode(_sfc_main$z, {
                  label: "Host",
                  value: ((_a = _ctx.domain) == null ? void 0 : _a.trd) ? _ctx.domain.trd : "@",
                  appendix: `.${(_b = _ctx.domain) == null ? void 0 : _b.base_domain}`
                }, null, 8, ["value", "appendix"]),
                createVNode(_sfc_main$z, {
                  label: "Value",
                  value: (_c = _ctx.cluster) == null ? void 0 : _c.cluster_ip
                }, null, 8, ["value"])
              ])
            ]),
            _hoisted_10$f
          ]),
          createVNode(_sfc_main$Y, {
            success: unref(success),
            error: unref(error)
          }, null, 8, ["success", "error"]),
          _ctx.withVerifyCTA ? (openBlock(), createElementBlock("button", {
            key: 0,
            onClick: verify,
            disabled: isButtonDisabled.value,
            class: "w-full sm:w-auto px-6 py-3 text-lg font-semibold text-white bg-brand-500 disabled:bg-gray-400 disabled:cursor-not-allowed hover:bg-brand-600 rounded-lg transition duration-100 ease-in-out"
          }, toDisplayString(unref(isSubmitting) ? "Verifying..." : "Verify Domain"), 9, _hoisted_11$g)) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_12$d, [
            createVNode(unref(Icon), {
              icon: "mdi:information-outline",
              class: "h-5 w-5 text-brandcomp-700 mr-2 mt-0.5 flex-shrink-0",
              "aria-hidden": "true"
            }),
            _hoisted_13$d
          ])
        ]);
      };
    }
  });
  const _hoisted_1$w = {
    key: 1,
    class: "bg-white dark:bg-gray-800 shadow-md rounded-lg p-6 my-8"
  };
  const _hoisted_2$t = /* @__PURE__ */ createBaseVNode("h2", { class: "text-2xl font-bold mb-4 text-gray-900 dark:text-white" }, "Domain Status", -1);
  const _hoisted_3$o = { class: "flex flex-col" };
  const _hoisted_4$l = {
    key: 0,
    class: "grid grid-cols-1 sm:grid-cols-2 gap-4"
  };
  const _hoisted_5$l = { class: "flex flex-col" };
  const _hoisted_6$h = /* @__PURE__ */ createBaseVNode("span", { class: "text-sm font-medium text-gray-500 dark:text-gray-400" }, "Domain", -1);
  const _hoisted_7$d = { class: "text-lg text-gray-900 dark:text-white" };
  const _hoisted_8$d = { class: "flex flex-col" };
  const _hoisted_9$f = /* @__PURE__ */ createBaseVNode("span", { class: "text-sm font-medium text-gray-500 dark:text-gray-400" }, "Status", -1);
  const _hoisted_10$e = { class: "flex flex-col" };
  const _hoisted_11$f = /* @__PURE__ */ createBaseVNode("span", { class: "text-sm font-medium text-gray-500 dark:text-gray-400" }, "Target Address", -1);
  const _hoisted_12$c = { class: "text-lg text-gray-900 dark:text-white" };
  const _hoisted_13$c = { class: "flex flex-col" };
  const _hoisted_14$a = /* @__PURE__ */ createBaseVNode("span", { class: "text-sm font-medium text-gray-500 dark:text-gray-400" }, "A Record", -1);
  const _hoisted_15$a = { class: "text-lg text-gray-900 dark:text-white" };
  const _hoisted_16$9 = { class: "flex flex-col" };
  const _hoisted_17$a = /* @__PURE__ */ createBaseVNode("span", { class: "text-sm font-medium text-gray-500 dark:text-gray-400" }, "SSL Renews", -1);
  const _hoisted_18$8 = { class: "text-lg text-gray-900 dark:text-white" };
  const _hoisted_19$7 = { key: 0 };
  const _hoisted_20$6 = { class: "flex flex-col" };
  const _hoisted_21$5 = /* @__PURE__ */ createBaseVNode("span", { class: "text-sm font-medium text-gray-500 dark:text-gray-400" }, "SSL Status", -1);
  const _hoisted_22$5 = { class: "flex flex-col" };
  const _hoisted_23$3 = /* @__PURE__ */ createBaseVNode("span", { class: "text-sm font-medium text-gray-500 dark:text-gray-400" }, "Last Monitored", -1);
  const _hoisted_24$3 = { class: "text-lg text-gray-900 dark:text-white" };
  const _sfc_main$x = /* @__PURE__ */ defineComponent({
    __name: "DomainVerificationInfo",
    props: {
      domain: {},
      mode: {}
    },
    setup(__props) {
      const props = __props;
      const isActive = computed(() => {
        var _a, _b;
        return (_b = (_a = props.domain.vhost) == null ? void 0 : _a.status) == null ? void 0 : _b.includes("ACTIVE");
      });
      const isWarning2 = computed(() => {
        var _a;
        return ((_a = props.domain.vhost) == null ? void 0 : _a.status) === "DNS_INCORRECT";
      });
      const isError = computed(() => {
        return !isActive.value && !isWarning2.value;
      });
      const statusIcon = computed(() => {
        if (isActive.value) return "mdi:check-circle";
        if (isWarning2.value) return "mdi:alert-circle";
        return "mdi:close-circle";
      });
      const statusColor = computed(() => {
        if (isActive.value) return "text-green-600";
        if (isWarning2.value) return "text-yellow-600";
        return "text-red-600";
      });
      const formatDate = (dateString) => {
        const date = new Date(dateString);
        return new Intl.DateTimeFormat(void 0, {
          year: "numeric",
          month: "long",
          day: "numeric"
        }).format(date);
      };
      return (_ctx, _cache) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n2, _o, _p, _q, _r, _s;
        return openBlock(), createElementBlock("div", null, [
          _ctx.mode === "icon" ? (openBlock(), createBlock(unref(Icon), {
            key: 0,
            icon: statusIcon.value,
            class: normalizeClass([
              "w-5 h-5",
              { "text-green-600": isActive.value, "text-yellow-600": isWarning2.value, "text-red-600": isError.value }
            ])
          }, null, 8, ["icon", "class"])) : (openBlock(), createElementBlock("div", _hoisted_1$w, [
            _hoisted_2$t,
            createBaseVNode("div", _hoisted_3$o, [
              ((_a = _ctx.domain) == null ? void 0 : _a.vhost) ? (openBlock(), createElementBlock("div", _hoisted_4$l, [
                createBaseVNode("div", _hoisted_5$l, [
                  _hoisted_6$h,
                  createBaseVNode("span", _hoisted_7$d, toDisplayString((_c = (_b = _ctx.domain) == null ? void 0 : _b.vhost) == null ? void 0 : _c.incoming_address), 1)
                ]),
                createBaseVNode("div", _hoisted_8$d, [
                  _hoisted_9$f,
                  createBaseVNode("span", {
                    class: normalizeClass([statusColor.value, "text-lg"])
                  }, toDisplayString((_e = (_d = _ctx.domain) == null ? void 0 : _d.vhost) == null ? void 0 : _e.status_message), 3)
                ]),
                createBaseVNode("div", _hoisted_10$e, [
                  _hoisted_11$f,
                  createBaseVNode("span", _hoisted_12$c, toDisplayString((_g = (_f = _ctx.domain) == null ? void 0 : _f.vhost) == null ? void 0 : _g.target_address), 1)
                ]),
                createBaseVNode("div", _hoisted_13$c, [
                  _hoisted_14$a,
                  createBaseVNode("span", _hoisted_15$a, toDisplayString((_i = (_h = _ctx.domain) == null ? void 0 : _h.vhost) == null ? void 0 : _i.dns_pointed_at), 1)
                ]),
                createBaseVNode("div", _hoisted_16$9, [
                  _hoisted_17$a,
                  createBaseVNode("span", _hoisted_18$8, [
                    ((_k = (_j = _ctx.domain) == null ? void 0 : _j.vhost) == null ? void 0 : _k.ssl_active_until) ? (openBlock(), createElementBlock("span", _hoisted_19$7, toDisplayString(formatDate((_m = (_l = _ctx.domain) == null ? void 0 : _l.vhost) == null ? void 0 : _m.ssl_active_until)), 1)) : createCommentVNode("", true)
                  ])
                ]),
                createBaseVNode("div", _hoisted_20$6, [
                  _hoisted_21$5,
                  createBaseVNode("span", {
                    class: normalizeClass(["text-lg", ((_o = (_n2 = _ctx.domain) == null ? void 0 : _n2.vhost) == null ? void 0 : _o.has_ssl) ? "text-green-600" : "text-red-600"])
                  }, toDisplayString(((_q = (_p = _ctx.domain) == null ? void 0 : _p.vhost) == null ? void 0 : _q.has_ssl) ? "Active" : "Inactive"), 3)
                ]),
                createBaseVNode("div", _hoisted_22$5, [
                  _hoisted_23$3,
                  createBaseVNode("span", _hoisted_24$3, toDisplayString((_s = (_r = _ctx.domain) == null ? void 0 : _r.vhost) == null ? void 0 : _s.last_monitored_humanized), 1)
                ])
              ])) : createCommentVNode("", true)
            ])
          ]))
        ]);
      };
    }
  });
  const _hoisted_1$v = { class: "" };
  const _hoisted_2$s = /* @__PURE__ */ createBaseVNode("h1", { class: "text-3xl font-bold mb-6 text-gray-900 dark:text-white" }, "Verify your domain", -1);
  const _hoisted_3$n = {
    key: 1,
    class: "text-lg mb-6 text-gray-600 dark:text-gray-300"
  };
  const _hoisted_4$k = { class: "bg-white dark:bg-gray-800 text-brand-600 dark:text-brand-400" };
  const _hoisted_5$k = { class: "px-6 py-6" };
  const _hoisted_6$g = { class: "max-w-xl text-base text-gray-600 dark:text-gray-300" };
  const _hoisted_7$c = { class: "font-bold bg-white dark:bg-gray-800 px-2 text-brand-600 dark:text-brand-400" };
  const _hoisted_8$c = ["title"];
  const _hoisted_9$e = ["title"];
  const _hoisted_10$d = /* @__PURE__ */ createBaseVNode("div", { class: "mt-4 text-sm" }, [
    /* @__PURE__ */ createBaseVNode("a", {
      href: "#",
      class: "font-medium text-brandcomp-600 hover:text-brandcomp-500 dark:text-brandcomp-400 dark:hover:text-brandcomp-300"
    })
  ], -1);
  const _hoisted_11$e = {
    key: 3,
    class: "text-gray-600 dark:text-gray-400"
  };
  const _sfc_main$w = /* @__PURE__ */ defineComponent({
    __name: "AccountDomainVerify",
    setup(__props) {
      const route = useRoute();
      const domain = ref(null);
      const cluster = ref(null);
      console.log("VerifyDomain.ts", route.params.domain);
      const fetchDomain = async () => {
        var _a, _b;
        const domainName = route.params.domain;
        try {
          const response = await fetch(`/api/v2/account/domains/${domainName}`);
          if (!response.ok) {
            throw new Error("Failed to fetch domain information");
          }
          const json = await response.json();
          console.debug("json", json);
          domain.value = json.record;
          if (json.details) {
            cluster.value = (_a = json.details) == null ? void 0 : _a.cluster;
          }
          const currentTime = Math.floor(Date.now() / 1e3);
          const last_monitored_unix = ((_b = domain.value) == null ? void 0 : _b.updated) || currentTime;
          if (last_monitored_unix) {
            const timeDifference = currentTime - last_monitored_unix;
            if (timeDifference >= 30) {
              console.debug("It has been at least 30 second since the last monitored time.", timeDifference);
              allowVerifyCTA.value = true;
            } else {
              console.debug("It has not been 30 seconds yet since the last monitored time.", timeDifference);
              allowVerifyCTA.value = false;
            }
          }
        } catch (error) {
          console.error("Error fetching domain:", error);
        }
      };
      const allowVerifyCTA = ref(false);
      const handleDomainVerify = async (data) => {
        console.log("Domain verified: refreshing domain info", data);
        await fetchDomain();
      };
      onMounted(() => {
        console.log("AccountDomainVerify component mounted");
        console.log("Domain parameter:", route.params.domain);
        fetchDomain();
      });
      return (_ctx, _cache) => {
        var _a, _b, _c;
        return openBlock(), createElementBlock("div", _hoisted_1$v, [
          createVNode(_sfc_main$T),
          _hoisted_2$s,
          ((_b = (_a = domain.value) == null ? void 0 : _a.vhost) == null ? void 0 : _b.last_monitored_unix) ? (openBlock(), createBlock(_sfc_main$x, {
            key: 0,
            domain: domain.value,
            mode: "table"
          }, null, 8, ["domain"])) : (openBlock(), createElementBlock("p", _hoisted_3$n, [
            createTextVNode(" Before we can activate links for "),
            createBaseVNode("span", _hoisted_4$k, toDisplayString((_c = domain.value) == null ? void 0 : _c.display_domain), 1),
            createTextVNode(", you'll need to complete these steps. ")
          ])),
          createVNode(_sfc_main$B, {
            textColor: "text-brandcomp-800 dark:text-gray-100",
            bgColor: "bg-white dark:bg-gray-800"
          }, {
            default: withCtx(() => {
              var _a2, _b2, _c2, _d, _e;
              return [
                createBaseVNode("div", _hoisted_5$k, [
                  createBaseVNode("div", _hoisted_6$g, [
                    createBaseVNode("p", null, [
                      createTextVNode(" In order to connect your domain, you'll need to have a DNS A record that points "),
                      createBaseVNode("span", _hoisted_7$c, toDisplayString((_a2 = domain.value) == null ? void 0 : _a2.display_domain), 1),
                      createTextVNode(" at "),
                      createBaseVNode("span", {
                        title: ((_b2 = cluster.value) == null ? void 0 : _b2.cluster_name) ?? "",
                        class: "bg-white dark:bg-gray-800 px-2"
                      }, toDisplayString((_c2 = cluster.value) == null ? void 0 : _c2.cluster_ip), 9, _hoisted_8$c),
                      createTextVNode(". If you already have an A record for that address, please change it to point at "),
                      createBaseVNode("span", {
                        title: ((_d = cluster.value) == null ? void 0 : _d.cluster_name) ?? "",
                        class: "bg-white dark:bg-gray-800 px-2"
                      }, toDisplayString((_e = cluster.value) == null ? void 0 : _e.cluster_ip), 9, _hoisted_9$e),
                      createTextVNode(" and remove any other A, AAAA, or CNAME records for that exact address. ")
                    ])
                  ]),
                  _hoisted_10$d
                ])
              ];
            }),
            _: 1
          }),
          domain.value && cluster.value ? (openBlock(), createBlock(_sfc_main$y, {
            key: 2,
            domain: domain.value,
            cluster: cluster.value,
            withVerifyCTA: allowVerifyCTA.value,
            onDomainVerify: handleDomainVerify
          }, null, 8, ["domain", "cluster", "withVerifyCTA"])) : (openBlock(), createElementBlock("p", _hoisted_11$e, "Loading domain information..."))
        ]);
      };
    }
  });
  const AccountDomainVerify = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: _sfc_main$w
  }, Symbol.toStringTag, { value: "Module" }));
  const _hoisted_1$u = /* @__PURE__ */ createBaseVNode("label", {
    for: "domain",
    class: "hidden text-xl font-medium leading-6 text-gray-900 dark:text-gray-100 bg-inherit",
    "aria-hidden": "false"
  }, " Domain name ", -1);
  const _hoisted_2$r = { class: "relative mt-2 rounded-md shadow-sm" };
  const _hoisted_3$m = ["value", "placeholder", "aria-invalid"];
  const _hoisted_4$j = { class: "pointer-events-none absolute inset-y-0 right-0 flex items-center pr-3" };
  const _hoisted_5$j = {
    key: 0,
    class: "mt-2 text-sm text-red-600 dark:text-red-400",
    id: "domain-error"
  };
  const _sfc_main$v = /* @__PURE__ */ defineComponent({
    __name: "DomainInput",
    props: {
      domain: {},
      placeholder: {},
      isValid: { type: Boolean }
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", null, [
          _hoisted_1$u,
          createBaseVNode("div", _hoisted_2$r, [
            createBaseVNode("input", {
              type: "text",
              name: "domain",
              id: "domain",
              value: _ctx.domain,
              placeholder: _ctx.placeholder,
              "aria-invalid": !_ctx.isValid,
              "aria-describedby": "domain-error",
              class: "block w-full rounded-md border-0 py-3 pl-5 pr-10 text-xl text-gray-900 ring-1 ring-inset ring-gray-300 placeholder:text-gray-400 focus:ring-2 focus:ring-inset focus:ring-brandcomp-600 shadow-sm dark:bg-gray-700 dark:text-white dark:ring-gray-600 dark:placeholder:text-gray-400 dark:focus:ring-brandcomp-500"
            }, null, 8, _hoisted_3$m),
            createBaseVNode("div", _hoisted_4$j, [
              !_ctx.isValid ? (openBlock(), createBlock(unref(Icon), {
                key: 0,
                icon: "heroicons:exclamation-circle",
                class: "h-6 w-6 text-red-500",
                "aria-hidden": "true"
              })) : createCommentVNode("", true)
            ])
          ]),
          !_ctx.isValid ? (openBlock(), createElementBlock("p", _hoisted_5$j, " Not a valid domain address. ")) : createCommentVNode("", true)
        ]);
      };
    }
  });
  const _hoisted_1$t = { class: "space-y-9 my-16 dark:bg-gray-900" };
  const _hoisted_2$q = ["value"];
  const _hoisted_3$l = ["disabled"];
  const _sfc_main$u = /* @__PURE__ */ defineComponent({
    __name: "DomainForm",
    emits: ["domain-added"],
    setup(__props, { emit: __emit }) {
      const csrfStore = useCsrfStore();
      const domain = ref("");
      const emit2 = __emit;
      const {
        isSubmitting,
        error,
        success,
        submitForm
      } = useFormSubmission({
        url: "/api/v2/account/domains/add",
        successMessage: "Domain added successfully.",
        onSuccess: (data) => {
          console.log("Domain added:", data);
          domain.value = data.record.display_domain;
          if (!domain.value) {
            console.error("Domain is undefined or empty");
          }
          try {
            emit2("domain-added", domain.value);
          } catch (error2) {
            console.error("Error emitting domain-added event:", error2);
          }
        },
        onError: (data) => {
          console.error("Error adding domain:", data);
        }
      });
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$t, [
          createVNode(_sfc_main$Y, {
            success: unref(success),
            error: unref(error)
          }, null, 8, ["success", "error"]),
          createBaseVNode("form", {
            onSubmit: _cache[1] || (_cache[1] = withModifiers(
              //@ts-ignore
              (...args) => unref(submitForm) && unref(submitForm)(...args),
              ["prevent"]
            )),
            class: "space-y-6"
          }, [
            createBaseVNode("input", {
              type: "hidden",
              name: "shrimp",
              value: unref(csrfStore).shrimp
            }, null, 8, _hoisted_2$q),
            createVNode(_sfc_main$v, {
              modelValue: domain.value,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => domain.value = $event),
              "is-valid": true,
              domain: "",
              autofocus: "",
              required: "",
              placeholder: "e.g. secrets.example.com",
              class: "dark:bg-gray-800 dark:text-white dark:border-gray-700"
            }, null, 8, ["modelValue"]),
            createBaseVNode("button", {
              type: "submit",
              disabled: unref(isSubmitting),
              class: "w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-xl font-medium text-white bg-brand-600 hover:bg-brand-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-brand-500 dark:bg-brand-500 dark:hover:bg-brand-400 dark:focus:ring-offset-gray-900"
            }, toDisplayString(unref(isSubmitting) ? "Adding..." : "Continue"), 9, _hoisted_3$l)
          ], 32)
        ]);
      };
    }
  });
  const _hoisted_1$s = { class: "" };
  const _hoisted_2$p = /* @__PURE__ */ createBaseVNode("h1", { class: "text-3xl font-bold mb-6 dark:text-white" }, "Add your domain", -1);
  const _hoisted_3$k = {
    key: 0,
    class: "mt-4 text-gray-600 dark:text-gray-400"
  };
  const _sfc_main$t = /* @__PURE__ */ defineComponent({
    __name: "AccountDomainAdd",
    setup(__props) {
      const router2 = useRouter();
      const isNavigating = ref(false);
      onMounted(() => {
        console.log("AccountDomainAdd component mounted");
      });
      const onDomainAdded = async (domain) => {
        if (!domain) {
          throw new Error("Domain is undefined or empty");
        }
        isNavigating.value = true;
        try {
          console.info("Navigation to verify", domain);
          await router2.replace({ name: "AccountDomainVerify", params: { domain } });
          await nextTick();
        } catch (error) {
          console.error("Navigation error:", error);
          isNavigating.value = false;
        }
      };
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$s, [
          _hoisted_2$p,
          createVNode(_sfc_main$u, {
            onDomainAdded,
            disabled: isNavigating.value
          }, null, 8, ["disabled"]),
          isNavigating.value ? (openBlock(), createElementBlock("p", _hoisted_3$k, "Navigating to verification page...")) : createCommentVNode("", true)
        ]);
      };
    }
  });
  const AccountDomainAdd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: _sfc_main$t
  }, Symbol.toStringTag, { value: "Module" }));
  function d$1(u2, e2, r2) {
    let i2 = ref(r2 == null ? void 0 : r2.value), f2 = computed(() => u2.value !== void 0);
    return [computed(() => f2.value ? u2.value : i2.value), function(t2) {
      return f2.value || (i2.value = t2), e2 == null ? void 0 : e2(t2);
    }];
  }
  let t$2 = Symbol("headlessui.useid"), i$5 = 0;
  function I$1() {
    return inject(t$2, () => `${++i$5}`)();
  }
  function o$3(e2) {
    var l2;
    if (e2 == null || e2.value == null) return null;
    let n2 = (l2 = e2.value.$el) != null ? l2 : e2.value;
    return n2 instanceof Node ? n2 : null;
  }
  function u$5(r2, n2, ...a2) {
    if (r2 in n2) {
      let e2 = n2[r2];
      return typeof e2 == "function" ? e2(...a2) : e2;
    }
    let t2 = new Error(`Tried to handle "${r2}" but there is no handler defined. Only defined handlers are: ${Object.keys(n2).map((e2) => `"${e2}"`).join(", ")}.`);
    throw Error.captureStackTrace && Error.captureStackTrace(t2, u$5), t2;
  }
  var i$4 = Object.defineProperty;
  var d = (t2, e2, r2) => e2 in t2 ? i$4(t2, e2, { enumerable: true, configurable: true, writable: true, value: r2 }) : t2[e2] = r2;
  var n$2 = (t2, e2, r2) => (d(t2, typeof e2 != "symbol" ? e2 + "" : e2, r2), r2);
  let s$1 = class s {
    constructor() {
      n$2(this, "current", this.detect());
      n$2(this, "currentId", 0);
    }
    set(e2) {
      this.current !== e2 && (this.currentId = 0, this.current = e2);
    }
    reset() {
      this.set(this.detect());
    }
    nextId() {
      return ++this.currentId;
    }
    get isServer() {
      return this.current === "server";
    }
    get isClient() {
      return this.current === "client";
    }
    detect() {
      return typeof window == "undefined" || typeof document == "undefined" ? "server" : "client";
    }
  };
  let c$2 = new s$1();
  function i$3(r2) {
    if (c$2.isServer) return null;
    if (r2 instanceof Node) return r2.ownerDocument;
    if (r2 != null && r2.hasOwnProperty("value")) {
      let n2 = o$3(r2);
      if (n2) return n2.ownerDocument;
    }
    return document;
  }
  let c$1 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((e2) => `${e2}:not([tabindex='-1'])`).join(",");
  var N$2 = ((n2) => (n2[n2.First = 1] = "First", n2[n2.Previous = 2] = "Previous", n2[n2.Next = 4] = "Next", n2[n2.Last = 8] = "Last", n2[n2.WrapAround = 16] = "WrapAround", n2[n2.NoScroll = 32] = "NoScroll", n2))(N$2 || {}), T$1 = ((o2) => (o2[o2.Error = 0] = "Error", o2[o2.Overflow = 1] = "Overflow", o2[o2.Success = 2] = "Success", o2[o2.Underflow = 3] = "Underflow", o2))(T$1 || {}), F = ((t2) => (t2[t2.Previous = -1] = "Previous", t2[t2.Next = 1] = "Next", t2))(F || {});
  function E$2(e2 = document.body) {
    return e2 == null ? [] : Array.from(e2.querySelectorAll(c$1)).sort((r2, t2) => Math.sign((r2.tabIndex || Number.MAX_SAFE_INTEGER) - (t2.tabIndex || Number.MAX_SAFE_INTEGER)));
  }
  var h = ((t2) => (t2[t2.Strict = 0] = "Strict", t2[t2.Loose = 1] = "Loose", t2))(h || {});
  function w$2(e2, r2 = 0) {
    var t2;
    return e2 === ((t2 = i$3(e2)) == null ? void 0 : t2.body) ? false : u$5(r2, { [0]() {
      return e2.matches(c$1);
    }, [1]() {
      let l2 = e2;
      for (; l2 !== null; ) {
        if (l2.matches(c$1)) return true;
        l2 = l2.parentElement;
      }
      return false;
    } });
  }
  function _(e2) {
    let r2 = i$3(e2);
    nextTick(() => {
      r2 && !w$2(r2.activeElement, 0) && S$1(e2);
    });
  }
  var y$1 = ((t2) => (t2[t2.Keyboard = 0] = "Keyboard", t2[t2.Mouse = 1] = "Mouse", t2))(y$1 || {});
  typeof window != "undefined" && typeof document != "undefined" && (document.addEventListener("keydown", (e2) => {
    e2.metaKey || e2.altKey || e2.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
  }, true), document.addEventListener("click", (e2) => {
    e2.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : e2.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
  }, true));
  function S$1(e2) {
    e2 == null || e2.focus({ preventScroll: true });
  }
  let H$1 = ["textarea", "input"].join(",");
  function I(e2) {
    var r2, t2;
    return (t2 = (r2 = e2 == null ? void 0 : e2.matches) == null ? void 0 : r2.call(e2, H$1)) != null ? t2 : false;
  }
  function O$1(e2, r2 = (t2) => t2) {
    return e2.slice().sort((t2, l2) => {
      let o2 = r2(t2), i2 = r2(l2);
      if (o2 === null || i2 === null) return 0;
      let n2 = o2.compareDocumentPosition(i2);
      return n2 & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : n2 & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
    });
  }
  function v$1(e2, r2) {
    return P(E$2(), r2, { relativeTo: e2 });
  }
  function P(e2, r2, { sorted: t2 = true, relativeTo: l2 = null, skipElements: o2 = [] } = {}) {
    var m2;
    let i2 = (m2 = Array.isArray(e2) ? e2.length > 0 ? e2[0].ownerDocument : document : e2 == null ? void 0 : e2.ownerDocument) != null ? m2 : document, n2 = Array.isArray(e2) ? t2 ? O$1(e2) : e2 : E$2(e2);
    o2.length > 0 && n2.length > 1 && (n2 = n2.filter((s2) => !o2.includes(s2))), l2 = l2 != null ? l2 : i2.activeElement;
    let x = (() => {
      if (r2 & 5) return 1;
      if (r2 & 10) return -1;
      throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
    })(), p2 = (() => {
      if (r2 & 1) return 0;
      if (r2 & 2) return Math.max(0, n2.indexOf(l2)) - 1;
      if (r2 & 4) return Math.max(0, n2.indexOf(l2)) + 1;
      if (r2 & 8) return n2.length - 1;
      throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
    })(), L2 = r2 & 32 ? { preventScroll: true } : {}, a2 = 0, d2 = n2.length, u2;
    do {
      if (a2 >= d2 || a2 + d2 <= 0) return 0;
      let s2 = p2 + a2;
      if (r2 & 16) s2 = (s2 + d2) % d2;
      else {
        if (s2 < 0) return 3;
        if (s2 >= d2) return 1;
      }
      u2 = n2[s2], u2 == null || u2.focus(L2), a2 += x;
    } while (u2 !== i2.activeElement);
    return r2 & 6 && I(u2) && u2.select(), 2;
  }
  function t$1() {
    return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
  }
  function i$2() {
    return /Android/gi.test(window.navigator.userAgent);
  }
  function n$1() {
    return t$1() || i$2();
  }
  function u$4(e2, t2, n2) {
    c$2.isServer || watchEffect((o2) => {
      document.addEventListener(e2, t2, n2), o2(() => document.removeEventListener(e2, t2, n2));
    });
  }
  function w$1(e2, n2, t2) {
    c$2.isServer || watchEffect((o2) => {
      window.addEventListener(e2, n2, t2), o2(() => window.removeEventListener(e2, n2, t2));
    });
  }
  function w(f2, m2, l2 = computed(() => true)) {
    function a2(e2, r2) {
      if (!l2.value || e2.defaultPrevented) return;
      let t2 = r2(e2);
      if (t2 === null || !t2.getRootNode().contains(t2)) return;
      let c2 = function o2(n2) {
        return typeof n2 == "function" ? o2(n2()) : Array.isArray(n2) || n2 instanceof Set ? n2 : [n2];
      }(f2);
      for (let o2 of c2) {
        if (o2 === null) continue;
        let n2 = o2 instanceof HTMLElement ? o2 : o$3(o2);
        if (n2 != null && n2.contains(t2) || e2.composed && e2.composedPath().includes(n2)) return;
      }
      return !w$2(t2, h.Loose) && t2.tabIndex !== -1 && e2.preventDefault(), m2(e2, t2);
    }
    let u2 = ref(null);
    u$4("pointerdown", (e2) => {
      var r2, t2;
      l2.value && (u2.value = ((t2 = (r2 = e2.composedPath) == null ? void 0 : r2.call(e2)) == null ? void 0 : t2[0]) || e2.target);
    }, true), u$4("mousedown", (e2) => {
      var r2, t2;
      l2.value && (u2.value = ((t2 = (r2 = e2.composedPath) == null ? void 0 : r2.call(e2)) == null ? void 0 : t2[0]) || e2.target);
    }, true), u$4("click", (e2) => {
      n$1() || u2.value && (a2(e2, () => u2.value), u2.value = null);
    }, true), u$4("touchend", (e2) => a2(e2, () => e2.target instanceof HTMLElement ? e2.target : null), true), w$1("blur", (e2) => a2(e2, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), true);
  }
  function r$1(t2, e2) {
    if (t2) return t2;
    let n2 = e2 != null ? e2 : "button";
    if (typeof n2 == "string" && n2.toLowerCase() === "button") return "button";
  }
  function s(t2, e2) {
    let n2 = ref(r$1(t2.value.type, t2.value.as));
    return onMounted(() => {
      n2.value = r$1(t2.value.type, t2.value.as);
    }), watchEffect(() => {
      var u2;
      n2.value || o$3(e2) && o$3(e2) instanceof HTMLButtonElement && !((u2 = o$3(e2)) != null && u2.hasAttribute("type")) && (n2.value = "button");
    }), n2;
  }
  function r(e2) {
    return [e2.screenX, e2.screenY];
  }
  function u$3() {
    let e2 = ref([-1, -1]);
    return { wasMoved(n2) {
      let t2 = r(n2);
      return e2.value[0] === t2[0] && e2.value[1] === t2[1] ? false : (e2.value = t2, true);
    }, update(n2) {
      e2.value = r(n2);
    } };
  }
  function i$1({ container: e2, accept: t2, walk: d2, enabled: o2 }) {
    watchEffect(() => {
      let r2 = e2.value;
      if (!r2 || o2 !== void 0 && !o2.value) return;
      let l2 = i$3(e2);
      if (!l2) return;
      let c2 = Object.assign((f2) => t2(f2), { acceptNode: t2 }), n2 = l2.createTreeWalker(r2, NodeFilter.SHOW_ELEMENT, c2, false);
      for (; n2.nextNode(); ) d2(n2.currentNode);
    });
  }
  var N$1 = ((o2) => (o2[o2.None = 0] = "None", o2[o2.RenderStrategy = 1] = "RenderStrategy", o2[o2.Static = 2] = "Static", o2))(N$1 || {}), S = ((e2) => (e2[e2.Unmount = 0] = "Unmount", e2[e2.Hidden = 1] = "Hidden", e2))(S || {});
  function A$1({ visible: r2 = true, features: t2 = 0, ourProps: e2, theirProps: o2, ...i2 }) {
    var a2;
    let n2 = j(o2, e2), l2 = Object.assign(i2, { props: n2 });
    if (r2 || t2 & 2 && n2.static) return y(l2);
    if (t2 & 1) {
      let d2 = (a2 = n2.unmount) == null || a2 ? 0 : 1;
      return u$5(d2, { [0]() {
        return null;
      }, [1]() {
        return y({ ...i2, props: { ...n2, hidden: true, style: { display: "none" } } });
      } });
    }
    return y(l2);
  }
  function y({ props: r2, attrs: t2, slots: e2, slot: o2, name: i2 }) {
    var m2, h2;
    let { as: n2, ...l2 } = T(r2, ["unmount", "static"]), a2 = (m2 = e2.default) == null ? void 0 : m2.call(e2, o2), d2 = {};
    if (o2) {
      let u2 = false, c2 = [];
      for (let [p2, f2] of Object.entries(o2)) typeof f2 == "boolean" && (u2 = true), f2 === true && c2.push(p2);
      u2 && (d2["data-headlessui-state"] = c2.join(" "));
    }
    if (n2 === "template") {
      if (a2 = b(a2 != null ? a2 : []), Object.keys(l2).length > 0 || Object.keys(t2).length > 0) {
        let [u2, ...c2] = a2 != null ? a2 : [];
        if (!v(u2) || c2.length > 0) throw new Error(['Passing props on "template"!', "", `The current component <${i2} /> is rendering a "template".`, "However we need to passthrough the following props:", Object.keys(l2).concat(Object.keys(t2)).map((s2) => s2.trim()).filter((s2, g2, R) => R.indexOf(s2) === g2).sort((s2, g2) => s2.localeCompare(g2)).map((s2) => `  - ${s2}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "template".', "Render a single element as the child so that we can forward the props onto that element."].map((s2) => `  - ${s2}`).join(`
`)].join(`
`));
        let p2 = j((h2 = u2.props) != null ? h2 : {}, l2, d2), f2 = cloneVNode(u2, p2, true);
        for (let s2 in p2) s2.startsWith("on") && (f2.props || (f2.props = {}), f2.props[s2] = p2[s2]);
        return f2;
      }
      return Array.isArray(a2) && a2.length === 1 ? a2[0] : a2;
    }
    return h$1(n2, Object.assign({}, l2, d2), { default: () => a2 });
  }
  function b(r2) {
    return r2.flatMap((t2) => t2.type === Fragment ? b(t2.children) : [t2]);
  }
  function j(...r2) {
    if (r2.length === 0) return {};
    if (r2.length === 1) return r2[0];
    let t2 = {}, e2 = {};
    for (let i2 of r2) for (let n2 in i2) n2.startsWith("on") && typeof i2[n2] == "function" ? (e2[n2] != null || (e2[n2] = []), e2[n2].push(i2[n2])) : t2[n2] = i2[n2];
    if (t2.disabled || t2["aria-disabled"]) return Object.assign(t2, Object.fromEntries(Object.keys(e2).map((i2) => [i2, void 0])));
    for (let i2 in e2) Object.assign(t2, { [i2](n2, ...l2) {
      let a2 = e2[i2];
      for (let d2 of a2) {
        if (n2 instanceof Event && n2.defaultPrevented) return;
        d2(n2, ...l2);
      }
    } });
    return t2;
  }
  function E$1(r2) {
    let t2 = Object.assign({}, r2);
    for (let e2 in t2) t2[e2] === void 0 && delete t2[e2];
    return t2;
  }
  function T(r2, t2 = []) {
    let e2 = Object.assign({}, r2);
    for (let o2 of t2) o2 in e2 && delete e2[o2];
    return e2;
  }
  function v(r2) {
    return r2 == null ? false : typeof r2.type == "string" || typeof r2.type == "object" || typeof r2.type == "function";
  }
  var u$2 = ((e2) => (e2[e2.None = 1] = "None", e2[e2.Focusable = 2] = "Focusable", e2[e2.Hidden = 4] = "Hidden", e2))(u$2 || {});
  let f$2 = /* @__PURE__ */ defineComponent({ name: "Hidden", props: { as: { type: [Object, String], default: "div" }, features: { type: Number, default: 1 } }, setup(t2, { slots: n2, attrs: i2 }) {
    return () => {
      var r2;
      let { features: e2, ...d2 } = t2, o2 = { "aria-hidden": (e2 & 2) === 2 ? true : (r2 = d2["aria-hidden"]) != null ? r2 : void 0, hidden: (e2 & 4) === 4 ? true : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(e2 & 4) === 4 && (e2 & 2) !== 2 && { display: "none" } } };
      return A$1({ ourProps: o2, theirProps: d2, slot: {}, attrs: i2, slots: n2, name: "Hidden" });
    };
  } });
  let n = Symbol("Context");
  var i = ((e2) => (e2[e2.Open = 1] = "Open", e2[e2.Closed = 2] = "Closed", e2[e2.Closing = 4] = "Closing", e2[e2.Opening = 8] = "Opening", e2))(i || {});
  function l() {
    return inject(n, null);
  }
  function t(o2) {
    provide(n, o2);
  }
  var o$2 = ((r2) => (r2.Space = " ", r2.Enter = "Enter", r2.Escape = "Escape", r2.Backspace = "Backspace", r2.Delete = "Delete", r2.ArrowLeft = "ArrowLeft", r2.ArrowUp = "ArrowUp", r2.ArrowRight = "ArrowRight", r2.ArrowDown = "ArrowDown", r2.Home = "Home", r2.End = "End", r2.PageUp = "PageUp", r2.PageDown = "PageDown", r2.Tab = "Tab", r2))(o$2 || {});
  function u$1(l2) {
    throw new Error("Unexpected object: " + l2);
  }
  var c = ((i2) => (i2[i2.First = 0] = "First", i2[i2.Previous = 1] = "Previous", i2[i2.Next = 2] = "Next", i2[i2.Last = 3] = "Last", i2[i2.Specific = 4] = "Specific", i2[i2.Nothing = 5] = "Nothing", i2))(c || {});
  function f$1(l2, n2) {
    let t2 = n2.resolveItems();
    if (t2.length <= 0) return null;
    let r2 = n2.resolveActiveIndex(), s2 = r2 != null ? r2 : -1;
    switch (l2.focus) {
      case 0: {
        for (let e2 = 0; e2 < t2.length; ++e2) if (!n2.resolveDisabled(t2[e2], e2, t2)) return e2;
        return r2;
      }
      case 1: {
        s2 === -1 && (s2 = t2.length);
        for (let e2 = s2 - 1; e2 >= 0; --e2) if (!n2.resolveDisabled(t2[e2], e2, t2)) return e2;
        return r2;
      }
      case 2: {
        for (let e2 = s2 + 1; e2 < t2.length; ++e2) if (!n2.resolveDisabled(t2[e2], e2, t2)) return e2;
        return r2;
      }
      case 3: {
        for (let e2 = t2.length - 1; e2 >= 0; --e2) if (!n2.resolveDisabled(t2[e2], e2, t2)) return e2;
        return r2;
      }
      case 4: {
        for (let e2 = 0; e2 < t2.length; ++e2) if (n2.resolveId(t2[e2], e2, t2) === l2.id) return e2;
        return r2;
      }
      case 5:
        return null;
      default:
        u$1(l2);
    }
  }
  function e(i2 = {}, s2 = null, t2 = []) {
    for (let [r2, n2] of Object.entries(i2)) o$1(t2, f(s2, r2), n2);
    return t2;
  }
  function f(i2, s2) {
    return i2 ? i2 + "[" + s2 + "]" : s2;
  }
  function o$1(i2, s2, t2) {
    if (Array.isArray(t2)) for (let [r2, n2] of t2.entries()) o$1(i2, f(s2, r2.toString()), n2);
    else t2 instanceof Date ? i2.push([s2, t2.toISOString()]) : typeof t2 == "boolean" ? i2.push([s2, t2 ? "1" : "0"]) : typeof t2 == "string" ? i2.push([s2, t2]) : typeof t2 == "number" ? i2.push([s2, `${t2}`]) : t2 == null ? i2.push([s2, ""]) : e(t2, s2, i2);
  }
  function p$1(i2) {
    var t2, r2;
    let s2 = (t2 = i2 == null ? void 0 : i2.form) != null ? t2 : i2.closest("form");
    if (s2) {
      for (let n2 of s2.elements) if (n2 !== i2 && (n2.tagName === "INPUT" && n2.type === "submit" || n2.tagName === "BUTTON" && n2.type === "submit" || n2.nodeName === "INPUT" && n2.type === "image")) {
        n2.click();
        return;
      }
      (r2 = s2.requestSubmit) == null || r2.call(s2);
    }
  }
  let u = Symbol("DescriptionContext");
  function k({ slot: t2 = ref({}), name: o2 = "Description", props: s2 = {} } = {}) {
    let e2 = ref([]);
    function r2(n2) {
      return e2.value.push(n2), () => {
        let i2 = e2.value.indexOf(n2);
        i2 !== -1 && e2.value.splice(i2, 1);
      };
    }
    return provide(u, { register: r2, slot: t2, name: o2, props: s2 }), computed(() => e2.value.length > 0 ? e2.value.join(" ") : void 0);
  }
  let a$1 = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
  function o(e2) {
    var r2, i2;
    let n2 = (r2 = e2.innerText) != null ? r2 : "", t2 = e2.cloneNode(true);
    if (!(t2 instanceof HTMLElement)) return n2;
    let u2 = false;
    for (let f2 of t2.querySelectorAll('[hidden],[aria-hidden],[role="img"]')) f2.remove(), u2 = true;
    let l2 = u2 ? (i2 = t2.innerText) != null ? i2 : "" : n2;
    return a$1.test(l2) && (l2 = l2.replace(a$1, "")), l2;
  }
  function g(e2) {
    let n2 = e2.getAttribute("aria-label");
    if (typeof n2 == "string") return n2.trim();
    let t2 = e2.getAttribute("aria-labelledby");
    if (t2) {
      let u2 = t2.split(" ").map((l2) => {
        let r2 = document.getElementById(l2);
        if (r2) {
          let i2 = r2.getAttribute("aria-label");
          return typeof i2 == "string" ? i2.trim() : o(r2).trim();
        }
        return null;
      }).filter(Boolean);
      if (u2.length > 0) return u2.join(", ");
    }
    return o(e2).trim();
  }
  function p(a2) {
    let t2 = ref(""), r2 = ref("");
    return () => {
      let e2 = o$3(a2);
      if (!e2) return "";
      let l2 = e2.innerText;
      if (t2.value === l2) return r2.value;
      let u2 = g(e2).trim().toLowerCase();
      return t2.value = l2, r2.value = u2, u2;
    };
  }
  var Z = ((i2) => (i2[i2.Open = 0] = "Open", i2[i2.Closed = 1] = "Closed", i2))(Z || {}), ee = ((i2) => (i2[i2.Pointer = 0] = "Pointer", i2[i2.Other = 1] = "Other", i2))(ee || {});
  function te(o2) {
    requestAnimationFrame(() => requestAnimationFrame(o2));
  }
  let A = Symbol("MenuContext");
  function O(o2) {
    let M = inject(A, null);
    if (M === null) {
      let i2 = new Error(`<${o2} /> is missing a parent <Menu /> component.`);
      throw Error.captureStackTrace && Error.captureStackTrace(i2, O), i2;
    }
    return M;
  }
  let ge = /* @__PURE__ */ defineComponent({ name: "Menu", props: { as: { type: [Object, String], default: "template" } }, setup(o2, { slots: M, attrs: i$12 }) {
    let I2 = ref(1), p2 = ref(null), e2 = ref(null), r2 = ref([]), f2 = ref(""), d2 = ref(null), g2 = ref(1);
    function b2(t2 = (a2) => a2) {
      let a2 = d2.value !== null ? r2.value[d2.value] : null, n2 = O$1(t2(r2.value.slice()), (v2) => o$3(v2.dataRef.domRef)), s2 = a2 ? n2.indexOf(a2) : null;
      return s2 === -1 && (s2 = null), { items: n2, activeItemIndex: s2 };
    }
    let l2 = { menuState: I2, buttonRef: p2, itemsRef: e2, items: r2, searchQuery: f2, activeItemIndex: d2, activationTrigger: g2, closeMenu: () => {
      I2.value = 1, d2.value = null;
    }, openMenu: () => I2.value = 0, goToItem(t2, a2, n2) {
      let s2 = b2(), v2 = f$1(t2 === c.Specific ? { focus: c.Specific, id: a2 } : { focus: t2 }, { resolveItems: () => s2.items, resolveActiveIndex: () => s2.activeItemIndex, resolveId: (u2) => u2.id, resolveDisabled: (u2) => u2.dataRef.disabled });
      f2.value = "", d2.value = v2, g2.value = n2 != null ? n2 : 1, r2.value = s2.items;
    }, search(t2) {
      let n2 = f2.value !== "" ? 0 : 1;
      f2.value += t2.toLowerCase();
      let v2 = (d2.value !== null ? r2.value.slice(d2.value + n2).concat(r2.value.slice(0, d2.value + n2)) : r2.value).find((h2) => h2.dataRef.textValue.startsWith(f2.value) && !h2.dataRef.disabled), u2 = v2 ? r2.value.indexOf(v2) : -1;
      u2 === -1 || u2 === d2.value || (d2.value = u2, g2.value = 1);
    }, clearSearch() {
      f2.value = "";
    }, registerItem(t2, a2) {
      let n2 = b2((s2) => [...s2, { id: t2, dataRef: a2 }]);
      r2.value = n2.items, d2.value = n2.activeItemIndex, g2.value = 1;
    }, unregisterItem(t2) {
      let a2 = b2((n2) => {
        let s2 = n2.findIndex((v2) => v2.id === t2);
        return s2 !== -1 && n2.splice(s2, 1), n2;
      });
      r2.value = a2.items, d2.value = a2.activeItemIndex, g2.value = 1;
    } };
    return w([p2, e2], (t2, a2) => {
      var n2;
      l2.closeMenu(), w$2(a2, h.Loose) || (t2.preventDefault(), (n2 = o$3(p2)) == null || n2.focus());
    }, computed(() => I2.value === 0)), provide(A, l2), t(computed(() => u$5(I2.value, { [0]: i.Open, [1]: i.Closed }))), () => {
      let t2 = { open: I2.value === 0, close: l2.closeMenu };
      return A$1({ ourProps: {}, theirProps: o2, slot: t2, slots: M, attrs: i$12, name: "Menu" });
    };
  } }), Se = /* @__PURE__ */ defineComponent({ name: "MenuButton", props: { disabled: { type: Boolean, default: false }, as: { type: [Object, String], default: "button" }, id: { type: String, default: null } }, setup(o2, { attrs: M, slots: i2, expose: I2 }) {
    var b2;
    let p2 = (b2 = o2.id) != null ? b2 : `headlessui-menu-button-${I$1()}`, e2 = O("MenuButton");
    I2({ el: e2.buttonRef, $el: e2.buttonRef });
    function r2(l2) {
      switch (l2.key) {
        case o$2.Space:
        case o$2.Enter:
        case o$2.ArrowDown:
          l2.preventDefault(), l2.stopPropagation(), e2.openMenu(), nextTick(() => {
            var t2;
            (t2 = o$3(e2.itemsRef)) == null || t2.focus({ preventScroll: true }), e2.goToItem(c.First);
          });
          break;
        case o$2.ArrowUp:
          l2.preventDefault(), l2.stopPropagation(), e2.openMenu(), nextTick(() => {
            var t2;
            (t2 = o$3(e2.itemsRef)) == null || t2.focus({ preventScroll: true }), e2.goToItem(c.Last);
          });
          break;
      }
    }
    function f2(l2) {
      switch (l2.key) {
        case o$2.Space:
          l2.preventDefault();
          break;
      }
    }
    function d2(l2) {
      o2.disabled || (e2.menuState.value === 0 ? (e2.closeMenu(), nextTick(() => {
        var t2;
        return (t2 = o$3(e2.buttonRef)) == null ? void 0 : t2.focus({ preventScroll: true });
      })) : (l2.preventDefault(), e2.openMenu(), te(() => {
        var t2;
        return (t2 = o$3(e2.itemsRef)) == null ? void 0 : t2.focus({ preventScroll: true });
      })));
    }
    let g2 = s(computed(() => ({ as: o2.as, type: M.type })), e2.buttonRef);
    return () => {
      var n2;
      let l2 = { open: e2.menuState.value === 0 }, { ...t2 } = o2, a2 = { ref: e2.buttonRef, id: p2, type: g2.value, "aria-haspopup": "menu", "aria-controls": (n2 = o$3(e2.itemsRef)) == null ? void 0 : n2.id, "aria-expanded": e2.menuState.value === 0, onKeydown: r2, onKeyup: f2, onClick: d2 };
      return A$1({ ourProps: a2, theirProps: t2, slot: l2, attrs: M, slots: i2, name: "MenuButton" });
    };
  } }), Me = /* @__PURE__ */ defineComponent({ name: "MenuItems", props: { as: { type: [Object, String], default: "div" }, static: { type: Boolean, default: false }, unmount: { type: Boolean, default: true }, id: { type: String, default: null } }, setup(o2, { attrs: M, slots: i$22, expose: I2 }) {
    var l$1;
    let p2 = (l$1 = o2.id) != null ? l$1 : `headlessui-menu-items-${I$1()}`, e2 = O("MenuItems"), r2 = ref(null);
    I2({ el: e2.itemsRef, $el: e2.itemsRef }), i$1({ container: computed(() => o$3(e2.itemsRef)), enabled: computed(() => e2.menuState.value === 0), accept(t2) {
      return t2.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : t2.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
    }, walk(t2) {
      t2.setAttribute("role", "none");
    } });
    function f2(t2) {
      var a2;
      switch (r2.value && clearTimeout(r2.value), t2.key) {
        case o$2.Space:
          if (e2.searchQuery.value !== "") return t2.preventDefault(), t2.stopPropagation(), e2.search(t2.key);
        case o$2.Enter:
          if (t2.preventDefault(), t2.stopPropagation(), e2.activeItemIndex.value !== null) {
            let s2 = e2.items.value[e2.activeItemIndex.value];
            (a2 = o$3(s2.dataRef.domRef)) == null || a2.click();
          }
          e2.closeMenu(), _(o$3(e2.buttonRef));
          break;
        case o$2.ArrowDown:
          return t2.preventDefault(), t2.stopPropagation(), e2.goToItem(c.Next);
        case o$2.ArrowUp:
          return t2.preventDefault(), t2.stopPropagation(), e2.goToItem(c.Previous);
        case o$2.Home:
        case o$2.PageUp:
          return t2.preventDefault(), t2.stopPropagation(), e2.goToItem(c.First);
        case o$2.End:
        case o$2.PageDown:
          return t2.preventDefault(), t2.stopPropagation(), e2.goToItem(c.Last);
        case o$2.Escape:
          t2.preventDefault(), t2.stopPropagation(), e2.closeMenu(), nextTick(() => {
            var n2;
            return (n2 = o$3(e2.buttonRef)) == null ? void 0 : n2.focus({ preventScroll: true });
          });
          break;
        case o$2.Tab:
          t2.preventDefault(), t2.stopPropagation(), e2.closeMenu(), nextTick(() => v$1(o$3(e2.buttonRef), t2.shiftKey ? N$2.Previous : N$2.Next));
          break;
        default:
          t2.key.length === 1 && (e2.search(t2.key), r2.value = setTimeout(() => e2.clearSearch(), 350));
          break;
      }
    }
    function d2(t2) {
      switch (t2.key) {
        case o$2.Space:
          t2.preventDefault();
          break;
      }
    }
    let g2 = l(), b2 = computed(() => g2 !== null ? (g2.value & i.Open) === i.Open : e2.menuState.value === 0);
    return () => {
      var s2, v2;
      let t2 = { open: e2.menuState.value === 0 }, { ...a2 } = o2, n2 = { "aria-activedescendant": e2.activeItemIndex.value === null || (s2 = e2.items.value[e2.activeItemIndex.value]) == null ? void 0 : s2.id, "aria-labelledby": (v2 = o$3(e2.buttonRef)) == null ? void 0 : v2.id, id: p2, onKeydown: f2, onKeyup: d2, role: "menu", tabIndex: 0, ref: e2.itemsRef };
      return A$1({ ourProps: n2, theirProps: a2, slot: t2, attrs: M, slots: i$22, features: N$1.RenderStrategy | N$1.Static, visible: b2.value, name: "MenuItems" });
    };
  } }), be = /* @__PURE__ */ defineComponent({ name: "MenuItem", inheritAttrs: false, props: { as: { type: [Object, String], default: "template" }, disabled: { type: Boolean, default: false }, id: { type: String, default: null } }, setup(o2, { slots: M, attrs: i2, expose: I2 }) {
    var v2;
    let p$12 = (v2 = o2.id) != null ? v2 : `headlessui-menu-item-${I$1()}`, e2 = O("MenuItem"), r2 = ref(null);
    I2({ el: r2, $el: r2 });
    let f2 = computed(() => e2.activeItemIndex.value !== null ? e2.items.value[e2.activeItemIndex.value].id === p$12 : false), d2 = p(r2), g2 = computed(() => ({ disabled: o2.disabled, get textValue() {
      return d2();
    }, domRef: r2 }));
    onMounted(() => e2.registerItem(p$12, g2)), onUnmounted(() => e2.unregisterItem(p$12)), watchEffect(() => {
      e2.menuState.value === 0 && f2.value && e2.activationTrigger.value !== 0 && nextTick(() => {
        var u2, h2;
        return (h2 = (u2 = o$3(r2)) == null ? void 0 : u2.scrollIntoView) == null ? void 0 : h2.call(u2, { block: "nearest" });
      });
    });
    function b2(u2) {
      if (o2.disabled) return u2.preventDefault();
      e2.closeMenu(), _(o$3(e2.buttonRef));
    }
    function l2() {
      if (o2.disabled) return e2.goToItem(c.Nothing);
      e2.goToItem(c.Specific, p$12);
    }
    let t2 = u$3();
    function a2(u2) {
      t2.update(u2);
    }
    function n2(u2) {
      t2.wasMoved(u2) && (o2.disabled || f2.value || e2.goToItem(c.Specific, p$12, 0));
    }
    function s2(u2) {
      t2.wasMoved(u2) && (o2.disabled || f2.value && e2.goToItem(c.Nothing));
    }
    return () => {
      let { disabled: u2, ...h2 } = o2, C = { active: f2.value, disabled: u2, close: e2.closeMenu };
      return A$1({ ourProps: { id: p$12, ref: r2, role: "menuitem", tabIndex: u2 === true ? void 0 : -1, "aria-disabled": u2 === true ? true : void 0, onClick: b2, onFocus: l2, onPointerenter: a2, onMouseenter: a2, onPointermove: n2, onMousemove: n2, onPointerleave: s2, onMouseleave: s2 }, theirProps: { ...i2, ...h2 }, slot: C, attrs: i2, slots: M, name: "MenuItem" });
    };
  } });
  let a = Symbol("LabelContext");
  function E({ slot: t2 = {}, name: n2 = "Label", props: i2 = {} } = {}) {
    let e2 = ref([]);
    function o2(r2) {
      return e2.value.push(r2), () => {
        let l2 = e2.value.indexOf(r2);
        l2 !== -1 && e2.value.splice(l2, 1);
      };
    }
    return provide(a, { register: o2, slot: t2, name: n2, props: i2 }), computed(() => e2.value.length > 0 ? e2.value.join(" ") : void 0);
  }
  function le(t2, m2) {
    return t2 === m2;
  }
  let H = Symbol("RadioGroupContext");
  function N(t2) {
    let m2 = inject(H, null);
    if (m2 === null) {
      let u2 = new Error(`<${t2} /> is missing a parent <RadioGroup /> component.`);
      throw Error.captureStackTrace && Error.captureStackTrace(u2, N), u2;
    }
    return m2;
  }
  let he = /* @__PURE__ */ defineComponent({ name: "RadioGroup", emits: { "update:modelValue": (t2) => true }, props: { as: { type: [Object, String], default: "div" }, disabled: { type: [Boolean], default: false }, by: { type: [String, Function], default: () => le }, modelValue: { type: [Object, String, Number, Boolean], default: void 0 }, defaultValue: { type: [Object, String, Number, Boolean], default: void 0 }, form: { type: String, optional: true }, name: { type: String, optional: true }, id: { type: String, default: null } }, inheritAttrs: false, setup(t2, { emit: m2, attrs: u2, slots: S2, expose: g2 }) {
    var O2;
    let d2 = (O2 = t2.id) != null ? O2 : `headlessui-radiogroup-${I$1()}`, p2 = ref(null), l2 = ref([]), R = E({ name: "RadioGroupLabel" }), T$2 = k({ name: "RadioGroupDescription" });
    g2({ el: p2, $el: p2 });
    let [f2, G] = d$1(computed(() => t2.modelValue), (e2) => m2("update:modelValue", e2), computed(() => t2.defaultValue)), s2 = { options: l2, value: f2, disabled: computed(() => t2.disabled), firstOption: computed(() => l2.value.find((e2) => !e2.propsRef.disabled)), containsCheckedOption: computed(() => l2.value.some((e2) => s2.compare(toRaw(e2.propsRef.value), toRaw(t2.modelValue)))), compare(e2, a2) {
      if (typeof t2.by == "string") {
        let n2 = t2.by;
        return (e2 == null ? void 0 : e2[n2]) === (a2 == null ? void 0 : a2[n2]);
      }
      return t2.by(e2, a2);
    }, change(e2) {
      var n2;
      if (t2.disabled || s2.compare(toRaw(f2.value), toRaw(e2))) return false;
      let a2 = (n2 = l2.value.find((i2) => s2.compare(toRaw(i2.propsRef.value), toRaw(e2)))) == null ? void 0 : n2.propsRef;
      return a2 != null && a2.disabled ? false : (G(e2), true);
    }, registerOption(e2) {
      l2.value.push(e2), l2.value = O$1(l2.value, (a2) => a2.element);
    }, unregisterOption(e2) {
      let a2 = l2.value.findIndex((n2) => n2.id === e2);
      a2 !== -1 && l2.value.splice(a2, 1);
    } };
    provide(H, s2), i$1({ container: computed(() => o$3(p2)), accept(e2) {
      return e2.getAttribute("role") === "radio" ? NodeFilter.FILTER_REJECT : e2.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
    }, walk(e2) {
      e2.setAttribute("role", "none");
    } });
    function v2(e2) {
      if (!p2.value || !p2.value.contains(e2.target)) return;
      let a2 = l2.value.filter((n2) => n2.propsRef.disabled === false).map((n2) => n2.element);
      switch (e2.key) {
        case o$2.Enter:
          p$1(e2.currentTarget);
          break;
        case o$2.ArrowLeft:
        case o$2.ArrowUp:
          if (e2.preventDefault(), e2.stopPropagation(), P(a2, N$2.Previous | N$2.WrapAround) === T$1.Success) {
            let i2 = l2.value.find((r2) => {
              var c2;
              return r2.element === ((c2 = i$3(p2)) == null ? void 0 : c2.activeElement);
            });
            i2 && s2.change(i2.propsRef.value);
          }
          break;
        case o$2.ArrowRight:
        case o$2.ArrowDown:
          if (e2.preventDefault(), e2.stopPropagation(), P(a2, N$2.Next | N$2.WrapAround) === T$1.Success) {
            let i2 = l2.value.find((r2) => {
              var c2;
              return r2.element === ((c2 = i$3(r2.element)) == null ? void 0 : c2.activeElement);
            });
            i2 && s2.change(i2.propsRef.value);
          }
          break;
        case o$2.Space:
          {
            e2.preventDefault(), e2.stopPropagation();
            let n2 = l2.value.find((i2) => {
              var r2;
              return i2.element === ((r2 = i$3(i2.element)) == null ? void 0 : r2.activeElement);
            });
            n2 && s2.change(n2.propsRef.value);
          }
          break;
      }
    }
    let b2 = computed(() => {
      var e2;
      return (e2 = o$3(p2)) == null ? void 0 : e2.closest("form");
    });
    return onMounted(() => {
      watch([b2], () => {
        if (!b2.value || t2.defaultValue === void 0) return;
        function e2() {
          s2.change(t2.defaultValue);
        }
        return b2.value.addEventListener("reset", e2), () => {
          var a2;
          (a2 = b2.value) == null || a2.removeEventListener("reset", e2);
        };
      }, { immediate: true });
    }), () => {
      let { disabled: e$1, name: a2, form: n2, ...i2 } = t2, r2 = { ref: p2, id: d2, role: "radiogroup", "aria-labelledby": R.value, "aria-describedby": T$2.value, onKeydown: v2 };
      return h$1(Fragment, [...a2 != null && f2.value != null ? e({ [a2]: f2.value }).map(([c2, L2]) => h$1(f$2, E$1({ features: u$2.Hidden, key: c2, as: "input", type: "hidden", hidden: true, readOnly: true, form: n2, disabled: e$1, name: c2, value: L2 }))) : [], A$1({ ourProps: r2, theirProps: { ...u2, ...T(i2, ["modelValue", "defaultValue", "by"]) }, slot: {}, attrs: u2, slots: S2, name: "RadioGroup" })]);
    };
  } });
  var ie = ((u2) => (u2[u2.Empty = 1] = "Empty", u2[u2.Active = 2] = "Active", u2))(ie || {});
  let Oe = /* @__PURE__ */ defineComponent({ name: "RadioGroupOption", props: { as: { type: [Object, String], default: "div" }, value: { type: [Object, String, Number, Boolean] }, disabled: { type: Boolean, default: false }, id: { type: String, default: null } }, setup(t2, { attrs: m2, slots: u2, expose: S2 }) {
    var i2;
    let g2 = (i2 = t2.id) != null ? i2 : `headlessui-radiogroup-option-${I$1()}`, d2 = N("RadioGroupOption"), p2 = E({ name: "RadioGroupLabel" }), l2 = k({ name: "RadioGroupDescription" }), R = ref(null), T2 = computed(() => ({ value: t2.value, disabled: t2.disabled })), f2 = ref(1);
    S2({ el: R, $el: R });
    let G = computed(() => o$3(R));
    onMounted(() => d2.registerOption({ id: g2, element: G, propsRef: T2 })), onUnmounted(() => d2.unregisterOption(g2));
    let s2 = computed(() => {
      var r2;
      return ((r2 = d2.firstOption.value) == null ? void 0 : r2.id) === g2;
    }), v2 = computed(() => d2.disabled.value || t2.disabled), b2 = computed(() => d2.compare(toRaw(d2.value.value), toRaw(t2.value))), O2 = computed(() => v2.value ? -1 : b2.value || !d2.containsCheckedOption.value && s2.value ? 0 : -1);
    function e2() {
      var r2;
      d2.change(t2.value) && (f2.value |= 2, (r2 = o$3(R)) == null || r2.focus());
    }
    function a2() {
      f2.value |= 2;
    }
    function n2() {
      f2.value &= -3;
    }
    return () => {
      let { value: r2, disabled: c2, ...L2 } = t2, K = { checked: b2.value, disabled: v2.value, active: Boolean(f2.value & 2) }, M = { id: g2, ref: R, role: "radio", "aria-checked": b2.value ? "true" : "false", "aria-labelledby": p2.value, "aria-describedby": l2.value, "aria-disabled": v2.value ? true : void 0, tabIndex: O2.value, onClick: v2.value ? void 0 : e2, onFocus: v2.value ? void 0 : a2, onBlur: v2.value ? void 0 : n2 };
      return A$1({ ourProps: M, theirProps: L2, slot: K, attrs: m2, slots: u2, name: "RadioGroupOption" });
    };
  } });
  const _hoisted_1$r = /* @__PURE__ */ createBaseVNode("span", { class: "sr-only" }, "Open options", -1);
  const _hoisted_2$o = { class: "py-1" };
  const _sfc_main$s = {
    __name: "MinimalDropdownMenu",
    setup(__props) {
      return (_ctx, _cache) => {
        return openBlock(), createBlock(unref(ge), {
          as: "div",
          class: "relative inline-block text-left"
        }, {
          default: withCtx(() => [
            createBaseVNode("div", null, [
              createVNode(unref(Se), { class: "flex items-center rounded-full text-gray-400 hover:text-gray-600 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 focus:ring-offset-gray-100" }, {
                default: withCtx(() => [
                  _hoisted_1$r,
                  createVNode(unref(Icon), {
                    icon: "heroicons:ellipsis-vertical-20-solid",
                    class: "h-5 w-5",
                    "aria-hidden": "true"
                  })
                ]),
                _: 1
              })
            ]),
            createVNode(Transition, {
              "enter-active-class": "transition ease-out duration-100",
              "enter-from-class": "transform opacity-0 scale-95",
              "enter-to-class": "transform opacity-100 scale-100",
              "leave-active-class": "transition ease-in duration-75",
              "leave-from-class": "transform opacity-100 scale-100",
              "leave-to-class": "transform opacity-0 scale-95"
            }, {
              default: withCtx(() => [
                createVNode(unref(Me), { class: "absolute right-0 z-10 mt-2 w-56 origin-top-right rounded-md bg-white shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none" }, {
                  default: withCtx(() => [
                    createBaseVNode("div", _hoisted_2$o, [
                      renderSlot(_ctx.$slots, "menu-items")
                    ])
                  ]),
                  _: 3
                })
              ]),
              _: 3
            })
          ]),
          _: 3
        });
      };
    }
  };
  const _hoisted_1$q = { class: "px-4 sm:px-6 lg:px-8 dark:bg-gray-900" };
  const _hoisted_2$n = { class: "sm:flex sm:items-center" };
  const _hoisted_3$j = /* @__PURE__ */ createBaseVNode("div", { class: "sm:flex-auto" }, [
    /* @__PURE__ */ createBaseVNode("h1", { class: "text-base font-semibold leading-6 text-gray-900 dark:text-gray-100" }, "Domains"),
    /* @__PURE__ */ createBaseVNode("p", { class: "mt-2 text-sm text-gray-700 dark:text-gray-300" }, "These are your verified custom domains.")
  ], -1);
  const _hoisted_4$i = { class: "mt-4 sm:ml-16 sm:mt-0 sm:flex-none" };
  const _hoisted_5$i = { class: "-mx-4 mt-10 ring-1 ring-gray-300 sm:mx-0 sm:rounded-lg dark:ring-gray-700" };
  const _hoisted_6$f = { class: "min-w-full divide-y divide-gray-300 dark:divide-gray-700" };
  const _hoisted_7$b = /* @__PURE__ */ createBaseVNode("thead", null, [
    /* @__PURE__ */ createBaseVNode("tr", null, [
      /* @__PURE__ */ createBaseVNode("th", {
        scope: "col",
        class: "py-3.5 pl-4 pr-3 text-left text-sm font-semibold text-gray-900 sm:pl-6 dark:text-gray-100"
      }, "Domain "),
      /* @__PURE__ */ createBaseVNode("th", {
        scope: "col",
        class: "hidden px-3 py-3.5 text-left text-sm font-semibold text-gray-900 lg:table-cell dark:text-gray-100"
      }, " Status"),
      /* @__PURE__ */ createBaseVNode("th", {
        scope: "col",
        class: "hidden px-3 py-3.5 text-left text-sm font-semibold text-gray-900 lg:table-cell dark:text-gray-100"
      }, " Added"),
      /* @__PURE__ */ createBaseVNode("th", {
        scope: "col",
        class: "relative py-3.5 pl-3 pr-4 sm:pr-6"
      }, [
        /* @__PURE__ */ createBaseVNode("span", { class: "sr-only" }, "Actions")
      ])
    ])
  ], -1);
  const _hoisted_8$b = { class: "divide-y divide-gray-200 dark:divide-gray-700" };
  const _hoisted_9$d = ["tabindex"];
  const _hoisted_10$c = { class: "whitespace-nowrap py-4 pl-4 pr-3 text-sm font-medium text-gray-900 sm:pl-6 dark:text-gray-100" };
  const _hoisted_11$d = { class: "hidden whitespace-nowrap px-3 py-4 text-sm text-gray-500 lg:table-cell dark:text-gray-300" };
  const _hoisted_12$b = { class: "hidden whitespace-nowrap px-3 py-4 text-sm text-gray-500 lg:table-cell dark:text-gray-300" };
  const _hoisted_13$b = { class: "whitespace-nowrap py-4 pl-3 pr-4 text-right text-sm font-medium sm:pr-6" };
  const _hoisted_14$9 = ["action"];
  const _hoisted_15$9 = ["value"];
  const _hoisted_16$8 = ["disabled"];
  const _hoisted_17$9 = /* @__PURE__ */ createBaseVNode("span", null, "Remove", -1);
  const _sfc_main$r = /* @__PURE__ */ defineComponent({
    __name: "DomainsTable",
    props: {
      domains: {}
    },
    setup(__props) {
      const csrfStore = useCsrfStore();
      const router2 = useRouter();
      const { isSubmitting, submitForm } = useFormSubmission({
        successMessage: "Domain removed successfully",
        onSuccess: () => {
          router2.go(0);
        }
      });
      const formatRelativeTime = (epochSeconds) => {
        const date = new Date(epochSeconds * 1e3);
        const now = /* @__PURE__ */ new Date();
        const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1e3);
        const rtf = new Intl.RelativeTimeFormat("en", { numeric: "auto" });
        if (diffInSeconds < 60) {
          return rtf.format(-diffInSeconds, "second");
        } else if (diffInSeconds < 3600) {
          return rtf.format(-Math.floor(diffInSeconds / 60), "minute");
        } else if (diffInSeconds < 86400) {
          return rtf.format(-Math.floor(diffInSeconds / 3600), "hour");
        } else {
          return rtf.format(-Math.floor(diffInSeconds / 86400), "day");
        }
      };
      return (_ctx, _cache) => {
        const _component_router_link = resolveComponent("router-link");
        return openBlock(), createElementBlock("div", _hoisted_1$q, [
          createBaseVNode("div", _hoisted_2$n, [
            _hoisted_3$j,
            createBaseVNode("div", _hoisted_4$i, [
              createVNode(_component_router_link, {
                to: "/account/domains/add",
                class: "block rounded-md bg-brand-600 px-3 py-2 text-center text-sm font-semibold text-white shadow-sm hover:bg-brand-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-brand-600 dark:bg-brand-500 dark:hover:bg-brand-400"
              }, {
                default: withCtx(() => [
                  createTextVNode("Add Domain")
                ]),
                _: 1
              })
            ])
          ]),
          createBaseVNode("div", _hoisted_5$i, [
            createBaseVNode("table", _hoisted_6$f, [
              _hoisted_7$b,
              createBaseVNode("tbody", _hoisted_8$b, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.domains, (domain, domainIdx) => {
                  return openBlock(), createElementBlock("tr", {
                    key: domain.identifier,
                    tabindex: domainIdx
                  }, [
                    createBaseVNode("td", _hoisted_10$c, toDisplayString(domain.display_domain), 1),
                    createBaseVNode("td", _hoisted_11$d, [
                      createVNode(_sfc_main$x, {
                        mode: "icon",
                        domain
                      }, null, 8, ["domain"])
                    ]),
                    createBaseVNode("td", _hoisted_12$b, toDisplayString(formatRelativeTime(Number(domain.created))), 1),
                    createBaseVNode("td", _hoisted_13$b, [
                      createVNode(_sfc_main$s, null, {
                        "menu-items": withCtx(() => [
                          createVNode(unref(be), null, {
                            default: withCtx(({ active }) => [
                              createVNode(_component_router_link, {
                                to: { name: "AccountDomainVerify", params: { domain: domain.display_domain } },
                                class: normalizeClass([active ? "bg-gray-100 text-gray-900" : "text-gray-700", "block px-4 py-2 text-sm"])
                              }, {
                                default: withCtx(() => [
                                  createTextVNode(" Review verification steps ")
                                ]),
                                _: 2
                              }, 1032, ["to", "class"])
                            ]),
                            _: 2
                          }, 1024),
                          createBaseVNode("form", {
                            onSubmit: _cache[0] || (_cache[0] = withModifiers((event) => unref(submitForm)(event), ["prevent"])),
                            action: `/api/v2/account/domains/${domain.display_domain}/remove`
                          }, [
                            createBaseVNode("input", {
                              type: "hidden",
                              name: "shrimp",
                              value: unref(csrfStore).shrimp
                            }, null, 8, _hoisted_15$9),
                            createVNode(unref(be), { class: "text-red-500" }, {
                              default: withCtx(({ active }) => [
                                createBaseVNode("button", {
                                  type: "submit",
                                  class: normalizeClass([
                                    active ? "bg-gray-100 text-gray-900" : "text-gray-700",
                                    "flex w-full items-center px-4 py-2 text-left text-sm"
                                  ]),
                                  disabled: unref(isSubmitting)
                                }, [
                                  createVNode(unref(Icon), {
                                    icon: "heroicons:trash-20-solid",
                                    class: "mr-2 h-5 w-5 text-red-500"
                                  }),
                                  _hoisted_17$9
                                ], 10, _hoisted_16$8)
                              ]),
                              _: 1
                            })
                          ], 40, _hoisted_14$9)
                        ]),
                        _: 2
                      }, 1024)
                    ])
                  ], 8, _hoisted_9$d);
                }), 128))
              ])
            ])
          ])
        ]);
      };
    }
  });
  const _hoisted_1$p = { class: "" };
  const _sfc_main$q = /* @__PURE__ */ defineComponent({
    __name: "AccountDomains",
    setup(__props) {
      const { records: domains, fetchData: fetchDomains } = useFetchData({
        url: "/api/v2/account/domains"
      });
      onMounted(fetchDomains);
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$p, [
          createVNode(_sfc_main$T),
          createVNode(_sfc_main$r, { domains: unref(domains) }, null, 8, ["domains"])
        ]);
      };
    }
  });
  const AccountDomains = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: _sfc_main$q
  }, Symbol.toStringTag, { value: "Module" }));
  const _hoisted_1$o = ["value"];
  const _hoisted_2$m = /* @__PURE__ */ createBaseVNode("div", { class: "hidden" }, [
    /* @__PURE__ */ createBaseVNode("label", { for: "username" }, "Username"),
    /* @__PURE__ */ createBaseVNode("input", {
      type: "text",
      id: "username",
      autocomplete: "username"
    })
  ], -1);
  const _hoisted_3$i = { class: "relative mb-4" };
  const _hoisted_4$h = /* @__PURE__ */ createBaseVNode("label", {
    for: "currentPassword",
    id: "currentPasswordLabel",
    class: "dark:text-gray-300 block text-sm font-medium text-gray-700"
  }, "Current Password", -1);
  const _hoisted_5$h = { class: "relative" };
  const _hoisted_6$e = ["type"];
  const _hoisted_7$a = { class: "relative mb-4" };
  const _hoisted_8$a = /* @__PURE__ */ createBaseVNode("label", {
    for: "newPassword",
    id: "newPasswordLabel",
    class: "dark:text-gray-300 block text-sm font-medium text-gray-700"
  }, "New Password", -1);
  const _hoisted_9$c = { class: "relative" };
  const _hoisted_10$b = ["type"];
  const _hoisted_11$c = { class: "relative mb-4" };
  const _hoisted_12$a = /* @__PURE__ */ createBaseVNode("label", {
    for: "confirmPassword",
    id: "confirmPasswordlabel",
    class: "dark:text-gray-300 block text-sm font-medium text-gray-700"
  }, "Confirm", -1);
  const _hoisted_13$a = { class: "relative" };
  const _hoisted_14$8 = ["type"];
  const _hoisted_15$8 = {
    key: 0,
    class: "mb-4 text-red-500"
  };
  const _hoisted_16$7 = {
    key: 1,
    class: "mb-4 text-green-500"
  };
  const _hoisted_17$8 = {
    type: "submit",
    class: "hover:bg-gray-600 flex items-center justify-center w-full px-4 py-2 text-white bg-gray-500 rounded"
  };
  const _hoisted_18$7 = /* @__PURE__ */ createBaseVNode("i", { class: "fas fa-save mr-2" }, null, -1);
  const _sfc_main$p = /* @__PURE__ */ defineComponent({
    __name: "AccountChangePasswordForm",
    props: {
      apitoken: {}
    },
    emits: ["update:password"],
    setup(__props, { emit: __emit }) {
      const csrfStore = useCsrfStore();
      const currentPassword = ref("");
      const newPassword = ref("");
      const confirmPassword = ref("");
      const showPassword = reactive({
        current: false,
        new: false,
        confirm: false
      });
      const emit2 = __emit;
      const {
        isSubmitting: isUpdatingPassword,
        error: passwordError,
        success: passwordSuccess,
        submitForm: updatePassword
      } = useFormSubmission({
        url: "/api/v2/account/change-password",
        successMessage: "Password updated successfully.",
        onSuccess() {
          emit2("update:password");
        }
      });
      const togglePassword = (field) => {
        showPassword[field] = !showPassword[field];
      };
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("form", {
          onSubmit: _cache[6] || (_cache[6] = withModifiers(
            //@ts-ignore
            (...args) => unref(updatePassword) && unref(updatePassword)(...args),
            ["prevent"]
          ))
        }, [
          createBaseVNode("input", {
            type: "hidden",
            name: "shrimp",
            value: unref(csrfStore).shrimp
          }, null, 8, _hoisted_1$o),
          _hoisted_2$m,
          createBaseVNode("div", _hoisted_3$i, [
            _hoisted_4$h,
            createBaseVNode("div", _hoisted_5$h, [
              withDirectives(createBaseVNode("input", {
                type: showPassword.current ? "text" : "password",
                name: "currentp",
                id: "currentPassword",
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => currentPassword.value = $event),
                required: "",
                tabindex: "1",
                autocomplete: "current-password",
                "aria-label": "Current Password",
                "aria-labelledby": "currentPasswordLabel",
                class: "dark:border-gray-600 focus:border-brand-500 focus:ring focus:ring-brand-500 focus:ring-opacity-50 dark:bg-gray-700 dark:text-white block w-full pr-10 mt-1 border-gray-300 rounded-md shadow-sm"
              }, null, 8, _hoisted_6$e), [
                [vModelDynamic, currentPassword.value]
              ]),
              createBaseVNode("button", {
                type: "button",
                onClick: _cache[1] || (_cache[1] = ($event) => togglePassword("current")),
                class: "absolute inset-y-0 right-0 flex items-center pr-3"
              }, [
                createVNode(unref(Icon), {
                  icon: showPassword.current ? "heroicons-solid:eye" : "heroicons-outline:eye-off",
                  class: "dark:text-gray-100 w-5 h-5 text-gray-400",
                  "aria-hidden": "true"
                }, null, 8, ["icon"])
              ])
            ])
          ]),
          createBaseVNode("div", _hoisted_7$a, [
            _hoisted_8$a,
            createBaseVNode("div", _hoisted_9$c, [
              withDirectives(createBaseVNode("input", {
                type: showPassword.new ? "text" : "password",
                name: "newp",
                id: "newPassword",
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => newPassword.value = $event),
                required: "",
                tabindex: "2",
                autocomplete: "new-password",
                "aria-label": "New Password",
                "aria-labelledby": "newPasswordLabel",
                class: "dark:border-gray-600 focus:border-brand-500 focus:ring focus:ring-brand-500 focus:ring-opacity-50 dark:bg-gray-700 dark:text-white block w-full pr-10 mt-1 border-gray-300 rounded-md shadow-sm"
              }, null, 8, _hoisted_10$b), [
                [vModelDynamic, newPassword.value]
              ]),
              createBaseVNode("button", {
                type: "button",
                onClick: _cache[3] || (_cache[3] = ($event) => togglePassword("new")),
                class: "hover:text-gray-600 dark:text-gray-300 dark:hover:text-gray-100 absolute inset-y-0 right-0 flex items-center pr-3 text-gray-400"
              }, [
                createVNode(unref(Icon), {
                  icon: showPassword.new ? "heroicons-solid:eye" : "heroicons-outline:eye-off",
                  class: "dark:text-gray-100 w-5 h-5 text-gray-400",
                  "aria-hidden": "true"
                }, null, 8, ["icon"])
              ])
            ])
          ]),
          createBaseVNode("div", _hoisted_11$c, [
            _hoisted_12$a,
            createBaseVNode("div", _hoisted_13$a, [
              withDirectives(createBaseVNode("input", {
                type: showPassword.confirm ? "text" : "password",
                name: "newp2",
                id: "confirmPassword",
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => confirmPassword.value = $event),
                required: "",
                tabindex: "3",
                autocomplete: "confirm-password",
                "aria-label": "New Password",
                "aria-labelledby": "confirmPasswordlabel",
                class: "dark:border-gray-600 focus:border-brand-500 focus:ring focus:ring-brand-500 focus:ring-opacity-50 dark:bg-gray-700 dark:text-white block w-full pr-10 mt-1 border-gray-300 rounded-md shadow-sm"
              }, null, 8, _hoisted_14$8), [
                [vModelDynamic, confirmPassword.value]
              ]),
              createBaseVNode("button", {
                type: "button",
                onClick: _cache[5] || (_cache[5] = ($event) => togglePassword("confirm")),
                class: "absolute inset-y-0 right-0 flex items-center pr-3"
              }, [
                createVNode(unref(Icon), {
                  icon: showPassword.confirm ? "heroicons-solid:eye" : "heroicons-outline:eye-off",
                  class: "dark:text-gray-100 w-5 h-5 text-gray-400",
                  "aria-hidden": "true"
                }, null, 8, ["icon"])
              ])
            ])
          ]),
          unref(passwordError) ? (openBlock(), createElementBlock("div", _hoisted_15$8, toDisplayString(unref(passwordError)), 1)) : createCommentVNode("", true),
          unref(passwordSuccess) ? (openBlock(), createElementBlock("div", _hoisted_16$7, toDisplayString(unref(passwordSuccess)), 1)) : createCommentVNode("", true),
          createBaseVNode("button", _hoisted_17$8, [
            _hoisted_18$7,
            createTextVNode(" " + toDisplayString(unref(isUpdatingPassword) ? "Updating..." : "Update Password"), 1)
          ])
        ], 32);
      };
    }
  });
  const _hoisted_1$n = /* @__PURE__ */ createStaticVNode('<p class="dark:text-gray-300 mb-4">Please be advised:</p><ul class="dark:text-gray-300 mb-4 list-disc list-inside"><li><span class="font-bold">Secrets will remain active until they expire.</span></li><li>Any secrets you wish to remove, <span class="underline">burn them before continuing</span>.</li><li>Deleting your account is <span class="italic">permanent and non-reversible.</span></li></ul>', 2);
  const _hoisted_3$h = /* @__PURE__ */ createBaseVNode("i", { class: "fas fa-trash-alt mr-2" }, null, -1);
  const _hoisted_4$g = { class: "dark:text-gray-400 mt-2 text-sm text-gray-500" };
  const _hoisted_5$g = {
    key: 0,
    class: "fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50"
  };
  const _hoisted_6$d = ["value"];
  const _hoisted_7$9 = { class: "dark:bg-gray-800 p-6 bg-white rounded-lg shadow-lg" };
  const _hoisted_8$9 = /* @__PURE__ */ createBaseVNode("h3", { class: "dark:text-white mb-4 text-xl font-bold text-gray-900" }, "Confirm Account Deletion", -1);
  const _hoisted_9$b = /* @__PURE__ */ createBaseVNode("p", { class: "dark:text-gray-300 mb-4 text-gray-700" }, "Are you sure you want to permanently delete your account? This action cannot be undone.", -1);
  const _hoisted_10$a = /* @__PURE__ */ createBaseVNode("input", {
    type: "hidden",
    name: "tabindex",
    value: "destroy"
  }, null, -1);
  const _hoisted_11$b = { class: "mb-4" };
  const _hoisted_12$9 = {
    key: 0,
    class: "mb-4 text-red-500"
  };
  const _hoisted_13$9 = {
    key: 1,
    class: "mb-4 text-green-500"
  };
  const _hoisted_14$7 = { class: "flex justify-end space-x-4" };
  const _hoisted_15$7 = ["disabled"];
  const _hoisted_16$6 = {
    key: 0,
    class: "animate-spin w-5 h-5 mr-3 -ml-1 text-white",
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24"
  };
  const _hoisted_17$7 = /* @__PURE__ */ createBaseVNode("circle", {
    class: "opacity-25",
    cx: "12",
    cy: "12",
    r: "10",
    stroke: "currentColor",
    "stroke-width": "4"
  }, null, -1);
  const _hoisted_18$6 = /* @__PURE__ */ createBaseVNode("path", {
    class: "opacity-75",
    fill: "currentColor",
    d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
  }, null, -1);
  const _hoisted_19$6 = [
    _hoisted_17$7,
    _hoisted_18$6
  ];
  const _hoisted_20$5 = {
    key: 1,
    xmlns: "http://www.w3.org/2000/svg",
    class: "w-5 h-5 mr-2",
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "currentColor"
  };
  const _hoisted_21$4 = /* @__PURE__ */ createBaseVNode("path", {
    "fill-rule": "evenodd",
    d: "M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z",
    "clip-rule": "evenodd"
  }, null, -1);
  const _hoisted_22$4 = [
    _hoisted_21$4
  ];
  const _sfc_main$o = /* @__PURE__ */ defineComponent({
    __name: "AccountDeleteButtonWithModalForm",
    props: {
      apitoken: {},
      cust: {}
    },
    emits: ["delete:account"],
    setup(__props, { emit: __emit }) {
      const csrfStore = useCsrfStore();
      const emit2 = __emit;
      const showDeleteModal = ref(false);
      const deletePassword = ref("");
      const {
        isSubmitting: isDeleting,
        error: deleteError,
        success: deleteSuccess,
        submitForm: submitDeleteAccount
      } = useFormSubmission({
        url: "/api/v2/account/destroy",
        successMessage: "Account deleted successfully.",
        onSuccess: () => {
          emit2("delete:account");
          showDeleteModal.value = false;
          window.location.href = "/";
        }
      });
      const openDeleteModal = () => {
        showDeleteModal.value = true;
      };
      const closeDeleteModal = () => {
        showDeleteModal.value = false;
        deletePassword.value = "";
      };
      return (_ctx, _cache) => {
        var _a;
        return openBlock(), createElementBlock(Fragment, null, [
          _hoisted_1$n,
          createBaseVNode("button", {
            onClick: openDeleteModal,
            class: "hover:bg-red-700 flex items-center justify-center w-full px-4 py-2 font-bold text-white bg-red-600 rounded"
          }, [
            _hoisted_3$h,
            createTextVNode(" Permanently Delete Account ")
          ]),
          createBaseVNode("p", _hoisted_4$g, "Deleting " + toDisplayString((_a = _ctx.cust) == null ? void 0 : _a.custid), 1),
          showDeleteModal.value ? (openBlock(), createElementBlock("div", _hoisted_5$g, [
            createBaseVNode("form", {
              onSubmit: _cache[1] || (_cache[1] = withModifiers(
                //@ts-ignore
                (...args) => unref(submitDeleteAccount) && unref(submitDeleteAccount)(...args),
                ["prevent"]
              )),
              class: "w-full max-w-md"
            }, [
              createBaseVNode("input", {
                type: "hidden",
                name: "shrimp",
                value: unref(csrfStore).shrimp
              }, null, 8, _hoisted_6$d),
              createBaseVNode("div", _hoisted_7$9, [
                _hoisted_8$9,
                _hoisted_9$b,
                _hoisted_10$a,
                createBaseVNode("div", _hoisted_11$b, [
                  withDirectives(createBaseVNode("input", {
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => deletePassword.value = $event),
                    name: "confirmation",
                    type: "password",
                    class: "focus:outline-none focus:ring-2 focus:ring-brand-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white w-full px-3 py-2 border border-gray-300 rounded-md",
                    autocomplete: "confirmation",
                    placeholder: "Confirm with your password"
                  }, null, 512), [
                    [vModelText, deletePassword.value]
                  ])
                ]),
                unref(deleteError) ? (openBlock(), createElementBlock("p", _hoisted_12$9, toDisplayString(unref(deleteError)), 1)) : createCommentVNode("", true),
                unref(deleteSuccess) ? (openBlock(), createElementBlock("p", _hoisted_13$9, toDisplayString(unref(deleteSuccess)), 1)) : createCommentVNode("", true),
                createBaseVNode("div", _hoisted_14$7, [
                  createBaseVNode("button", {
                    onClick: closeDeleteModal,
                    type: "button",
                    class: "hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-400 dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600 px-4 py-2 text-gray-800 bg-gray-200 rounded-md"
                  }, " Cancel "),
                  createBaseVNode("button", {
                    type: "submit",
                    disabled: !deletePassword.value || unref(isDeleting),
                    class: "hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 dark:bg-red-700 dark:hover:bg-red-800 disabled:opacity-50 disabled:cursor-not-allowed flex items-center px-4 py-2 text-white bg-red-600 rounded-md"
                  }, [
                    unref(isDeleting) ? (openBlock(), createElementBlock("svg", _hoisted_16$6, _hoisted_19$6)) : (openBlock(), createElementBlock("svg", _hoisted_20$5, _hoisted_22$4)),
                    createTextVNode(" " + toDisplayString(unref(isDeleting) ? "Deleting..." : "Delete Account"), 1)
                  ], 8, _hoisted_15$7)
                ])
              ])
            ], 32)
          ])) : createCommentVNode("", true)
        ], 64);
      };
    }
  });
  const _hoisted_1$m = {
    key: 0,
    class: "bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md space-y-6 mb-6"
  };
  const _hoisted_2$l = { class: "flex items-center justify-between" };
  const _hoisted_3$g = { class: "text-2xl font-bold text-gray-900 dark:text-white flex items-center" };
  const _hoisted_4$f = /* @__PURE__ */ createBaseVNode("a", {
    href: "/account/billing_portal",
    class: "inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-brandcomp-500 hover:bg-brandcomp-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-brandcomp-500 transition-colors duration-150"
  }, " Manage Subscription ", -1);
  const _hoisted_5$f = { class: "grid grid-cols-1 md:grid-cols-2 gap-6" };
  const _hoisted_6$c = { class: "space-y-4" };
  const _hoisted_7$8 = /* @__PURE__ */ createBaseVNode("h3", { class: "text-lg font-semibold text-gray-700 dark:text-gray-300" }, "Customer Information", -1);
  const _hoisted_8$8 = { class: "text-sm text-gray-600 dark:text-gray-400 space-y-2" };
  const _hoisted_9$a = { key: 0 };
  const _hoisted_10$9 = { key: 1 };
  const _hoisted_11$a = {
    key: 0,
    class: "space-y-4"
  };
  const _hoisted_12$8 = /* @__PURE__ */ createBaseVNode("h3", { class: "text-lg font-semibold text-gray-700 dark:text-gray-300" }, "Default Payment Method", -1);
  const _hoisted_13$8 = { class: "flex items-center text-sm text-gray-600 dark:text-gray-400" };
  const _hoisted_14$6 = { class: "space-y-6" };
  const _hoisted_15$6 = /* @__PURE__ */ createBaseVNode("h3", { class: "text-lg font-semibold text-gray-700 dark:text-gray-300" }, "Subscriptions", -1);
  const _hoisted_16$5 = { class: "flex justify-between items-center mb-4" };
  const _hoisted_17$6 = { class: "text-sm font-medium text-gray-700 dark:text-gray-300" };
  const _hoisted_18$5 = { class: "text-sm text-gray-600 dark:text-gray-400" };
  const _hoisted_19$5 = { key: 0 };
  const _sfc_main$n = /* @__PURE__ */ defineComponent({
    __name: "AccountBillingSection",
    props: {
      stripeCustomer: { default: null },
      stripeSubscriptions: { default: () => [] }
    },
    setup(__props) {
      const props = __props;
      const formatDate = (timestamp) => new Date(timestamp * 1e3).toLocaleDateString();
      const defaultPaymentMethod = computed(() => {
        var _a, _b;
        return (_b = (_a = props.stripeCustomer) == null ? void 0 : _a.invoice_settings) == null ? void 0 : _b.default_payment_method;
      });
      const subscriptionDetails = computed(() => {
        return props.stripeSubscriptions.map((subscription) => {
          var _a, _b, _c, _d, _e, _f;
          return {
            id: subscription.id,
            status: subscription.status,
            amount: ((_b = (_a = subscription.items.data[0]) == null ? void 0 : _a.price) == null ? void 0 : _b.unit_amount) ?? 0,
            quantity: ((_c = subscription.items.data[0]) == null ? void 0 : _c.quantity) ?? 1,
            interval: ((_f = (_e = (_d = subscription.items.data[0]) == null ? void 0 : _d.price) == null ? void 0 : _e.recurring) == null ? void 0 : _f.interval) ?? "month",
            currentPeriodEnd: subscription.current_period_end
          };
        });
      });
      return (_ctx, _cache) => {
        var _a;
        return props.stripeSubscriptions.length > 0 && props.stripeCustomer ? (openBlock(), createElementBlock("div", _hoisted_1$m, [
          createBaseVNode("header", _hoisted_2$l, [
            createBaseVNode("h2", _hoisted_3$g, [
              createVNode(unref(Icon), {
                icon: "mdi:credit-card-outline",
                class: "w-6 h-6 mr-2 text-brandcomp-500"
              }),
              createTextVNode(" Subscription ")
            ]),
            _hoisted_4$f
          ]),
          createBaseVNode("section", _hoisted_5$f, [
            createBaseVNode("div", _hoisted_6$c, [
              _hoisted_7$8,
              createBaseVNode("ul", _hoisted_8$8, [
                createBaseVNode("li", null, "Customer since: " + toDisplayString(formatDate(props.stripeCustomer.created)), 1),
                props.stripeCustomer.email ? (openBlock(), createElementBlock("li", _hoisted_9$a, "Email: " + toDisplayString(props.stripeCustomer.email), 1)) : createCommentVNode("", true),
                props.stripeCustomer.balance !== 0 ? (openBlock(), createElementBlock("li", _hoisted_10$9, " Account balance: $" + toDisplayString((props.stripeCustomer.balance / 100).toFixed(2)), 1)) : createCommentVNode("", true)
              ])
            ]),
            ((_a = defaultPaymentMethod.value) == null ? void 0 : _a.card) ? (openBlock(), createElementBlock("div", _hoisted_11$a, [
              _hoisted_12$8,
              createBaseVNode("div", _hoisted_13$8, [
                createVNode(unref(Icon), {
                  icon: "mdi:credit-card",
                  class: "w-8 h-8 mr-2 text-gray-400"
                }),
                createTextVNode(" " + toDisplayString(defaultPaymentMethod.value.card.brand) + " ending in " + toDisplayString(defaultPaymentMethod.value.card.last4), 1)
              ])
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("section", _hoisted_14$6, [
            _hoisted_15$6,
            (openBlock(true), createElementBlock(Fragment, null, renderList(subscriptionDetails.value, (subscription) => {
              return openBlock(), createElementBlock("div", {
                key: subscription.id,
                class: "bg-gray-50 dark:bg-gray-700 p-4 rounded-lg"
              }, [
                createBaseVNode("div", _hoisted_16$5, [
                  createBaseVNode("span", {
                    class: normalizeClass([
                      "px-2 py-1 text-xs font-semibold rounded-full",
                      subscription.status === "active" ? "bg-green-100 text-green-800 dark:bg-green-800 dark:text-green-100" : "bg-yellow-100 text-yellow-800 dark:bg-yellow-800 dark:text-yellow-100"
                    ])
                  }, toDisplayString(subscription.status.charAt(0).toUpperCase() + subscription.status.slice(1)), 3),
                  createBaseVNode("span", _hoisted_17$6, " $" + toDisplayString((subscription.amount * subscription.quantity / 100).toFixed(2)) + " / " + toDisplayString(subscription.interval), 1)
                ]),
                createBaseVNode("div", _hoisted_18$5, [
                  subscription.quantity > 1 ? (openBlock(), createElementBlock("p", _hoisted_19$5, " Quantity: " + toDisplayString(subscription.quantity) + " x $" + toDisplayString((subscription.amount / 100).toFixed(2)), 1)) : createCommentVNode("", true),
                  createBaseVNode("p", null, "Next billing date: " + toDisplayString(formatDate(subscription.currentPeriodEnd)), 1)
                ])
              ]);
            }), 128))
          ])
        ])) : createCommentVNode("", true);
      };
    }
  });
  const _withScopeId$2 = (n2) => (pushScopeId("data-v-9e123fa9"), n2 = n2(), popScopeId(), n2);
  const _hoisted_1$l = {
    key: 0,
    class: "mb-4 p-4 bg-gradient-to-r from-pink-500 via-red-500 to-yellow-400 rounded-lg shadow-lg"
  };
  const _hoisted_2$k = { class: "font-mono text-lg text-white" };
  const _hoisted_3$f = { class: "bg-black bg-opacity-20 p-3 rounded flex items-center overflow-x-auto relative" };
  const _hoisted_4$e = { class: "break-all pr-10" };
  const _hoisted_5$e = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("p", { class: "text-white text-sm mt-2 font-semibold" }, " 🔐 Keep this token secure! It provides full access to your account. ", -1));
  const _sfc_main$m = /* @__PURE__ */ defineComponent({
    __name: "APIKeyCard",
    props: {
      apitoken: { default: "" },
      onCopy: { type: Function, default: () => {
      } }
    },
    setup(__props) {
      const props = __props;
      const copied = ref(false);
      const handleCopy = () => {
        navigator.clipboard.writeText(props.apitoken).then(() => {
          copied.value = true;
          setTimeout(() => {
            copied.value = false;
          }, 2e3);
          props.onCopy();
        }).catch((err) => {
          console.error("Failed to copy text: ", err);
        });
      };
      return (_ctx, _cache) => {
        return _ctx.apitoken ? (openBlock(), createElementBlock("div", _hoisted_1$l, [
          createBaseVNode("div", _hoisted_2$k, [
            createBaseVNode("div", _hoisted_3$f, [
              createBaseVNode("span", _hoisted_4$e, toDisplayString(_ctx.apitoken), 1),
              createBaseVNode("button", {
                onClick: withModifiers(handleCopy, ["stop"]),
                type: "button",
                class: "absolute right-2 top-1/2 transform -translate-y-1/2 text-white hover:text-gray-200 transition-colors duration-200"
              }, [
                createVNode(unref(Icon), {
                  icon: copied.value ? "heroicons-outline:check" : "heroicons-outline:clipboard-copy",
                  class: "w-6 h-6"
                }, null, 8, ["icon"])
              ])
            ])
          ]),
          _hoisted_5$e
        ])) : createCommentVNode("", true);
      };
    }
  });
  const APIKeyCard = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["__scopeId", "data-v-9e123fa9"]]);
  const _hoisted_1$k = ["value"];
  const _hoisted_2$j = {
    key: 0,
    class: "mb-4 text-red-500"
  };
  const _hoisted_3$e = {
    key: 1,
    class: "mb-4 text-green-500"
  };
  const _hoisted_4$d = {
    type: "submit",
    class: "hover:bg-gray-600 flex items-center justify-center w-full px-4 py-2 text-white bg-gray-500 rounded"
  };
  const _hoisted_5$d = /* @__PURE__ */ createBaseVNode("i", { class: "fas fa-trash-alt mr-2" }, null, -1);
  const _hoisted_6$b = /* @__PURE__ */ createBaseVNode("p", { class: "dark:text-gray-400 mt-2 text-sm text-gray-500" }, null, -1);
  const _sfc_main$l = /* @__PURE__ */ defineComponent({
    __name: "APIKeyForm",
    props: {
      apitoken: {}
    },
    emits: ["update:apitoken"],
    setup(__props, { emit: __emit }) {
      const csrfStore = useCsrfStore();
      const props = __props;
      const emit2 = __emit;
      const localApiToken = ref(props.apitoken);
      watch(() => props.apitoken, (newValue) => {
        localApiToken.value = newValue;
      });
      const {
        isSubmitting: isGeneratingAPIKey,
        error: apiKeyError,
        success: apiKeySuccess,
        submitForm: generateAPIKey
      } = useFormSubmission({
        url: "/api/v2/account/apitoken",
        successMessage: "Token generated.",
        onSuccess: async (data) => {
          var _a;
          const newToken = ((_a = data.record) == null ? void 0 : _a.apitoken) || "";
          localApiToken.value = newToken;
          emit2("update:apitoken", newToken);
        }
      });
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("form", {
          onSubmit: _cache[0] || (_cache[0] = withModifiers(
            //@ts-ignore
            (...args) => unref(generateAPIKey) && unref(generateAPIKey)(...args),
            ["prevent"]
          ))
        }, [
          createBaseVNode("input", {
            type: "hidden",
            name: "shrimp",
            value: unref(csrfStore).shrimp
          }, null, 8, _hoisted_1$k),
          createVNode(APIKeyCard, { apitoken: localApiToken.value }, null, 8, ["apitoken"]),
          unref(apiKeyError) ? (openBlock(), createElementBlock("div", _hoisted_2$j, toDisplayString(unref(apiKeyError)), 1)) : createCommentVNode("", true),
          unref(apiKeySuccess) ? (openBlock(), createElementBlock("div", _hoisted_3$e, toDisplayString(unref(apiKeySuccess)), 1)) : createCommentVNode("", true),
          createBaseVNode("button", _hoisted_4$d, [
            _hoisted_5$d,
            createTextVNode(" " + toDisplayString(unref(isGeneratingAPIKey) ? "Generating..." : "Generate Token"), 1)
          ]),
          _hoisted_6$b
        ], 32);
      };
    }
  });
  const _hoisted_1$j = { class: "" };
  const _hoisted_2$i = /* @__PURE__ */ createBaseVNode("h1", { class: "dark:text-white mb-6 text-3xl font-bold" }, "Your Account", -1);
  const _hoisted_3$d = { class: "dark:text-gray-300 mb-4 text-lg" };
  const _hoisted_4$c = { class: "dark:bg-gray-800 p-6 mb-6 bg-white rounded-lg shadow" };
  const _hoisted_5$c = /* @__PURE__ */ createBaseVNode("h2", { class: "dark:text-white flex items-center mb-4 text-xl font-semibold" }, [
    /* @__PURE__ */ createBaseVNode("i", { class: "fas fa-exclamation-triangle mr-2 text-red-500" }),
    /* @__PURE__ */ createBaseVNode("span", { class: "flex-1" }, "API Key")
  ], -1);
  const _hoisted_6$a = { class: "pl-3" };
  const _hoisted_7$7 = { class: "dark:bg-gray-800 p-6 mb-6 bg-white rounded-lg shadow" };
  const _hoisted_8$7 = /* @__PURE__ */ createBaseVNode("h2", { class: "dark:text-white flex items-center mb-4 text-xl font-semibold" }, [
    /* @__PURE__ */ createBaseVNode("i", { class: "fas fa-lock mr-2" }),
    /* @__PURE__ */ createTextVNode(" Update Password ")
  ], -1);
  const _hoisted_9$9 = { class: "pl-3" };
  const _hoisted_10$8 = { class: "dark:bg-gray-800 p-6 bg-white rounded-lg shadow" };
  const _hoisted_11$9 = /* @__PURE__ */ createBaseVNode("h2", { class: "dark:text-white flex items-center mb-4 text-xl font-semibold" }, [
    /* @__PURE__ */ createBaseVNode("i", { class: "fas fa-exclamation-triangle mr-2 text-red-500" }),
    /* @__PURE__ */ createBaseVNode("span", { class: "flex-1" }, "Delete Account")
  ], -1);
  const _hoisted_12$7 = { class: "pl-3" };
  const _hoisted_13$7 = { class: "dark:text-gray-400 mt-6 text-sm text-gray-600" };
  const _sfc_main$k = /* @__PURE__ */ defineComponent({
    __name: "AccountIndex",
    setup(__props) {
      const { plan, cust, customer_since } = useWindowProps(["plan", "cust", "customer_since"]);
      const { record: account, fetchData: fetchAccount } = useFetchDataRecord({
        url: "/api/v2/account",
        onSuccess: (data) => {
          if (data[0]) ;
        }
      });
      onMounted(fetchAccount);
      return (_ctx, _cache) => {
        var _a, _b, _c, _d, _e, _f;
        return openBlock(), createElementBlock("div", _hoisted_1$j, [
          createVNode(_sfc_main$T),
          _hoisted_2$i,
          createBaseVNode("p", _hoisted_3$d, "Account type: " + toDisplayString((_b = (_a = unref(plan)) == null ? void 0 : _a.options) == null ? void 0 : _b.name), 1),
          createBaseVNode("div", _hoisted_4$c, [
            _hoisted_5$c,
            createBaseVNode("div", _hoisted_6$a, [
              createVNode(_sfc_main$l, {
                apitoken: (_c = unref(account)) == null ? void 0 : _c.apitoken
              }, null, 8, ["apitoken"])
            ])
          ]),
          createVNode(_sfc_main$n, {
            "stripe-customer": (_d = unref(account)) == null ? void 0 : _d.stripe_customer,
            "stripe-subscriptions": (_e = unref(account)) == null ? void 0 : _e.stripe_subscriptions
          }, null, 8, ["stripe-customer", "stripe-subscriptions"]),
          createBaseVNode("div", _hoisted_7$7, [
            _hoisted_8$7,
            createBaseVNode("div", _hoisted_9$9, [
              createVNode(_sfc_main$p)
            ])
          ]),
          createBaseVNode("div", _hoisted_10$8, [
            _hoisted_11$9,
            createBaseVNode("div", _hoisted_12$7, [
              unref(cust) ? (openBlock(), createBlock(_sfc_main$o, {
                key: 0,
                cust: unref(cust)
              }, null, 8, ["cust"])) : createCommentVNode("", true)
            ])
          ]),
          createBaseVNode("p", _hoisted_13$7, " Created " + toDisplayString((_f = unref(cust)) == null ? void 0 : _f.secrets_created) + " secrets since " + toDisplayString(unref(customer_since)) + ". ", 1)
        ]);
      };
    }
  });
  const AccountIndex = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: _sfc_main$k
  }, Symbol.toStringTag, { value: "Module" }));
  const _hoisted_1$i = { class: "p-2" };
  const _hoisted_2$h = { class: "text-sm font-semibold text-gray-700 dark:text-gray-300 mb-1" };
  const _hoisted_3$c = { class: "space-y-1" };
  const _hoisted_4$b = { class: "text-gray-800 dark:text-gray-200 flex-grow" };
  const _hoisted_5$b = { class: "text-xs text-gray-500 dark:text-gray-400 ml-2 whitespace-nowrap" };
  const _sfc_main$j = /* @__PURE__ */ defineComponent({
    __name: "FeedbackSection",
    props: {
      title: {},
      count: {},
      feedback: {}
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$i, [
          createBaseVNode("h4", _hoisted_2$h, toDisplayString(_ctx.title) + " (" + toDisplayString(_ctx.count) + ") ", 1),
          createBaseVNode("ul", _hoisted_3$c, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.feedback, (item) => {
              return openBlock(), createElementBlock("li", {
                key: item.stamp,
                class: "bg-gray-50 dark:bg-gray-900 rounded px-2 py-1 flex justify-between items-start"
              }, [
                createBaseVNode("span", _hoisted_4$b, toDisplayString(item.msg), 1),
                createBaseVNode("span", _hoisted_5$b, toDisplayString(item.stamp), 1)
              ]);
            }), 128))
          ])
        ]);
      };
    }
  });
  const _hoisted_1$h = { class: "bg-white dark:bg-gray-800 shadow-lg rounded-lg overflow-hidden" };
  const _hoisted_2$g = {
    id: "primaryTabs",
    class: "border-b border-gray-200 dark:border-gray-700 sticky top-0 bg-white dark:bg-gray-800 z-10"
  };
  const _hoisted_3$b = { class: "flex overflow-x-auto" };
  const _hoisted_4$a = ["href"];
  const _hoisted_5$a = { class: "p-6" };
  const _hoisted_6$9 = {
    id: "stats",
    class: "mb-8"
  };
  const _hoisted_7$6 = { class: "bg-gray-100 dark:bg-gray-700 rounded-lg p-4 mb-4" };
  const _hoisted_8$6 = { class: "text-gray-800 dark:text-gray-200" };
  const _hoisted_9$8 = { class: "font-bold" };
  const _hoisted_10$7 = { class: "text-xl font-bold mb-2 text-gray-800 dark:text-gray-200" };
  const _hoisted_11$8 = { class: "text-gray-800 dark:text-gray-200" };
  const _hoisted_12$6 = {
    id: "feedback",
    class: "mb-8"
  };
  const _hoisted_13$6 = { class: "text-lg font-bold mb-2 text-gray-800 dark:text-gray-200" };
  const _hoisted_14$5 = { class: "bg-white dark:bg-gray-800 shadow overflow-hidden sm:rounded-lg text-sm" };
  const _hoisted_15$5 = { class: "divide-y divide-gray-200 dark:divide-gray-700" };
  const _hoisted_16$4 = {
    id: "customers",
    class: "mb-8"
  };
  const _hoisted_17$5 = { class: "text-xl font-bold mb-2 text-gray-800 dark:text-gray-200" };
  const _hoisted_18$4 = { class: "bg-white dark:bg-gray-800 shadow overflow-hidden sm:rounded-lg divide-y divide-gray-200 dark:divide-gray-700" };
  const _hoisted_19$4 = ["title"];
  const _hoisted_20$4 = { class: "flex items-center justify-between" };
  const _hoisted_21$3 = { class: "text-sm font-medium text-gray-900 dark:text-gray-100" };
  const _hoisted_22$3 = { class: "text-sm text-gray-500 dark:text-gray-400" };
  const _hoisted_23$2 = { class: "mt-1 text-sm text-gray-500 dark:text-gray-400" };
  const _hoisted_24$2 = {
    id: "misc",
    class: "mb-8"
  };
  const _hoisted_25$2 = /* @__PURE__ */ createBaseVNode("h3", { class: "text-xl font-bold mt-6 mb-2 text-gray-800 dark:text-gray-200" }, "Redis Info", -1);
  const _hoisted_26$2 = { class: "bg-gray-100 dark:bg-gray-700 p-4 rounded-lg overflow-x-auto text-sm text-gray-800 dark:text-gray-200" };
  const _sfc_main$i = /* @__PURE__ */ defineComponent({
    __name: "ColonelIndex",
    setup(__props) {
      const tabs = [
        { name: "Stats", href: "#stats" },
        { name: "Customers", href: "#customers" },
        { name: "Feedback", href: "#feedback" },
        { name: "Misc", href: "#misc" }
      ];
      const feedbackSections = computed(() => {
        if (!colonelData.value) return [];
        return [
          { title: "Today", count: colonelData.value.counts.today_feedback_count, feedback: colonelData.value.today_feedback },
          { title: "Yesterday", count: colonelData.value.counts.yesterday_feedback_count, feedback: colonelData.value.yesterday_feedback },
          { title: "Past 14 Days", count: colonelData.value.counts.older_feedback_count, feedback: colonelData.value.older_feedback }
        ];
      });
      const { record: colonelData, fetchData: fetchColonelData } = useFetchDataRecord({
        url: "/api/v2/colonel"
      });
      onMounted(fetchColonelData);
      return (_ctx, _cache) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
        return openBlock(), createElementBlock("div", _hoisted_1$h, [
          createBaseVNode("div", _hoisted_2$g, [
            createBaseVNode("nav", _hoisted_3$b, [
              (openBlock(), createElementBlock(Fragment, null, renderList(tabs, (tab) => {
                return createBaseVNode("a", {
                  key: tab.href,
                  href: tab.href,
                  class: "text-gray-600 dark:text-gray-300 hover:text-brand-500 dark:hover:text-brand-400 px-3 py-2 font-medium text-sm"
                }, toDisplayString(tab.name), 9, _hoisted_4$a);
              }), 64))
            ])
          ]),
          createBaseVNode("div", _hoisted_5$a, [
            createBaseVNode("div", _hoisted_6$9, [
              createBaseVNode("div", _hoisted_7$6, [
                createBaseVNode("p", _hoisted_8$6, [
                  createTextVNode(" Sessions: "),
                  createBaseVNode("span", _hoisted_9$8, toDisplayString((_a = unref(colonelData)) == null ? void 0 : _a.counts.session_count), 1),
                  createTextVNode(" (active in the past 5 minutes) ")
                ])
              ]),
              createBaseVNode("h3", _hoisted_10$7, " Secrets (" + toDisplayString((_b = unref(colonelData)) == null ? void 0 : _b.counts.secret_count) + ") ", 1),
              createBaseVNode("p", _hoisted_11$8, " Metadata / Secrets: " + toDisplayString((_c = unref(colonelData)) == null ? void 0 : _c.counts.metadata_count) + "/" + toDisplayString((_d = unref(colonelData)) == null ? void 0 : _d.counts.secret_count) + " (" + toDisplayString((_e = unref(colonelData)) == null ? void 0 : _e.counts.secrets_created) + "/" + toDisplayString((_f = unref(colonelData)) == null ? void 0 : _f.counts.secrets_shared) + "/" + toDisplayString((_g = unref(colonelData)) == null ? void 0 : _g.counts.emails_sent) + " total) ", 1)
            ]),
            createBaseVNode("div", _hoisted_12$6, [
              createBaseVNode("h3", _hoisted_13$6, " User Feedback (Total: " + toDisplayString((_h = unref(colonelData)) == null ? void 0 : _h.counts.feedback_count) + ") ", 1),
              createBaseVNode("div", _hoisted_14$5, [
                createBaseVNode("div", _hoisted_15$5, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(feedbackSections.value, (section) => {
                    return openBlock(), createBlock(_sfc_main$j, {
                      key: section.title,
                      title: section.title,
                      count: section.count,
                      feedback: section.feedback
                    }, null, 8, ["title", "count", "feedback"]);
                  }), 128))
                ])
              ])
            ]),
            createBaseVNode("div", _hoisted_16$4, [
              createBaseVNode("h3", _hoisted_17$5, " Customers (" + toDisplayString((_i = unref(colonelData)) == null ? void 0 : _i.counts.recent_customer_count) + " of " + toDisplayString((_j = unref(colonelData)) == null ? void 0 : _j.counts.customer_count) + ") ", 1),
              createBaseVNode("ul", _hoisted_18$4, [
                (openBlock(true), createElementBlock(Fragment, null, renderList((_k = unref(colonelData)) == null ? void 0 : _k.recent_customers, (customer) => {
                  return openBlock(), createElementBlock("li", {
                    key: customer.custid,
                    class: "px-4 py-3 sm:px-6",
                    title: customer.verified ? "verified" : "not verified"
                  }, [
                    createBaseVNode("div", _hoisted_20$4, [
                      createBaseVNode("p", _hoisted_21$3, [
                        createBaseVNode("strong", null, toDisplayString(customer.custid), 1),
                        createTextVNode(toDisplayString(customer.colonel ? "*" : ""), 1)
                      ]),
                      createBaseVNode("p", _hoisted_22$3, toDisplayString(customer.secrets_created) + "/" + toDisplayString(customer.secrets_shared) + "/" + toDisplayString(customer.emails_sent) + " [" + toDisplayString(customer.planid) + "] ", 1)
                    ]),
                    createBaseVNode("p", _hoisted_23$2, [
                      createBaseVNode("em", null, toDisplayString(customer.stamp), 1),
                      createTextVNode(toDisplayString(!customer.verified ? "?" : ""), 1)
                    ])
                  ], 8, _hoisted_19$4);
                }), 128))
              ])
            ]),
            createBaseVNode("div", _hoisted_24$2, [
              _hoisted_25$2,
              createBaseVNode("pre", _hoisted_26$2, toDisplayString((_l = unref(colonelData)) == null ? void 0 : _l.redis_info), 1)
            ])
          ])
        ]);
      };
    }
  });
  const ColonelIndex = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: _sfc_main$i
  }, Symbol.toStringTag, { value: "Module" }));
  const _hoisted_1$g = {
    action: "/signin",
    method: "POST",
    class: "bg-white dark:bg-gray-800 shadow-md rounded px-8 pt-6 pb-8 mb-4"
  };
  const _hoisted_2$f = /* @__PURE__ */ createBaseVNode("input", {
    type: "hidden",
    name: "utf8",
    value: "✓"
  }, null, -1);
  const _hoisted_3$a = ["value"];
  const _hoisted_4$9 = { class: "mb-4 relative" };
  const _hoisted_5$9 = {
    class: "block text-gray-700 dark:text-gray-300 text-sm font-bold mb-2",
    for: "custidField"
  };
  const _hoisted_6$8 = { class: "relative" };
  const _hoisted_7$5 = /* @__PURE__ */ createBaseVNode("svg", {
    class: "absolute left-3 top-1/2 transform -translate-y-1/2 h-5 w-5 text-gray-400",
    fill: "none",
    stroke: "currentColor",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20"
  }, [
    /* @__PURE__ */ createBaseVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M16 12a4 4 0 10-8 0 4 4 0 008 0zm0 0v1.5a2.5 2.5 0 005 0V12a9 9 0 10-9 9m4.5-1.206a8.959 8.959 0 01-4.5 1.207"
    })
  ], -1);
  const _hoisted_8$5 = ["placeholder"];
  const _hoisted_9$7 = { class: "mb-6 relative" };
  const _hoisted_10$6 = {
    class: "block text-gray-700 dark:text-gray-300 text-sm font-bold mb-2",
    for: "passField"
  };
  const _hoisted_11$7 = { class: "relative" };
  const _hoisted_12$5 = ["type", "placeholder"];
  const _hoisted_13$5 = /* @__PURE__ */ createBaseVNode("svg", {
    class: "absolute left-3 top-1/2 transform -translate-y-1/2 h-5 w-5 text-gray-400",
    fill: "none",
    stroke: "currentColor",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20"
  }, [
    /* @__PURE__ */ createBaseVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"
    })
  ], -1);
  const _hoisted_14$4 = /* @__PURE__ */ createBaseVNode("svg", {
    class: "h-5 w-5",
    fill: "none",
    stroke: "currentColor",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20"
  }, [
    /* @__PURE__ */ createBaseVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M15 12a3 3 0 11-6 0 3 3 0 016 0z"
    }),
    /* @__PURE__ */ createBaseVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"
    })
  ], -1);
  const _hoisted_15$4 = [
    _hoisted_14$4
  ];
  const _hoisted_16$3 = { class: "mb-6 flex items-center" };
  const _hoisted_17$4 = { class: "flex items-center" };
  const _hoisted_18$3 = {
    for: "rememberMe",
    class: "ml-2 text-sm font-medium text-gray-900 dark:text-gray-300"
  };
  const _hoisted_19$3 = { class: "flex items-center justify-between" };
  const _hoisted_20$3 = {
    type: "submit",
    tabindex: "4",
    class: "px-4 py-2 font-bold text-white bg-brand-500 rounded-md hover:bg-brand-600 focus:outline-none focus:ring-2 focus:ring-brandcomp-500 focus:ring-offset-2 dark:bg-brand-600 dark:hover:bg-brand-700 transition-colors duration-300 ease-in-out transform hover:scale-105"
  };
  const _sfc_main$h = /* @__PURE__ */ defineComponent({
    __name: "SignInForm",
    props: {
      enabled: { type: Boolean, default: true }
    },
    setup(__props) {
      const csrfStore = useCsrfStore();
      const email2 = ref("");
      const password = ref("");
      const rememberMe = ref(false);
      const showPassword = ref(false);
      const togglePasswordVisibility = () => {
        showPassword.value = !showPassword.value;
      };
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("form", _hoisted_1$g, [
          _hoisted_2$f,
          createBaseVNode("input", {
            type: "hidden",
            name: "shrimp",
            value: unref(csrfStore).shrimp
          }, null, 8, _hoisted_3$a),
          createBaseVNode("fieldset", null, [
            createBaseVNode("div", _hoisted_4$9, [
              createBaseVNode("label", _hoisted_5$9, toDisplayString(_ctx.$t("web.COMMON.field_email")), 1),
              createBaseVNode("div", _hoisted_6$8, [
                _hoisted_7$5,
                withDirectives(createBaseVNode("input", {
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => email2.value = $event),
                  type: "email",
                  name: "u",
                  id: "custidField",
                  required: "",
                  tabindex: "1",
                  autofocus: "",
                  class: "shadow appearance-none border rounded w-full py-2 pl-10 pr-3 text-gray-700 dark:text-gray-300 dark:bg-gray-700 focus:ring-brandcomp-500 focus:ring-2 leading-tight focus:outline-none focus:shadow-outline transition duration-300 ease-in-out invalid:not(:placeholder-shown):border-red-500 invalid:not(:placeholder-shown):text-red-600",
                  placeholder: _ctx.$t("web.COMMON.email_placeholder"),
                  autocomplete: "email",
                  "aria-required": "true"
                }, null, 8, _hoisted_8$5), [
                  [vModelText, email2.value]
                ])
              ])
            ]),
            createBaseVNode("div", _hoisted_9$7, [
              createBaseVNode("label", _hoisted_10$6, toDisplayString(_ctx.$t("web.COMMON.field_password")), 1),
              createBaseVNode("div", _hoisted_11$7, [
                withDirectives(createBaseVNode("input", {
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => password.value = $event),
                  type: showPassword.value ? "text" : "password",
                  name: "p",
                  id: "passField",
                  required: "",
                  tabindex: "2",
                  class: "w-full pl-10 pr-10 py-2 text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-700 border rounded-md transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-brandcomp-500",
                  placeholder: _ctx.$t("web.COMMON.password_placeholder"),
                  autocomplete: "new-password",
                  "aria-required": "true"
                }, null, 8, _hoisted_12$5), [
                  [vModelDynamic, password.value]
                ]),
                _hoisted_13$5,
                createBaseVNode("button", {
                  type: "button",
                  class: "absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600",
                  onClick: togglePasswordVisibility
                }, _hoisted_15$4)
              ])
            ]),
            createBaseVNode("div", _hoisted_16$3, [
              createBaseVNode("div", _hoisted_17$4, [
                withDirectives(createBaseVNode("input", {
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => rememberMe.value = $event),
                  type: "checkbox",
                  tabindex: "3",
                  name: "remember",
                  id: "rememberMe",
                  class: "w-4 h-4 text-brandcomp-600 bg-gray-100 border-gray-300 rounded focus:ring-brandcomp-500 dark:focus:ring-brandcomp-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600"
                }, null, 512), [
                  [vModelCheckbox, rememberMe.value]
                ]),
                createBaseVNode("label", _hoisted_18$3, toDisplayString(_ctx.$t("web.login.remember_me")), 1)
              ])
            ]),
            createBaseVNode("div", _hoisted_19$3, [
              createBaseVNode("button", _hoisted_20$3, toDisplayString(_ctx.$t("web.login.button_sign_in")), 1)
            ])
          ])
        ]);
      };
    }
  });
  const _hoisted_1$f = { class: "my-20" };
  const _hoisted_2$e = { class: "my-8" };
  const _hoisted_3$9 = {
    class: "text-2xl font-semibold mb-4 text-gray-900 dark:text-gray-100",
    "aria-label": "Sign In"
  };
  const _hoisted_4$8 = { class: "text-center" };
  const _hoisted_5$8 = { class: "space-y-2" };
  const _sfc_main$g = /* @__PURE__ */ defineComponent({
    __name: "Signin",
    setup(__props) {
      return (_ctx, _cache) => {
        const _component_router_link = resolveComponent("router-link");
        return openBlock(), createElementBlock("div", _hoisted_1$f, [
          createBaseVNode("section", _hoisted_2$e, [
            createBaseVNode("h3", _hoisted_3$9, toDisplayString(_ctx.$t("web.login.enter_your_credentials")), 1),
            createVNode(_sfc_main$h)
          ]),
          createBaseVNode("div", _hoisted_4$8, [
            createBaseVNode("ul", _hoisted_5$8, [
              createBaseVNode("li", null, [
                createVNode(_component_router_link, {
                  to: "/signup",
                  class: "text-sm text-gray-600 dark:text-gray-400 hover:underline transition duration-300 ease-in-out",
                  "aria-label": "Sign Up"
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(_ctx.$t("web.login.need_an_account")), 1)
                  ]),
                  _: 1
                })
              ]),
              createBaseVNode("li", null, [
                createVNode(_component_router_link, {
                  to: "/forgot",
                  class: "text-sm text-gray-600 dark:text-gray-400 hover:underline transition duration-300 ease-in-out",
                  "aria-label": "Forgot Password"
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(_ctx.$t("web.login.forgot_your_password")), 1)
                  ]),
                  _: 1
                })
              ])
            ])
          ])
        ]);
      };
    }
  });
  const Signin = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: _sfc_main$g
  }, Symbol.toStringTag, { value: "Module" }));
  const _hoisted_1$e = { class: "mb-8 bg-gradient-to-r from-brand-600 to-brand-800 dark:from-brand-800 dark:to-brand-900 rounded-lg shadow-lg p-6 text-white" };
  const _hoisted_2$d = { class: "text-xl font-semibold mb-2 text-white" };
  const _hoisted_3$8 = { class: "mb-4 text-white/90 dark:text-white/80" };
  const _hoisted_4$7 = ["href"];
  const _hoisted_5$7 = /* @__PURE__ */ createBaseVNode("svg", {
    class: "mr-2 h-5 w-5",
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor",
    "aria-hidden": "true",
    height: "24",
    width: "24"
  }, [
    /* @__PURE__ */ createBaseVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.03 3-9s-1.343-9-3-9m0 18c-1.657 0-3-4.03-3-9s1.343-9 3-9m-9 9a9 9 0 019-9"
    })
  ], -1);
  const _hoisted_6$7 = /* @__PURE__ */ createBaseVNode("svg", {
    class: "ml-2 w-4 h-4",
    fill: "none",
    stroke: "currentColor",
    height: "20",
    width: "20",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    /* @__PURE__ */ createBaseVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M9 5l7 7-7 7"
    })
  ], -1);
  const _sfc_main$f = /* @__PURE__ */ defineComponent({
    __name: "PlansElevateCta",
    setup(__props) {
      const router2 = useRouter();
      const pricingLink = computed(() => router2.resolve({ name: "Pricing" }).href);
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("section", _hoisted_1$e, [
          createBaseVNode("h4", _hoisted_2$d, toDisplayString(_ctx.$t("web.COMMON.custom_domains_title")), 1),
          createBaseVNode("p", _hoisted_3$8, toDisplayString(_ctx.$t("web.COMMON.custom_domains_description")), 1),
          createBaseVNode("a", {
            href: pricingLink.value,
            class: "inline-flex items-center px-4 py-2 border border-transparent text-sm font-brand rounded-md text-brand-600 bg-white dark:bg-gray-800 dark:text-brand-400 hover:bg-gray-50 dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-brand-500 dark:focus:ring-brand-400 transition-colors duration-200"
          }, [
            _hoisted_5$7,
            createTextVNode(" " + toDisplayString(_ctx.$t("web.COMMON.get_started_button")) + " ", 1),
            _hoisted_6$7
          ], 8, _hoisted_4$7)
        ]);
      };
    }
  });
  const _hoisted_1$d = {
    action: "/signup",
    method: "POST",
    class: "max-w-md mx-auto bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg"
  };
  const _hoisted_2$c = /* @__PURE__ */ createBaseVNode("input", {
    type: "hidden",
    name: "utf8",
    value: "✓"
  }, null, -1);
  const _hoisted_3$7 = ["value"];
  const _hoisted_4$6 = ["value"];
  const _hoisted_5$6 = { class: "mb-4 relative" };
  const _hoisted_6$6 = {
    class: "block text-gray-700 dark:text-gray-300 text-sm font-bold mb-2",
    for: "custidField"
  };
  const _hoisted_7$4 = { class: "relative" };
  const _hoisted_8$4 = ["placeholder"];
  const _hoisted_9$6 = /* @__PURE__ */ createBaseVNode("svg", {
    class: "absolute left-3 top-1/2 transform -translate-y-1/2 h-5 w-5 text-gray-400",
    fill: "none",
    stroke: "currentColor",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20"
  }, [
    /* @__PURE__ */ createBaseVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M16 12a4 4 0 10-8 0 4 4 0 008 0zm0 0v1.5a2.5 2.5 0 005 0V12a9 9 0 10-9 9m4.5-1.206a8.959 8.959 0 01-4.5 1.207"
    })
  ], -1);
  const _hoisted_10$5 = { class: "mb-4 relative" };
  const _hoisted_11$6 = {
    class: "block text-gray-700 dark:text-gray-300 text-sm font-bold mb-2",
    for: "passField"
  };
  const _hoisted_12$4 = { class: "relative" };
  const _hoisted_13$4 = ["type", "placeholder"];
  const _hoisted_14$3 = /* @__PURE__ */ createBaseVNode("svg", {
    class: "absolute left-3 top-1/2 transform -translate-y-1/2 h-5 w-5 text-gray-400",
    fill: "none",
    stroke: "currentColor",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20"
  }, [
    /* @__PURE__ */ createBaseVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"
    })
  ], -1);
  const _hoisted_15$3 = /* @__PURE__ */ createBaseVNode("svg", {
    class: "h-5 w-5",
    fill: "none",
    stroke: "currentColor",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20"
  }, [
    /* @__PURE__ */ createBaseVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M15 12a3 3 0 11-6 0 3 3 0 016 0z"
    }),
    /* @__PURE__ */ createBaseVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"
    })
  ], -1);
  const _hoisted_16$2 = [
    _hoisted_15$3
  ];
  const _hoisted_17$3 = { class: "mb-4 relative" };
  const _hoisted_18$2 = {
    class: "block text-gray-700 dark:text-gray-300 text-sm font-bold mb-2",
    for: "pass2Field"
  };
  const _hoisted_19$2 = { class: "relative" };
  const _hoisted_20$2 = ["type", "placeholder"];
  const _hoisted_21$2 = /* @__PURE__ */ createBaseVNode("svg", {
    class: "absolute left-3 top-1/2 transform -translate-y-1/2 h-5 w-5 text-gray-400",
    fill: "none",
    stroke: "currentColor",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20"
  }, [
    /* @__PURE__ */ createBaseVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"
    })
  ], -1);
  const _hoisted_22$2 = /* @__PURE__ */ createBaseVNode("svg", {
    class: "h-5 w-5",
    fill: "none",
    stroke: "currentColor",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20"
  }, [
    /* @__PURE__ */ createBaseVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M15 12a3 3 0 11-6 0 3 3 0 016 0z"
    }),
    /* @__PURE__ */ createBaseVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"
    })
  ], -1);
  const _hoisted_23$1 = [
    _hoisted_22$2
  ];
  const _hoisted_24$1 = { class: "mb-4 hidden" };
  const _hoisted_25$1 = /* @__PURE__ */ createBaseVNode("label", {
    class: "block text-gray-700 dark:text-gray-300 text-sm font-bold mb-2",
    for: "skillTest"
  }, " Skill ", -1);
  const _hoisted_26$1 = ["placeholder"];
  const _hoisted_27$1 = { class: "flex items-center justify-between" };
  const _hoisted_28$1 = {
    type: "submit",
    tabindex: "4",
    class: "px-4 py-2 font-bold text-white bg-brand-500 rounded-md hover:bg-brand-600 focus:outline-none focus:ring-2 focus:ring-brandcomp-500 focus:ring-offset-2 dark:bg-brand-600 dark:hover:bg-brand-700 transition-colors duration-300 ease-in-out transform hover:scale-105"
  };
  const _sfc_main$e = /* @__PURE__ */ defineComponent({
    __name: "SignUpForm",
    props: {
      enabled: { type: Boolean, default: true },
      planid: { default: "basic" }
    },
    setup(__props) {
      const csrfStore = useCsrfStore();
      const props = __props;
      const email2 = ref("");
      const password = ref("");
      const confirmPassword = ref("");
      const skill = ref("");
      const passwordFieldType = ref("password");
      const confirmPasswordFieldType = ref("password");
      const togglePasswordVisibility = (field) => {
        if (field === "password") {
          passwordFieldType.value = passwordFieldType.value === "password" ? "text" : "password";
        } else {
          confirmPasswordFieldType.value = confirmPasswordFieldType.value === "password" ? "text" : "password";
        }
      };
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("form", _hoisted_1$d, [
          _hoisted_2$c,
          createBaseVNode("input", {
            type: "hidden",
            name: "shrimp",
            value: unref(csrfStore).shrimp
          }, null, 8, _hoisted_3$7),
          createBaseVNode("input", {
            type: "hidden",
            name: "planid",
            value: props.planid
          }, null, 8, _hoisted_4$6),
          createBaseVNode("fieldset", null, [
            createBaseVNode("div", _hoisted_5$6, [
              createBaseVNode("label", _hoisted_6$6, toDisplayString(_ctx.$t("web.COMMON.field_email")), 1),
              createBaseVNode("div", _hoisted_7$4, [
                withDirectives(createBaseVNode("input", {
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => email2.value = $event),
                  type: "email",
                  name: "u",
                  id: "custidField",
                  tabindex: "1",
                  class: "w-full pl-10 pr-3 py-2 text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-700 border rounded-md transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-brandcomp-500 invalid:border-red-500",
                  placeholder: _ctx.$t("web.COMMON.email_placeholder"),
                  autocomplete: "email",
                  "aria-required": "true"
                }, null, 8, _hoisted_8$4), [
                  [vModelText, email2.value]
                ]),
                _hoisted_9$6
              ])
            ]),
            createBaseVNode("div", _hoisted_10$5, [
              createBaseVNode("label", _hoisted_11$6, toDisplayString(_ctx.$t("web.COMMON.field_password")), 1),
              createBaseVNode("div", _hoisted_12$4, [
                withDirectives(createBaseVNode("input", {
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => password.value = $event),
                  type: passwordFieldType.value,
                  name: "p",
                  id: "passField",
                  tabindex: "2",
                  class: "w-full pl-10 pr-10 py-2 text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-700 border rounded-md transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-brandcomp-500",
                  placeholder: _ctx.$t("web.COMMON.password_placeholder"),
                  autocomplete: "new-password",
                  "aria-required": "true"
                }, null, 8, _hoisted_13$4), [
                  [vModelDynamic, password.value]
                ]),
                _hoisted_14$3,
                createBaseVNode("button", {
                  type: "button",
                  onClick: _cache[2] || (_cache[2] = ($event) => togglePasswordVisibility("password")),
                  class: "absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600"
                }, _hoisted_16$2)
              ])
            ]),
            createBaseVNode("div", _hoisted_17$3, [
              createBaseVNode("label", _hoisted_18$2, toDisplayString(_ctx.$t("web.COMMON.field_password2")), 1),
              createBaseVNode("div", _hoisted_19$2, [
                withDirectives(createBaseVNode("input", {
                  "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => confirmPassword.value = $event),
                  type: confirmPasswordFieldType.value,
                  name: "p2",
                  id: "pass2Field",
                  tabindex: "3",
                  class: "w-full pl-10 pr-10 py-2 text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-700 border rounded-md transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-brandcomp-500",
                  placeholder: _ctx.$t("web.COMMON.confirm_password_placeholder"),
                  autocomplete: "new-password",
                  "aria-required": "true"
                }, null, 8, _hoisted_20$2), [
                  [vModelDynamic, confirmPassword.value]
                ]),
                _hoisted_21$2,
                createBaseVNode("button", {
                  type: "button",
                  onClick: _cache[4] || (_cache[4] = ($event) => togglePasswordVisibility("confirmPassword")),
                  class: "absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600"
                }, _hoisted_23$1)
              ])
            ]),
            createBaseVNode("div", _hoisted_24$1, [
              _hoisted_25$1,
              withDirectives(createBaseVNode("input", {
                "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => skill.value = $event),
                type: "text",
                name: "skill",
                id: "skillTest",
                class: "w-full px-3 py-2 text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-700 border rounded-md transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-brandcomp-500",
                placeholder: _ctx.$t("web.COMMON.skill_placeholder"),
                autocomplete: "off"
              }, null, 8, _hoisted_26$1), [
                [vModelText, skill.value]
              ])
            ]),
            createBaseVNode("div", _hoisted_27$1, [
              createBaseVNode("button", _hoisted_28$1, toDisplayString(_ctx.$t("web.COMMON.button_create_account")), 1)
            ])
          ])
        ]);
      };
    }
  });
  const _hoisted_1$c = { class: "mb-8" };
  const _hoisted_2$b = /* @__PURE__ */ createBaseVNode("h1", { class: "font-semibold mb-6 text-gray-900 dark:text-gray-100" }, "Signup", -1);
  const _hoisted_3$6 = { class: "font-semibold mb- text-gray-900 dark:text-gray-100" };
  const _hoisted_4$5 = { class: "list-disc pl-6 text-gray-700 dark:text-gray-300" };
  const _hoisted_5$5 = { class: "font-bold text-brand-600 dark:text-brand-400" };
  const _hoisted_6$5 = { key: 0 };
  const _hoisted_7$3 = /* @__PURE__ */ createBaseVNode("span", { class: "font-bold text-brand-600 dark:text-brand-400" }, "email", -1);
  const _hoisted_8$3 = { key: 1 };
  const _hoisted_9$5 = ["href"];
  const _hoisted_10$4 = { class: "mt-6 text-center" };
  const _hoisted_11$5 = /* @__PURE__ */ createBaseVNode("strong", { class: "font-medium text-gray-900 dark:text-gray-200" }, "Sign In", -1);
  const _sfc_main$d = /* @__PURE__ */ defineComponent({
    __name: "Signup",
    props: {
      planCode: {}
    },
    setup(__props) {
      const props = __props;
      const currentPlanId = props.planCode || "basic";
      const availablePlans = window.available_plans;
      const currentPlan = availablePlans[currentPlanId];
      const supportHost = useWindowProp("support_host");
      return (_ctx, _cache) => {
        const _component_router_link = resolveComponent("router-link");
        return openBlock(), createElementBlock("div", null, [
          createBaseVNode("section", _hoisted_1$c, [
            _hoisted_2$b,
            createBaseVNode("h3", _hoisted_3$6, " Our " + toDisplayString(unref(currentPlan).options.name) + " plan! You get: ", 1),
            createBaseVNode("ul", _hoisted_4$5, [
              createBaseVNode("li", null, [
                createTextVNode("secrets that live up to "),
                createBaseVNode("span", _hoisted_5$5, toDisplayString(unref(currentPlan).options.ttl / 3600 / 24) + " days", 1),
                createTextVNode(".")
              ]),
              unref(currentPlan).options.email ? (openBlock(), createElementBlock("li", _hoisted_6$5, [
                createTextVNode("to send secret links via "),
                _hoisted_7$3,
                createTextVNode(".")
              ])) : createCommentVNode("", true),
              unref(currentPlan).options.api ? (openBlock(), createElementBlock("li", _hoisted_8$3, [
                createTextVNode("access to the "),
                createBaseVNode("a", {
                  href: `${unref(supportHost)}/docs/rest-api`,
                  class: "font-bold text-brand-600 dark:text-brand-400 hover:underline"
                }, "API", 8, _hoisted_9$5),
                createTextVNode(".")
              ])) : createCommentVNode("", true)
            ])
          ]),
          createVNode(_sfc_main$f),
          createVNode(_sfc_main$e, { planid: unref(currentPlanId) }, null, 8, ["planid"]),
          createBaseVNode("div", _hoisted_10$4, [
            createVNode(_component_router_link, {
              to: "/signin",
              class: "text-sm text-gray-600 dark:text-gray-400 hover:underline"
            }, {
              default: withCtx(() => [
                createTextVNode(" Already have an account? "),
                _hoisted_11$5
              ]),
              _: 1
            })
          ])
        ]);
      };
    }
  });
  const Signup = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: _sfc_main$d
  }, Symbol.toStringTag, { value: "Module" }));
  const _sfc_main$c = /* @__PURE__ */ defineComponent({
    __name: "EmailObfuscator",
    props: {
      email: {},
      subject: { default: "" }
    },
    setup(__props) {
      const props = __props;
      const obfuscateEmail = (email2) => {
        return email2.replace("@", " &#65;&#84; ").replace(".", " D0T ");
      };
      const deobfuscateEmail = (email2) => {
        return email2.replace(/ &#65;&#84; /g, "@").replace(/ AT /g, "@").replace(/ D0T /g, ".");
      };
      const displayedEmail = ref(obfuscateEmail(props.email));
      const handleClick = async () => {
        const deobfuscatedEmail = deobfuscateEmail(props.email);
        try {
          await navigator.clipboard.writeText(deobfuscatedEmail);
          alert("Email address copied to clipboard!");
        } catch (err) {
          console.error("Failed to copy email: ", err);
        }
      };
      onMounted(() => {
        displayedEmail.value = deobfuscateEmail(props.email);
      });
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("a", {
          onClick: handleClick,
          class: "email cursor-pointer text-brand-500 dark:text-brand-400 hover:underline"
        }, toDisplayString(displayedEmail.value), 1);
      };
    }
  });
  const _hoisted_1$b = { class: "container mx-auto p-4 max-w-2xl" };
  const _hoisted_2$a = { class: "prose dark:text-gray-300" };
  const _hoisted_3$5 = /* @__PURE__ */ createStaticVNode('<h1 class="intro dark:text-gray-300">Privacy Policy</h1><p class="prose dark:text-gray-300">Effective date: <span class="font-bold dark:text-gray-300">June 15, 2024</span></p><p class="prose dark:text-gray-300"> Thanks for entrusting onetimesecret.com with your secrets. Holding onto your private information is a serious responsibility, and we want you to know how we&#39;re handling it. </p><h2 class="dark:text-gray-300">The short version</h2><p class="prose dark:text-gray-300"> We collect your information only with your consent; we only collect the minimum amount of personal information that is necessary to fulfill the purpose of your interaction with us; we don&#39;t sell it to third parties; and we only use it as this Privacy Statement describes. </p><p class="prose dark:text-gray-300"> Of course, the short version doesn&#39;t tell you everything, so please read on for more details! </p><h2 class="dark:text-gray-300">What information onetimesecret.com collects and why</h2><h3 class="dark:text-gray-300">Information from website browsers</h3><p class="prose dark:text-gray-300"> If you&#39;re <span class="font-bold dark:text-gray-300">just browsing the website</span>, we collect the same basic information that most websites collect. We use common internet technologies, such as cookies and web server logs. This is stuff we collect from everybody, whether they have an account or not. </p><p class="prose dark:text-gray-300"> The information we collect about all visitors to our website includes the visitor’s browser type, language preference, referring site, additional websites requested, and the date and time of each visitor request. We also collect potentially personally-identifying information like Internet Protocol (IP) addresses. </p><h5 class="dark:text-gray-300">Why do we collect this?</h5><p class="prose dark:text-gray-300"> We collect this information to better understand how our website visitors use onetimesecret.com and to monitor and protect the security of the website. </p><h3 class="dark:text-gray-300">Information from users with accounts</h3><p class="prose dark:text-gray-300"> If you <span class="font-bold dark:text-gray-300">create an account</span>, we require some basic information at the time of account creation. You will create your own user name and password, and we will ask you for a valid email account. You also have the option to give us more information if you want to, and this may include &quot;User Personal Information.&quot; </p><p class="prose dark:text-gray-300"> &quot;User Personal Information&quot; is any information about one of our users which could, alone or together with other information, personally identify him or her. Information such as a user name and password, an email address, a real name, and a photograph are examples of “User Personal Information.” </p><p class="prose dark:text-gray-300"> User Personal Information does not include aggregated, non-personally identifying information. We may use aggregated, non-personally identifying information to operate, improve, and optimize our website and service. </p><h5 class="dark:text-gray-300">Why do we collect this?</h5><ul><li> We need your User Personal Information to create your account, and to provide the services you request. </li><li> We use your User Personal Information, specifically your user name and email address, to identify you on onetimesecret.com. </li><li> We will use your email address to communicate with you, if you&#39;ve said that&#39;s okay, <span class="font-bold dark:text-gray-300">and only for the reasons you’ve said that’s okay</span>. Please see our section on <a class="dark:text-gray-300" href="#how-we-communicate-with-you" rel="noopener noreferrer">email communication</a> for more information. </li><li> We limit our use of your User Personal Information to the purposes listed in this Privacy Statement. If we need to use your User Personal Information for other purposes, we will ask your permission first. </li></ul><h2 class="dark:text-gray-300">What information onetimesecret.com does not collect</h2><p class="prose dark:text-gray-300"> We do not intentionally collect <span class="font-bold dark:text-gray-300">sensitive personal information</span>, such as social security numbers, genetic data, health information, or religious information. Although onetimesecret.com does not request or intentionally collect any sensitive personal information, we realize that you might store this kind of information in your account, such as in a secret. If you store any sensitive personal information on our servers, you are consenting to our storage of that information on our servers, which are in the European Union (EU) and subject to European data protection laws. </p><p class="prose dark:text-gray-300"> We do not intentionally collect information that is <span class="font-bold dark:text-gray-300">stored in your secrets</span> or other free-form content inputs. Information in your secrets belongs to you, and you are responsible for it, as well as for making sure that your content complies with our <a class="dark:text-gray-300" href="/info/terms/" rel="noopener noreferrer">Terms of Service</a>. onetimesecret.com employees do not access secrets unless required to for security or maintenance, or for support reasons, with the consent of the secret owner. </p><p class="prose dark:text-gray-300"> If you&#39;re a <span class="font-bold dark:text-gray-300">child under the age of 13</span>, you may not have an account on onetimesecret.com. onetimesecret.com does not knowingly collect information from or direct any of our content specifically to children under 13. If we learn or have reason to suspect that you are a user who is under the age of 13, we will unfortunately have to close your account. We don&#39;t want to discourage you from learning to code, but those are the rules. Please see our <a class="dark:text-gray-300" href="/info/terms/" rel="noopener noreferrer">Terms of Service</a> for information about account termination. </p><h2 class="dark:text-gray-300">How we share the information we collect</h2><p class="prose dark:text-gray-300"> We <span class="font-bold dark:text-gray-300">do not</span> share, sell, rent, or trade User Personal Information with third parties for their commercial purposes. </p><p class="prose dark:text-gray-300"> We do not disclose User Personal Information outside onetimesecret.com, except in the situations listed in this section or in the section below on <a class="dark:text-gray-300" href="#how-we-respond-to-compelled-disclosure">Compelled Disclosure</a>. </p><p class="prose dark:text-gray-300"> We <span class="font-bold dark:text-gray-300">do</span> share certain aggregated, non-personally identifying information with others about how our users, collectively, use onetimesecret.com, or how our users respond to our other offerings, such as our conferences or events. For example, we may compile statistics on the usage of HTTP content types across onetimesecret.com. However, we do not sell this information to advertisers or marketers. </p><p class="prose dark:text-gray-300"> We do not host advertising on onetimesecret.com. We may occasionally embed content from third party sites, such as YouTube, and that content may include ads. While we try to minimize the amount of ads our embedded content contains, we can&#39;t always control what third parties show. </p><p class="prose dark:text-gray-300"> We may share User Personal Information with your permission, so we can perform services you have requested. </p><p class="prose dark:text-gray-300"> We may share User Personal Information with a limited number of third-party vendors who process it on our behalf to provide or improve our service, and who have agreed to privacy restrictions similar to our own Privacy Statement. Our vendors perform services such as payment processing, customer support ticketing, network data transmission, and other similar services. </p><p class="prose dark:text-gray-300"> We may share User Personal Information if we are involved in a merger, sale, or acquisition. If any such change of ownership happens, we will ensure that it is under terms that preserve the confidentiality of User Personal Information, and we will notify you on our website or by email before any transfer of your User Personal Information. The organization receiving any User Personal Information will have to honor any promises we have made in our Privacy Statement or in our Terms of Service. </p><h2 class="dark:text-gray-300">Our use of cookies and tracking</h2><h3 class="dark:text-gray-300">Cookies</h3><p class="prose dark:text-gray-300"> onetimesecret.com uses cookies to make interactions with our service easy and meaningful. We use cookies (and similar technologies, like HTML5 localStorage) to keep you logged in, remember your preferences, and provide information for future development of onetimesecret.com. </p><p class="prose dark:text-gray-300"> A cookie is a small piece of text that our web server stores on your computer or mobile device, which your browser sends to us when you return to our site. Cookies do not necessarily identify you if you are merely visiting onetimesecret.com; however, a cookie may store a unique identifier for each logged in user. The cookies onetimesecret.com sets are essential for the operation of the website, or are used for performance or functionality. By using our website, you agree that we can place these types of cookies on your computer or device. If you disable your browser or device’s ability to accept cookies, you will not be able to log in or use our services. </p><h3 class="dark:text-gray-300">Third-party tracking services</h3><p class="prose dark:text-gray-300"> We do not use Google Analytics or similar third party tracking services. </p><p class="prose dark:text-gray-300"> Certain pages on our site may set other third party cookies. For example, we may embed content, such as videos, from another site that sets a cookie. While we try to minimize these third party cookies, we can’t always control what cookies this third party content sets. </p><h3 class="dark:text-gray-300">Tracking</h3><p class="prose dark:text-gray-300"> &quot;<a class="dark:text-gray-300" href="https://donottrack.us/" rel="noopener noreferrer">Do Not Track</a>&quot; is a privacy preference you can set in your browser if you do not want online services to collect and share certain kinds of information about your online activity from third party tracking services. We do not track your online browsing activity on other online services over time and we do not permit third-party services to track your activity on our site. Because we do not share this kind of data with third party services or permit this kind of third party data collection on onetimesecret.com for any of our users, and we do not track our users on third-party websites ourselves, we do not need to respond differently to an individual browser&#39;s Do Not Track setting. </p><p class="prose dark:text-gray-300"> If you are interested in turning on your browser’s privacy and Do Not Track settings, the <a class="dark:text-gray-300" href="https://donottrack.us/" rel="noopener noreferrer">Do Not Track</a> website has browser-specific instructions. </p><p class="prose dark:text-gray-300"> Please see our section on <a class="dark:text-gray-300" href="#how-we-communicate-with-you">email communication</a> to learn about our use of pixel tags in marketing emails. </p><h2 class="dark:text-gray-300">How onetimesecret.com secures your information</h2><p class="prose dark:text-gray-300"> onetimesecret.com takes all measures reasonably necessary to protect User Personal Information from unauthorized access, alteration, or destruction; maintain data accuracy; and help ensure the appropriate use of User Personal Information. We follow generally accepted industry standards to protect the personal information submitted to us, both during transmission and once we receive it. </p><p class="prose dark:text-gray-300"> No method of transmission, or method of electronic storage, is 100% secure. Therefore, we cannot guarantee its absolute security. For more information, see our <a class="dark:text-gray-300" href="/info/security/">security disclosures</a>. </p><h2 class="dark:text-gray-300">onetimesecret.com&#39;s global privacy practices</h2><p class="prose dark:text-gray-300"><span>Information that we collect will be stored and processed in the European Union</span> in accordance with this Privacy Statement. However, we understand that we have users from different countries and regions with different privacy expectations, and we try to meet those needs. </p><p class="prose dark:text-gray-300"> We may choose to offer data storage in the United States or other countries in the future. In such circumstances, data entered and stored in the EU will not be transferred to the United States or other countries without explicit consent and without changes to this Privacy Statement. </p><p class="prose dark:text-gray-300"> We provide the same standard of privacy protection to all our users around the world, regardless of their country of origin or location, and we are proud of the levels of notice, choice, accountability, security, data integrity, access, and recourse we provide. We have appointed a Privacy Counsel and we work hard to comply with the applicable data privacy laws wherever we do business. Additionally, we require that if our vendors or affiliates have access to User Personal Information, they must comply with our privacy policies and with applicable data privacy laws, including signing data transfer agreements such as Standard Contractual Clause agreements. </p><p class="prose dark:text-gray-300"> In particular: - onetimesecret.com provides clear methods of unambiguous, informed consent at the time of data collection, when we do collect your personal data. - We collect only the minimum amount of personal data necessary, unless you choose to provide more. We encourage you to only give us the amount of data you are comfortable sharing. - We offer you simple methods of accessing, correcting, or deleting the data we have collected. - We provide our users notice, choice, accountability, security, and access, and we limit the purpose for processing. We also provide our users a method of recourse and enforcement. These are the Privacy Shield Principles, but they are also just good practices. </p><h2 class="dark:text-gray-300">Resolving Complaints</h2>', 50);
  const _hoisted_53 = { class: "prose dark:text-gray-300" };
  const _hoisted_54 = /* @__PURE__ */ createBaseVNode("h2", { class: "dark:text-gray-300" }, "How we respond to compelled disclosure", -1);
  const _hoisted_55 = /* @__PURE__ */ createBaseVNode("p", { class: "prose dark:text-gray-300" }, " onetimesecret.com may disclose personally-identifying information or other information we collect about you to law enforcement in response to a valid subpoena, court order, warrant, or similar government order, or when we believe in good faith that disclosure is reasonably necessary to protect our property or rights, or those of third parties or the public at large. ", -1);
  const _hoisted_56 = /* @__PURE__ */ createBaseVNode("p", { class: "prose dark:text-gray-300" }, " In complying with court orders and similar legal processes, onetimesecret.com strives for transparency. When permitted, we will make a reasonable effort to notify users of any disclosure of their information, unless we are prohibited by law or court order from doing so, or in rare, exigent circumstances. ", -1);
  const _hoisted_57 = /* @__PURE__ */ createBaseVNode("h2", { class: "dark:text-gray-300" }, "How you can access and control the information we collect", -1);
  const _hoisted_58 = { class: "prose dark:text-gray-300" };
  const _hoisted_59 = /* @__PURE__ */ createBaseVNode("a", {
    class: "dark:text-gray-300",
    href: "https://onetimesecret.com.com/account"
  }, "editing your user profile", -1);
  const _hoisted_60 = /* @__PURE__ */ createBaseVNode("h3", { class: "dark:text-gray-300" }, "Data Retention and Deletion", -1);
  const _hoisted_61 = /* @__PURE__ */ createBaseVNode("p", { class: "prose dark:text-gray-300" }, " onetimesecret.com will retain User Personal Information for as long as your account is active or as needed to provide you services. ", -1);
  const _hoisted_62 = /* @__PURE__ */ createBaseVNode("p", { class: "prose dark:text-gray-300" }, " We may retain certain User Personal Information indefinitely, unless you delete it or request its deletion. For example, we don’t automatically delete inactive user accounts, so unless you choose to delete your account, we will retain your account information indefinitely. ", -1);
  const _hoisted_63 = { class: "prose dark:text-gray-300" };
  const _hoisted_64 = /* @__PURE__ */ createStaticVNode('<h2 class="dark:text-gray-300">How we communicate with you</h2><p class="prose dark:text-gray-300"> We will use your email address to communicate with you, if you&#39;ve said that&#39;s okay, <span class="font-bold dark:text-gray-300">and only for the reasons you’ve said that’s okay</span>. You have a lot of control over how your email address is used and shared on and through onetimesecret.com. </p><p class="prose dark:text-gray-300"> Depending on your email settings, onetimesecret.com may occasionally send notification emails about new features, requests for feedback, important policy changes, or offer customer support. We also send marketing emails, but only with your consent. There&#39;s an unsubscribe link located at the bottom of each of the emails we send you. </p><p class="prose dark:text-gray-300"> Our emails might contain a pixel tag, which is a small, clear image that can tell us whether or not you have opened an email and what your IP address is. We use this pixel tag to make our email more effective for you and to make sure we’re not sending you unwanted email. If you prefer not to receive pixel tags, please opt out of marketing emails. </p><h2 class="dark:text-gray-300">Changes to our Privacy Statement</h2><p class="prose dark:text-gray-300"> Although most changes are likely to be minor, onetimesecret.com may change this Privacy Statement from time to time. We will provide notification to Users of material changes to this Privacy Statement through our Website at least 30 days prior to the change taking effect by posting a notice on our home page or sending email to the email address specified in your onetimesecret.com primary account. For changes to this Privacy Statement that do not affect your rights, we encourage visitors to check this page frequently. </p><h2 class="dark:text-gray-300">License</h2><p class="prose dark:text-gray-300"> This Privacy Statement is licensed under this <a class="dark:text-gray-300" href="https://creativecommons.org/publicdomain/zero/1.0/" rel="noopener noreferrer">Creative Commons Zero license</a>. For details, see our <a class="dark:text-gray-300" href="https://github.com/onetimesecret/site-policy" rel="noopener noreferrer">site-policy repository</a>. </p><h2 class="dark:text-gray-300">Contacting onetimesecret.com</h2>', 9);
  const _hoisted_73 = { class: "prose dark:text-gray-300" };
  const _sfc_main$b = /* @__PURE__ */ defineComponent({
    __name: "PrivacyDoc",
    setup(__props) {
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$b, [
          createBaseVNode("article", _hoisted_2$a, [
            _hoisted_3$5,
            createBaseVNode("p", _hoisted_53, [
              createTextVNode(" If you have concerns about the way onetimesecret.com is handling your User Personal Information, please let us know immediately. We want to help. You may email us directly at "),
              createVNode(_sfc_main$c, {
                email: "support@onetimesecret.com",
                subject: "Resolving Complaints"
              }),
              createTextVNode(' with the subject line "Privacy Concerns." We will respond within 45 days at the latest. ')
            ]),
            _hoisted_54,
            _hoisted_55,
            _hoisted_56,
            _hoisted_57,
            createBaseVNode("p", _hoisted_58, [
              createTextVNode(" If you're already a onetimesecret.com user, you may access, update, alter, or delete your basic user profile information by "),
              _hoisted_59,
              createTextVNode(" or contacting "),
              createVNode(_sfc_main$c, {
                email: "support@onetimesecret.com",
                subject: "Account Update Request"
              }),
              createTextVNode(". ")
            ]),
            _hoisted_60,
            _hoisted_61,
            _hoisted_62,
            createBaseVNode("p", _hoisted_63, [
              createTextVNode(" If you would like to cancel your account or delete your User Personal Information, you may do so by emailing "),
              createVNode(_sfc_main$c, {
                email: "support@onetimesecret.com",
                subject: "Delete Account Request"
              }),
              createTextVNode(". We will retain and use your information as necessary to comply with our legal obligations, resolve disputes, and enforce our agreements, but barring legal requirements, we will delete your full profile (within reason) within 30 days. ")
            ]),
            _hoisted_64,
            createBaseVNode("p", _hoisted_73, [
              createTextVNode(" Questions regarding onetimesecret.com's Privacy Statement or information practices should be directed to "),
              createVNode(_sfc_main$c, {
                email: "support@onetimesecret.com",
                subject: "Privacy Questions"
              }),
              createTextVNode(". ")
            ])
          ])
        ]);
      };
    }
  });
  const PrivacyDoc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: _sfc_main$b
  }, Symbol.toStringTag, { value: "Module" }));
  const _sfc_main$a = {};
  const _hoisted_1$a = { class: "prose dark:text-gray-300" };
  const _hoisted_2$9 = /* @__PURE__ */ createStaticVNode('<h1 class="dark:text-gray-300">Terms of Service</h1><p class="prose dark:text-gray-300"> Effective date: <span class="dark:text-gray-300">June 15, 2024</span></p><p class="prose dark:text-gray-300"> Welcome to Onetime Secret! These terms of use (the &quot;Terms of Use&quot;) are a legal agreement between you and onetimesecret.com (&quot;Onetime Secret&quot;, &quot;Onetime Secret&quot; &quot;we&quot;, &quot;us&quot; or &quot;our&quot;) setting forth, among other things, the terms of service for your access and use of the onetimesecret.com website, and any related sub-domains, operated by Onetime Secret (the &quot;Website&quot; or &quot;Onetime Secret&quot;). </p><p class="prose dark:text-gray-300"> PLEASE READ ALL THE TERMS OF USE CAREFULLY Use of the Website. By using the Website, you accept and agree to the provisions of the Terms of Use without any reservations, modifications, additions or deletions. If you do not agree to any provisions contained in the Terms of Use, you are not authorized to use the Website. You may be denied access to the Website, with or without notice to you if you do not comply with any provisions of the Terms of Use. </p><p class="prose text-gray-800 dark:text-gray-300"><span class="font-bold dark:text-gray-300">Amendments.</span> We may from time to time modify the Terms of Use and will post a copy of the amended Terms of Use on the Website, so we encourage you to review them periodically. If we make any substantial changes to the Terms of Use, we will notify you by sending a notice to the email address specified in your account or by posting a prominent notice on our pages. If you do not agree to, or cannot comply with, the Terms of Use as amended, you are not authorized to use the Website. You will be deemed to have accepted the Terms of Use as amended if you continue to use the Website after any amendments are posted on the Website. We reserve the right to refuse to provide our Services to anyone at any time. </p><h3 class="dark:text-gray-300">1. Resources Used for the Provision of Services</h3><p class="prose dark:text-gray-300"> User accounts have fixed limits in order that we can provide a well functioning service for all users. We can disable your account should there be any attempt to use the service in a way that we deem to be unreasonable and that affects the usage of the service by others. What consists of &#39;reasonable use&#39; is completely at our discretion and your account may be disabled without prior notice if your usage is disruptive and if deemed necessary to restore a quality of service. </p><h3 class="dark:text-gray-300">2. Protection of Privacy, User Data</h3><p class="prose dark:text-gray-300"> As spelled out in our <a class="font-bold dark:text-gray-300" href="/info/privacy" rel="noopener noreferrer" aria-label="Read more about our privacy policy">Privacy Policy</a> personal and account information will never be disclosed to third parties under any circumstances other than to respond to subpoenas, court orders, or other legal process, as required by law, or to establish or exercise our legal rights or defend against legal claims. We will never sell or share any of this data. </p><p class="prose dark:text-gray-300"> Once a secret has been received by a recipient, we have no way of retrieving said secret again, nor do we log or keep any data that tracks the sender or receiver&#39;s IP address beyond 14 days. Necessary data that attaches the contents of a secret to a user account is kept only until the secret is received, at which point it is destroyed permanently. </p><h3 class="dark:text-gray-300">3. License, Restrictions and Prohibited Acts</h3><p class="prose dark:text-gray-300"><span class="font-bold dark:text-gray-300">Grant of License.</span> Onetime Secret grants you a limited, nonexclusive, nontransferable, revocable license to access and make personal use of the Website and the Services in accordance with the terms set forth in the Terms of Use. Onetime Secret reserves all right, title and interest not expressly granted under this license to the fullest extent possible under applicable laws. You may not sublicense, assign, or transfer the license granted to you under the Terms of Use, and any attempt to sublicense, assign, or transfer any part of your rights under the Terms of Use is void. </p><p class="prose dark:text-gray-300"><span class="font-bold dark:text-gray-300">Restrictions and Prohibited Acts.</span> So that the Website is available for all users to enjoy, you may not, and hereby represent, warrant and covenant that you will not or permit or enable third party to: </p><p class="prose dark:text-gray-300"> use the Website in any way that (i) violates the terms of the Terms of Use; (ii) is unlawful, harmful, threatening, tortious, defamatory, libellous, abusive, obscene, invasive of another&#39;s privacy, hateful, fraudulent or malicious; (iii) involves the transmission of &quot;junk mail,&quot; &quot;chain letters,&quot; or unsolicited mass mailing or &quot;spamming&quot;; (iv) involves the sending of any virus, Trojan horse, worm, harmful code, shutdown mechanism or similar mechanism; (v) interferes with or disrupts the Website or any server or network involved with the operation of the Website; or (vi) otherwise violates any local, national or other applicable law or regulation; use our Services to harm, in any way, the operation of any website that you do not own or operate, including, without limitation, by generating recurring traffic to such website through the conduct of tests using our Services; modify, publish, transmit, transfer or sell, reproduce, create derivative works from, distribute, perform, display or in any way exploit any of the content of the Website in whole or in part, except as expressly permitted; or use automated tools to operate the Services on the Website (scripts, etc.). Sanctions. ANY USE OF THE WEBSITE NOT SPECIFICALLY PERMITTED UNDER THE TERMS OF USE IS STRICTLY PROHIBITED AND MAY RESULT, AT ONETIME SECRET&#39; DISCRETION, IN THE SUSPENSION OR TERMINATION OF YOUR ACCOUNT AND/OR THE BLACKLISTING OF YOUR IP ADDRESS. </p><p class="prose dark:text-gray-300"><span class="font-bold dark:text-gray-300">Contact.</span> Any misuse of the Services may be reported to <span class="email dark:text-gray-300" data-subject="Potential Misuse">abuse AT onetimesecret D0T com</span>. </p><h3 class="dark:text-gray-300">4. Service Interruptions</h3><p class="prose dark:text-gray-300"><span class="font-bold dark:text-gray-300">Interruptions.</span> You acknowledge that: (i) your access to and use of the Website and/or the provision Services may be suspended for the duration of any unanticipated or unscheduled downtime or unavailability of any portion or all of the Website for any reason, including as a result of power outages, system failures or other interruptions; and (ii) we shall also be entitled, without any liability to you, to suspend access to any portion or all of the Website and/or the Services at any time (a) for scheduled downtime to permit us to conduct maintenance or make modifications to any service; (b) in the event of a denial of service attack or other attack on the Website or other event that we determine, in our sole discretion, that a risk to the applicable service, to you or to any of our other users may be created if the Service were not suspended; or (c) in the event that we determine that any Service is prohibited by law or we otherwise determine that it is necessary or prudent to do so for legal or regulatory reasons (collectively, &quot;Service Suspensions&quot;). We shall have no liability whatsoever for any damage, liabilities, losses (including any loss of data or profits) or any other consequences that you may incur as a result of any Service Suspension. </p><p class="prose dark:text-gray-300"><span class="font-bold dark:text-gray-300">Watch of Interruptions.</span> To the extent we are able, we will endeavour to post updates on the Website regarding any Service Suspension and resumption of service following any such suspension, but shall have no liability for the manner in which we may do so or if we fail to do so. </p><h3 class="dark:text-gray-300">5. Security</h3><p class="prose dark:text-gray-300"><span class="font-bold dark:text-gray-300">Your Responsibility for Security.</span> You are solely responsible for maintaining the confidentiality of your Account Information and for restricting access to your computer while logged into the Website. You agree to accept responsibility for all activities that occur under your account or from your computer. </p><p class="prose dark:text-gray-300"><span class="font-bold dark:text-gray-300">No Security Guarantee.</span> We endeavour to use <a class="font-bold dark:text-gray-300" href="/info/security" rel="noopener noreferrer">reasonable security measures</a> to protect against unauthorized access to your account. We cannot, however, guarantee absolute security of your account or the personal information we collect, and we cannot promise that our security measures will prevent thirdparty &quot;hackers&quot; from illegally accessing the Website or its contents. You agree to immediately notify Onetime Secret of any unauthorized use or your account, or any other breach of security, and you accept all risks of unauthorized access to the Website, your Account Information and any other information you provide to Onetime Secret. </p><p class="prose dark:text-gray-300"><span class="font-bold dark:text-gray-300">Disclaimer and Indemnity.</span> Onetime Secret will not be responsible for any losses arising out of the unauthorized use of your account and you agree to indemnify and hold harmless Onetime Secret, its shareholders, officers, directors, agents, employees, partners and/or licensors, as applicable, for any improper, unauthorized or illegal uses of your account. </p><h3 class="dark:text-gray-300">6. Payment</h3><p class="prose dark:text-gray-300"><span class="font-bold dark:text-gray-300">Service Providers.</span> You understand and agree that all payment for your use of the Services will be handled by third party service providers such as Stripe.com, which we may change from time to time. Your credit card information will NOT be stored by Onetime Secret but by such third party service providers. By subscribing to a paid account, you expressly authorize our payment partners to charge your credit card. </p><p class="prose dark:text-gray-300"><span class="font-bold dark:text-gray-300">Billing Period.</span> Paid accounts are billed on a monthly basis. Your account will be automatically renewed at the end of each billing period for an additional one-month period until you cancel your account. To avoid being charged for any subsequent month, you must cancel your subscription before the end of the current billing period (see &quot;Cancelling Your Account and Refund&quot; below). </p><h3 class="dark:text-gray-300"> 7. Upgrading/Downgrading Your Account, Termination and Refund Policy </h3><p class="prose dark:text-gray-300"><span class="font-bold dark:text-gray-300">Changing Your Account.</span> You may change your subscription plan at any time, and may incur additional fees if you upgrade your plan. If you have already been billed for the current month, you will not be charged for or receive the difference. If you have not been charged for the month, you will be charged the new plan amount. </p><p class="prose dark:text-gray-300"><span class="font-bold dark:text-gray-300">Cancelling Your Account and Refund.</span> You can cancel your account at any time by logging into your account, clicking the &quot;Account&quot; link in the user box at the top right, then clicking the &quot;Cancel your account&quot; link at the bottom of the page. You are responsible for the payment of any charges that have been incurred prior to the cancellation of your account. ANY PREPAID FEES WILL NOT BE REFUNDED. If you have not been charged for the month, you will not be charged. </p><p class="prose dark:text-gray-300"><span class="font-bold dark:text-gray-300">Termination by Onetime Secret.</span> Onetime Secret may terminate your account immediately upon notice to you (i) in the event of breach or violation of the Terms of Use by you, including without limitation for nonpayment of any fees owed by you in connection with your use of the Services or (ii) as set forth in the section &quot;Warranty Disclaimer&quot; (see paragraph 9 below). ANY PREPAID FEES WILL NOT BE REFUNDED. </p><p class="prose dark:text-gray-300"><span class="font-bold dark:text-gray-300">Surviving Obligations.</span> All provisions of the Terms of Use which by their nature should survive expiration or termination shall survive the expiration or termination of the Terms of Use, including, without limitation, ownership provisions, warranty disclaimers, and limitations of liability. Termination of your access to and use of the Website shall not relieve you of any obligations arising or accruing prior to such expiration or termination or limit any liability which you otherwise may have to Onetime Secret, including without limitation any indemnification obligations contained herein. </p><h3 class="dark:text-gray-300">8. Intellectual Property</h3><p class="prose dark:text-gray-300"><span class="font-bold dark:text-gray-300">Trade-marks and Copyright.</span> The following are trade-marks (registered or not) of Onetime Secret: &quot;Onetime Secret&quot;, &quot;OneTimeSecret&quot;, &quot;OnetimeSecret&quot; as well as certain other Onetime Secret trade-marks, service marks, graphics, and logos (collectively, the &quot;Trade-marks&quot;) used in connection with the Website and the provision of Services. The Website may also contain third-party trade-marks, service marks, graphics, and logos (collectively, the &quot;Other Trade-marks&quot;). All content displayed on the Website as well as all the software (including any source code) used in connection with the Services is the exclusive property of Onetime Secret or third parties and is protected by copyright laws. </p><p class="prose dark:text-gray-300"><span class="font-bold dark:text-gray-300">No License.</span> Nothing appearing on the Website will be construed as granting you any license, right, title or interest relating to the Trade-marks, the Other Trade-marks or other intellectual property used in connection with the Website and/or the Services (collectively, the &quot;Intellectual Property&quot;) and the Intellectual Property remains the exclusive property of Onetime Secret or owners. You agree not to copy, reproduce or use any Intellectual Property without our prior written consent; however, the open source tool used to create the Services is available via the MIT licence (for more information on the MIT license terms, click here). </p><p class="prose dark:text-gray-300"><span class="font-bold dark:text-gray-300">Feedback.</span> If you choose to communicate to us suggestions for improvements to the Website (collectively, &quot;Feedback&quot;), we shall own all right, title, and interest in and to the Feedback and we shall be entitled to use the Feedback without restriction. You hereby irrevocably assign all right, title and interest in and to the Feedback to us and waive all you moral rights in the Feedback, and agree to provide us such assistance as we may require to document, perfect, and maintain our rights to the Feedback. You acknowledge and agree that: (i) your Feedback does not contain confidential or proprietary information; (ii) Onetime Secret is not under any obligation of confidentiality, express or implied, with respect to the Feedback; (iii) Onetime Secret shall be entitled to use or disclose (or choose not to use or disclose) such Feedback for any purpose, in any way, in any media worldwide; (iv) Onetime Secret may have something similar to the Feedback already under consideration or in development; and (v) you are not entitled to any compensation or reimbursement of any kind from Onetime Secret under any circumstances. </p><h3 class="dark:text-gray-300">9. Disclaimers</h3><p class="prose dark:text-gray-300"> &quot;AS IS&quot; BASIS. THE WEBSITE (INCLUDING ALL OF THE CONTENT AND SERVICES AVAILABLE ON THE WEBSITE) ARE PROVIDED TO YOU &quot;AS IS.&quot; ANY USE OF THIS WEBSITE IS AT YOUR OWN RISK. TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, ONETIME SECRET DISCLAIMS ALL REPRESENTATIONS, WARRANTIES OR CONDITIONS, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OR CONDITIONS OF MERCHANTABILITY, MERCHANTABLE QUALITY, DURABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NONINFRINGEMENT. ONETIME SECRET MAKES NO REPRESENTATIONS, WARRANTIES OR GUARANTEES THAT THE WEBSITE WILL BE FREE FROM LOSS, DESTRUCTION, DAMAGE, CORRUPTION, ATTACK, VIRUSES, INTERFERENCE, HACKING, OR OTHER SECURITY INTRUSION, AND ONETIME SECRET DISCLAIMS ANY LIABILITY RELATING THERETO. </p><p class="prose dark:text-gray-300"><span class="font-bold dark:text-gray-300">Warranty Disclaimer.</span> ONETIME SECRET MAKES NO REPRESENTATIONS, WARRANTIES OR GUARANTEES THAT THE USE OR THE RESULTS OF THE USE OF THE WEBSITE (INCLUDING ALL OF ITS CONTENT OR SERVICES) ARE OR WILL BE ACCURATE, RELIABLE, CURRENT, UNINTERRUPTED OR WITHOUT ERRORS. WITHOUT PRIOR NOTICE, ONETIME SECRET MAY MODIFY, SUSPEND, OR DISCONTINUE ANY ASPECT OR FEATURE OF THE WEBSITE OR YOUR USE OF THIS WEBSITE. IF ONETIME SECRET ELECTS TO MODIFY, SUSPEND, OR DISCONTINUE THE WEBSITE, IT WILL NOT BE LIABLE TO YOU OR ANY THIRD PARTY. </p><h3 class="dark:text-gray-300">10. Limitation of Liability and Indemnity</h3><p class="prose dark:text-gray-300"><span class="font-bold dark:text-gray-300">Limitation of Liability.</span> IN NO CASE WILL ONETIME SECRET, ITS OFFICERS, DIRECTORS, SHAREHOLDERS, AGENTS, LICENSORS OR EMPLOYEES BE LIABLE FOR ANY INDIRECT, SPECIAL, CONSEQUENTIAL, EXEMPLARY, PUNITIVE DAMAGES OR OTHER DAMAGES, OR FOR ANY LOSSES, DAMAGES, LIABILITIES, COSTS AND EXPENSES ARISING OUT OF OR RELATING TO YOUR USE OF THE WEBSITE, REGARDLESS OF THE CAUSE OF ACTION (WHETHER IN CONTRACT, WARRANTY, DELICT, QUASI-DELICT, TORT, NEGLIGENCE, STRICT LIABILITY OR ANY OTHER THEORY OF LIABILITY) AND EVEN IF ONETIME SECRET HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. NOTHWITHSTANDING ANYTHING TO THE CONTRARY IN THESE TERMS OF USE, IN NO EVENT WILL ONETIME SECRET&#39; AGGREGATE LIABILITY FOR ANY CLAIMS RESULTING FROM YOUR USE OF THE WEBSITE (INCLUDING ALL OF ITS CONTENT OR SERVICES) EXCEED (I) CAD$600, IF YOU DO NOT HAVE A PAID ACCOUNT OR (II) THE FEES YOU PAID DURING THE 12 MONTHS PRECEDING THE EVENT GIVING RISE TO THE LIABILITY, IF YOU HAVE A PAID ACCOUNT. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION OF IMPLIED WARRANTIES OR LIMITATION OR EXCLUSION OF LIABILITY FOR INCIDENTAL OR CONSEQUENTIAL DAMAGES, SO THE ABOVE EXCLUSIONS AND LIMITATIONS MAY OR MAY NOT APPLY TO YOU. </p><p class="prose dark:text-gray-300"><span class="font-bold dark:text-gray-300">Indemnity.</span> YOU WILL INDEMNIFY AND HOLD ONETIME SECRET, ITS OFFICERS, DIRECTORS, SHAREHOLDERS, AGENTS, LICENSORS AND EMPLOYEE HARMLESS WITH RESPECT TO ANY SUITS, CLAIMS OR DEMANDS (INCLUDING REASONABLE LAWYERS&#39; FEES) ARISING OUT OF (I) YOUR BREACH OF THESE TERMS OF USE; (II) ANY DAMAGES BY YOU OR YOUR USE OF THE WEBSITE CAUSED TO A THIRD PARTY; OR (III) YOUR USE OR MISUSE OF THE WEBSITE AND/OR THE SERVICES. </p><h3 class="dark:text-gray-300">11. Privacy Policy</h3><p class="prose dark:text-gray-300"> Your use of the Website is also subject to Onetime Secret <a class="font-bold dark:text-gray-300" href="/info/privacy" rel="noopener noreferrer" aria-label="Read more about our privacy policy">Privacy Policy</a> (the &quot;Privacy Policy&quot;), which is incorporated by reference and made a part of the Terms of Use. It is important that you read and understand the terms of our Privacy Policy. </p><h3 class="dark:text-gray-300">12. General</h3><p class="prose dark:text-gray-300"><span class="font-bold dark:text-gray-300">No Partnership.</span> No agency, partnership, joint venture, or employment is created between you and Onetime Secret as a result of the Terms of Use and you do not have any authority of any kind to bind Onetime Secret in any respect whatsoever. </p><p class="prose dark:text-gray-300"><span class="font-bold dark:text-gray-300">Applicable Law; Jurisdiction.</span> The Terms of Use shall be governed by and construed in accordance with the laws of the Province of Québec, Canada, applicable to agreements made and entirely to be performed within the Province of Québec, excluding any rules of private international law or the conflict of laws which would lead to the application of any other laws. Regardless of where you access this site, you agree that any action at law or in equity arising out of or relating to these Terms of Use shall be filed and adjudicated only in the federal or provincial courts located in Québec (district of Montreal), and you hereby irrevocably and unconditionally consent and attorn to the exclusive jurisdiction and venue of such courts over any suit, action or proceeding arising out of these Terms of Use. </p><p class="prose dark:text-gray-300"><span class="font-bold dark:text-gray-300">Severability.</span> If any provision of this Agreement is, for any reason, held to be invalid or unenforceable, the other provisions of this Agreement will remain enforceable and the invalid or unenforceable provision will be deemed modified so that it is valid and enforceable to the maximum extent permitted by law. Waiver. Any waiver or failure to enforce any provision of this Agreement on one occasion will not be deemed a waiver of any other provision or of such provision on any other occasion. </p><p class="prose dark:text-gray-300"><span class="font-bold dark:text-gray-300">Questions.</span> If you have any questions regarding the Terms of Service or wish to report any issue relating to the Website, its content or the Services you were provided, please contact us by email at <span class="email dark:text-gray-300" data-subject="Terms of Service">support AT onetimesecret D0T com</span>. </p>', 47);
  const _hoisted_49 = [
    _hoisted_2$9
  ];
  function _sfc_render$1(_ctx, _cache) {
    return openBlock(), createElementBlock("article", _hoisted_1$a, _hoisted_49);
  }
  const TermsDoc = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$1]]);
  const TermsDoc$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: TermsDoc
  }, Symbol.toStringTag, { value: "Module" }));
  const _hoisted_1$9 = { class: "prose dark:prose-invert" };
  const _hoisted_2$8 = /* @__PURE__ */ createStaticVNode('<h2 class="text-2xl font-bold mb-4 dark:text-white">Security Policy</h2><p class="mb-4 dark:text-gray-300"> We take the security of this project seriously and appreciate your efforts to responsibly disclose vulnerabilities. This document outlines our security policy and provides guidelines on how to report vulnerabilities. </p><h3 class="text-xl font-semibold mb-2 dark:text-white">Supported Versions</h3><p class="mb-4 dark:text-gray-300">We provide security updates for the following versions of our project:</p><table class="w-full mb-4"><thead><tr class="bg-gray-100 dark:bg-gray-700"><th class="p-2 text-left dark:text-white">Version</th><th class="p-2 text-left dark:text-white">Supported</th></tr></thead><tbody><tr class="border-b dark:border-gray-600"><td class="p-2 dark:text-gray-300">0.18.x+</td><td class="p-2 dark:text-gray-300">✅</td></tr><tr class="border-b dark:border-gray-600"><td class="p-2 dark:text-gray-300">0.17.x</td><td class="p-2 dark:text-gray-300">✅</td></tr><tr><td class="p-2 dark:text-gray-300">&lt;= 0.16.0</td><td class="p-2 dark:text-gray-300">❌</td></tr></tbody></table><p class="mb-4 dark:text-gray-300"> If you are using an unsupported version, we strongly recommend upgrading to one of the supported versions to ensure you receive the latest security updates. </p><h3 class="text-xl font-semibold mb-2 dark:text-white">Reporting a Vulnerability</h3><p class="mb-4 dark:text-gray-300"> If you discover a security vulnerability within this project, we encourage you to report it as soon as possible. Here&#39;s how you can do it: </p><h4 class="text-lg font-semibold mb-2 dark:text-white">How to Report</h4>', 9);
  const _hoisted_11$4 = { class: "list-decimal pl-6 mb-4 dark:text-gray-300" };
  const _hoisted_12$3 = { class: "mb-2" };
  const _hoisted_13$3 = /* @__PURE__ */ createBaseVNode("strong", null, "Email", -1);
  const _hoisted_14$2 = /* @__PURE__ */ createBaseVNode("li", null, [
    /* @__PURE__ */ createBaseVNode("strong", null, "Details"),
    /* @__PURE__ */ createTextVNode(": Include as much information as possible about the vulnerability. This should include: "),
    /* @__PURE__ */ createBaseVNode("ul", { class: "list-disc pl-6 mt-2" }, [
      /* @__PURE__ */ createBaseVNode("li", null, "A detailed description of the vulnerability."),
      /* @__PURE__ */ createBaseVNode("li", null, "Steps to reproduce the issue."),
      /* @__PURE__ */ createBaseVNode("li", null, "Any potential impact."),
      /* @__PURE__ */ createBaseVNode("li", null, "Your contact information for follow-up questions.")
    ])
  ], -1);
  const _hoisted_15$2 = /* @__PURE__ */ createStaticVNode('<h4 class="text-lg font-semibold mb-2 dark:text-white">What to Expect</h4><ol class="dark:text-gray-300"><li><strong>Acknowledgment</strong>: You will receive an acknowledgment of your report within 5 business days. </li><li><strong>Initial Assessment</strong>: We will conduct an initial assessment of the vulnerability within 14 business days. </li><li><strong>Updates</strong>: You can expect to receive updates on the status of your report at least once every 7 days until the issue is resolved or a decision is made. </li></ol><h4 class="text-lg font-semibold mb-2 dark:text-white">Resolution Process</h4><ol class="dark:text-gray-300"><li><strong>Accepted Vulnerabilities</strong>: If the vulnerability is accepted, we will work on a fix and aim to release it as soon as possible. You will be notified once the fix is deployed. </li><li><strong>Declined Vulnerabilities</strong>: If the vulnerability is declined, we will provide a detailed explanation as to why it was not accepted. </li></ol><h4 class="text-lg font-semibold mb-2 dark:text-white">Confidentiality</h4><p class="prose dark:text-gray-300"> We take your privacy seriously. All reports will be kept confidential, and we will work with you to ensure that any details of the vulnerability are not disclosed until a fix is in place. </p><p class="prose dark:text-gray-300">Thank you for helping us keep Onetime Secret secure and excellent!</p>', 7);
  const _sfc_main$9 = /* @__PURE__ */ defineComponent({
    __name: "SecurityDoc",
    setup(__props) {
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("article", _hoisted_1$9, [
          _hoisted_2$8,
          createBaseVNode("ol", _hoisted_11$4, [
            createBaseVNode("li", _hoisted_12$3, [
              _hoisted_13$3,
              createTextVNode(": Send an email to "),
              createVNode(_sfc_main$c, {
                email: "security@onetimesecret.com",
                subject: "Vulnerability Report: [Brief Description]"
              }),
              createTextVNode(' with the subject line "Vulnerability Report: [Brief Description]". ')
            ]),
            _hoisted_14$2
          ]),
          _hoisted_15$2
        ]);
      };
    }
  });
  const SecurityDoc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: _sfc_main$9
  }, Symbol.toStringTag, { value: "Module" }));
  const _hoisted_1$8 = { class: "relative inline-block mx-1" };
  const _sfc_main$8 = /* @__PURE__ */ defineComponent({
    __name: "InfoTooltip",
    props: {
      color: {
        type: String,
        default: "bg-white text-gray-800"
      }
    },
    setup(__props) {
      const props = __props;
      const isModalVisible = ref(false);
      const toggleModal = () => {
        isModalVisible.value = !isModalVisible.value;
      };
      const closeModal = () => {
        isModalVisible.value = false;
      };
      const modalClasses = computed(() => {
        return `${props.color} border-2 border-dashed`;
      });
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$8, [
          createVNode(unref(Icon), {
            icon: "heroicons:information-circle",
            class: "inline align-baseline cursor-pointer text-base",
            onClick: toggleModal
          }),
          createVNode(Transition, { name: "fade" }, {
            default: withCtx(() => [
              isModalVisible.value ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50",
                onClick: closeModal
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(["relative max-w-md p-6 rounded-lg shadow-lg", modalClasses.value]),
                  onClick: _cache[0] || (_cache[0] = withModifiers(() => {
                  }, ["stop"]))
                }, [
                  createBaseVNode("button", {
                    onClick: closeModal,
                    class: "absolute top-2 right-2 text-gray-500 hover:text-gray-700"
                  }, [
                    createVNode(unref(Icon), { icon: "heroicons:x-mark-20-solid" })
                  ]),
                  renderSlot(_ctx.$slots, "default", {}, void 0, true)
                ], 2)
              ])) : createCommentVNode("", true)
            ]),
            _: 3
          })
        ]);
      };
    }
  });
  const InfoTooltip = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["__scopeId", "data-v-78233a39"]]);
  const _hoisted_1$7 = { class: "flex items-center" };
  const _hoisted_2$7 = /* @__PURE__ */ createBaseVNode("path", { d: "M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" }, null, -1);
  const _hoisted_3$4 = [
    _hoisted_2$7
  ];
  const _hoisted_4$4 = {
    key: 0,
    class: "w-5 h-5 text-yellow-400",
    fill: "currentColor",
    viewBox: "0 0 20 20",
    width: "20",
    height: "20"
  };
  const _hoisted_5$4 = /* @__PURE__ */ createBaseVNode("defs", null, [
    /* @__PURE__ */ createBaseVNode("linearGradient", { id: "half" }, [
      /* @__PURE__ */ createBaseVNode("stop", {
        offset: "50%",
        "stop-color": "currentColor"
      }),
      /* @__PURE__ */ createBaseVNode("stop", {
        offset: "50%",
        "stop-color": "white",
        "stop-opacity": "1"
      })
    ])
  ], -1);
  const _hoisted_6$4 = /* @__PURE__ */ createBaseVNode("path", {
    fill: "url(#half)",
    d: "M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"
  }, null, -1);
  const _hoisted_7$2 = [
    _hoisted_5$4,
    _hoisted_6$4
  ];
  const _hoisted_8$2 = /* @__PURE__ */ createBaseVNode("path", { d: "M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" }, null, -1);
  const _hoisted_9$4 = [
    _hoisted_8$2
  ];
  const _sfc_main$7 = /* @__PURE__ */ defineComponent({
    __name: "StarsRating",
    props: {
      stars: { default: 2.5 }
    },
    setup(__props) {
      const props = __props;
      const fullStars = Math.floor(props.stars);
      const hasHalfStar = props.stars % 1 !== 0;
      const emptyStars = 5 - Math.ceil(props.stars);
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$7, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(fullStars), (i2) => {
            return openBlock(), createElementBlock("svg", {
              key: "full-" + i2,
              class: "w-5 h-5 text-yellow-400",
              fill: "currentColor",
              viewBox: "0 0 20 20",
              width: "20",
              height: "20"
            }, _hoisted_3$4);
          }), 128)),
          hasHalfStar ? (openBlock(), createElementBlock("svg", _hoisted_4$4, _hoisted_7$2)) : createCommentVNode("", true),
          (openBlock(), createElementBlock(Fragment, null, renderList(emptyStars, (i2) => {
            return createBaseVNode("svg", {
              key: "empty-" + i2,
              class: "w-5 h-5 text-gray-300",
              fill: "currentColor",
              viewBox: "0 0 20 20",
              width: "20",
              height: "20"
            }, _hoisted_9$4);
          }), 64))
        ]);
      };
    }
  });
  const _hoisted_1$6 = { class: "max-w-2xl mx-auto px-4 sm:px-6 lg:px-8 pt-24 pb-12" };
  const _hoisted_2$6 = /* @__PURE__ */ createBaseVNode("h2", { class: "text-3xl font-bold text-left text-gray-900 dark:text-white mb-8" }, [
    /* @__PURE__ */ createBaseVNode("span", { class: "text-xl font-semibold text-gray-700 dark:text-gray-300" }, "AI-Generated Testimonials"),
    /* @__PURE__ */ createBaseVNode("br"),
    /* @__PURE__ */ createBaseVNode("span", null, "What leading AI says about us:")
  ], -1);
  const _hoisted_3$3 = { class: "bg-white dark:bg-gray-800 shadow-lg rounded-lg overflow-hidden" };
  const _hoisted_4$3 = { class: "p-6 sm:p-8" };
  const _hoisted_5$3 = /* @__PURE__ */ createBaseVNode("svg", {
    class: "w-5 h-5 text-brand-500 mb-4",
    fill: "currentColor",
    viewBox: "0 0 24 24",
    width: "20",
    height: "20"
  }, [
    /* @__PURE__ */ createBaseVNode("path", { d: "M14.017 21v-7.391c0-5.704 3.731-9.57 8.983-10.609l.995 2.151c-2.432.917-3.995 3.638-3.995 5.849h4v10h-9.983zm-14.017 0v-7.391c0-5.704 3.748-9.57 9-10.609l.996 2.151c-2.433.917-3.996 3.638-3.996 5.849h3.983v10h-9.983z" })
  ], -1);
  const _hoisted_6$3 = { class: "text-lg leading-relaxed text-gray-700 dark:text-gray-300 mb-6 italic" };
  const _hoisted_7$1 = { class: "flex items-center justify-between" };
  const _hoisted_8$1 = { class: "font-semibold text-gray-900 dark:text-white" };
  const _hoisted_9$3 = { class: "text-sm text-gray-600 dark:text-gray-400" };
  const _hoisted_10$3 = { class: "flex items-center" };
  const _hoisted_11$3 = /* @__PURE__ */ createBaseVNode("div", { class: "bg-gray-100 dark:bg-gray-700 px-6 py-4" }, [
    /* @__PURE__ */ createBaseVNode("p", { class: "text-sm text-gray-600 dark:text-gray-400 italic" }, [
      /* @__PURE__ */ createTextVNode(" Note: "),
      /* @__PURE__ */ createBaseVNode("span", { class: "" }, [
        /* @__PURE__ */ createTextVNode("This quote was generated by "),
        /* @__PURE__ */ createBaseVNode("a", {
          href: "https://www.anthropic.com/news/claude-3-5-sonnet",
          class: "underline",
          rel: "noopener noreferrer",
          target: "_blank"
        }, "Claude 3.5")
      ]),
      /* @__PURE__ */ createTextVNode(". It was based on the content of the page and does not represent an actual person or company. ")
    ])
  ], -1);
  const _sfc_main$6 = /* @__PURE__ */ defineComponent({
    __name: "QuoteSection",
    props: {
      testimonial: {}
    },
    setup(__props) {
      const props = __props;
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$6, [
          _hoisted_2$6,
          createBaseVNode("div", _hoisted_3$3, [
            createBaseVNode("div", _hoisted_4$3, [
              _hoisted_5$3,
              createBaseVNode("p", _hoisted_6$3, ' "' + toDisplayString(props.testimonial.quote) + '" ', 1),
              createBaseVNode("div", _hoisted_7$1, [
                createBaseVNode("div", null, [
                  createBaseVNode("p", _hoisted_8$1, toDisplayString(props.testimonial.name), 1),
                  createBaseVNode("p", _hoisted_9$3, toDisplayString(props.testimonial.company), 1)
                ]),
                createBaseVNode("div", _hoisted_10$3, [
                  createVNode(_sfc_main$7, {
                    stars: props.testimonial.stars
                  }, null, 8, ["stars"])
                ])
              ])
            ]),
            _hoisted_11$3
          ])
        ]);
      };
    }
  });
  const paymentFrequencies = [
    { value: "monthly", label: "Monthly", priceSuffix: "/month" },
    { value: "annually", label: "Yearly", priceSuffix: "/year" }
  ];
  const productTiers = [
    {
      id: "tier-identity",
      name: "Identity Plus",
      href: "/plans/identity",
      cta: "Start today",
      price: {
        monthly: "$35",
        annually: "$365"
      },
      //description: "Secure sharing that elevates your brand and simplifies communication.",
      //description: "Elevate your brand with secure sharing that simplifies communication.",
      //description: "Elevate your brand with secure, streamlined communication.",
      description: "Secure your brand, build customer trust with links from your domain.",
      features: [
        "Unlimited custom domains",
        //'Unlimited sharing capacity',
        "Privacy-first design",
        "Full API access",
        "Meets and exceeds compliance standards"
      ],
      featured: false
    },
    {
      id: "tier-dedicated",
      name: "Global Elite",
      href: "/plans/dedicated",
      cta: "Coming this fall",
      price: {
        monthly: "$245",
        annually: "$2545"
      },
      description: "Dedicated infrastructure for data-compliance and deep integrations.",
      features: [
        "Private cloud environment",
        "Fully customizable",
        "Enterprise-grade security and compliance",
        "Data locality options (EU, US)",
        "Scheduled delivery within 2-4 business days"
      ],
      featured: true
    }
  ];
  const testimonials = [
    {
      quote: "Onetime Secret helps us share sensitive information securely while maintaining our professional facade.",
      name: "Aisha",
      company: "SameDay Financial",
      uri: "",
      stars: 4.5
    },
    {
      quote: "The custom domain feature has significantly elevated our company's reputation among biological, human clients.",
      name: "Hiro",
      company: "Growth Dynamics",
      uri: "",
      stars: 4
    },
    {
      quote: "Their SafeTek® Security Architecture gives us peace of mind when sharing confidential data with our carbon-based business partners.",
      name: "Priya",
      company: "Agile Innovations",
      uri: "",
      stars: 5
    },
    {
      quote: "As a real freelancer, the unlimited sharing capacity allows me to collaborate securely with my several hundred thousand clients.",
      name: "Carlos",
      company: "Creative Freelance Warehouse",
      uri: "",
      stars: 4.5
    },
    {
      quote: "The advanced compliance options ensure we meet all regulatory requirements in our heavily regulated industry.",
      name: "Fatima",
      company: '"AAA" Body Supplements',
      uri: "",
      stars: 4
    },
    {
      quote: "The private cloud environment has been crucial in building trust with our high-profile clients.",
      name: "Unit ZW-731",
      company: "Scaling Solutions",
      uri: "",
      stars: 5
    },
    {
      quote: "The flexible data residency options keep us in good standing with our regional CPU conservation society.",
      name: "Liam-3000",
      company: "Community Impact Foundation",
      uri: "",
      stars: 4.5
    }
  ];
  const _withScopeId$1 = (n2) => (pushScopeId("data-v-bea3c294"), n2 = n2(), popScopeId(), n2);
  const _hoisted_1$5 = { class: "relative isolate bg-white dark:bg-gray-900 px-6 py-18 sm:py-12 lg:px-8" };
  const _hoisted_2$5 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("div", { class: "pb-6 flex justify-center text-sm" }, null, -1));
  const _hoisted_3$2 = /* @__PURE__ */ createStaticVNode('<div class="mx-auto max-w-7xl px-4 sm:px-6 lg:px-8" data-v-bea3c294><div class="mx-auto text-center max-w-2xl lg:max-w-4xl" data-v-bea3c294><h2 class="text-base font-semibold leading-7 text-brand-600 dark:text-brand-400 sm:text-lg md:text-xl" data-v-bea3c294>Pricing </h2><p class="mt-2 text-4xl font-brand font-bold tracking-tight text-gray-900 dark:text-white sm:text-5xl md:text-6xl lg:text-7xl" data-v-bea3c294> Secure Links, Stronger Connections </p><p class="mx-auto mt-6 max-w-md lg:max-w-xl text-center text-base sm:text-lg md:text-xl leading-7 sm:leading-8 text-gray-600 dark:text-gray-300" data-v-bea3c294> Share confidential information with confidence, elevate your brand, and build trust </p></div></div>', 1);
  const _hoisted_4$2 = { class: "mt-16 flex justify-center font-serif" };
  const _hoisted_5$2 = { "aria-label": "Payment frequency" };
  const _hoisted_6$2 = { class: "mx-auto mt-16 grid max-w-lg grid-cols-1 items-center gap-y-6 sm:mt-20 sm:gap-y-0 lg:max-w-4xl lg:grid-cols-2" };
  const _hoisted_7 = ["id"];
  const _hoisted_8 = { class: "mt-4 flex items-baseline gap-x-2" };
  const _hoisted_9$2 = ["action"];
  const _hoisted_10$2 = ["aria-describedby"];
  const _hoisted_11$2 = { class: "relative" };
  const _hoisted_12$2 = { class: "py-12 mx-auto max-w-7xl px-4 sm:px-6 lg:px-8" };
  const _hoisted_13$2 = { class: "rounded-lg bg-white dark:bg-gray-800 shadow-lg overflow-hidden" };
  const _hoisted_14$1 = { class: "px-6 py-8 sm:p-10 lg:flex lg:items-center lg:justify-between" };
  const _hoisted_15$1 = { class: "flex-1 space-y-6" };
  const _hoisted_16$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("h3", { class: "inline-flex items-center rounded-full bg-brandcomp-100 dark:bg-brandcomp-900 px-4 py-1 text-sm font-semibold text-brandcomp-700 dark:text-brandcomp-300" }, [
    /* @__PURE__ */ createBaseVNode("svg", {
      class: "w-5 h-5 mr-2",
      fill: "currentColor",
      viewBox: "0 0 20 20",
      xmlns: "http://www.w3.org/2000/svg"
    }, [
      /* @__PURE__ */ createBaseVNode("path", {
        "fill-rule": "evenodd",
        d: "M5 2a1 1 0 011 1v1h1a1 1 0 010 2H6v1a1 1 0 01-2 0V6H3a1 1 0 010-2h1V3a1 1 0 011-1zm0 10a1 1 0 011 1v1h1a1 1 0 110 2H6v1a1 1 0 11-2 0v-1H3a1 1 0 110-2h1v-1a1 1 0 011-1zm7-10a1 1 0 01.707.293l3 3a1 1 0 010 1.414l-3 3a1 1 0 01-1.414-1.414L13.586 8l-2.293-2.293a1 1 0 011.414-1.414l3 3z",
        "clip-rule": "evenodd"
      })
    ]),
    /* @__PURE__ */ createTextVNode(" An Unlimited-Time Offer ")
  ], -1));
  const _hoisted_17$2 = { class: "space-y-4 text-base text-gray-600 dark:text-gray-300" };
  const _hoisted_18$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("li", { class: "flex items-center" }, [
    /* @__PURE__ */ createBaseVNode("svg", {
      class: "w-6 h-6 text-brandcomp-500 mr-3",
      fill: "none",
      stroke: "currentColor",
      viewBox: "0 0 24 24",
      xmlns: "http://www.w3.org/2000/svg"
    }, [
      /* @__PURE__ */ createBaseVNode("path", {
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "M13 10V3L4 14h7v7l9-11h-7z"
      })
    ]),
    /* @__PURE__ */ createBaseVNode("span", null, [
      /* @__PURE__ */ createBaseVNode("strong", { class: "font-medium" }, "Start Free:"),
      /* @__PURE__ */ createTextVNode(" Unlock most features at $0/month")
    ])
  ], -1));
  const _hoisted_19$1 = { class: "flex items-center" };
  const _hoisted_20$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("svg", {
    class: "w-6 h-6 text-brandcomp-500 mr-3",
    fill: "none",
    stroke: "currentColor",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    /* @__PURE__ */ createBaseVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"
    })
  ], -1));
  const _hoisted_21$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("span", null, [
    /* @__PURE__ */ createBaseVNode("strong", { class: "font-medium" }, "Self-Host:"),
    /* @__PURE__ */ createTextVNode(" Get our SimpleStack℠ guarantee included")
  ], -1));
  const _hoisted_22$1 = { class: "float-left mr-4 mb-2 shape-icon" };
  const _hoisted_23 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("h3", { class: "font-bold mb-2 text-gray-900 dark:text-white" }, "Our SimpleStack℠ Guarantee", -1));
  const _hoisted_24 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("p", { class: "prose dark:prose-invert" }, "Our SimpleStack guarantee ensures effortless deployment and management of our software. You can have the entire system up and running in minutes, from a single docker container. ", -1));
  const _hoisted_25 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("p", { class: "prose dark:prose-invert" }, "Whether you're a seasoned DevOps pro or new to self-hosting, our SimpleStack design ensures you can focus on using the product, not wrestling with infrastructure. That's the SimpleStack advantage!", -1));
  const _hoisted_26 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("p", { class: "prose mt-4 font-semibold dark:prose-invert" }, " While others are stacking up complications, we've got your back with a stack so simple, it just works. ", -1));
  const _hoisted_27 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("p", { class: "text-base text-gray-600 dark:text-gray-300" }, " Why wait? Join thousands of happy users today! ", -1));
  const _hoisted_28 = { class: "mt-8 lg:mt-0 lg:ml-10 flex flex-col space-y-4" };
  const _hoisted_29 = {
    href: "https://github.com/onetimesecret/onetimesecret",
    ref: "noopener noreferrer",
    class: "font-brand inline-flex items-center justify-center px-5 py-3 border border-gray-300 dark:border-gray-600 text-base font-medium rounded-md text-gray-700 dark:text-gray-200 bg-white dark:bg-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-brandcomp-500 transition-colors duration-200"
  };
  const _sfc_main$5 = /* @__PURE__ */ defineComponent({
    __name: "PricingDual",
    setup(__props) {
      const testimonials$1 = ref(testimonials);
      const randomTestimonial = ref(testimonials$1.value[0]);
      const tiers = ref(productTiers);
      const frequencies = ref(paymentFrequencies);
      const frequency = ref(frequencies.value[0]);
      onMounted(() => {
        const randomIndex = Math.floor(Math.random() * testimonials$1.value.length);
        randomTestimonial.value = testimonials$1.value[randomIndex];
      });
      return (_ctx, _cache) => {
        const _component_router_link = resolveComponent("router-link");
        return openBlock(), createElementBlock("div", _hoisted_1$5, [
          _hoisted_2$5,
          createVNode(_sfc_main$18, {
            "from-colour": "#23b5dd",
            "to-colour": "#dc4a22",
            speed: "10s",
            interval: 3e3,
            scale: 1
          }),
          _hoisted_3$2,
          createBaseVNode("div", _hoisted_4$2, [
            createBaseVNode("fieldset", _hoisted_5$2, [
              createVNode(unref(he), {
                modelValue: frequency.value,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => frequency.value = $event),
                class: "grid grid-cols-2 gap-x-1 rounded-full bg-white/5 p-1 text-center text-xs font-semibold leading-5 text-white"
              }, {
                default: withCtx(() => [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(frequencies.value, (option) => {
                    return openBlock(), createBlock(unref(Oe), {
                      as: "template",
                      key: option.value,
                      value: option
                    }, {
                      default: withCtx(({ checked }) => [
                        createBaseVNode("div", {
                          class: normalizeClass([checked ? "bg-brand-600 dark:bg-brand-500" : "bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-200 opacity-55", "cursor-pointer rounded-full px-2.5 py-1"])
                        }, toDisplayString(option.label), 3)
                      ]),
                      _: 2
                    }, 1032, ["value"]);
                  }), 128))
                ]),
                _: 1
              }, 8, ["modelValue"])
            ])
          ]),
          createBaseVNode("div", _hoisted_6$2, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(tiers.value, (tier, tierIdx) => {
              return openBlock(), createElementBlock("div", {
                key: tier.id,
                class: normalizeClass([tier.featured ? "relative bg-slate-800 dark:bg-slate-700 shadow-2xl" : "bg-white/60 dark:bg-gray-800/60 sm:mx-8 lg:mx-0", tier.featured ? "" : tierIdx === 0 ? "rounded-t-3xl sm:rounded-b-none lg:rounded-bl-3xl lg:rounded-tr-none" : "sm:rounded-t-none lg:rounded-bl-none lg:rounded-tr-3xl", "rounded-3xl p-8 ring-1 ring-gray-900/10 dark:ring-gray-100/10 sm:p-10"])
              }, [
                createBaseVNode("h3", {
                  id: tier.id,
                  class: normalizeClass([tier.featured ? "text-brand-500" : "text-brand-500", "text-xl font-semibold leading-7"])
                }, toDisplayString(tier.name), 11, _hoisted_7),
                createBaseVNode("p", _hoisted_8, [
                  createBaseVNode("span", {
                    class: normalizeClass([tier.featured ? "text-white blur-lg" : "text-gray-900 dark:text-white", "text-5xl font-bold tracking-tight"])
                  }, toDisplayString(tier.price[frequency.value.value]), 3),
                  createBaseVNode("span", {
                    class: normalizeClass([tier.featured ? "text-gray-400" : "text-gray-500 dark:text-gray-400", "text-base"])
                  }, toDisplayString(frequency.value.priceSuffix), 3)
                ]),
                createBaseVNode("p", {
                  class: normalizeClass([tier.featured ? "text-gray-300" : "text-gray-600 dark:text-gray-300", "mt-6 text-base leading-7"])
                }, toDisplayString(tier.description), 3),
                createBaseVNode("ul", {
                  role: "list",
                  class: normalizeClass([tier.featured ? "text-gray-300 pb-10" : "text-gray-600 dark:text-gray-300", "mt-8 space-y-3 text-base leading-6 sm:mt-10"])
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(tier.features, (feature) => {
                    return openBlock(), createElementBlock("li", {
                      key: feature,
                      class: "flex gap-x-3"
                    }, [
                      createVNode(unref(Icon), {
                        icon: "heroicons-solid:check",
                        class: normalizeClass([tier.featured ? "text-brand-400" : "text-brand-600 dark:text-brand-400", "h-6 w-5 flex-none"]),
                        "aria-hidden": "true"
                      }, null, 8, ["class"]),
                      createTextVNode(" " + toDisplayString(feature), 1)
                    ]);
                  }), 128))
                ], 2),
                createBaseVNode("form", {
                  action: `${tier.href}${frequency.value.priceSuffix}`,
                  method: "GET"
                }, [
                  createBaseVNode("button", mergeProps({
                    type: "submit",
                    "aria-describedby": tier.id
                  }, toHandlers(tier.featured ? { click: ($event) => $event.preventDefault() } : {}, true), {
                    class: [tier.featured ? "block text-brand-400 dark:text-brand-400 ring-2 ring-inset bg-gray-800 dark:ring-slate-800 hover:ring-gray-300 dark:hover:ring-gray-800 focus-visible:outline-gray-600" : "block bg-brand-500 text-white shadow-sm hover:bg-brand-600 focus-visible:outline-brand-500", "mt-8 block rounded-md px-3.5 py-2.5 text-center text-lg font-semibold focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 sm:mt-10"]
                  }), toDisplayString(tier.cta), 17, _hoisted_10$2)
                ], 8, _hoisted_9$2)
              ], 2);
            }), 128))
          ]),
          createBaseVNode("div", _hoisted_11$2, [
            createVNode(_sfc_main$6, {
              class: "relative z-10 bg-opacity-80 dark:bg-opacity-80",
              testimonial: randomTestimonial.value
            }, null, 8, ["testimonial"]),
            createVNode(_sfc_main$18, {
              class: "absolute inset-0 z-0",
              "from-colour": "#23b5dd",
              "to-colour": "#dc4a22",
              speed: "10s",
              interval: 1e3,
              scale: 2
            })
          ]),
          createBaseVNode("div", _hoisted_12$2, [
            createBaseVNode("div", _hoisted_13$2, [
              createBaseVNode("div", _hoisted_14$1, [
                createBaseVNode("div", _hoisted_15$1, [
                  _hoisted_16$1,
                  createBaseVNode("ul", _hoisted_17$2, [
                    _hoisted_18$1,
                    createBaseVNode("li", _hoisted_19$1, [
                      _hoisted_20$1,
                      _hoisted_21$1,
                      createVNode(InfoTooltip, { color: "bg-brandcomp-100 dark:bg-brandcomp-900" }, {
                        default: withCtx(() => [
                          createBaseVNode("div", _hoisted_22$1, [
                            createVNode(unref(Icon), {
                              icon: "fa6-solid:handshake-simple",
                              class: "w-24 h-24 text-brandcomp-600 dark:text-brandcomp-400"
                            })
                          ]),
                          _hoisted_23,
                          _hoisted_24,
                          _hoisted_25,
                          _hoisted_26
                        ]),
                        _: 1
                      })
                    ])
                  ]),
                  _hoisted_27
                ]),
                createBaseVNode("div", _hoisted_28, [
                  createVNode(_component_router_link, {
                    to: "/signup/basic",
                    class: "font-brand inline-flex items-center justify-center px-5 py-3 border border-transparent text-base font-medium rounded-md text-white bg-brandcomp-500 hover:bg-brandcomp-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-brandcomp-500 transition-colors duration-200"
                  }, {
                    default: withCtx(() => [
                      createTextVNode(" Get Started for Free ")
                    ]),
                    _: 1
                  }),
                  createBaseVNode("a", _hoisted_29, " Learn About Self-Hosting ", 512)
                ])
              ])
            ])
          ])
        ]);
      };
    }
  });
  const PricingDual = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__scopeId", "data-v-bea3c294"]]);
  const PricingDual$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: PricingDual
  }, Symbol.toStringTag, { value: "Module" }));
  const _hoisted_1$4 = { class: "mb-8" };
  const _hoisted_2$4 = /* @__PURE__ */ createBaseVNode("h3", {
    class: "text-2xl font-semibold mb-4 text-gray-900 dark:text-gray-100",
    "aria-label": "Feedback Form"
  }, " Give us your feedback ", -1);
  const _sfc_main$4 = /* @__PURE__ */ defineComponent({
    __name: "Feedback",
    setup(__props) {
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("section", _hoisted_1$4, [
          _hoisted_2$4,
          createVNode(_sfc_main$1d, { showRedButton: true })
        ]);
      };
    }
  });
  const Feedback = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: _sfc_main$4
  }, Symbol.toStringTag, { value: "Module" }));
  const _hoisted_1$3 = /* @__PURE__ */ createBaseVNode("h3", { class: "text-2xl font-semibold mb-6 text-gray-900 dark:text-gray-100" }, " Request password reset ", -1);
  const _hoisted_2$3 = { class: "bg-white dark:bg-gray-800 shadow-md rounded px-8 pt-6 pb-8 mb-4" };
  const _hoisted_3$1 = /* @__PURE__ */ createBaseVNode("p", { class: "mb-4 text-gray-700 dark:text-gray-300" }, " Enter your email address below, and we'll send you instructions to reset your password. ", -1);
  const _hoisted_4$1 = {
    method: "post",
    id: "resetRequestForm"
  };
  const _hoisted_5$1 = ["value"];
  const _hoisted_6$1 = /* @__PURE__ */ createStaticVNode('<div class="mb-4"><label class="block text-gray-700 dark:text-gray-300 text-sm font-bold mb-2" for="custidField"> Email address </label><input type="email" name="u" id="custidField" required class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 dark:text-gray-300 dark:bg-gray-700 leading-tight focus:outline-none focus:shadow-outline" value="{{form_fields.custid}}" placeholder="your@email.com"></div><div class="mb-6"></div><div class="flex items-center justify-between"><button type="submit" class="bg-brand-500 hover:bg-brand-700 dark:bg-brand-600 dark:hover:bg-brand-800 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline transition duration-300"> Request Reset </button></div>', 3);
  const _hoisted_9$1 = { class: "bg-white dark:bg-gray-800 shadow-md rounded px-8 pt-6 pb-8 mb-4" };
  const _hoisted_10$1 = /* @__PURE__ */ createBaseVNode("p", { class: "mb-4 text-gray-700 dark:text-gray-300" }, " Please enter your new password below. Make sure it's at least 8 characters long and includes a mix of letters, numbers, and symbols. ", -1);
  const _hoisted_11$1 = {
    method: "post",
    id: "passwordResetForm"
  };
  const _hoisted_12$1 = ["value"];
  const _hoisted_13$1 = /* @__PURE__ */ createStaticVNode('<div class="mb-4"><label class="block text-gray-700 dark:text-gray-300 text-sm font-bold mb-2" for="passField"> New password </label><input type="password" name="newp" id="passField" required minlength="8" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 dark:text-gray-300 dark:bg-gray-700 leading-tight focus:outline-none focus:shadow-outline" placeholder="••••••••"></div><div class="mb-6"><label class="block text-gray-700 dark:text-gray-300 text-sm font-bold mb-2" for="pass2Field"> Confirm password </label><input type="password" name="newp2" id="pass2Field" required minlength="8" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 dark:text-gray-300 dark:bg-gray-700 leading-tight focus:outline-none focus:shadow-outline" placeholder="••••••••"></div><div id="app"></div><div class="flex items-center justify-between"><button type="submit" class="bg-brand-500 hover:bg-brand-700 dark:bg-brand-600 dark:hover:bg-brand-800 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline transition duration-300"> Update Password </button></div>', 4);
  const _hoisted_17$1 = { class: "text-center mt-6" };
  const _sfc_main$3 = /* @__PURE__ */ defineComponent({
    __name: "PasswordReset",
    props: {
      enabled: { type: Boolean, default: true }
    },
    setup(__props) {
      const csrfStore = useCsrfStore();
      return (_ctx, _cache) => {
        const _component_router_link = resolveComponent("router-link");
        return openBlock(), createElementBlock(Fragment, null, [
          _hoisted_1$3,
          createBaseVNode("div", _hoisted_2$3, [
            _hoisted_3$1,
            createBaseVNode("form", _hoisted_4$1, [
              createBaseVNode("input", {
                type: "hidden",
                name: "shrimp",
                value: unref(csrfStore).shrimp
              }, null, 8, _hoisted_5$1),
              _hoisted_6$1
            ])
          ]),
          createBaseVNode("div", _hoisted_9$1, [
            _hoisted_10$1,
            createBaseVNode("form", _hoisted_11$1, [
              createBaseVNode("input", {
                type: "hidden",
                name: "shrimp",
                value: unref(csrfStore).shrimp
              }, null, 8, _hoisted_12$1),
              _hoisted_13$1
            ])
          ]),
          createBaseVNode("div", _hoisted_17$1, [
            createVNode(_component_router_link, {
              to: "/signin",
              class: "text-slate-500 hover:text-slate-700 dark:text-slate-400 dark:hover:text-slate-300"
            }, {
              default: withCtx(() => [
                createTextVNode(" Back to Sign-in ")
              ]),
              _: 1
            })
          ])
        ], 64);
      };
    }
  });
  const PasswordReset = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: _sfc_main$3
  }, Symbol.toStringTag, { value: "Module" }));
  const _imports_0 = "/dist/assets/delano-g.png";
  const _hoisted_1$2 = { class: "prose dark:prose-invert md:prose-lg lg:prose-xl" };
  const _hoisted_2$2 = /* @__PURE__ */ createStaticVNode('<h2 class="intro">About Us</h2><p class=""> Hi, I&#39;m <a href="https://delanotes.com/" title="Delano Mandelbaum">Delano</a>, the creator of Onetime Secret. What started in 2012 as a simple, secure way to share sensitive information has grown beyond our wildest expectations. Over a decade later, we&#39;re facilitating the secure sharing of millions of secrets monthly, with use cases we never imagined. </p><p> The first half of 2024 has been our busiest period yet. We&#39;re grateful that people have continued to use and share our product for more than a decade. We&#39;re currently working on improvements that we think will make the service even more useful — we&#39;ll share more details soon. </p><p> True to our roots, <a href="https://github.com/onetimesecret/onetimesecret" title="Fork us on GitHub">our code remains open-source</a> on GitHub. As we navigate the evolving landscape of digital privacy and security, we&#39;re committed to transparency and continual improvement. </p><p> Thank you for being part of our journey. Here&#39;s to another decade of secure, ephemeral sharing. </p><p class=""> If you have any questions, there is a feedback form at the bottom of (almost) every page. </p><p class="">Happy sharing,<br>Delano</p><p style="margin-left:40%;margin-right:40%;"><a href="https://delanotes.com/" title="Delano Mandelbaum"><img src="' + _imports_0 + '" width="95" height="120" border="0"></a></p><h3>F.A.Q.</h3><h4>Why would I use this?</h4><p> When you send people passwords and private links via email or chat, there are copies of that information stored in many places. If you use a Onetime link instead, the information persists for a single viewing which means it can&#39;t be read by someone else later. This allows you to send sensitive information in a safe way knowing it&#39;s seen by one person only. Think of it like a self-destructing message. </p><h4>Why can&#39;t I send pictures or other kinds of files?</h4><p> Our service is designed specifically for text-based secrets to ensure maximum security and simplicity. Files, especially images, can contain metadata that might unintentionally reveal information about the sender or recipient. By focusing on text, we can guarantee that no additional data is transmitted beyond what you explicitly type. If you need to share a file securely, we recommend using a dedicated secure file transfer service. We may consider adding support for files in the future if there are compelling use cases for it. </p><h4>But I can copy the secret text. What&#39;s the difference?</h4><p> True, but all you have is text. Images and other file types can contain metadata and other potentially revealing information about the sender or recipient. Again, this is simply to ensure that no private information is shared outside of the intended recipient. </p><h4>Can I retrieve a secret that has already been shared?</h4><p>Nope. We display it once and then delete it. After that, it&#39;s gone forever.</p>', 17);
  const _hoisted_19 = { key: 0 };
  const _hoisted_20 = /* @__PURE__ */ createBaseVNode("h4", null, "What's the difference between anonymous use and having a free account?", -1);
  const _hoisted_21 = /* @__PURE__ */ createBaseVNode("h4", null, "How do you handle data requests from law enforcement or other third parties?", -1);
  const _hoisted_22 = /* @__PURE__ */ createStaticVNode('<h4>Why should I trust you?</h4><p> We&#39;ve designed our system with privacy and security as top priorities. Here&#39;s why you can trust us: </p><ul><li> We can&#39;t access your information even if we wanted to (which we don&#39;t). For example, if you share a password, we don&#39;t know the username or even the application it&#39;s for. </li><li> If you use a passphrase (available under &quot;Privacy Options&quot;), we include that in the encryption key for the secret. We only store a bcrypt hash of the passphrase, making it impossible for us to decrypt your secret once it&#39;s saved. </li><li> Our code is <a href="https://github.com/onetimesecret/onetimesecret">open source</a>. You can review it yourself or even run your own instance if you prefer. </li><li> We use industry-standard security practices, including HTTPS for all connections and encryption at rest for stored data. </li></ul><h4>How does the passphrase option work?</h4><p> When you use a passphrase, we encrypt your secret on our servers using the passphrase you provide. We don&#39;t store the passphrase itself, only a bcrypt hash of it. This hash is used to verify the passphrase when the recipient enters it. Here&#39;s why this is secure: </p><ul><li>We never store the unencrypted secret or the passphrase.</li><li>The bcrypt hash cannot be used to decrypt the secret.</li><li> Without the original passphrase, the encrypted secret cannot be decrypted, even by us. </li><li> This means that even if our servers were compromised, your secret would remain secure as long as the passphrase remains unknown. </li></ul><p> Remember, the security of your secret depends on the strength of your passphrase and how securely you communicate it to the recipient. </p>', 7);
  const _sfc_main$2 = /* @__PURE__ */ defineComponent({
    __name: "About",
    setup(__props) {
      const { available_plans, default_planid } = useWindowProps(["available_plans", "default_planid"]);
      const defaultPlan = ref({});
      const anonymousPlan = ref({});
      const secondsToDays = (seconds) => {
        return seconds != null ? Math.floor(seconds / 86400) : 0;
      };
      const bytesToKB = (bytes) => {
        return bytes != null ? Math.round(bytes / 1024) : 0;
      };
      const anonymousTtlDays = computed(() => {
        var _a, _b;
        return secondsToDays((_b = (_a = anonymousPlan.value) == null ? void 0 : _a.options) == null ? void 0 : _b.ttl);
      });
      const anonymousSizeKB = computed(() => {
        var _a, _b;
        return bytesToKB((_b = (_a = anonymousPlan.value) == null ? void 0 : _a.options) == null ? void 0 : _b.size);
      });
      const defaultTtlDays = computed(() => {
        var _a, _b;
        return secondsToDays((_b = (_a = defaultPlan.value) == null ? void 0 : _a.options) == null ? void 0 : _b.ttl);
      });
      const defaultSizeKB = computed(() => {
        var _a, _b;
        return bytesToKB((_b = (_a = defaultPlan.value) == null ? void 0 : _a.options) == null ? void 0 : _b.size);
      });
      onMounted(() => {
        if (available_plans.value && default_planid.value) {
          defaultPlan.value = available_plans.value[default_planid.value] ?? null;
          anonymousPlan.value = available_plans.value.anonymous;
        }
      });
      return (_ctx, _cache) => {
        const _component_router_link = resolveComponent("router-link");
        return openBlock(), createElementBlock("article", _hoisted_1$2, [
          _hoisted_2$2,
          anonymousPlan.value && defaultPlan.value ? (openBlock(), createElementBlock("span", _hoisted_19, [
            _hoisted_20,
            createBaseVNode("p", null, " Anonymous users can create secrets that last up to " + toDisplayString(anonymousTtlDays.value) + " days and have a maximum size of " + toDisplayString(anonymousSizeKB.value) + " KB. Free account holders get extended benefits: secrets can last up to " + toDisplayString(defaultTtlDays.value) + " days and can be up to " + toDisplayString(defaultSizeKB.value) + " KB in size. Account holders also get access to additional features like burn-before-reading options, which allow senders to delete secrets before they're received. ", 1)
          ])) : createCommentVNode("", true),
          _hoisted_21,
          createBaseVNode("p", null, [
            createTextVNode(" We designed our system with privacy in mind. We don't store secrets after they've been viewed, and we don't keep access logs beyond the minimum necessary. This means that in most cases, we simply don't have any data to provide in response to such requests. For more details, please review our "),
            createVNode(_component_router_link, { to: "/info/privacy" }, {
              default: withCtx(() => [
                createTextVNode("privacy policy")
              ]),
              _: 1
            }),
            createTextVNode(". ")
          ]),
          _hoisted_22
        ]);
      };
    }
  });
  const About = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: _sfc_main$2
  }, Symbol.toStringTag, { value: "Module" }));
  const translations = [
    {
      name: "Ukrainian",
      code: "uk",
      translators: [
        {
          name: "Claude 3.5 Sonnet",
          url: "https://github.com/anthropics",
          date: "Aug, 2024"
        }
      ]
    },
    {
      name: "Portuguese (Portugal)",
      code: "pt_PT",
      translators: [
        {
          name: "Claude 3.5 Sonnet",
          url: "https://github.com/anthropics",
          date: "Aug, 2024"
        }
      ]
    },
    {
      name: "Hungarian",
      code: "hu",
      translators: [
        {
          name: "halmosigabor",
          url: "https://github.com/halmosigabor",
          date: "Mar, 2023"
        }
      ]
    },
    {
      name: "Hebrew",
      code: "he",
      translators: [
        {
          name: "Erez K",
          url: "https://twitter.com/kaerez",
          date: "Mar, 2022"
        }
      ]
    },
    {
      name: "Danish",
      code: "da_DK",
      translators: [
        {
          name: "PurGe",
          url: null,
          date: "Dec, 2018"
        }
      ]
    },
    {
      name: "Swedish",
      code: "sv_SE",
      translators: [
        {
          name: "Wollyhat",
          url: "https://github.com/Wollyhat",
          date: "May, 2021"
        }
      ]
    },
    {
      name: "Slovenian",
      code: "sl_SI",
      translators: [
        {
          name: "Aleš M",
          url: null,
          date: "Jan, 2021"
        }
      ]
    },
    {
      name: "Greek",
      code: "el_GR",
      translators: [
        {
          name: "Stef Ki",
          url: null,
          date: "Sept, 2020"
        }
      ]
    },
    {
      name: "Arabic",
      code: "ar",
      translators: [
        {
          name: "Dergham Alaa",
          url: "https://www.facebook.com/DerghamAlaa1",
          date: "Dec 2017, 2020"
        }
      ]
    },
    {
      name: "French",
      code: "fr",
      translators: [
        {
          name: "NetAgence",
          url: "https://github.com/netagence",
          date: "June, 2018"
        },
        {
          name: "Laurent NAUDIER",
          url: "https://github.com/fr-laurentn",
          date: "June, 2018"
        },
        {
          name: "Olha Horbachuk",
          url: "https://github.com/KittPaws13",
          date: "March, 2017"
        }
      ]
    },
    {
      name: "Chinese",
      code: "cn",
      translators: [
        {
          name: "Rayi_Yosoro",
          url: "https://github.com/inewhero",
          date: "February, 2018"
        }
      ]
    },
    {
      name: "Italian",
      code: "it_IT",
      translators: [
        {
          name: "Giuseppe Pignataro",
          url: "https://github.com/fastbyte01",
          date: "November, 2017"
        }
      ]
    },
    {
      name: "Portuguese",
      code: "pt_BR",
      translators: [
        {
          name: "ramirovjr",
          url: "https://github.com/ramirovjr",
          date: "April, 2017"
        }
      ]
    },
    {
      name: "Turkish",
      code: "tr",
      translators: [
        {
          name: "webninjasi",
          url: "https://github.com/webninjasi",
          date: "April, 2017"
        }
      ]
    },
    {
      name: "Polish",
      code: "pl",
      translators: [
        {
          name: "Michał Paulus",
          url: "https://www.techinet.pl",
          date: "April, 2017"
        }
      ]
    },
    {
      name: "Catalan",
      code: "ca_ES",
      translators: [
        {
          name: "Ningú No res",
          url: null,
          date: "April, 2017"
        }
      ]
    },
    {
      name: "Bulgarian",
      code: "bg",
      translators: [
        {
          name: "Byalk",
          url: "https://github.com/Byalk",
          date: "March, 2017"
        }
      ]
    },
    {
      name: "Czech",
      code: "cs",
      translators: [
        {
          name: "kibeb",
          url: "https://github.com/kibeb",
          date: "February, 2017"
        }
      ]
    },
    {
      name: "Russian",
      code: "ru",
      translators: [
        {
          name: "Ivan Klochko",
          url: "https://i1group.ru",
          date: "September, 2020"
        },
        {
          name: "DotTheI",
          url: "https://github.com/DotTheI",
          date: "September, 2016"
        }
      ]
    },
    {
      name: "Deutsch",
      code: "de",
      translators: [
        {
          name: "blobgo",
          url: "",
          date: "June, 2015"
        }
      ]
    },
    {
      name: "Español",
      code: "es",
      translators: [
        {
          name: "Freedom Apps",
          url: "https://play.google.com/store/apps/details?id=com.goldeagle.secretemail",
          date: "April, 2015"
        }
      ]
    },
    {
      name: "Nederlands",
      code: "nl",
      translators: [
        {
          name: "Bas Berkhout",
          url: "http://under-ctrl.nl",
          date: "October, 2015"
        }
      ]
    },
    {
      name: "Vietnamese",
      code: "vi",
      translators: [
        {
          name: "Duc Nguyen",
          url: "https://fb.me/socthaovat",
          date: "Nov, 2022"
        }
      ]
    }
  ];
  const _sfc_main$1 = {};
  const _withScopeId = (n2) => (pushScopeId("data-v-e1941d89"), n2 = n2(), popScopeId(), n2);
  const _hoisted_1$1 = {
    href: "https://github.com/onetimesecret/onetimesecret",
    class: "github-corner",
    "aria-label": "View source on GitHub"
  };
  const _hoisted_2$1 = {
    width: "80",
    height: "80",
    viewBox: "0 0 250 250",
    style: { "fill": "#151513", "color": "#fff", "position": "absolute", "top": "0", "border": "0", "right": "0" },
    "aria-hidden": "true"
  };
  const _hoisted_3 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("path", { d: "M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z" }, null, -1));
  const _hoisted_4 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("path", {
    d: "M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2",
    fill: "currentColor",
    style: { "transform-origin": "130px 106px" },
    class: "octo-arm"
  }, null, -1));
  const _hoisted_5 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("path", {
    d: "M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z",
    fill: "currentColor",
    class: "octo-body"
  }, null, -1));
  const _hoisted_6 = [
    _hoisted_3,
    _hoisted_4,
    _hoisted_5
  ];
  function _sfc_render(_ctx, _cache) {
    return openBlock(), createElementBlock("a", _hoisted_1$1, [
      (openBlock(), createElementBlock("svg", _hoisted_2$1, _hoisted_6))
    ]);
  }
  const GithubCorner = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render], ["__scopeId", "data-v-e1941d89"]]);
  const _hoisted_1 = { class: "prose dark:prose-invert lg:prose-lg xl:prose-xl" };
  const _hoisted_2 = /* @__PURE__ */ createStaticVNode('<h2 class="text-3xl font-bold mb-4 text-brand-500 dark:text-brand-400">Help us translate!</h2><p class="mb-4"> Since Onetime Secret launched in 2012, one of the most requested features has been to support languages other than english. Many visitors -- in fact, most -- live in countries where English is not the first or even second language. </p><p class="mb-4"> One of the major goals of Onetime Secret is to simplify secure communication so that it can help as many people as possible. Translating the site plays a big role in that. Since 2015 our contributors have added over 20, plus corrections and other updates! But we still have a ways to go. <strong class="text-brand-500 dark:text-brand-400"> I need your help to add support for more languages. </strong></p><div class="mt-8 text-center"><a href="https://github.com/onetimesecret/onetimesecret" class="bg-white hover:bg-brand-50 text-brand-500 font-bold py-2 px-4 rounded inline-flex items-center" target="_blank" rel="noopener noreferrer"><svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 24 24" width="20" height="20" xmlns="http://www.w3.org/2000/svg"><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg> Fork on GitHub and Submit a PR </a></div><hr class="my-8"><h3 class="text-2xl font-semibold mb-4">Translations</h3><p class="mb-4"> The following people have donated their time to help expand the reach of Onetime Secret: </p>', 7);
  const _hoisted_9 = { class: "text-xl font-semibold mb-2" };
  const _hoisted_10 = ["onClick"];
  const _hoisted_11 = { class: "list-disc pl-5 mb-4" };
  const _hoisted_12 = ["href"];
  const _hoisted_13 = { key: 1 };
  const _hoisted_14 = /* @__PURE__ */ createBaseVNode("hr", { class: "my-8" }, null, -1);
  const _hoisted_15 = { class: "mb-4" };
  const _hoisted_16 = /* @__PURE__ */ createBaseVNode("a", {
    href: "https://github.com/onetimesecret/onetimesecret/blob/develop/etc/locale/en",
    class: "text-brand-500 dark:text-brand-400 hover:underline"
  }, "english", -1);
  const _hoisted_17 = /* @__PURE__ */ createBaseVNode("p", { class: "mb-4" }, " There is a feedback form at the bottom of the page if you have any questions. If you're not logged in, be sure to include an email address so I can reply. ", -1);
  const _hoisted_18 = /* @__PURE__ */ createBaseVNode("p", { class: "mb-4" }, "Delano", -1);
  const _sfc_main = /* @__PURE__ */ defineComponent({
    __name: "Translations",
    setup(__props) {
      const languageStore = useLanguageStore();
      const changeLocale = async (newLocale) => {
        if (languageStore.getSupportedLocales.includes(newLocale)) {
          try {
            await languageStore.updateLanguage(newLocale);
            await setLanguage(newLocale);
          } catch (err) {
            console.error("Failed to update language:", err);
          }
        }
      };
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", null, [
          createVNode(GithubCorner),
          createBaseVNode("article", _hoisted_1, [
            _hoisted_2,
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(translations), (translation) => {
              return openBlock(), createElementBlock("div", {
                key: translation["code"]
              }, [
                createBaseVNode("h4", _hoisted_9, [
                  createTextVNode(toDisplayString(translation["name"]) + " (", 1),
                  createBaseVNode("a", {
                    onClick: withModifiers(($event) => changeLocale(translation["code"]), ["prevent"]),
                    href: "#",
                    class: "text-brand-500 dark:text-brand-400 hover:underline cursor-pointer"
                  }, "switch", 8, _hoisted_10),
                  createTextVNode(") ")
                ]),
                createBaseVNode("ul", _hoisted_11, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(translation["translators"], (translator, index) => {
                    return openBlock(), createElementBlock("li", {
                      key: `${translation["code"]}-${index}}`
                    }, [
                      translator["url"] ? (openBlock(), createElementBlock("a", {
                        key: 0,
                        href: translator["url"],
                        class: "text-brand-500 dark:text-brand-400 hover:underline"
                      }, toDisplayString(translator["name"]), 9, _hoisted_12)) : (openBlock(), createElementBlock("span", _hoisted_13, toDisplayString(translator["name"]), 1)),
                      createTextVNode(" (" + toDisplayString(translator["date"]) + ") ", 1)
                    ]);
                  }), 128))
                ])
              ]);
            }), 128)),
            _hoisted_14,
            createBaseVNode("p", _hoisted_15, [
              createTextVNode(" If you have a Github account, you can use the links above to create a new language file. If not, you can copy the text from an existing lanaguage -- like "),
              _hoisted_16,
              createTextVNode(" -- and send a text file via email to "),
              createVNode(_sfc_main$c, {
                email: "contribute@onetimesecret.com",
                subject: "Translations"
              }),
              createTextVNode(". ")
            ]),
            _hoisted_17,
            _hoisted_18
          ])
        ]);
      };
    }
  });
  const Translations = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: _sfc_main
  }, Symbol.toStringTag, { value: "Module" }));
});
//# sourceMappingURL=main.js.map
